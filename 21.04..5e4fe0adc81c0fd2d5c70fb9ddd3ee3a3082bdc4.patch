From 8e85b675fc9a9902316d81f8a588ba5a08c4aac4 Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Fri, 16 Apr 2021 17:05:48 +0300
Subject: [PATCH 001/342] sock: Add new params to configure zcopy for server,
 client sockets

When zcero copy send is enabled and used by initiator,
it could significantly increase latency in some payloads.
To enable more fine graing configuration of zero copy
send feature, add new parameters enable_zerocopy_send_server
and enable_zerocopy_send_client to spdk_sock_impl_opts to
enable/disable zcopy for specific type of sockets.
Exisiting enable_zerocopy_send parameter affects all types
of sockets.

Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Change-Id: I111c75608f8826980a56e210c076ab8ff16ddbdc
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7457
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 CHANGELOG.md              |  6 ++++++
 doc/jsonrpc.md            | 30 +++++++++++++++++++-----------
 examples/nvme/perf/perf.c |  1 +
 include/spdk/sock.h       |  9 +++++++++
 lib/sock/sock.c           |  2 ++
 lib/sock/sock_rpc.c       | 13 +++++++++++--
 module/sock/posix/posix.c | 19 +++++++++++++++----
 scripts/rpc.py            | 15 +++++++++++++--
 scripts/rpc/sock.py       | 10 +++++++++-
 9 files changed, 85 insertions(+), 20 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 241417bc7..f7667a84f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -179,6 +179,12 @@ sockets to be marked using the SO_MARK socket option as a hint for which hardwar
 queue they should be associated with. This mode leverages that by setting the same
 value for all sockets within a poll group.
 
+New parameters `enable_zerocopy_send_server` and `enable_zerocopy_send_client` were added
+to struct spdk_sock_impl_opts, these parameters enable or disable zero copy send for server
+and client sockets which are created using `spdk_sock_listen` and `spdk_sock_listen_ext` (server);
+`spdk_sock_connect` and `spdk_sock_connect_ext` (client) functions. Existing parameter
+`enable_zerocopy_send`  enables or disables zero copy send for both server and client sockets.
+
 ### thread
 
 A new API `spdk_io_channel_get_io_device` was added to get the io_device for the specified
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 876c00f4d..2833a0125 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -8591,7 +8591,11 @@ Example response:
     "recv_buf_size": 2097152,
     "send_buf_size": 2097152,
     "enable_recv_pipe": true,
-    "enable_zerocopy_send": true
+    "enable_zerocopy_send": true,
+    "enable_quickack": true,
+    "enable_placement_id": 0,
+    "enable_zerocopy_send_server": true,
+    "enable_zerocopy_send_client": false
   }
 }
 ~~~
@@ -8602,15 +8606,17 @@ Set parameters for the socket layer implementation.
 
 ### Parameters
 
-Name                    | Optional | Type        | Description
------------------------ | -------- | ----------- | -----------
-impl_name               | Required | string      | Name of socket implementation, e.g. posix
-recv_buf_size           | Optional | number      | Size of socket receive buffer in bytes
-send_buf_size           | Optional | number      | Size of socket send buffer in bytes
-enable_recv_pipe        | Optional | boolean     | Enable or disable receive pipe
-enable_zerocopy_send    | Optional | boolean     | Enable or disable zero copy on send
-enable_quick_ack        | Optional | boolean     | Enable or disable quick ACK
-enable_placement_id     | Optional | number      | Enable or disable placement_id. 0:disable,1:incoming_napi,2:incoming_cpu
+Name                        | Optional | Type        | Description
+--------------------------- | -------- | ----------- | -----------
+impl_name                   | Required | string      | Name of socket implementation, e.g. posix
+recv_buf_size               | Optional | number      | Size of socket receive buffer in bytes
+send_buf_size               | Optional | number      | Size of socket send buffer in bytes
+enable_recv_pipe            | Optional | boolean     | Enable or disable receive pipe
+enable_zerocopy_send        | Optional | boolean     | Enable or disable zero copy on send for client and server sockets
+enable_quick_ack            | Optional | boolean     | Enable or disable quick ACK
+enable_placement_id         | Optional | number      | Enable or disable placement_id. 0:disable,1:incoming_napi,2:incoming_cpu
+enable_zerocopy_send_server | Optional | boolean     | Enable or disable zero copy on send for server sockets
+enable_zerocopy_send_client | Optional | boolean     | Enable or disable zero copy on send for client sockets
 
 ### Response
 
@@ -8632,7 +8638,9 @@ Example request:
     "enable_recv_pipe": false,
     "enable_zerocopy_send": true,
     "enable_quick_ack": false,
-    "enable_placement_id": 0
+    "enable_placement_id": 0,
+    "enable_zerocopy_send_server": true,
+    "enable_zerocopy_send_client": false
   }
 }
 ~~~
diff --git a/examples/nvme/perf/perf.c b/examples/nvme/perf/perf.c
index b34585957..844d6908f 100644
--- a/examples/nvme/perf/perf.c
+++ b/examples/nvme/perf/perf.c
@@ -335,6 +335,7 @@ perf_set_sock_zcopy(const char *impl_name, bool enable)
 	}
 
 	sock_opts.enable_zerocopy_send = enable;
+	sock_opts.enable_zerocopy_send_client = enable;
 
 	if (spdk_sock_impl_set_opts(impl_name, &sock_opts, opts_size)) {
 		fprintf(stderr, "Failed to %s zcopy send for sock impl %s: error %d (%s)\n",
diff --git a/include/spdk/sock.h b/include/spdk/sock.h
index 73b6a2046..1fcecf93e 100644
--- a/include/spdk/sock.h
+++ b/include/spdk/sock.h
@@ -126,6 +126,15 @@ struct spdk_sock_impl_opts {
 	 */
 	uint32_t enable_placement_id;
 
+	/**
+	 * Enable or disable use of zero copy flow on send for server sockets. Used by posix socket module.
+	 */
+	bool enable_zerocopy_send_server;
+
+	/**
+	 * Enable or disable use of zero copy flow on send for client sockets. Used by posix socket module.
+	 */
+	bool enable_zerocopy_send_client;
 };
 
 /**
diff --git a/lib/sock/sock.c b/lib/sock/sock.c
index 1438f12d8..320e7474e 100644
--- a/lib/sock/sock.c
+++ b/lib/sock/sock.c
@@ -791,6 +791,8 @@ spdk_sock_write_config_json(struct spdk_json_write_ctx *w)
 			spdk_json_write_named_bool(w, "enable_zerocopy_send", opts.enable_zerocopy_send);
 			spdk_json_write_named_bool(w, "enable_quickack", opts.enable_quickack);
 			spdk_json_write_named_uint32(w, "enable_placement_id", opts.enable_placement_id);
+			spdk_json_write_named_bool(w, "enable_zerocopy_send_server", opts.enable_zerocopy_send_server);
+			spdk_json_write_named_bool(w, "enable_zerocopy_send_client", opts.enable_zerocopy_send_client);
 			spdk_json_write_object_end(w);
 			spdk_json_write_object_end(w);
 		} else {
diff --git a/lib/sock/sock_rpc.c b/lib/sock/sock_rpc.c
index 602fb8699..46d725cbd 100644
--- a/lib/sock/sock_rpc.c
+++ b/lib/sock/sock_rpc.c
@@ -1,7 +1,7 @@
 /*-
  *   BSD LICENSE
  *
- *   Copyright (c) 2020 Mellanox Technologies LTD. All rights reserved.
+ *   Copyright (c) 2020, 2021 Mellanox Technologies LTD. All rights reserved.
  *
  *   Redistribution and use in source and binary forms, with or without
  *   modification, are permitted provided that the following conditions
@@ -77,6 +77,8 @@ rpc_sock_impl_get_options(struct spdk_jsonrpc_request *request,
 	spdk_json_write_named_bool(w, "enable_zerocopy_send", sock_opts.enable_zerocopy_send);
 	spdk_json_write_named_bool(w, "enable_quickack", sock_opts.enable_quickack);
 	spdk_json_write_named_uint32(w, "enable_placement_id", sock_opts.enable_placement_id);
+	spdk_json_write_named_bool(w, "enable_zerocopy_send_server", sock_opts.enable_zerocopy_send_server);
+	spdk_json_write_named_bool(w, "enable_zerocopy_send_client", sock_opts.enable_zerocopy_send_client);
 	spdk_json_write_object_end(w);
 	spdk_jsonrpc_end_result(request, w);
 	free(impl_name);
@@ -118,7 +120,14 @@ static const struct spdk_json_object_decoder rpc_sock_impl_set_opts_decoders[] =
 		"enable_placement_id", offsetof(struct spdk_rpc_sock_impl_set_opts, sock_opts.enable_placement_id),
 		spdk_json_decode_uint32, true
 	},
-
+	{
+		"enable_zerocopy_send_server", offsetof(struct spdk_rpc_sock_impl_set_opts, sock_opts.enable_zerocopy_send_server),
+		spdk_json_decode_bool, true
+	},
+	{
+		"enable_zerocopy_send_client", offsetof(struct spdk_rpc_sock_impl_set_opts, sock_opts.enable_zerocopy_send_client),
+		spdk_json_decode_bool, true
+	}
 };
 
 static void
diff --git a/module/sock/posix/posix.c b/module/sock/posix/posix.c
index 53dc1d498..59125f823 100644
--- a/module/sock/posix/posix.c
+++ b/module/sock/posix/posix.c
@@ -92,6 +92,8 @@ static struct spdk_sock_impl_opts g_spdk_posix_sock_impl_opts = {
 	.enable_zerocopy_send = true,
 	.enable_quickack = false,
 	.enable_placement_id = PLACEMENT_NONE,
+	.enable_zerocopy_send_server = true,
+	.enable_zerocopy_send_client = false
 };
 
 static struct spdk_sock_map g_map = {
@@ -348,7 +350,7 @@ posix_sock_alloc(int fd, bool enable_zero_copy)
 #if defined(SPDK_ZEROCOPY)
 	flag = 1;
 
-	if (enable_zero_copy && g_spdk_posix_sock_impl_opts.enable_zerocopy_send) {
+	if (enable_zero_copy) {
 		/* Try to turn on zero copy sends */
 		rc = setsockopt(sock->fd, SOL_SOCKET, SO_ZEROCOPY, &flag, sizeof(flag));
 		if (rc == 0) {
@@ -441,7 +443,8 @@ posix_sock_create(const char *ip, int port,
 	int fd, flag;
 	int val = 1;
 	int rc, sz;
-	bool enable_zero_copy = true;
+	bool enable_zcopy_user_opts = true;
+	bool enable_zcopy_impl_opts = true;
 
 	assert(opts != NULL);
 
@@ -555,6 +558,8 @@ retry:
 				fd = -1;
 				break;
 			}
+			enable_zcopy_impl_opts = g_spdk_posix_sock_impl_opts.enable_zerocopy_send_server &&
+						 g_spdk_posix_sock_impl_opts.enable_zerocopy_send;
 		} else if (type == SPDK_SOCK_CREATE_CONNECT) {
 			rc = connect(fd, res->ai_addr, res->ai_addrlen);
 			if (rc != 0) {
@@ -564,6 +569,8 @@ retry:
 				fd = -1;
 				continue;
 			}
+			enable_zcopy_impl_opts = g_spdk_posix_sock_impl_opts.enable_zerocopy_send_client &&
+						 g_spdk_posix_sock_impl_opts.enable_zerocopy_send;
 		}
 
 		flag = fcntl(fd, F_GETFL);
@@ -582,9 +589,9 @@ retry:
 	}
 
 	/* Only enable zero copy for non-loopback sockets. */
-	enable_zero_copy = opts->zcopy && !sock_is_loopback(fd);
+	enable_zcopy_user_opts = opts->zcopy && !sock_is_loopback(fd);
 
-	sock = posix_sock_alloc(fd, enable_zero_copy);
+	sock = posix_sock_alloc(fd, enable_zcopy_user_opts && enable_zcopy_impl_opts);
 	if (sock == NULL) {
 		SPDK_ERRLOG("sock allocation failed\n");
 		close(fd);
@@ -1524,6 +1531,8 @@ posix_sock_impl_get_opts(struct spdk_sock_impl_opts *opts, size_t *len)
 	GET_FIELD(enable_zerocopy_send);
 	GET_FIELD(enable_quickack);
 	GET_FIELD(enable_placement_id);
+	GET_FIELD(enable_zerocopy_send_server);
+	GET_FIELD(enable_zerocopy_send_client);
 
 #undef GET_FIELD
 #undef FIELD_OK
@@ -1554,6 +1563,8 @@ posix_sock_impl_set_opts(const struct spdk_sock_impl_opts *opts, size_t len)
 	SET_FIELD(enable_zerocopy_send);
 	SET_FIELD(enable_quickack);
 	SET_FIELD(enable_placement_id);
+	SET_FIELD(enable_zerocopy_send_server);
+	SET_FIELD(enable_zerocopy_send_client);
 
 #undef SET_FIELD
 #undef FIELD_OK
diff --git a/scripts/rpc.py b/scripts/rpc.py
index 3de543e9e..7fecc5388 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -2606,7 +2606,9 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
                                        enable_recv_pipe=args.enable_recv_pipe,
                                        enable_zerocopy_send=args.enable_zerocopy_send,
                                        enable_quickack=args.enable_quickack,
-                                       enable_placement_id=args.enable_placement_id)
+                                       enable_placement_id=args.enable_placement_id,
+                                       enable_zerocopy_send_server=args.enable_zerocopy_send_server,
+                                       enable_zerocopy_send_client=args.enable_zerocopy_send_client)
 
     p = subparsers.add_parser('sock_impl_set_options', help="""Set options of socket layer implementation""")
     p.add_argument('-i', '--impl', help='Socket implementation name, e.g. posix', required=True)
@@ -2625,8 +2627,17 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
                    action='store_true', dest='enable_quickack')
     p.add_argument('--disable-quickack', help='Disable quick ACK',
                    action='store_false', dest='enable_quickack')
+    p.add_argument('--enable-zerocopy-send-server', help='Enable zerocopy on send for server sockets',
+                   action='store_true', dest='enable_zerocopy_send_server')
+    p.add_argument('--disable-zerocopy-send-server', help='Disable zerocopy on send for server sockets',
+                   action='store_false', dest='enable_zerocopy_server_client')
+    p.add_argument('--enable-zerocopy-send-client', help='Enable zerocopy on send for client sockets',
+                   action='store_true', dest='enable_zerocopy_send_client')
+    p.add_argument('--disable-zerocopy-send-client', help='Disable zerocopy on send for client sockets',
+                   action='store_false', dest='enable_zerocopy_send_client')
     p.set_defaults(func=sock_impl_set_options, enable_recv_pipe=None, enable_zerocopy_send=None,
-                   enable_quickack=None, enable_placement_id=None)
+                   enable_quickack=None, enable_placement_id=None, enable_zerocopy_send_server=None,
+                   enable_zerocopy_send_client=None)
 
     def sock_set_default_impl(args):
         print_json(rpc.sock.sock_set_default_impl(args.client,
diff --git a/scripts/rpc/sock.py b/scripts/rpc/sock.py
index 081bf91b1..450822069 100644
--- a/scripts/rpc/sock.py
+++ b/scripts/rpc/sock.py
@@ -18,7 +18,9 @@ def sock_impl_set_options(client,
                           enable_recv_pipe=None,
                           enable_zerocopy_send=None,
                           enable_quickack=None,
-                          enable_placement_id=None):
+                          enable_placement_id=None,
+                          enable_zerocopy_send_server=None,
+                          enable_zerocopy_send_client=None):
     """Set parameters for the socket layer implementation.
 
     Args:
@@ -29,6 +31,8 @@ def sock_impl_set_options(client,
         enable_zerocopy_send: enable or disable zerocopy on send (optional)
         enable_quickack: enable or disable quickack (optional)
         enable_placement_id: option for placement_id. 0:disable,1:incoming_napi,2:incoming_cpu (optional)
+        enable_zerocopy_send_server: enable or disable zerocopy on send for server sockets(optional)
+        enable_zerocopy_send_client: enable or disable zerocopy on send for client sockets(optional)
     """
     params = {}
 
@@ -45,6 +49,10 @@ def sock_impl_set_options(client,
         params['enable_quickack'] = enable_quickack
     if enable_placement_id is not None:
         params['enable_placement_id'] = enable_placement_id
+    if enable_zerocopy_send_server is not None:
+        params['enable_zerocopy_send_server'] = enable_zerocopy_send_server
+    if enable_zerocopy_send_client is not None:
+        params['enable_zerocopy_send_client'] = enable_zerocopy_send_client
 
     return client.call('sock_impl_set_options', params)
 
-- 
2.26.2


From 2fd97e28bf3ba91a856089cdc02f33a53da2dd3e Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Mon, 26 Apr 2021 12:15:52 +0300
Subject: [PATCH 002/342] sock: Deprecate enable_zerocopy_send in
 sock_impl_set_options RPC

This deprecated parameter will be removed in SPDK 21.07

Change-Id: I2b2fbcc798bb50fa6f9dfe35045f66e41c1ceaa9
Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7608
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 CHANGELOG.md        | 5 +++++
 deprecation.md      | 7 +++++++
 doc/jsonrpc.md      | 2 +-
 include/spdk/sock.h | 1 +
 scripts/rpc.py      | 6 ++++--
 scripts/rpc/sock.py | 3 ++-
 6 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index f7667a84f..f227ad324 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -161,6 +161,11 @@ For `bdev_raid_create` RPC, the deprecated parameter `strip_size` was removed.
 New RPC `bdev_nvme_get_transport_statistics` was added, it allows to get transport statistics
 of nvme poll groups.
 
+Parameter `enable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,
+use `enable-zerocopy-send-server` or `enable-zerocopy-send-client` instead.
+Parameter `disable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,
+use `disable-zerocopy-send-server` or `disable-zerocopy-send-client` instead.
+
 ### rpm
 
 Added support for new RPM spec, rpmbuild/spdk.spec, which can be used for packaging the
diff --git a/deprecation.md b/deprecation.md
index af5e595d8..691710399 100644
--- a/deprecation.md
+++ b/deprecation.md
@@ -28,6 +28,13 @@ The following APIs have been deprecated and will be removed in SPDK 21.07:
 - `poll_group_free_stat` (transport op in `nvmf_transport.h`).
 Please use `spdk_nvmf_poll_group_dump_stat` and `poll_group_dump_stat` instead.
 
+## rpc
+
+Parameter `enable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,
+use `enable-zerocopy-send-server` or `enable-zerocopy-send-client` instead.
+Parameter `disable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,
+use `disable-zerocopy-send-server` or `disable-zerocopy-send-client` instead.
+
 ## rpm
 
 `pkg/spdk.spec` is considered to be deprecated and scheduled for removal in SPDK 21.07.
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 2833a0125..e5e4d748a 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -8612,7 +8612,7 @@ impl_name                   | Required | string      | Name of socket implementa
 recv_buf_size               | Optional | number      | Size of socket receive buffer in bytes
 send_buf_size               | Optional | number      | Size of socket send buffer in bytes
 enable_recv_pipe            | Optional | boolean     | Enable or disable receive pipe
-enable_zerocopy_send        | Optional | boolean     | Enable or disable zero copy on send for client and server sockets
+enable_zerocopy_send        | Optional | boolean     | Deprecated. Enable or disable zero copy on send for client and server sockets
 enable_quick_ack            | Optional | boolean     | Enable or disable quick ACK
 enable_placement_id         | Optional | number      | Enable or disable placement_id. 0:disable,1:incoming_napi,2:incoming_cpu
 enable_zerocopy_send_server | Optional | boolean     | Enable or disable zero copy on send for server sockets
diff --git a/include/spdk/sock.h b/include/spdk/sock.h
index 1fcecf93e..6336c167f 100644
--- a/include/spdk/sock.h
+++ b/include/spdk/sock.h
@@ -111,6 +111,7 @@ struct spdk_sock_impl_opts {
 	bool enable_recv_pipe;
 
 	/**
+	 * **Deprecated, please use enable_zerocopy_send_server or enable_zerocopy_send_client instead**
 	 * Enable or disable use of zero copy flow on send. Used by posix socket module.
 	 */
 	bool enable_zerocopy_send;
diff --git a/scripts/rpc.py b/scripts/rpc.py
index 7fecc5388..f60863cb0 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -2619,9 +2619,11 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
                    action='store_true', dest='enable_recv_pipe')
     p.add_argument('--disable-recv-pipe', help='Disable receive pipe',
                    action='store_false', dest='enable_recv_pipe')
-    p.add_argument('--enable-zerocopy-send', help='Enable zerocopy on send',
+    p.add_argument('--enable-zerocopy-send', help="""Enable zerocopy on send
+    (Deprecated, use enable-zerocopy-send-server or enable-zerocopy-send-client)""",
                    action='store_true', dest='enable_zerocopy_send')
-    p.add_argument('--disable-zerocopy-send', help='Disable zerocopy on send',
+    p.add_argument('--disable-zerocopy-send', help="""Enable zerocopy on send
+    (Deprecated, use disable-zerocopy-send-server or disable-zerocopy-send-client)""",
                    action='store_false', dest='enable_zerocopy_send')
     p.add_argument('--enable-quickack', help='Enable quick ACK',
                    action='store_true', dest='enable_quickack')
diff --git a/scripts/rpc/sock.py b/scripts/rpc/sock.py
index 450822069..cd1c42887 100644
--- a/scripts/rpc/sock.py
+++ b/scripts/rpc/sock.py
@@ -28,7 +28,7 @@ def sock_impl_set_options(client,
         recv_buf_size: size of socket receive buffer in bytes (optional)
         send_buf_size: size of socket send buffer in bytes (optional)
         enable_recv_pipe: enable or disable receive pipe (optional)
-        enable_zerocopy_send: enable or disable zerocopy on send (optional)
+        enable_zerocopy_send: (Deprecated) enable or disable zerocopy on send (optional)
         enable_quickack: enable or disable quickack (optional)
         enable_placement_id: option for placement_id. 0:disable,1:incoming_napi,2:incoming_cpu (optional)
         enable_zerocopy_send_server: enable or disable zerocopy on send for server sockets(optional)
@@ -44,6 +44,7 @@ def sock_impl_set_options(client,
     if enable_recv_pipe is not None:
         params['enable_recv_pipe'] = enable_recv_pipe
     if enable_zerocopy_send is not None:
+        print("WARNING: enable_zerocopy_send is deprecated, please use enable_zerocopy_send_server or enable_zerocopy_send_client.")
         params['enable_zerocopy_send'] = enable_zerocopy_send
     if enable_quickack is not None:
         params['enable_quickack'] = enable_quickack
-- 
2.26.2


From 5f106e26c9f3d3c2e8972e8c166a2064d83d3cbd Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 26 Apr 2021 12:23:05 -0400
Subject: [PATCH 003/342] version: SPDK 21.07 pre

This is first commit that should go into latest SPDK
after the code freeze for SPDK 21.04.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I515772a0c90a362bd4a23a7717281a8d7a9e4393
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7615
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 CHANGELOG.md           | 4 +++-
 include/spdk/version.h | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index f227ad324..5c76c4126 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,8 @@
 # Changelog
 
-## v21.04: (Upcoming Release)
+## v21.07: (Upcoming Release)
+
+## v21.04:
 
 ### accel
 
diff --git a/include/spdk/version.h b/include/spdk/version.h
index 5814028a9..39c47d369 100644
--- a/include/spdk/version.h
+++ b/include/spdk/version.h
@@ -46,7 +46,7 @@
 /**
  * Minor version number (month of original release).
  */
-#define SPDK_VERSION_MINOR	4
+#define SPDK_VERSION_MINOR	7
 
 /**
  * Patch level.
-- 
2.26.2


From a417658803b42f0cfaf65ca47bd3c193050e5fc6 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Wed, 31 Mar 2021 17:09:16 +0800
Subject: [PATCH 004/342] test/nvme_ns: cases for identifying id descriptor and
 find descriptor

Change-Id: I20d0a798423ee08f4a9e019aa62b93981586d134
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7161
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/unit/lib/nvme/nvme_ns.c/nvme_ns_ut.c | 70 +++++++++++++++++++++++
 1 file changed, 70 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_ns.c/nvme_ns_ut.c b/test/unit/lib/nvme/nvme_ns.c/nvme_ns_ut.c
index 39f03ed4f..fa8468fd1 100644
--- a/test/unit/lib/nvme/nvme_ns.c/nvme_ns_ut.c
+++ b/test/unit/lib/nvme/nvme_ns.c/nvme_ns_ut.c
@@ -63,11 +63,15 @@ static struct spdk_nvme_zns_ns_data nsdata_zns = {
 	.mor = 1024,
 };
 
+struct spdk_nvme_cmd g_ut_cmd = {};
+
 int
 nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cntid, uint32_t nsid,
 			uint8_t csi, void *payload, size_t payload_size,
 			spdk_nvme_cmd_cb cb_fn, void *cb_arg)
 {
+	memset(&g_ut_cmd, 0, sizeof(g_ut_cmd));
+
 	if (cns == SPDK_NVME_IDENTIFY_NS) {
 		assert(payload_size == sizeof(struct spdk_nvme_ns_data));
 		if (fake_nsdata) {
@@ -81,6 +85,12 @@ nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cnt
 		assert(payload_size == sizeof(struct spdk_nvme_zns_ns_data));
 		memcpy(payload, &nsdata_zns, sizeof(struct spdk_nvme_zns_ns_data));
 		return 0;
+	} else if (cns == SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST) {
+		g_ut_cmd.cdw10_bits.identify.cns = cns;
+		g_ut_cmd.cdw10_bits.identify.cntid = cntid;
+		g_ut_cmd.cdw11_bits.identify.csi = csi;
+		g_ut_cmd.nsid = nsid;
+		return 0;
 	}
 	return -1;
 }
@@ -453,6 +463,64 @@ test_nvme_ctrlr_identify_ns_iocs_specific(void)
 	CU_ASSERT(ns.nsdata_zns == NULL);
 }
 
+static void
+test_nvme_ctrlr_identify_id_desc(void)
+{
+	struct spdk_nvme_ns ns = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	int rc;
+
+	ns.ctrlr = &ctrlr;
+	ns.ctrlr->vs.raw = SPDK_NVME_VERSION(1, 3, 0);
+	ns.ctrlr->cap.bits.css |= SPDK_NVME_CAP_CSS_IOCS;
+	ns.id = 1;
+
+	rc = nvme_ctrlr_identify_id_desc(&ns);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(g_ut_cmd.cdw10_bits.identify.cns == SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST);
+	CU_ASSERT(g_ut_cmd.cdw10_bits.identify.cntid == 0);
+	CU_ASSERT(g_ut_cmd.cdw11_bits.identify.csi == spdk_nvme_ns_get_csi(&ns));
+	CU_ASSERT(g_ut_cmd.nsid == 1);
+
+	/* NVME version and css unsupported */
+	ns.ctrlr->vs.raw = SPDK_NVME_VERSION(1, 2, 0);
+	ns.ctrlr->cap.bits.css &= ~SPDK_NVME_CAP_CSS_IOCS;
+
+	rc = nvme_ctrlr_identify_id_desc(&ns);
+	CU_ASSERT(rc == 0);
+}
+
+static void
+test_nvme_ns_find_id_desc(void)
+{
+	struct spdk_nvme_ns ns = {};
+	struct spdk_nvme_ns_id_desc *desc = NULL;
+	const uint8_t *csi = NULL;
+	size_t length = 0;
+
+	desc = (void *)ns.id_desc_list;
+	desc->nidl = 4;
+	desc->nidt = SPDK_NVME_NIDT_CSI;
+
+	/* Case 1: get id descriptor successfully */
+	csi = nvme_ns_find_id_desc(&ns, SPDK_NVME_NIDT_CSI, &length);
+	CU_ASSERT(csi == desc->nid);
+	CU_ASSERT(length == 4);
+
+	/* Case 2: ns_id length invalid, expect fail */
+	desc->nidl = 0;
+
+	csi = nvme_ns_find_id_desc(&ns, SPDK_NVME_NIDT_CSI, &length);
+	CU_ASSERT(csi == NULL);
+
+	/* Case 3: No correct id descriptor type entry, expect fail */
+	desc->nidl = 4;
+	desc->nidt = SPDK_NVME_NIDT_CSI;
+
+	csi = nvme_ns_find_id_desc(&ns, SPDK_NVME_NIDT_UUID, &length);
+	CU_ASSERT(csi == NULL);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -473,6 +541,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, spdk_nvme_ns_supports);
 	CU_ADD_TEST(suite, test_nvme_ns_has_supported_iocs_specific_data);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_identify_ns_iocs_specific);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_identify_id_desc);
+	CU_ADD_TEST(suite, test_nvme_ns_find_id_desc);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 8af74b5ac7d6c7a61830732b623bc3074a24c4ad Mon Sep 17 00:00:00 2001
From: Rui Chang <rui.chang@arm.com>
Date: Fri, 16 Apr 2021 14:28:05 +0800
Subject: [PATCH 005/342] test/setup: fix failure in allowed() when there is
 only one device

If there is only one device in ${devs[*]}, we see failure backtrace:
========== Backtrace start: ==========

in /home/jenkins/spdk_repo/spdk/test/setup/acl.sh:41 -> allowed([])
     ...
   36  	}
   37
   38  	allowed() {
   39  		PCI_ALLOWED="${devs[0]}" setup output config \
   40  			| grep "Skipping denied controller at " \
=> 41  			| grep -v "${devs[0]}"
   42  		verify "${devs[@]:1}"
   43  		setup reset
   44  	}
   45
   46  	setup reset

Signed-off-by: Rui Chang <rui.chang@arm.com>
Change-Id: I9aba6b19f6de6bea7149e0f39da8d5d8d6978a4e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7467
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 test/setup/acl.sh | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/test/setup/acl.sh b/test/setup/acl.sh
index 4c3b9bc22..088caf9ea 100755
--- a/test/setup/acl.sh
+++ b/test/setup/acl.sh
@@ -11,6 +11,7 @@ collect_setup_devs() {
 
 	while read -r _ dev _ _ _ driver _; do
 		[[ $dev == *:*:*.* ]] || continue
+		[[ $driver == nvme ]] || continue
 		devs+=("$dev") drivers["$dev"]=$driver
 	done < <(setup output status)
 	((${#devs[@]} > 0))
@@ -37,8 +38,7 @@ denied() {
 
 allowed() {
 	PCI_ALLOWED="${devs[0]}" setup output config \
-		| grep "Skipping denied controller at " \
-		| grep -v "${devs[0]}"
+		| grep -E "${devs[0]} .*: ${drivers["${devs[0]}"]} -> .*"
 	verify "${devs[@]:1}"
 	setup reset
 }
-- 
2.26.2


From 71b4e2a968331bf2a47742d8c97c8f86aa7b402f Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Wed, 21 Apr 2021 18:34:08 +0200
Subject: [PATCH 006/342] autobuild: build mainline DPDK with -Werror only for
 GCC > 5

DPDK now officially supports only GCC > 4.9.0.
Some older systems like Centos7  (gcc 4.8.5) can still
build DPDK, but sometimes fail due to -Werror enabled.
Disable this option to increase build success chance.

Fixes #1891

Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Change-Id: I0950ad01e2d8361851e9ac42c556004980e00ff4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7536
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autobuild.sh | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/autobuild.sh b/autobuild.sh
index f66c063d2..5f3ef533a 100755
--- a/autobuild.sh
+++ b/autobuild.sh
@@ -51,7 +51,10 @@ function ocf_precompile() {
 function build_native_dpdk() {
 	local external_dpdk_dir
 	local external_dpdk_base_dir
+	local gcc_version
 
+	gcc_version=$(gcc -dumpversion)
+	gcc_version=${gcc_version//./}
 	external_dpdk_dir="$SPDK_RUN_EXTERNAL_DPDK"
 	external_dpdk_base_dir="$(dirname $external_dpdk_dir)"
 
@@ -65,9 +68,13 @@ function build_native_dpdk() {
 	git clone --branch $SPDK_TEST_NATIVE_DPDK --depth 1 http://dpdk.org/git/dpdk "$external_dpdk_base_dir"
 	git -C "$external_dpdk_base_dir" log --oneline -n 5
 
-	dpdk_cflags="-fPIC -g -Werror -fcommon"
+	dpdk_cflags="-fPIC -g -fcommon"
 	dpdk_ldflags=""
 
+	if [[ $gcc_version -ge 5 ]]; then
+		dpdk_cflags+=" -Werror"
+	fi
+
 	# the drivers we use
 	# net/i40e driver is not really needed by us, but it's built as a workaround
 	# for DPDK issue: https://bugs.dpdk.org/show_bug.cgi?id=576
-- 
2.26.2


From e1fe11875ba629483314e656b6f90bf130a8bfd1 Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Wed, 21 Apr 2021 18:37:23 +0200
Subject: [PATCH 007/342] autobuild: enable -Wno-stringop-overflow for DPDK
 builds only for GCC > 10

Use -Wno-stringop-overflow only for GCC > 10.
Change made to use the same condition as in
dpdkbuild/Makefile.

Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Change-Id: I6a396e250807f46720ff5dcaf21f13d802404a1b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7537
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autobuild.sh | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/autobuild.sh b/autobuild.sh
index 5f3ef533a..4edde9691 100755
--- a/autobuild.sh
+++ b/autobuild.sh
@@ -75,6 +75,10 @@ function build_native_dpdk() {
 		dpdk_cflags+=" -Werror"
 	fi
 
+	if [[ $gcc_version -ge 10 ]]; then
+		dpdk_cflags+=" -Wno-stringop-overflow"
+	fi
+
 	# the drivers we use
 	# net/i40e driver is not really needed by us, but it's built as a workaround
 	# for DPDK issue: https://bugs.dpdk.org/show_bug.cgi?id=576
@@ -120,7 +124,6 @@ function build_native_dpdk() {
 
 	cd $external_dpdk_base_dir
 	if [ "$(uname -s)" = "Linux" ]; then
-		dpdk_cflags+=" -Wno-stringop-overflow"
 		# Fix for freeing device if not kernel driver configured.
 		# TODO: Remove once this is merged in upstream DPDK
 		if grep "20.08.0" $external_dpdk_base_dir/VERSION; then
-- 
2.26.2


From 9ed384dab022654ea31d484e4da8c216e178a00f Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Mon, 29 Mar 2021 17:24:46 +0800
Subject: [PATCH 008/342] test/nvme_pcie: cases for building PRP and SGL
 request

Change-Id: I41c13f95b36308154dfa61ef8c6c54592ee7525d
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7143
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c | 203 +++++++++++++++++-
 1 file changed, 202 insertions(+), 1 deletion(-)

diff --git a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
index b988f795a..f7fa13ed1 100644
--- a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
@@ -86,6 +86,11 @@ DEFINE_STUB(nvme_transport_get_name, const char *, (const struct spdk_nvme_trans
 
 SPDK_LOG_REGISTER_COMPONENT(nvme)
 
+struct nvme_pcie_ut_bdev_io {
+	struct iovec iovs[NVME_MAX_SGL_DESCRIPTORS];
+	int iovpos;
+};
+
 struct nvme_driver *g_spdk_nvme_driver = NULL;
 
 void
@@ -139,7 +144,9 @@ prp_list_prep(struct nvme_tracker *tr, struct nvme_request *req, uint32_t *prp_i
 	memset(tr, 0, sizeof(*tr));
 	tr->req = req;
 	tr->prp_sgl_bus_addr = 0xDEADBEEF;
-	*prp_index = 0;
+	if (prp_index) {
+		*prp_index = 0;
+	}
 }
 
 static void
@@ -509,6 +516,197 @@ test_nvme_pcie_qpair_build_metadata(void)
 	MOCK_CLEAR(spdk_vtophys);
 }
 
+static int
+nvme_pcie_ut_next_sge(void *cb_arg, void **address, uint32_t *length)
+{
+	struct nvme_pcie_ut_bdev_io *bio = cb_arg;
+	struct iovec *iov;
+
+	SPDK_CU_ASSERT_FATAL(bio->iovpos < NVME_MAX_SGL_DESCRIPTORS);
+
+	iov = &bio->iovs[bio->iovpos];
+
+	*address = iov->iov_base;
+	*length = iov->iov_len;
+	bio->iovpos++;
+
+	return 0;
+}
+
+static void
+nvme_pcie_ut_reset_sgl(void *cb_arg, uint32_t offset)
+{
+	struct nvme_pcie_ut_bdev_io *bio = cb_arg;
+	struct iovec *iov;
+
+	for (bio->iovpos = 0; bio->iovpos < NVME_MAX_SGL_DESCRIPTORS; bio->iovpos++) {
+		iov = &bio->iovs[bio->iovpos];
+		/* Offset must be aligned with the start of any SGL entry */
+		if (offset == 0) {
+			break;
+		}
+
+		SPDK_CU_ASSERT_FATAL(offset >= iov->iov_len);
+		offset -= iov->iov_len;
+	}
+
+	SPDK_CU_ASSERT_FATAL(offset == 0);
+	SPDK_CU_ASSERT_FATAL(bio->iovpos < NVME_MAX_SGL_DESCRIPTORS);
+}
+
+static void
+test_nvme_pcie_qpair_build_prps_sgl_request(void)
+{
+	struct spdk_nvme_qpair qpair = {};
+	struct nvme_request req = {};
+	struct nvme_tracker tr = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct nvme_pcie_ut_bdev_io bio = {};
+	int rc;
+
+	tr.req = &req;
+	qpair.ctrlr = &ctrlr;
+	req.payload.contig_or_cb_arg = &bio;
+
+	req.payload.reset_sgl_fn = nvme_pcie_ut_reset_sgl;
+	req.payload.next_sge_fn = nvme_pcie_ut_next_sge;
+	req.payload_size = 4096;
+	ctrlr.page_size = 4096;
+	bio.iovs[0].iov_base = (void *)0x100000;
+	bio.iovs[0].iov_len = 4096;
+
+	rc = nvme_pcie_qpair_build_prps_sgl_request(&qpair, &req, &tr, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.dptr.prp.prp1 == 0x100000);
+}
+
+static void
+test_nvme_pcie_qpair_build_hw_sgl_request(void)
+{
+	struct spdk_nvme_qpair qpair = {};
+	struct nvme_request req = {};
+	struct nvme_tracker tr = {};
+	struct nvme_pcie_ut_bdev_io bio = {};
+	int rc;
+
+	req.payload.contig_or_cb_arg = &bio;
+	req.payload.reset_sgl_fn = nvme_pcie_ut_reset_sgl;
+	req.payload.next_sge_fn = nvme_pcie_ut_next_sge;
+	req.cmd.opc = SPDK_NVME_OPC_WRITE;
+	tr.prp_sgl_bus_addr =  0xDAADBEE0;
+	g_vtophys_size = 4096;
+
+	/* Multiple vectors, 2k + 4k + 2k */
+	req.payload_size = 8192;
+	bio.iovpos = 3;
+	bio.iovs[0].iov_base = (void *)0xDBADBEE0;
+	bio.iovs[0].iov_len = 2048;
+	bio.iovs[1].iov_base = (void *)0xDCADBEE0;
+	bio.iovs[1].iov_len = 4096;
+	bio.iovs[2].iov_base = (void *)0xDDADBEE0;
+	bio.iovs[2].iov_len = 2048;
+
+	rc = nvme_pcie_qpair_build_hw_sgl_request(&qpair, &req, &tr, true);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(tr.u.sgl[0].unkeyed.type == SPDK_NVME_SGL_TYPE_DATA_BLOCK);
+	CU_ASSERT(tr.u.sgl[0].unkeyed.length == 2048);
+	CU_ASSERT(tr.u.sgl[0].address == 0xDBADBEE0);
+	CU_ASSERT(tr.u.sgl[0].unkeyed.subtype == 0);
+	CU_ASSERT(tr.u.sgl[1].unkeyed.type == SPDK_NVME_SGL_TYPE_DATA_BLOCK);
+	CU_ASSERT(tr.u.sgl[1].unkeyed.length == 4096);
+	CU_ASSERT(tr.u.sgl[1].address == 0xDCADBEE0);
+	CU_ASSERT(tr.u.sgl[2].unkeyed.type == SPDK_NVME_SGL_TYPE_DATA_BLOCK);
+	CU_ASSERT(tr.u.sgl[2].unkeyed.length == 2048);
+	CU_ASSERT(tr.u.sgl[2].unkeyed.length == 2048);
+	CU_ASSERT(tr.u.sgl[2].address == 0xDDADBEE0);
+	CU_ASSERT(req.cmd.psdt == SPDK_NVME_PSDT_SGL_MPTR_CONTIG);
+	CU_ASSERT(req.cmd.dptr.sgl1.unkeyed.subtype == 0);
+	CU_ASSERT(req.cmd.dptr.sgl1.unkeyed.type == SPDK_NVME_SGL_TYPE_LAST_SEGMENT);
+	CU_ASSERT(req.cmd.dptr.sgl1.address == 0xDAADBEE0);
+	CU_ASSERT(req.cmd.dptr.sgl1.unkeyed.length == 48);
+
+	/* Single vector */
+	memset(&tr, 0, sizeof(tr));
+	memset(&bio, 0, sizeof(bio));
+	memset(&req, 0, sizeof(req));
+	req.payload.contig_or_cb_arg = &bio;
+	req.payload.reset_sgl_fn = nvme_pcie_ut_reset_sgl;
+	req.payload.next_sge_fn = nvme_pcie_ut_next_sge;
+	req.cmd.opc = SPDK_NVME_OPC_WRITE;
+	req.payload_size = 4096;
+	bio.iovpos = 1;
+	bio.iovs[0].iov_base = (void *)0xDBADBEE0;
+	bio.iovs[0].iov_len = 4096;
+
+	rc = nvme_pcie_qpair_build_hw_sgl_request(&qpair, &req, &tr, true);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(tr.u.sgl[0].unkeyed.type == SPDK_NVME_SGL_TYPE_DATA_BLOCK);
+	CU_ASSERT(tr.u.sgl[0].unkeyed.length == 4096);
+	CU_ASSERT(tr.u.sgl[0].address == 0xDBADBEE0);
+	CU_ASSERT(tr.u.sgl[0].unkeyed.subtype == 0);
+	CU_ASSERT(req.cmd.psdt == SPDK_NVME_PSDT_SGL_MPTR_CONTIG);
+	CU_ASSERT(req.cmd.dptr.sgl1.unkeyed.subtype == 0);
+	CU_ASSERT(req.cmd.dptr.sgl1.unkeyed.type == SPDK_NVME_SGL_TYPE_DATA_BLOCK);
+	CU_ASSERT(req.cmd.dptr.sgl1.address == 0xDBADBEE0);
+	CU_ASSERT(req.cmd.dptr.sgl1.unkeyed.length == 4096);
+}
+
+static void
+test_nvme_pcie_qpair_build_contig_request(void)
+{
+	struct nvme_pcie_qpair pqpair = {};
+	struct nvme_request req = {};
+	struct nvme_tracker tr = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	int rc;
+
+	pqpair.qpair.ctrlr = &ctrlr;
+	ctrlr.page_size = 0x1000;
+
+	/* 1 prp, 4k-aligned */
+	prp_list_prep(&tr, &req, NULL);
+	req.payload_size = 0x1000;
+	req.payload.contig_or_cb_arg = (void *)0x100000;
+
+	rc = nvme_pcie_qpair_build_contig_request(&pqpair.qpair, &req, &tr, true);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.dptr.prp.prp1 == 0x100000);
+
+	/* 2 prps, non-4K-aligned */
+	prp_list_prep(&tr, &req, NULL);
+	req.payload_size = 0x1000;
+	req.payload_offset = 0x800;
+	req.payload.contig_or_cb_arg = (void *)0x100000;
+
+	rc = nvme_pcie_qpair_build_contig_request(&pqpair.qpair, &req, &tr, true);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.dptr.prp.prp1 == 0x100800);
+	CU_ASSERT(req.cmd.dptr.prp.prp2 == 0x101000);
+
+	/* 3 prps, 4k-aligned */
+	prp_list_prep(&tr, &req, NULL);
+	req.payload_size = 0x3000;
+	req.payload.contig_or_cb_arg = (void *)0x100000;
+
+	rc = nvme_pcie_qpair_build_contig_request(&pqpair.qpair, &req, &tr, true);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.dptr.prp.prp1 == 0x100000);
+	CU_ASSERT(req.cmd.dptr.prp.prp2 == tr.prp_sgl_bus_addr);
+	CU_ASSERT(tr.u.prp[0] == 0x101000);
+	CU_ASSERT(tr.u.prp[1] == 0x102000);
+
+	/* address not dword aligned */
+	prp_list_prep(&tr, &req, NULL);
+	req.payload_size = 0x3000;
+	req.payload.contig_or_cb_arg = (void *)0x100001;
+	req.qpair = &pqpair.qpair;
+	TAILQ_INIT(&pqpair.outstanding_tr);
+	TAILQ_INSERT_TAIL(&pqpair.outstanding_tr, &tr, tq_list);
+
+	rc = nvme_pcie_qpair_build_contig_request(&pqpair.qpair, &req, &tr, true);
+	CU_ASSERT(rc == -EFAULT);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -523,6 +721,9 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_shadow_doorbell_update);
 	CU_ADD_TEST(suite, test_build_contig_hw_sgl_request);
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_metadata);
+	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_prps_sgl_request);
+	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_hw_sgl_request);
+	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_contig_request);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 6fd1cc3716d847e708742f9b533325b6a747eb6b Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 28 Apr 2021 11:26:32 -0700
Subject: [PATCH 009/342] nvme: remove IDENTIFY_CNS quirk from normal QEMU SSDs

The IDENTIFY_CNS quirk was applied as part of QEMU
OCSSD handling in commit 6442451b.  But it was applied
not only to the OCSSD dev ID, but also the dev ID
for non-OCSSD NVMe controllers.

Starting with QEMU 5.2, QEMU will allocate a default
256 namespaces, but only some are active (associated
with the backing disks specified by the user).  QEMU
supports IDENTIFY_CNS, but since this quirk was set,
we wouldn't send a real IDENTIFY_CNS and instead
would just populate a fake list where all namespaces
were considered active.  This causes breakage in
a few places - mainly where we iterate through
the active namespaces, and then are surprised that
calling spdk_nvme_ns_is_active() returns false.

It was also breaking bdev_nvme_attach_controller RPC,
since by default we can only support returning 128
names, but since all of the namespaces were deemed
active, it was trying to return 256.

Fixes #1916.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I4fdd27e0e36f0ac07a95f9f29aa83357e8505a45

Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7658
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/nvme/nvme_quirks.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/lib/nvme/nvme_quirks.c b/lib/nvme/nvme_quirks.c
index 7355ea263..a529933f2 100644
--- a/lib/nvme/nvme_quirks.c
+++ b/lib/nvme/nvme_quirks.c
@@ -89,7 +89,6 @@ static const struct nvme_quirk nvme_quirks[] = {
 		NVME_QUIRK_DELAY_AFTER_QUEUE_ALLOC
 	},
 	{	{SPDK_PCI_CLASS_NVME, SPDK_PCI_VID_INTEL, 0x5845, SPDK_PCI_ANY_ID, SPDK_PCI_ANY_ID},
-		NVME_QUIRK_IDENTIFY_CNS |
 		NVME_INTEL_QUIRK_NO_LOG_PAGES |
 		NVME_QUIRK_MAXIMUM_PCI_ACCESS_WIDTH
 	},
-- 
2.26.2


From 5354d0c63f5da25e3c85d77bbfa44530d58c78e5 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 28 Apr 2021 12:44:18 -0700
Subject: [PATCH 010/342] nvme: reset mapping_length correctly for contig SGL

spdk_vtophys() takes a mapping_length parameter, so
it can return the length for which the returned
virtual address is valid.

But spdk_vtophys() will only return the max
between the valid length and the input mapping_length
parameter.

So the nvme SGL building code for contiguous buffers
was broken, since it would only set the mapping_length
once, before the loop started.  Worst case, if a buffer
started just before (maybe 256 bytes) before a huge page
boundary, each time through the loop we would create
a new SGL for only 256 bytes at a time, very quickly
running out of SGL entries for a large buffer.

Fixes #1852.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ib1000d8b130e8e4bfeacccd6e60f8109428dfc1e

Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7659
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/nvme/nvme_pcie.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/nvme/nvme_pcie.c b/lib/nvme/nvme_pcie.c
index df751c479..2a5a7f72d 100644
--- a/lib/nvme/nvme_pcie.c
+++ b/lib/nvme/nvme_pcie.c
@@ -1219,7 +1219,6 @@ nvme_pcie_qpair_build_contig_hw_sgl_request(struct spdk_nvme_qpair *qpair, struc
 
 	length = req->payload_size;
 	virt_addr = req->payload.contig_or_cb_arg + req->payload_offset;
-	mapping_length = length;
 
 	while (length > 0) {
 		if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
@@ -1233,6 +1232,7 @@ nvme_pcie_qpair_build_contig_hw_sgl_request(struct spdk_nvme_qpair *qpair, struc
 			return -EFAULT;
 		}
 
+		mapping_length = length;
 		phys_addr = spdk_vtophys(virt_addr, &mapping_length);
 		if (phys_addr == SPDK_VTOPHYS_ERROR) {
 			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-- 
2.26.2


From 0fdd826a009ffc496cf614fdf4afba6c4dff56f3 Mon Sep 17 00:00:00 2001
From: Nick Connolly <nick.connolly@mayadata.io>
Date: Mon, 26 Apr 2021 13:42:40 +0100
Subject: [PATCH 011/342] ut/nvme_ctrlr_cmd: add missing mutex init

Add missing mutex init for ctrlr ctrlr_lock.

Signed-off-by: Nick Connolly <nick.connolly@mayadata.io>
Change-Id: Ib3d665a28e91a72d1f1f6d09c374583ff731fb6f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7613
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c b/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
index fdbdb2864..610ce9903 100644
--- a/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
@@ -899,6 +899,7 @@ test_spdk_nvme_ctrlr_cmd_abort(void)
 	ctrlr.adminq = &admin_qpair;
 	admin_qpair.id = 0;
 	MOCK_SET(nvme_ctrlr_submit_admin_request, 0);
+	CU_ASSERT(pthread_mutex_init(&ctrlr.ctrlr_lock, NULL) == 0);
 
 	rc = spdk_nvme_ctrlr_cmd_abort(&ctrlr, qpair, 2, (void *)0xDEADBEEF, (void *)0xDCADBEEF);
 	CU_ASSERT(rc == 0);
@@ -914,6 +915,7 @@ test_spdk_nvme_ctrlr_cmd_abort(void)
 	rc = spdk_nvme_ctrlr_cmd_abort(&ctrlr, qpair, 2, (void *)0xDEADBEEF, (void *)0xDCADBEEF);
 	CU_ASSERT(rc == -ENOMEM);
 	MOCK_CLEAR(nvme_ctrlr_submit_admin_request);
+	CU_ASSERT(pthread_mutex_destroy(&ctrlr.ctrlr_lock) == 0);
 }
 
 int main(int argc, char **argv)
-- 
2.26.2


From 50935184c890c205e094c73d064619c02de7455f Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 27 Apr 2021 04:02:02 -0400
Subject: [PATCH 012/342] lib/blob: force execution of queued persists

When performing snapshot creation the I/O is frozen
during the process. The blob persists for extent page
allocation is delayed until snapshot creation is finished.

This results in multiple blob persists executing one after
the other, with only intent of writing out updated extent table
pointing to new extent pages.
Since blob->state is marked DIRTY before issuing each persist,
but a single persist completion marks state CLEAR.

Blob serialize correctly expects each persist to contain
dirtied metadata, in order to avoid unnecessary md writes.
Since all other instances of marking blob DIRTY is explicit,
assert in blob serialize is left as is.

Instead when running the queued up blob persists, the blob
state is marked DIRTY.

Side effect is that it will write out same md in some cases.

Fixes #1909

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I39f37299f3f0ebfccbdd4063781b5ecce286e993
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7640
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 lib/blob/blobstore.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/blob/blobstore.c b/lib/blob/blobstore.c
index df894037b..0278eab80 100644
--- a/lib/blob/blobstore.c
+++ b/lib/blob/blobstore.c
@@ -1642,6 +1642,7 @@ blob_persist_complete(spdk_bs_sequence_t *seq, struct spdk_blob_persist_ctx *ctx
 	free(ctx);
 
 	if (next_persist != NULL) {
+		blob->state = SPDK_BLOB_STATE_DIRTY;
 		blob_persist_check_dirty(next_persist);
 	}
 }
-- 
2.26.2


From ac0c36d72a5125115bebcb19367b2e265eaaa7a2 Mon Sep 17 00:00:00 2001
From: Liu Xiaodong <xiaodong.liu@intel.com>
Date: Fri, 15 Jan 2021 09:47:43 -0500
Subject: [PATCH 013/342] test: add functional test for reactor_set_intr

test script 'test/interrupt/reactor_set_intr.sh' will
do various reactor set intr operations on interrupt_tgt
without spdk_thread and with spdk_thread.

Change-Id: Ie5af1dc68b0272c34a91e8a66b78088c3794907c
Signed-off-by: Liu Xiaodong <xiaodong.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7348
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autotest.sh                             |   1 +
 test/interrupt/interrupt_common.sh      |  98 +++++++++++++++++++++++
 test/interrupt/reactor_set_interrupt.sh | 102 ++++++++++++++++++++++++
 3 files changed, 201 insertions(+)
 create mode 100644 test/interrupt/interrupt_common.sh
 create mode 100755 test/interrupt/reactor_set_interrupt.sh

diff --git a/autotest.sh b/autotest.sh
index 76063015e..1b2f2f6cb 100755
--- a/autotest.sh
+++ b/autotest.sh
@@ -195,6 +195,7 @@ if [ $SPDK_RUN_FUNCTIONAL_TEST -eq 1 ]; then
 		run_test "bdevperf_config" test/bdev/bdevperf/test_config.sh
 		if [[ $(uname -s) == Linux ]]; then
 			run_test "spdk_dd" test/dd/dd.sh
+			run_test "reactor_set_interrupt" test/interrupt/reactor_set_interrupt.sh
 		fi
 	fi
 
diff --git a/test/interrupt/interrupt_common.sh b/test/interrupt/interrupt_common.sh
new file mode 100644
index 000000000..b6402d8ac
--- /dev/null
+++ b/test/interrupt/interrupt_common.sh
@@ -0,0 +1,98 @@
+testdir=$(readlink -f $(dirname $0))
+rootdir=$(readlink -f $testdir/../..)
+source $rootdir/test/common/autotest_common.sh
+
+rpc_py="$rootdir/scripts/rpc.py"
+
+r0_mask=0x1
+r1_mask=0x2
+r2_mask=0x4
+
+cpu_server_mask=0x07
+rpc_server_addr="/var/tmp/spdk.sock"
+
+function cleanup() {
+	rm -f "$SPDK_TEST_STORAGE/aiofile"
+}
+
+function start_intr_tgt() {
+	local rpc_addr="${1:-$rpc_server_addr}"
+	local cpu_mask="${2:-$cpu_server_mask}"
+
+	"$SPDK_EXAMPLE_DIR/interrupt_tgt" -m $cpu_mask -r $rpc_addr -E -g &
+	intr_tgt_pid=$!
+	trap 'killprocess "$intr_tgt_pid"; cleanup; exit 1' SIGINT SIGTERM EXIT
+	waitforlisten "$intr_tgt_pid" $rpc_addr
+}
+
+function reactor_is_busy_or_idle() {
+	local pid=$1
+	local idx=$2
+	local state=$3
+
+	if [[ $state != "busy" ]] && [[ $state != "idle" ]]; then
+		return 1
+	fi
+
+	if ! hash top; then
+		# Fail this test if top is missing from system.
+		return 1
+	fi
+
+	for ((j = 10; j != 0; j--)); do
+		top_reactor=$(top -bHn 1 -p $pid -w 256 | grep reactor_$idx)
+		cpu_rate=$(echo $top_reactor | sed -e 's/^\s*//g' | awk '{print $9}')
+		cpu_rate=${cpu_rate%.*}
+
+		if [[ $state = "busy" ]] && [[ $cpu_rate -lt 70 ]]; then
+			sleep 1
+		elif [[ $state = "idle" ]] && [[ $cpu_rate -gt 30 ]]; then
+			sleep 1
+		else
+			return 0
+		fi
+	done
+
+	if [[ $state = "busy" ]]; then
+		echo "cpu rate ${cpu_rate} of reactor $i probably is not busy polling"
+	else
+		echo "cpu rate ${cpu_rate} of reactor $i probably is not idle interrupt"
+	fi
+
+	return 1
+}
+
+function reactor_is_busy() {
+	reactor_is_busy_or_idle $1 $2 "busy"
+}
+
+function reactor_is_idle() {
+	reactor_is_busy_or_idle $1 $2 "idle"
+}
+
+function reactor_get_thread_ids() {
+	local reactor_cpumask=$1
+	local grep_str
+
+	reactor_cpumask=$((reactor_cpumask))
+	jq_str='.threads|.[]|select(.cpumask == $reactor_cpumask)|.id'
+
+	# shellcheck disable=SC2005
+	echo "$($rpc_py thread_get_stats | jq --arg reactor_cpumask "$reactor_cpumask" "$jq_str")"
+
+}
+
+function setup_bdev_mem() {
+	"$rpc_py" <<- RPC
+		bdev_malloc_create -b Malloc0 32 512
+		bdev_malloc_create -b Malloc1 32 512
+		bdev_malloc_create -b Malloc2 32 512
+	RPC
+}
+
+function setup_bdev_aio() {
+	if [[ $(uname -s) != "FreeBSD" ]]; then
+		dd if=/dev/zero of="$SPDK_TEST_STORAGE/aiofile" bs=2048 count=5000
+		"$rpc_py" bdev_aio_create "$SPDK_TEST_STORAGE/aiofile" AIO0 2048
+	fi
+}
diff --git a/test/interrupt/reactor_set_interrupt.sh b/test/interrupt/reactor_set_interrupt.sh
new file mode 100755
index 000000000..e1a4f8892
--- /dev/null
+++ b/test/interrupt/reactor_set_interrupt.sh
@@ -0,0 +1,102 @@
+#!/usr/bin/env bash
+
+testdir=$(readlink -f $(dirname $0))
+rootdir=$(readlink -f $testdir/../..)
+source $rootdir/test/common/autotest_common.sh
+source $testdir/interrupt_common.sh
+
+export PYTHONPATH=$rootdir/examples/interrupt_tgt
+
+function reactor_set_intr_mode() {
+	local spdk_pid=$1
+	local without_thd=$2
+
+	thd0_ids=($(reactor_get_thread_ids $r0_mask))
+	thd2_ids=($(reactor_get_thread_ids $r2_mask))
+
+	# Nubmer of thd0_ids shouldn't be zero
+	if [[ ${#thd0_ids[*]} -eq 0 ]]; then
+		echo "spdk_thread is expected in reactor 0."
+		return 1
+	else
+		echo "spdk_thread ids are ${thd0_ids[*]} on reactor0."
+	fi
+
+	# CPU utilization of reactor 0~2 should be idle
+	for i in {0..2}; do
+		reactor_is_idle $spdk_pid $i
+	done
+
+	if [ "$without_thd"x = x ]; then
+		# Schedule all spdk_threads to reactor 1
+		for i in ${thd0_ids[*]}; do
+			$rpc_py thread_set_cpumask -i $i -m $r1_mask
+		done
+		for i in ${thd2_ids[*]}; do
+			$rpc_py thread_set_cpumask -i $i -m $r1_mask
+		done
+	fi
+	# Set reactor 0 and 2 to be poll mode
+	$rpc_py --plugin interrupt_plugin reactor_set_interrupt_mode 0 -d
+	$rpc_py --plugin interrupt_plugin reactor_set_interrupt_mode 2 -d
+	# CPU utilization of reactor 0 and 2 should be busy
+	for i in 0 2; do
+		reactor_is_busy $spdk_pid $i
+	done
+
+	# Set reactor 2 back to intr mode
+	$rpc_py --plugin interrupt_plugin reactor_set_interrupt_mode 2
+	if [ "$without_thd"x = x ]; then
+		# Schedule spdk_threads in thd2_ids back to reactor 2
+		for i in ${thd2_ids[*]}; do
+			$rpc_py thread_set_cpumask -i $i -m $r2_mask
+		done
+	fi
+	# CPU utilization of reactor 2 should be idle
+	reactor_is_idle $spdk_pid 2
+
+	# Set reactor 0 back to intr mode
+	$rpc_py --plugin interrupt_plugin reactor_set_interrupt_mode 0
+	if [ "$without_thd"x = x ]; then
+		# Schedule spdk_threads in thd2_ids back to reactor 0
+		for i in ${thd0_ids[*]}; do
+			$rpc_py thread_set_cpumask -i $i -m $r0_mask
+		done
+	fi
+	# CPU utilization of reactor 0 should be idle
+	reactor_is_idle $spdk_pid 0
+
+	return 0
+}
+
+function reactor_set_mode_without_threads() {
+	reactor_set_intr_mode $1 "without_thd"
+	return 0
+}
+
+function reactor_set_mode_with_threads() {
+	reactor_set_intr_mode $1
+	return 0
+}
+
+# Set reactors with intr_tgt without spdk_thread
+start_intr_tgt
+setup_bdev_mem
+setup_bdev_aio
+
+reactor_set_mode_without_threads $intr_tgt_pid
+
+trap - SIGINT SIGTERM EXIT
+killprocess $intr_tgt_pid
+cleanup
+
+# Set reactors with intr_tgt with spdk_thread
+start_intr_tgt
+setup_bdev_mem
+setup_bdev_aio
+
+reactor_set_mode_with_threads $intr_tgt_pid
+
+trap - SIGINT SIGTERM EXIT
+killprocess $intr_tgt_pid
+cleanup
-- 
2.26.2


From 469d8f32d0664b56f8abb862093a124455db3069 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 26 Apr 2021 12:48:29 -0400
Subject: [PATCH 014/342] so_ver: reenable test preventing increasing SO
 version

This check was disabled after 21.01 LTS to allow for
clear break of SO versions. Now that SPDK 21.04 is being
released, this test should be reenabled.

See following patch for details:
(e4070ee0)so_ver: increase all major versions

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I8a299a340338e7a2ab3439b81153818778b4c93a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7616
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 test/make/check_so_deps.sh | 2 --
 1 file changed, 2 deletions(-)

diff --git a/test/make/check_so_deps.sh b/test/make/check_so_deps.sh
index 9e3c55963..c53ccc25f 100755
--- a/test/make/check_so_deps.sh
+++ b/test/make/check_so_deps.sh
@@ -132,8 +132,6 @@ EOF
 			fi
 
 			if [[ $so_name_changed == yes ]]; then
-				# After 21.01 LTS all SO major versions were intentionally increased. Disable this check until SPDK 21.04 release.
-				found_abi_change=true
 				if ! $found_abi_change; then
 					echo "SO name for $so_file changed without a change to abi. please revert that change."
 					touch $fail_file
-- 
2.26.2


From cddfa0241aa367dac65aefef904b4955b6e92687 Mon Sep 17 00:00:00 2001
From: jwyka <jakub.wyka@intel.com>
Date: Fri, 16 Apr 2021 14:47:57 +0200
Subject: [PATCH 015/342] lib/nvme: allign cuse ctx data to 4k

We have seen that dptr was not alligned to 4k using cuse. Added allignment of data in cuse ctx to 4k same as it is done in nvme_allocate_request_user_copy
Signed-off-by: jwyka <jakub.wyka@intel.com>
Change-Id: Ic5c2482eae20d64ba467016eb61f5255467f70a9
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7453
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Broadcom CI
---
 lib/nvme/nvme_cuse.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index 62d1422df..0d7696a71 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -168,7 +168,7 @@ cuse_nvme_admin_cmd_send(fuse_req_t req, struct nvme_admin_cmd *admin_cmd,
 	ctx->data_len = admin_cmd->data_len;
 
 	if (ctx->data_len > 0) {
-		ctx->data = spdk_malloc(ctx->data_len, 0, NULL, SPDK_ENV_LCORE_ID_ANY, SPDK_MALLOC_DMA);
+		ctx->data = spdk_malloc(ctx->data_len, 4096, NULL, SPDK_ENV_LCORE_ID_ANY, SPDK_MALLOC_DMA);
 		if (!ctx->data) {
 			SPDK_ERRLOG("Cannot allocate memory for data\n");
 			fuse_reply_err(req, ENOMEM);
-- 
2.26.2


From eb76ccb04c975df836d4d50e2dcdc24c915487e4 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Tue, 20 Apr 2021 15:51:21 +0800
Subject: [PATCH 016/342] test/nvme_tcp: cases for connecting sock and sending
 icreq

Change-Id: Iece99816ad67ac585b6285cbd43e415425b75239
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6821
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 test/common/lib/test_sock.c                 |  2 -
 test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c | 89 +++++++++++++++++++++
 2 files changed, 89 insertions(+), 2 deletions(-)

diff --git a/test/common/lib/test_sock.c b/test/common/lib/test_sock.c
index d2c83b732..d3c0f2be6 100644
--- a/test/common/lib/test_sock.c
+++ b/test/common/lib/test_sock.c
@@ -40,8 +40,6 @@ DEFINE_STUB(spdk_sock_getaddr, int, (struct spdk_sock *sock, char *saddr, int sl
 				     char *caddr, int clen, uint16_t *cport), 0);
 DEFINE_STUB(spdk_sock_connect, struct spdk_sock *, (const char *ip, int port, char *impl_name),
 	    NULL);
-DEFINE_STUB(spdk_sock_connect_ext, struct spdk_sock *, (const char *ip, int port, char *impl_name,
-		struct spdk_sock_opts *opts), NULL);
 DEFINE_STUB(spdk_sock_listen, struct spdk_sock *, (const char *ip, int port, char *impl_name),
 	    NULL);
 DEFINE_STUB(spdk_sock_listen_ext, struct spdk_sock *, (const char *ip, int port, char *impl_name,
diff --git a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
index 07787cca0..72c6067cf 100644
--- a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
+++ b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
@@ -1047,6 +1047,93 @@ test_nvme_tcp_pdu_ch_handle(void)
 			  struct spdk_nvme_tcp_common_pdu_hdr));
 }
 
+DEFINE_RETURN_MOCK(spdk_sock_connect_ext, struct spdk_sock *);
+struct spdk_sock *
+spdk_sock_connect_ext(const char *ip, int port,
+		      char *_impl_name, struct spdk_sock_opts *opts)
+{
+	HANDLE_RETURN_MOCK(spdk_sock_connect_ext);
+	CU_ASSERT(port == 23);
+	CU_ASSERT(opts->opts_size == sizeof(*opts));
+	CU_ASSERT(opts->priority == 1);
+	CU_ASSERT(opts->zcopy == true);
+	CU_ASSERT(!strcmp(ip, "192.168.1.78"));
+	return (struct spdk_sock *)0xDDADBEEF;
+}
+
+static void
+test_nvme_tcp_qpair_connect_sock(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct nvme_tcp_qpair tqpair = {};
+	int rc;
+
+	tqpair.qpair.trtype = SPDK_NVME_TRANSPORT_TCP;
+	tqpair.qpair.id = 1;
+	tqpair.qpair.poll_group = (void *)0xDEADBEEF;
+	ctrlr.trid.priority = 1;
+	ctrlr.trid.adrfam = SPDK_NVMF_ADRFAM_IPV4;
+	memcpy(ctrlr.trid.traddr, "192.168.1.78", sizeof("192.168.1.78"));
+	memcpy(ctrlr.trid.trsvcid, "23", sizeof("23"));
+	memcpy(ctrlr.opts.src_addr, "192.168.1.77", sizeof("192.168.1.77"));
+	memcpy(ctrlr.opts.src_svcid, "23", sizeof("23"));
+
+	rc = nvme_tcp_qpair_connect_sock(&ctrlr, &tqpair.qpair);
+	CU_ASSERT(rc == 0);
+
+	/* Unsupported family of the transport address */
+	ctrlr.trid.adrfam = SPDK_NVMF_ADRFAM_IB;
+
+	rc = nvme_tcp_qpair_connect_sock(&ctrlr, &tqpair.qpair);
+	SPDK_CU_ASSERT_FATAL(rc == -1);
+
+	/* Invalid dst_port, INT_MAX is 2147483647 */
+	ctrlr.trid.adrfam = SPDK_NVMF_ADRFAM_IPV4;
+	memcpy(ctrlr.trid.trsvcid, "2147483647", sizeof("2147483647"));
+
+	rc = nvme_tcp_qpair_connect_sock(&ctrlr, &tqpair.qpair);
+	SPDK_CU_ASSERT_FATAL(rc == -1);
+
+	/* Parse invalid address */
+	memcpy(ctrlr.trid.trsvcid, "23", sizeof("23"));
+	memcpy(ctrlr.trid.traddr, "192.168.1.256", sizeof("192.168.1.256"));
+
+	rc = nvme_tcp_qpair_connect_sock(&ctrlr, &tqpair.qpair);
+	SPDK_CU_ASSERT_FATAL(rc != 0);
+}
+
+static void
+test_nvme_tcp_qpair_icreq_send(void)
+{
+	struct nvme_tcp_qpair tqpair = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct nvme_tcp_pdu pdu = {};
+	struct nvme_tcp_poll_group poll_group = {};
+	struct spdk_nvme_tcp_ic_req *ic_req = NULL;
+	int rc;
+
+	tqpair.send_pdu = &pdu;
+	tqpair.qpair.ctrlr = &ctrlr;
+	tqpair.qpair.poll_group = &poll_group.group;
+	ic_req = &pdu.hdr.ic_req;
+
+	tqpair.state = NVME_TCP_QPAIR_STATE_RUNNING;
+	tqpair.qpair.ctrlr->opts.header_digest = true;
+	tqpair.qpair.ctrlr->opts.data_digest = true;
+	TAILQ_INIT(&tqpair.send_queue);
+
+	rc = nvme_tcp_qpair_icreq_send(&tqpair);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(ic_req->common.hlen == sizeof(*ic_req));
+	CU_ASSERT(ic_req->common.plen == sizeof(*ic_req));
+	CU_ASSERT(ic_req->common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_IC_REQ);
+	CU_ASSERT(ic_req->pfv == 0);
+	CU_ASSERT(ic_req->maxr2t == NVME_TCP_MAX_R2T_DEFAULT - 1);
+	CU_ASSERT(ic_req->hpda == NVME_TCP_HPDA_DEFAULT);
+	CU_ASSERT(ic_req->dgst.bits.hdgst_enable == true);
+	CU_ASSERT(ic_req->dgst.bits.ddgst_enable == true);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -1071,6 +1158,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_tcp_parse_addr);
 	CU_ADD_TEST(suite, test_nvme_tcp_qpair_send_h2c_term_req);
 	CU_ADD_TEST(suite, test_nvme_tcp_pdu_ch_handle);
+	CU_ADD_TEST(suite, test_nvme_tcp_qpair_connect_sock);
+	CU_ADD_TEST(suite, test_nvme_tcp_qpair_icreq_send);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From b32cfc467b3f3a6a7bd00631334612f6181f7c08 Mon Sep 17 00:00:00 2001
From: Swapnil Ingle <swapnil.ingle@nutanix.com>
Date: Fri, 9 Apr 2021 12:18:41 -0400
Subject: [PATCH 017/342] nvmf: Support physical block size if exposed by bdev

Today the in-guest nvme device shows physical_block_size=512 even though
the backend iSCSI bdev supports physical_block_size=4K

iSCSI targets exposes physical block size using
logical_block_per_physical_block_exponent in READ_CAPACITY_16

NPWG is one of the way to let Linux nvme driver set
physical_block_size of the nvme block device.

This patch adds spdk_bdev.phys_blocklen which is updated if the iSCSI
backend exposes physical_block_size.
Later phys_blocklen is used in nvmf to set NPWG and NAWUPF to report
back during NS identity.
Linux driver uses min(nawupf, npwg) to set physical_block_size.

Similarly in scsi_bdev fill lbppbe in READ_CAP16 response
based on spdk_bdev.phys_blocklen.

Fixes #1884

Signed-off-by: Swapnil Ingle <swapnil.ingle@nutanix.com>
Change-Id: I0b6c81f1937e346d448f49c927eda8c79d2d75cf
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7310
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 examples/nvme/identify/identify.c               |  4 ++++
 include/spdk/bdev.h                             |  8 ++++++++
 include/spdk/bdev_module.h                      |  3 +++
 lib/bdev/bdev.c                                 | 10 ++++++++++
 lib/bdev/spdk_bdev.map                          |  1 +
 lib/nvmf/ctrlr_bdev.c                           | 10 ++++++++++
 lib/scsi/scsi_bdev.c                            |  7 +++++++
 module/bdev/iscsi/bdev_iscsi.c                  |  7 +++++--
 test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c |  3 +++
 test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c   |  3 +++
 10 files changed, 54 insertions(+), 2 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index f6ce6b73d..20a0d2d68 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -1014,6 +1014,10 @@ print_namespace(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
 			printf("  Atomic Write Unit (PFail):           %d\n", nsdata->nawupf + 1);
 		}
 
+		if (nsdata->npwg) {
+			printf("  Preferred Write Granularity:         %d\n", nsdata->npwg + 1);
+		}
+
 		if (nsdata->nacwu) {
 			printf("  Atomic Compare & Write Unit:         %d\n", nsdata->nacwu + 1);
 		}
diff --git a/include/spdk/bdev.h b/include/spdk/bdev.h
index 72f673b04..19b265735 100644
--- a/include/spdk/bdev.h
+++ b/include/spdk/bdev.h
@@ -590,6 +590,14 @@ bool spdk_bdev_is_zoned(const struct spdk_bdev *bdev);
  */
 uint32_t spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev);
 
+/**
+ * Get block device physical block size.
+ *
+ * \param bdev Block device to query.
+ * \return Size of physical block size for this bdev in bytes.
+ */
+uint32_t spdk_bdev_get_physical_block_size(const struct spdk_bdev *bdev);
+
 /**
  * Get DIF type of the block device.
  *
diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index ac7739625..70c37f497 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -265,6 +265,9 @@ struct spdk_bdev {
 	/** Size in bytes of a logical block for the backend */
 	uint32_t blocklen;
 
+	/** Size in bytes of a physical block for the backend */
+	uint32_t phys_blocklen;
+
 	/** Number of blocks */
 	uint64_t blockcnt;
 
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 9c741d001..9ede230c0 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -3291,6 +3291,12 @@ spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev)
 	}
 }
 
+uint32_t
+spdk_bdev_get_physical_block_size(const struct spdk_bdev *bdev)
+{
+	return bdev->phys_blocklen;
+}
+
 static uint32_t
 _bdev_get_block_size_with_md(const struct spdk_bdev *bdev)
 {
@@ -5464,6 +5470,10 @@ bdev_init(struct spdk_bdev *bdev)
 		bdev->acwu = 1;
 	}
 
+	if (bdev->phys_blocklen == 0) {
+		bdev->phys_blocklen = spdk_bdev_get_data_block_size(bdev);
+	}
+
 	TAILQ_INIT(&bdev->internal.open_descs);
 	TAILQ_INIT(&bdev->internal.locked_ranges);
 	TAILQ_INIT(&bdev->internal.pending_locked_ranges);
diff --git a/lib/bdev/spdk_bdev.map b/lib/bdev/spdk_bdev.map
index aec215d58..91d21d5db 100644
--- a/lib/bdev/spdk_bdev.map
+++ b/lib/bdev/spdk_bdev.map
@@ -40,6 +40,7 @@
 	spdk_bdev_is_md_separate;
 	spdk_bdev_is_zoned;
 	spdk_bdev_get_data_block_size;
+	spdk_bdev_get_physical_block_size;
 	spdk_bdev_get_dif_type;
 	spdk_bdev_is_dif_head_of_md;
 	spdk_bdev_is_dif_check_enabled;
diff --git a/lib/nvmf/ctrlr_bdev.c b/lib/nvmf/ctrlr_bdev.c
index a631b8003..b79254f79 100644
--- a/lib/nvmf/ctrlr_bdev.c
+++ b/lib/nvmf/ctrlr_bdev.c
@@ -140,6 +140,7 @@ nvmf_bdev_ctrlr_identify_ns(struct spdk_nvmf_ns *ns, struct spdk_nvme_ns_data *n
 {
 	struct spdk_bdev *bdev = ns->bdev;
 	uint64_t num_blocks;
+	uint32_t phys_blocklen;
 
 	num_blocks = spdk_bdev_get_num_blocks(bdev);
 
@@ -181,6 +182,15 @@ nvmf_bdev_ctrlr_identify_ns(struct spdk_nvmf_ns *ns, struct spdk_nvme_ns_data *n
 		nsdata->lbaf[0].ms = 0;
 		nsdata->lbaf[0].lbads = spdk_u32log2(spdk_bdev_get_data_block_size(bdev));
 	}
+
+	phys_blocklen = spdk_bdev_get_physical_block_size(bdev);
+	assert(phys_blocklen > 0);
+	/* Linux driver uses min(nawupf, npwg) to set physical_block_size */
+	nsdata->nsfeat.optperf = 1;
+	nsdata->nsfeat.ns_atomic_write_unit = 1;
+	nsdata->npwg = (phys_blocklen >> nsdata->lbaf[0].lbads) - 1;
+	nsdata->nawupf = nsdata->npwg;
+
 	nsdata->noiob = spdk_bdev_get_optimal_io_boundary(bdev);
 	nsdata->nmic.can_share = 1;
 	if (ns->ptpl_file != NULL) {
diff --git a/lib/scsi/scsi_bdev.c b/lib/scsi/scsi_bdev.c
index 06270eb5d..ba890af74 100644
--- a/lib/scsi/scsi_bdev.c
+++ b/lib/scsi/scsi_bdev.c
@@ -1620,9 +1620,16 @@ bdev_scsi_process_block(struct spdk_scsi_task *task)
 		switch (cdb[1] & 0x1f) { /* SERVICE ACTION */
 		case SPDK_SBC_SAI_READ_CAPACITY_16: {
 			uint8_t buffer[32] = {0};
+			uint32_t lbppb;
 
 			to_be64(&buffer[0], spdk_bdev_get_num_blocks(bdev) - 1);
 			to_be32(&buffer[8], spdk_bdev_get_data_block_size(bdev));
+			lbppb = spdk_bdev_get_physical_block_size(bdev) / spdk_bdev_get_data_block_size(bdev);
+			if (spdk_u32log2(lbppb) > 0xf) {
+				SPDK_ERRLOG("lbppbe(0x%x) > 0xf\n", spdk_u32log2(lbppb));
+			} else {
+				buffer[13] = spdk_u32log2(lbppb);
+			}
 			/*
 			 * Set the TPE bit to 1 to indicate thin provisioning.
 			 * The position of TPE bit is the 7th bit in 14th byte
diff --git a/module/bdev/iscsi/bdev_iscsi.c b/module/bdev/iscsi/bdev_iscsi.c
index 7516ea95e..edb537345 100644
--- a/module/bdev/iscsi/bdev_iscsi.c
+++ b/module/bdev/iscsi/bdev_iscsi.c
@@ -623,7 +623,8 @@ static const struct spdk_bdev_fn_table iscsi_fn_table = {
 static int
 create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *initiator_iqn,
 		 char *name,
-		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported)
+		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported,
+		 uint8_t lbppbe)
 {
 	struct bdev_iscsi_lun *lun;
 	int rc;
@@ -645,6 +646,7 @@ create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *ini
 	lun->bdev.product_name = "iSCSI LUN";
 	lun->bdev.module = &g_iscsi_bdev_module;
 	lun->bdev.blocklen = block_size;
+	lun->bdev.phys_blocklen = block_size * (1 << lbppbe);
 	lun->bdev.blockcnt = num_blocks;
 	lun->bdev.ctxt = lun;
 	lun->unmap_supported = unmap_supported;
@@ -691,7 +693,8 @@ iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,
 	}
 
 	status = create_iscsi_lun(req->context, req->lun, req->url, req->initiator_iqn, req->bdev_name,
-				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported);
+				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported,
+				  readcap16->lbppbe);
 	if (status) {
 		SPDK_ERRLOG("Unable to create iscsi bdev: %s (%d)\n", spdk_strerror(-status), status);
 	}
diff --git a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
index e3801b57d..7edb46dfc 100644
--- a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
+++ b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
@@ -51,6 +51,9 @@ DEFINE_STUB(spdk_bdev_get_acwu, uint16_t, (const struct spdk_bdev *bdev), 0);
 DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 512);
 
+DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
+	    (const struct spdk_bdev *bdev), 4096);
+
 DEFINE_STUB(nvmf_ctrlr_process_admin_cmd, int, (struct spdk_nvmf_request *req), 0);
 
 DEFINE_STUB(spdk_bdev_comparev_blocks, int, (struct spdk_bdev_desc *desc,
diff --git a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
index 87485b901..3e1705477 100644
--- a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
+++ b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
@@ -77,6 +77,9 @@ DEFINE_STUB(spdk_bdev_is_md_interleaved, bool,
 DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 512);
 
+DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
+	    (const struct spdk_bdev *bdev), 4096);
+
 uint64_t
 spdk_bdev_get_num_blocks(const struct spdk_bdev *bdev)
 {
-- 
2.26.2


From 63642befd3be53b4f25a037de3c2c88d760e742e Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Mon, 3 May 2021 15:40:35 -0700
Subject: [PATCH 018/342] Revert "nvmf: Support physical block size if exposed
 by bdev"

This reverts commit b32cfc467b3f3a6a7bd00631334612f6181f7c08.

This commit fails the ABI checks and only got through because the checks
were disabled until 21.04 hit.

Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Change-Id: Id26b8f8ba551193d99b1ccbd31b35378b4095a20
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7731
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 examples/nvme/identify/identify.c               |  4 ----
 include/spdk/bdev.h                             |  8 --------
 include/spdk/bdev_module.h                      |  3 ---
 lib/bdev/bdev.c                                 | 10 ----------
 lib/bdev/spdk_bdev.map                          |  1 -
 lib/nvmf/ctrlr_bdev.c                           | 10 ----------
 lib/scsi/scsi_bdev.c                            |  7 -------
 module/bdev/iscsi/bdev_iscsi.c                  |  7 ++-----
 test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c |  3 ---
 test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c   |  3 ---
 10 files changed, 2 insertions(+), 54 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index 20a0d2d68..f6ce6b73d 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -1014,10 +1014,6 @@ print_namespace(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
 			printf("  Atomic Write Unit (PFail):           %d\n", nsdata->nawupf + 1);
 		}
 
-		if (nsdata->npwg) {
-			printf("  Preferred Write Granularity:         %d\n", nsdata->npwg + 1);
-		}
-
 		if (nsdata->nacwu) {
 			printf("  Atomic Compare & Write Unit:         %d\n", nsdata->nacwu + 1);
 		}
diff --git a/include/spdk/bdev.h b/include/spdk/bdev.h
index 19b265735..72f673b04 100644
--- a/include/spdk/bdev.h
+++ b/include/spdk/bdev.h
@@ -590,14 +590,6 @@ bool spdk_bdev_is_zoned(const struct spdk_bdev *bdev);
  */
 uint32_t spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev);
 
-/**
- * Get block device physical block size.
- *
- * \param bdev Block device to query.
- * \return Size of physical block size for this bdev in bytes.
- */
-uint32_t spdk_bdev_get_physical_block_size(const struct spdk_bdev *bdev);
-
 /**
  * Get DIF type of the block device.
  *
diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index 70c37f497..ac7739625 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -265,9 +265,6 @@ struct spdk_bdev {
 	/** Size in bytes of a logical block for the backend */
 	uint32_t blocklen;
 
-	/** Size in bytes of a physical block for the backend */
-	uint32_t phys_blocklen;
-
 	/** Number of blocks */
 	uint64_t blockcnt;
 
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 9ede230c0..9c741d001 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -3291,12 +3291,6 @@ spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev)
 	}
 }
 
-uint32_t
-spdk_bdev_get_physical_block_size(const struct spdk_bdev *bdev)
-{
-	return bdev->phys_blocklen;
-}
-
 static uint32_t
 _bdev_get_block_size_with_md(const struct spdk_bdev *bdev)
 {
@@ -5470,10 +5464,6 @@ bdev_init(struct spdk_bdev *bdev)
 		bdev->acwu = 1;
 	}
 
-	if (bdev->phys_blocklen == 0) {
-		bdev->phys_blocklen = spdk_bdev_get_data_block_size(bdev);
-	}
-
 	TAILQ_INIT(&bdev->internal.open_descs);
 	TAILQ_INIT(&bdev->internal.locked_ranges);
 	TAILQ_INIT(&bdev->internal.pending_locked_ranges);
diff --git a/lib/bdev/spdk_bdev.map b/lib/bdev/spdk_bdev.map
index 91d21d5db..aec215d58 100644
--- a/lib/bdev/spdk_bdev.map
+++ b/lib/bdev/spdk_bdev.map
@@ -40,7 +40,6 @@
 	spdk_bdev_is_md_separate;
 	spdk_bdev_is_zoned;
 	spdk_bdev_get_data_block_size;
-	spdk_bdev_get_physical_block_size;
 	spdk_bdev_get_dif_type;
 	spdk_bdev_is_dif_head_of_md;
 	spdk_bdev_is_dif_check_enabled;
diff --git a/lib/nvmf/ctrlr_bdev.c b/lib/nvmf/ctrlr_bdev.c
index b79254f79..a631b8003 100644
--- a/lib/nvmf/ctrlr_bdev.c
+++ b/lib/nvmf/ctrlr_bdev.c
@@ -140,7 +140,6 @@ nvmf_bdev_ctrlr_identify_ns(struct spdk_nvmf_ns *ns, struct spdk_nvme_ns_data *n
 {
 	struct spdk_bdev *bdev = ns->bdev;
 	uint64_t num_blocks;
-	uint32_t phys_blocklen;
 
 	num_blocks = spdk_bdev_get_num_blocks(bdev);
 
@@ -182,15 +181,6 @@ nvmf_bdev_ctrlr_identify_ns(struct spdk_nvmf_ns *ns, struct spdk_nvme_ns_data *n
 		nsdata->lbaf[0].ms = 0;
 		nsdata->lbaf[0].lbads = spdk_u32log2(spdk_bdev_get_data_block_size(bdev));
 	}
-
-	phys_blocklen = spdk_bdev_get_physical_block_size(bdev);
-	assert(phys_blocklen > 0);
-	/* Linux driver uses min(nawupf, npwg) to set physical_block_size */
-	nsdata->nsfeat.optperf = 1;
-	nsdata->nsfeat.ns_atomic_write_unit = 1;
-	nsdata->npwg = (phys_blocklen >> nsdata->lbaf[0].lbads) - 1;
-	nsdata->nawupf = nsdata->npwg;
-
 	nsdata->noiob = spdk_bdev_get_optimal_io_boundary(bdev);
 	nsdata->nmic.can_share = 1;
 	if (ns->ptpl_file != NULL) {
diff --git a/lib/scsi/scsi_bdev.c b/lib/scsi/scsi_bdev.c
index ba890af74..06270eb5d 100644
--- a/lib/scsi/scsi_bdev.c
+++ b/lib/scsi/scsi_bdev.c
@@ -1620,16 +1620,9 @@ bdev_scsi_process_block(struct spdk_scsi_task *task)
 		switch (cdb[1] & 0x1f) { /* SERVICE ACTION */
 		case SPDK_SBC_SAI_READ_CAPACITY_16: {
 			uint8_t buffer[32] = {0};
-			uint32_t lbppb;
 
 			to_be64(&buffer[0], spdk_bdev_get_num_blocks(bdev) - 1);
 			to_be32(&buffer[8], spdk_bdev_get_data_block_size(bdev));
-			lbppb = spdk_bdev_get_physical_block_size(bdev) / spdk_bdev_get_data_block_size(bdev);
-			if (spdk_u32log2(lbppb) > 0xf) {
-				SPDK_ERRLOG("lbppbe(0x%x) > 0xf\n", spdk_u32log2(lbppb));
-			} else {
-				buffer[13] = spdk_u32log2(lbppb);
-			}
 			/*
 			 * Set the TPE bit to 1 to indicate thin provisioning.
 			 * The position of TPE bit is the 7th bit in 14th byte
diff --git a/module/bdev/iscsi/bdev_iscsi.c b/module/bdev/iscsi/bdev_iscsi.c
index edb537345..7516ea95e 100644
--- a/module/bdev/iscsi/bdev_iscsi.c
+++ b/module/bdev/iscsi/bdev_iscsi.c
@@ -623,8 +623,7 @@ static const struct spdk_bdev_fn_table iscsi_fn_table = {
 static int
 create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *initiator_iqn,
 		 char *name,
-		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported,
-		 uint8_t lbppbe)
+		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported)
 {
 	struct bdev_iscsi_lun *lun;
 	int rc;
@@ -646,7 +645,6 @@ create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *ini
 	lun->bdev.product_name = "iSCSI LUN";
 	lun->bdev.module = &g_iscsi_bdev_module;
 	lun->bdev.blocklen = block_size;
-	lun->bdev.phys_blocklen = block_size * (1 << lbppbe);
 	lun->bdev.blockcnt = num_blocks;
 	lun->bdev.ctxt = lun;
 	lun->unmap_supported = unmap_supported;
@@ -693,8 +691,7 @@ iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,
 	}
 
 	status = create_iscsi_lun(req->context, req->lun, req->url, req->initiator_iqn, req->bdev_name,
-				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported,
-				  readcap16->lbppbe);
+				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported);
 	if (status) {
 		SPDK_ERRLOG("Unable to create iscsi bdev: %s (%d)\n", spdk_strerror(-status), status);
 	}
diff --git a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
index 7edb46dfc..e3801b57d 100644
--- a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
+++ b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
@@ -51,9 +51,6 @@ DEFINE_STUB(spdk_bdev_get_acwu, uint16_t, (const struct spdk_bdev *bdev), 0);
 DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 512);
 
-DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
-	    (const struct spdk_bdev *bdev), 4096);
-
 DEFINE_STUB(nvmf_ctrlr_process_admin_cmd, int, (struct spdk_nvmf_request *req), 0);
 
 DEFINE_STUB(spdk_bdev_comparev_blocks, int, (struct spdk_bdev_desc *desc,
diff --git a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
index 3e1705477..87485b901 100644
--- a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
+++ b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
@@ -77,9 +77,6 @@ DEFINE_STUB(spdk_bdev_is_md_interleaved, bool,
 DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 512);
 
-DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
-	    (const struct spdk_bdev *bdev), 4096);
-
 uint64_t
 spdk_bdev_get_num_blocks(const struct spdk_bdev *bdev)
 {
-- 
2.26.2


From a922a2e24a5fbe5f84a78a0d34cdfb50771df4f3 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Mon, 3 May 2021 13:35:59 -0700
Subject: [PATCH 019/342] lvol: Don't include bdev_module.h in the public
 header

Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Change-Id: I8590bdedd8b1c3d0e417694f07f40deb3297ef24
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7728
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk_internal/lvolstore.h   | 2 +-
 test/unit/lib/lvol/lvol.c/lvol_ut.c | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/include/spdk_internal/lvolstore.h b/include/spdk_internal/lvolstore.h
index f82157e53..1607d8330 100644
--- a/include/spdk_internal/lvolstore.h
+++ b/include/spdk_internal/lvolstore.h
@@ -36,8 +36,8 @@
 
 #include "spdk/blob.h"
 #include "spdk/lvol.h"
+#include "spdk/queue.h"
 #include "spdk/uuid.h"
-#include "spdk/bdev_module.h"
 
 /* Default size of blobstore cluster */
 #define SPDK_LVS_OPTS_CLUSTER_SZ (4 * 1024 * 1024)
diff --git a/test/unit/lib/lvol/lvol.c/lvol_ut.c b/test/unit/lib/lvol/lvol.c/lvol_ut.c
index d8f16df4b..d48238dff 100644
--- a/test/unit/lib/lvol/lvol.c/lvol_ut.c
+++ b/test/unit/lib/lvol/lvol.c/lvol_ut.c
@@ -36,6 +36,8 @@
 #include "spdk/thread.h"
 #include "spdk/util.h"
 
+#include "spdk/bdev_module.h"
+
 #include "common/lib/ut_multithread.c"
 
 #include "lvol/lvol.c"
-- 
2.26.2


From b69796f777767cfc7aee30de91829d62f8b6673d Mon Sep 17 00:00:00 2001
From: John Kariuki <John.K.Kariuki@intel.com>
Date: Thu, 29 Apr 2021 09:17:17 -0700
Subject: [PATCH 020/342] scripts/perf: fix json param names

Fixed parameter names in the sample json config file.

Change-Id: I4e221b17c533c0957a325e24043a627b5acb6220
Signed-off-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7688
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 scripts/perf/nvmf/config.json | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/scripts/perf/nvmf/config.json b/scripts/perf/nvmf/config.json
index f846691a0..62f931a49 100644
--- a/scripts/perf/nvmf/config.json
+++ b/scripts/perf/nvmf/config.json
@@ -9,13 +9,13 @@
     "mode": "spdk",
     "null_block_devices": 0,
     "nvmet_dir": "/path/to/nvmetcli",
-    "num_cores": "[1]",
+    "core_mask": "[1]",
     "num_shared_buffers": 4096
   },
   "initiator1": {
     "ip": "10.0.0.1",
     "nic_ips": ["192.0.1.2"],
-    "remote_nic_ips": ["192.0.1.1"],
+    "target_nic_ips": ["192.0.1.1"],
     "mode": "spdk",
     "fio_bin": "/path/to/fio/bin",
     "nvmecli_bin": "/path/to/nvmecli/bin",
@@ -24,7 +24,7 @@
   "initiator2": {
     "ip": "10.0.0.2",
     "nic_ips": ["192.0.2.2"],
-    "remote_nic_ips": ["192.0.2.1"],
+    "target_nic_ips": ["192.0.2.1"],
     "mode": "spdk"
   },
   "fio": {
-- 
2.26.2


From 40549bb48e7cf2cf00b332376936bf4fa51e5b98 Mon Sep 17 00:00:00 2001
From: yidong0635 <dongx.yi@intel.com>
Date: Wed, 21 Apr 2021 06:12:11 +0800
Subject: [PATCH 021/342] log_rpc: Unify codes in end path.

Unify the end path, and remove duplicate codes.

Signed-off-by: yidong0635 <dongx.yi@intel.com>
Change-Id: Ie36cb2182b2b0b23f36670780b6e7af3652dc94b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7520
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Krzysztof Karas <krzysztof.karas@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/event/log_rpc.c | 40 ++++++++++++----------------------------
 1 file changed, 12 insertions(+), 28 deletions(-)

diff --git a/lib/event/log_rpc.c b/lib/event/log_rpc.c
index 9666dbd56..a56952e99 100644
--- a/lib/event/log_rpc.c
+++ b/lib/event/log_rpc.c
@@ -110,7 +110,7 @@ rpc_log_set_print_level(struct spdk_jsonrpc_request *request,
 		SPDK_DEBUGLOG(log_rpc, "spdk_json_decode_object failed\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
 						 "spdk_json_decode_object failed");
-		goto invalid;
+		goto end;
 	}
 
 	level = _parse_log_level(req.level);
@@ -118,16 +118,12 @@ rpc_log_set_print_level(struct spdk_jsonrpc_request *request,
 		SPDK_DEBUGLOG(log_rpc, "tried to set invalid log level\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
 						 "invalid log level");
-		goto invalid;
+		goto end;
 	}
 
 	spdk_log_set_print_level(level);
-	free_rpc_log_level(&req);
-
 	spdk_jsonrpc_send_bool_response(request, true);
-	return;
-
-invalid:
+end:
 	free_rpc_log_level(&req);
 }
 SPDK_RPC_REGISTER("log_set_print_level", rpc_log_set_print_level,
@@ -177,7 +173,7 @@ rpc_log_set_level(struct spdk_jsonrpc_request *request,
 		SPDK_DEBUGLOG(log_rpc, "spdk_json_decode_object failed\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
 						 "spdk_json_decode_object failed");
-		goto invalid;
+		goto end;
 	}
 
 	level = _parse_log_level(req.level);
@@ -185,17 +181,13 @@ rpc_log_set_level(struct spdk_jsonrpc_request *request,
 		SPDK_DEBUGLOG(log_rpc, "tried to set invalid log level\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
 						 "invalid log level");
-		goto invalid;
+		goto end;
 	}
 
 
 	spdk_log_set_level(level);
-	free_rpc_log_level(&req);
-
 	spdk_jsonrpc_send_bool_response(request, true);
-	return;
-
-invalid:
+end:
 	free_rpc_log_level(&req);
 }
 SPDK_RPC_REGISTER("log_set_level", rpc_log_set_level, SPDK_RPC_STARTUP | SPDK_RPC_RUNTIME)
@@ -242,23 +234,19 @@ rpc_log_set_flag(struct spdk_jsonrpc_request *request,
 		SPDK_DEBUGLOG(log_rpc, "spdk_json_decode_object failed\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
 						 "spdk_json_decode_object failed");
-		goto invalid;
+		goto end;
 	}
 
 	if (req.flag == 0) {
 		SPDK_DEBUGLOG(log_rpc, "invalid flag 0\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
 						 "invalid flag 0");
-		goto invalid;
+		goto end;
 	}
 
 	spdk_log_set_flag(req.flag);
-	free_rpc_log_flag(&req);
-
 	spdk_jsonrpc_send_bool_response(request, true);
-	return;
-
-invalid:
+end:
 	free_rpc_log_flag(&req);
 }
 SPDK_RPC_REGISTER("log_set_flag", rpc_log_set_flag, SPDK_RPC_STARTUP | SPDK_RPC_RUNTIME)
@@ -275,23 +263,19 @@ rpc_log_clear_flag(struct spdk_jsonrpc_request *request,
 		SPDK_DEBUGLOG(log_rpc, "spdk_json_decode_object failed\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
 						 "spdk_json_decode_object failed");
-		goto invalid;
+		goto end;
 	}
 
 	if (req.flag == 0) {
 		SPDK_DEBUGLOG(log_rpc, "Invalid flag 0\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
 						 "invalid flag 0");
-		goto invalid;
+		goto end;
 	}
 
 	spdk_log_clear_flag(req.flag);
-	free_rpc_log_flag(&req);
-
 	spdk_jsonrpc_send_bool_response(request, true);
-	return;
-
-invalid:
+end:
 	free_rpc_log_flag(&req);
 }
 SPDK_RPC_REGISTER("log_clear_flag", rpc_log_clear_flag,
-- 
2.26.2


From d97b106f817e3d2419f554915c1ad975e04968e2 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Tue, 20 Apr 2021 12:43:32 +0200
Subject: [PATCH 022/342] pkgdep: Update liburing version to 2.0 release

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I239c6eb2e9919a4605a14d39f4462b3aa5f54883
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7496
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Monica Kenguva <monica.kenguva@intel.com>
---
 scripts/pkgdep/common.sh | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/scripts/pkgdep/common.sh b/scripts/pkgdep/common.sh
index 2a3d304e4..041f37daa 100755
--- a/scripts/pkgdep/common.sh
+++ b/scripts/pkgdep/common.sh
@@ -14,8 +14,7 @@ install_liburing() {
 			git clone "${GIT_REPO_LIBURING}" "$liburing_dir"
 		fi
 		# Use commit we know we can compile against. See #1673 as a reference.
-		# FIXME: Switch to liburing-2.0 when it's finally released
-		git -C "$liburing_dir" checkout 5d027b315d78415a31dcc9111f6bd8924ba5b4e6
+		git -C "$liburing_dir" checkout liburing-2.0
 		(cd "$liburing_dir" && ./configure --libdir=/usr/lib64 && make install)
 		echo /usr/lib64 > /etc/ld.so.conf.d/spdk-liburing.conf
 		ldconfig
-- 
2.26.2


From 988af676da8b2f85cc538e205df0543b21a8177c Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Sun, 2 May 2021 20:46:13 +0800
Subject: [PATCH 023/342] nvmf/tcp: Remove the unnecessary qpair setting.

It is already set by nvmf_tcp_req_pdu_init
when we get the pdu. So we do not set it again.

Change-Id: I034bbc46e600afd802457c0b152e303f16bafba3
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7714
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvmf/tcp.c                    | 1 -
 test/unit/lib/nvmf/tcp.c/tcp_ut.c | 1 +
 2 files changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index b16ed22a4..57596cc11 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -901,7 +901,6 @@ nvmf_tcp_qpair_write_pdu(struct spdk_nvmf_tcp_qpair *tqpair,
 	hlen = pdu->hdr.common.hlen;
 	pdu->cb_fn = cb_fn;
 	pdu->cb_arg = cb_arg;
-	pdu->qpair = tqpair;
 
 	pdu->iov[0].iov_base = &pdu->hdr.raw;
 	pdu->iov[0].iov_len = hlen;
diff --git a/test/unit/lib/nvmf/tcp.c/tcp_ut.c b/test/unit/lib/nvmf/tcp.c/tcp_ut.c
index b96f9e854..f6a06ad3c 100644
--- a/test/unit/lib/nvmf/tcp.c/tcp_ut.c
+++ b/test/unit/lib/nvmf/tcp.c/tcp_ut.c
@@ -559,6 +559,7 @@ test_nvmf_tcp_send_c2h_data(void)
 
 	tcp_req.pdu = &pdu;
 	tcp_req.req.length = 300;
+	tcp_req.req.qpair = &tqpair.qpair;
 
 	tqpair.qpair.transport = &ttransport.transport;
 
-- 
2.26.2


From c86075607b4da1eab52838956edd1cf5d8068462 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 19 Feb 2021 19:46:25 +0000
Subject: [PATCH 024/342] nbd: use SOCK_NONBLOCK with socketpair() call

This simplifies the code a bit, removing the need
for the separate fcntl() calls.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I4fef8f01a055d1471df87bd979c21d6198e9868a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7596
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nbd/nbd.c | 21 +--------------------
 1 file changed, 1 insertion(+), 20 deletions(-)

diff --git a/lib/nbd/nbd.c b/lib/nbd/nbd.c
index 58e837622..3ae72ea3e 100644
--- a/lib/nbd/nbd.c
+++ b/lib/nbd/nbd.c
@@ -957,7 +957,6 @@ nbd_start_complete(struct spdk_nbd_start_ctx *ctx)
 {
 	int		rc;
 	pthread_t	tid;
-	int		flag;
 	unsigned long	nbd_flags = 0;
 
 	rc = ioctl(ctx->nbd->dev_fd, NBD_SET_BLKSIZE, spdk_bdev_get_block_size(ctx->nbd->bdev));
@@ -1016,14 +1015,6 @@ nbd_start_complete(struct spdk_nbd_start_ctx *ctx)
 		goto err;
 	}
 
-	flag = fcntl(ctx->nbd->spdk_sp_fd, F_GETFL);
-	if (fcntl(ctx->nbd->spdk_sp_fd, F_SETFL, flag | O_NONBLOCK) < 0) {
-		SPDK_ERRLOG("fcntl can't set nonblocking mode for socket, fd: %d (%s)\n",
-			    ctx->nbd->spdk_sp_fd, spdk_strerror(errno));
-		rc = -errno;
-		goto err;
-	}
-
 	if (spdk_interrupt_mode_is_enabled()) {
 		ctx->nbd->intr = SPDK_INTERRUPT_REGISTER(ctx->nbd->spdk_sp_fd, nbd_poll, ctx->nbd);
 	}
@@ -1051,20 +1042,10 @@ nbd_enable_kernel(void *arg)
 {
 	struct spdk_nbd_start_ctx *ctx = arg;
 	int rc;
-	int flag;
 
 	/* Declare device setup by this process */
 	rc = ioctl(ctx->nbd->dev_fd, NBD_SET_SOCK, ctx->nbd->kernel_sp_fd);
 
-	if (!rc) {
-		flag = fcntl(ctx->nbd->kernel_sp_fd, F_GETFL);
-		rc = fcntl(ctx->nbd->kernel_sp_fd, F_SETFL, flag | O_NONBLOCK);
-		if (rc < 0) {
-			SPDK_ERRLOG("fcntl can't set nonblocking mode for socket, fd: %d (%s)\n",
-				    ctx->nbd->kernel_sp_fd, spdk_strerror(errno));
-		}
-	}
-
 	if (rc) {
 		if (errno == EBUSY) {
 			if (ctx->nbd->retry_poller == NULL) {
@@ -1147,7 +1128,7 @@ spdk_nbd_start(const char *bdev_name, const char *nbd_path,
 	nbd->ch = spdk_bdev_get_io_channel(nbd->bdev_desc);
 	nbd->buf_align = spdk_max(spdk_bdev_get_buf_align(bdev), 64);
 
-	rc = socketpair(AF_UNIX, SOCK_STREAM, 0, sp);
+	rc = socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0, sp);
 	if (rc != 0) {
 		SPDK_ERRLOG("socketpair failed\n");
 		rc = -errno;
-- 
2.26.2


From 32999ab917f67af61872f868585fd3d78ad6fb8a Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 19 Feb 2021 19:57:25 +0000
Subject: [PATCH 025/342] jsonrpc: use SOCK_NONBLOCK in socket() calls

This allows us to remove separate fcntl() calls to
set O_NONBLOCK.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I1a590cfb3b65b3174bb5ef33e060cdc9bb7ac86c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7598
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/jsonrpc/jsonrpc_client_tcp.c | 12 ++----------
 lib/jsonrpc/jsonrpc_server_tcp.c | 13 ++-----------
 2 files changed, 4 insertions(+), 21 deletions(-)

diff --git a/lib/jsonrpc/jsonrpc_client_tcp.c b/lib/jsonrpc/jsonrpc_client_tcp.c
index 512f6261c..699860e14 100644
--- a/lib/jsonrpc/jsonrpc_client_tcp.c
+++ b/lib/jsonrpc/jsonrpc_client_tcp.c
@@ -227,23 +227,15 @@ static int
 jsonrpc_client_connect(struct spdk_jsonrpc_client *client, int domain, int protocol,
 		       struct sockaddr *server_addr, socklen_t addrlen)
 {
-	int rc, flags;
+	int rc;
 
-	client->sockfd = socket(domain, SOCK_STREAM, protocol);
+	client->sockfd = socket(domain, SOCK_STREAM | SOCK_NONBLOCK, protocol);
 	if (client->sockfd < 0) {
 		rc = errno;
 		SPDK_ERRLOG("socket() failed\n");
 		return -rc;
 	}
 
-	flags = fcntl(client->sockfd, F_GETFL);
-	if (flags < 0 || fcntl(client->sockfd, F_SETFL, flags | O_NONBLOCK) < 0) {
-		rc = errno;
-		SPDK_ERRLOG("fcntl(): can't set nonblocking mode for socket (%d): %s\n",
-			    errno, spdk_strerror(errno));
-		goto err;
-	}
-
 	rc = connect(client->sockfd, server_addr, addrlen);
 	if (rc != 0) {
 		rc = errno;
diff --git a/lib/jsonrpc/jsonrpc_server_tcp.c b/lib/jsonrpc/jsonrpc_server_tcp.c
index 71f3b5cc2..ba7c8d2a1 100644
--- a/lib/jsonrpc/jsonrpc_server_tcp.c
+++ b/lib/jsonrpc/jsonrpc_server_tcp.c
@@ -41,7 +41,7 @@ spdk_jsonrpc_server_listen(int domain, int protocol,
 			   spdk_jsonrpc_handle_request_fn handle_request)
 {
 	struct spdk_jsonrpc_server *server;
-	int rc, val, flag, i;
+	int rc, val, i;
 
 	server = calloc(1, sizeof(struct spdk_jsonrpc_server));
 	if (server == NULL) {
@@ -57,7 +57,7 @@ spdk_jsonrpc_server_listen(int domain, int protocol,
 
 	server->handle_request = handle_request;
 
-	server->sockfd = socket(domain, SOCK_STREAM, protocol);
+	server->sockfd = socket(domain, SOCK_STREAM | SOCK_NONBLOCK, protocol);
 	if (server->sockfd < 0) {
 		SPDK_ERRLOG("socket() failed\n");
 		free(server);
@@ -67,15 +67,6 @@ spdk_jsonrpc_server_listen(int domain, int protocol,
 	val = 1;
 	setsockopt(server->sockfd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
 
-	flag = fcntl(server->sockfd, F_GETFL);
-	if (fcntl(server->sockfd, F_SETFL, flag | O_NONBLOCK) < 0) {
-		SPDK_ERRLOG("fcntl can't set nonblocking mode for socket, fd: %d (%s)\n",
-			    server->sockfd, spdk_strerror(errno));
-		close(server->sockfd);
-		free(server);
-		return NULL;
-	}
-
 	rc = bind(server->sockfd, listen_addr, addrlen);
 	if (rc != 0) {
 		SPDK_ERRLOG("could not bind JSON-RPC server: %s\n", spdk_strerror(errno));
-- 
2.26.2


From 2fc1ccae774a1c3094ed52ed608dda756ee194d4 Mon Sep 17 00:00:00 2001
From: sunshihao520 <sunshihao@huawei.com>
Date: Fri, 16 Apr 2021 17:19:31 +0800
Subject: [PATCH 026/342] lib/nvme: add value check to fix value inversion

When payload_size is 0, we may get wrong cdw10 because of the calculate: 0 - 1,
add value check to fix value inversion bug.

Signed-off-by: sunshihao <sunshihao@huawei.com>
Change-Id: I3bcd38ba981c854ff917282341d32aac47d22b76
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7443
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/nvme/nvme_ctrlr_cmd.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/lib/nvme/nvme_ctrlr_cmd.c b/lib/nvme/nvme_ctrlr_cmd.c
index 29d76f333..1e99341f2 100644
--- a/lib/nvme/nvme_ctrlr_cmd.c
+++ b/lib/nvme/nvme_ctrlr_cmd.c
@@ -988,7 +988,9 @@ nvme_ctrlr_cmd_directive(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid,
 	cmd->opc = opc_type;
 	cmd->nsid = nsid;
 
-	cmd->cdw10 = (payload_size >> 2) - 1;
+	if ((payload_size >> 2) > 0) {
+		cmd->cdw10 = (payload_size >> 2) - 1;
+	}
 	cmd->cdw11_bits.directive.doper = doper;
 	cmd->cdw11_bits.directive.dtype = dtype;
 	cmd->cdw11_bits.directive.dspec = dspec;
-- 
2.26.2


From 33227bbcc04a34470c5ffd64917a30038c691bdb Mon Sep 17 00:00:00 2001
From: Maciej Wawryk <maciejx.wawryk@intel.com>
Date: Wed, 24 Mar 2021 13:27:58 +0100
Subject: [PATCH 027/342] test/nvmf: add remove non-existent subsystem listener
 test

Signed-off-by: Maciej Wawryk <maciejx.wawryk@intel.com>
Change-Id: I3504e874d8ec1c8bacbd394e3d4d208dc155f45c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7038
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 test/nvmf/target/invalid.sh | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/test/nvmf/target/invalid.sh b/test/nvmf/target/invalid.sh
index 98246efeb..dbd8cdf19 100755
--- a/test/nvmf/target/invalid.sh
+++ b/test/nvmf/target/invalid.sh
@@ -55,6 +55,17 @@ out=$("$rpc" nvmf_create_subsystem -s "$(gen_random_s 21)" "$nqn$RANDOM" 2>&1) &
 out=$("$rpc" nvmf_create_subsystem -d "$(gen_random_s 41)" "$nqn$RANDOM" 2>&1) && false
 [[ $out == *"Invalid MN"* ]]
 
+# Attempt to delete non-existing subsytem listener
+$rpc nvmf_create_transport --trtype "$TEST_TRANSPORT"
+$rpc nvmf_create_subsystem $nqn -s SPDK001 -a
+if [[ $TEST_TRANSPORT == "TCP" ]]; then
+	IP="127.0.0.1"
+else
+	IP=$(echo "$RDMA_IP_LIST" | head -n 1)
+fi
+out=$("$rpc" nvmf_subsystem_remove_listener "$nqn" -t "$TEST_TRANSPORT" -a "$IP" -s 4421 2>&1) && false
+[[ $out != *"Unable to stop listener."* ]]
+
 # Attempt to delete non-existing target
 out=$("$multi_target_rpc" nvmf_delete_target --name "$target" 2>&1) && false
 [[ $out == *"The specified target doesn't exist, cannot delete it."* ]]
-- 
2.26.2


From 517164a5fd06624edadc5b6c2d9b4560dcc0a5eb Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Wed, 21 Apr 2021 15:19:19 +0800
Subject: [PATCH 028/342] test/nvme_ctrlr: cases for setting arbitration
 feature and ctrlr state

Change-Id: I7467049e5f5f256704f5eb8fd51a0c9c1c44a581
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7196
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 59 ++++++++++++++++++-
 1 file changed, 57 insertions(+), 2 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index fa97fd491..22e65434c 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -254,13 +254,15 @@ fake_cpl_sc(spdk_nvme_cmd_cb cb_fn, void *cb_arg)
 	cb_fn(cb_arg, &fake_cpl);
 }
 
+static uint32_t g_ut_cdw11;
+
 int
 spdk_nvme_ctrlr_cmd_set_feature(struct spdk_nvme_ctrlr *ctrlr, uint8_t feature,
 				uint32_t cdw11, uint32_t cdw12, void *payload, uint32_t payload_size,
 				spdk_nvme_cmd_cb cb_fn, void *cb_arg)
 {
-	CU_ASSERT(0);
-	return -1;
+	g_ut_cdw11 = cdw11;
+	return 0;
 }
 
 int
@@ -2421,6 +2423,57 @@ test_nvme_cmd_map_sgls(void)
 	spdk_free(sgls);
 }
 
+static void
+test_nvme_ctrlr_set_arbitration_feature(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+
+	ctrlr.opts.arbitration_burst = 6;
+	ctrlr.flags |= SPDK_NVME_CTRLR_WRR_SUPPORTED;
+	ctrlr.opts.low_priority_weight = 1;
+	ctrlr.opts.medium_priority_weight = 2;
+	ctrlr.opts.high_priority_weight = 3;
+	/* g_ut_cdw11 used to record value command feature set. */
+	g_ut_cdw11 = 0;
+
+	/* arbitration_burst count available. */
+	nvme_ctrlr_set_arbitration_feature(&ctrlr);
+	CU_ASSERT((uint8_t)g_ut_cdw11 == 6);
+	CU_ASSERT((uint8_t)(g_ut_cdw11 >> 8) == 1);
+	CU_ASSERT((uint8_t)(g_ut_cdw11 >> 16) == 2);
+	CU_ASSERT((uint8_t)(g_ut_cdw11 >> 24) == 3);
+
+	/* arbitration_burst unavailable. */
+	g_ut_cdw11 = 0;
+	ctrlr.opts.arbitration_burst = 8;
+
+	nvme_ctrlr_set_arbitration_feature(&ctrlr);
+	CU_ASSERT(g_ut_cdw11 == 0);
+}
+
+static void
+test_nvme_ctrlr_set_state(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+	MOCK_SET(spdk_get_ticks, 0);
+
+	nvme_ctrlr_set_state(&ctrlr, NVME_CTRLR_STATE_SET_KEEP_ALIVE_TIMEOUT, 1000);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_KEEP_ALIVE_TIMEOUT);
+	CU_ASSERT(ctrlr.state_timeout_tsc == 1000000);
+
+	nvme_ctrlr_set_state(&ctrlr, NVME_CTRLR_STATE_SET_KEEP_ALIVE_TIMEOUT, 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_KEEP_ALIVE_TIMEOUT);
+	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+
+	/* Time out ticks causes integer overflow. */
+	MOCK_SET(spdk_get_ticks, UINT64_MAX);
+
+	nvme_ctrlr_set_state(&ctrlr, NVME_CTRLR_STATE_SET_KEEP_ALIVE_TIMEOUT, 1000);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_KEEP_ALIVE_TIMEOUT);
+	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+	MOCK_CLEAR(spdk_get_ticks);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -2463,6 +2516,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_ctrlr_add_remove_process);
 	CU_ADD_TEST(suite, test_nvme_cmd_map_prps);
 	CU_ADD_TEST(suite, test_nvme_cmd_map_sgls);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_set_arbitration_feature);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_set_state);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From ed2942461da5d929df1611a705fa3ceeda4d0da9 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 27 Apr 2021 17:59:41 +0800
Subject: [PATCH 029/342] nvmf/vfio-user: ignore unmapped DMA regions

libvfio-user DMA APIs report all regions notified by the client, including those
that don't have a corresponding shared mapping.  There are several of these for
a typical VM, so just ignore this case.

Signed-off-by: John Levon <john.levon@nutanix.com>
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Change-Id: I37b06f4bc6d1818a03c8742616ed142f575d3f0e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7532
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvmf/vfio_user.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index aa20e03f9..78c6baf1e 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -1078,7 +1078,15 @@ memory_region_add_cb(vfu_ctx_t *vfu_ctx, vfu_dma_info_t *info)
 	struct nvmf_vfio_user_qpair *qpair;
 	int i, ret;
 
-	if (!info->vaddr || ((uintptr_t)info->mapping.iov_base & MASK_2MB) ||
+	/*
+	 * We're not interested in any DMA regions that aren't mappable (we don't
+	 * support clients that don't share their memory).
+	 */
+	if (!info->vaddr) {
+		return;
+	}
+
+	if (((uintptr_t)info->mapping.iov_base & MASK_2MB) ||
 	    (info->mapping.iov_len & MASK_2MB)) {
 		SPDK_DEBUGLOG(nvmf_vfio, "Invalid memory region vaddr %p, IOVA %#lx-%#lx\n", info->vaddr,
 			      (uintptr_t)info->mapping.iov_base,
@@ -1154,7 +1162,11 @@ memory_region_remove_cb(vfu_ctx_t *vfu_ctx, vfu_dma_info_t *info)
 	void *map_start, *map_end;
 	int i;
 
-	if (!info->vaddr || ((uintptr_t)info->mapping.iov_base & MASK_2MB) ||
+	if (!info->vaddr) {
+		return 0;
+	}
+
+	if (((uintptr_t)info->mapping.iov_base & MASK_2MB) ||
 	    (info->mapping.iov_len & MASK_2MB)) {
 		SPDK_DEBUGLOG(nvmf_vfio, "Invalid memory region vaddr %p, IOVA %#lx-%#lx\n", info->vaddr,
 			      (uintptr_t)info->mapping.iov_base,
-- 
2.26.2


From 912dc6775584dd3d18d831fc0f594ea7c2d75952 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Wed, 14 Apr 2021 14:23:23 +0800
Subject: [PATCH 030/342] test/nvme_ctrlr_cmd: cases for command security
 receiving and sending

Change-Id: I07c7863ddadf333f15cfb2ebb64e7b3dcf5554d1
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7364
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c | 62 +++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c b/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
index 610ce9903..893f4f9ab 100644
--- a/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
@@ -918,6 +918,66 @@ test_spdk_nvme_ctrlr_cmd_abort(void)
 	CU_ASSERT(pthread_mutex_destroy(&ctrlr.ctrlr_lock) == 0);
 }
 
+static void
+test_nvme_ctrlr_cmd_identify(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+	struct nvme_payload payload = {};
+	int rc;
+	MOCK_SET(nvme_ctrlr_submit_admin_request, 0);
+
+	rc = nvme_ctrlr_cmd_identify(&ctrlr, SPDK_NVME_IDENTIFY_NS, 2, 1, 0, &payload, 4096, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_IDENTIFY);
+	CU_ASSERT(req.cmd.cdw10_bits.identify.cns == SPDK_NVME_IDENTIFY_NS);
+	CU_ASSERT(req.cmd.cdw10_bits.identify.cntid == 2);
+	CU_ASSERT(req.cmd.cdw11_bits.identify.csi == 0);
+	CU_ASSERT(req.cmd.nsid == 1);
+	CU_ASSERT(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+	DECONSTRUCT_CTRLR();
+	MOCK_CLEAR(nvme_ctrlr_submit_admin_request);
+}
+
+static void
+test_spdk_nvme_ctrlr_cmd_security_receive_send(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+	struct nvme_payload payload = {};
+	int rc;
+	MOCK_SET(nvme_ctrlr_submit_admin_request, 0);
+
+	rc = spdk_nvme_ctrlr_cmd_security_send(&ctrlr, 0xea, 0xaabb, 0xcc, &payload, 4096, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_SECURITY_SEND);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.nssf == 0xcc);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.spsp0 == 0xbb);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.spsp1 == 0xaa);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.secp == 0xea);
+	CU_ASSERT(req.cmd.cdw11 == 4096);
+	SPDK_CU_ASSERT_FATAL(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+
+	memset(&req, 0, sizeof(req));
+	STAILQ_INSERT_HEAD(&ctrlr.adminq->free_req, &req, stailq);
+	rc = spdk_nvme_ctrlr_cmd_security_receive(&ctrlr, 0xea, 0xaabb, 0xcc, &payload, 4096, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_SECURITY_RECEIVE);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.nssf == 0xcc);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.spsp0 == 0xbb);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.spsp1 == 0xaa);
+	CU_ASSERT(req.cmd.cdw10_bits.sec_send_recv.secp == 0xea);
+	CU_ASSERT(req.cmd.cdw11 == 4096);
+	SPDK_CU_ASSERT_FATAL(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+	MOCK_CLEAR(nvme_ctrlr_submit_admin_request);
+
+	/* Without request valid. */
+	rc = spdk_nvme_ctrlr_cmd_security_send(&ctrlr, 0xea, 0xaabb, 0xcc, &payload, 4096, NULL, NULL);
+	CU_ASSERT(rc == -ENOMEM);
+
+	rc = spdk_nvme_ctrlr_cmd_security_receive(&ctrlr, 0xea, 0xaabb, 0xcc, &payload, 4096, NULL, NULL);
+	CU_ASSERT(rc == -ENOMEM);
+	DECONSTRUCT_CTRLR();
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -950,6 +1010,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_directive);
 	CU_ADD_TEST(suite, test_nvme_request_add_abort);
 	CU_ADD_TEST(suite, test_spdk_nvme_ctrlr_cmd_abort);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_cmd_identify);
+	CU_ADD_TEST(suite, test_spdk_nvme_ctrlr_cmd_security_receive_send);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From bc7da8548162b917f373529b9cd7c530e0193ffb Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Thu, 22 Apr 2021 15:56:33 +0800
Subject: [PATCH 031/342] test/nvme_qpair: cases for getting sgl print
 information

Change-Id: Ic3cff09a102c4224eda3c4f6e2da0c17e50db303
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7552
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../lib/nvme/nvme_qpair.c/nvme_qpair_ut.c     | 41 +++++++++++++++++++
 1 file changed, 41 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_qpair.c/nvme_qpair_ut.c b/test/unit/lib/nvme/nvme_qpair.c/nvme_qpair_ut.c
index 7d214e2cf..dc51b32c2 100644
--- a/test/unit/lib/nvme/nvme_qpair.c/nvme_qpair_ut.c
+++ b/test/unit/lib/nvme/nvme_qpair.c/nvme_qpair_ut.c
@@ -711,6 +711,46 @@ test_nvme_qpair_init_deinit(void)
 	CU_ASSERT(TAILQ_EMPTY(&qpair.err_cmd_head));
 }
 
+static void
+test_nvme_get_sgl_print_info(void)
+{
+	char buf[NVME_CMD_DPTR_STR_SIZE] = {};
+	struct spdk_nvme_cmd cmd = {};
+
+	cmd.dptr.sgl1.keyed.length = 0x1000;
+	cmd.dptr.sgl1.keyed.key = 0xababccdd;
+
+	nvme_get_sgl_keyed(buf, NVME_CMD_DPTR_STR_SIZE, &cmd);
+	CU_ASSERT(!strncmp(buf, " len:0x1000 key:0xababccdd", NVME_CMD_DPTR_STR_SIZE));
+
+	memset(&cmd.dptr.sgl1, 0, sizeof(cmd.dptr.sgl1));
+	cmd.dptr.sgl1.unkeyed.length = 0x1000;
+
+	nvme_get_sgl_unkeyed(buf, NVME_CMD_DPTR_STR_SIZE, &cmd);
+	CU_ASSERT(!strncmp(buf, " len:0x1000", NVME_CMD_DPTR_STR_SIZE));
+
+	memset(&cmd.dptr.sgl1, 0, sizeof(cmd.dptr.sgl1));
+	cmd.dptr.sgl1.generic.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
+	cmd.dptr.sgl1.generic.subtype = 0;
+	cmd.dptr.sgl1.address = 0xdeadbeef;
+	cmd.dptr.sgl1.keyed.length = 0x1000;
+	cmd.dptr.sgl1.keyed.key = 0xababccdd;
+
+	nvme_get_sgl(buf, NVME_CMD_DPTR_STR_SIZE, &cmd);
+	CU_ASSERT(!strncmp(buf, "SGL DATA BLOCK ADDRESS 0xdeadbeef len:0x1000 key:0xababccdd",
+			   NVME_CMD_DPTR_STR_SIZE));
+
+	memset(&cmd.dptr.sgl1, 0, sizeof(cmd.dptr.sgl1));
+	cmd.dptr.sgl1.generic.type = SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK;
+	cmd.dptr.sgl1.generic.subtype = 0;
+	cmd.dptr.sgl1.address = 0xdeadbeef;
+	cmd.dptr.sgl1.unkeyed.length = 0x1000;
+
+	nvme_get_sgl(buf, NVME_CMD_DPTR_STR_SIZE, &cmd);
+	CU_ASSERT(!strncmp(buf, "SGL RESERVED ADDRESS 0xdeadbeef len:0x1000",
+			   NVME_CMD_DPTR_STR_SIZE));
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -734,6 +774,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_qpair_resubmit_request_with_transport_failed);
 	CU_ADD_TEST(suite, test_nvme_qpair_manual_complete_request);
 	CU_ADD_TEST(suite, test_nvme_qpair_init_deinit);
+	CU_ADD_TEST(suite, test_nvme_get_sgl_print_info);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 3e54a5bb43c8fb8dfb73bb2707a564eaf8885784 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Tue, 4 May 2021 20:59:10 +0000
Subject: [PATCH 032/342] bdev: rearrange bdev_module.h

Move some of the bdev_module APIs immediately after
the bdev_module structure definition.  This prepares
for an upcoming patch.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I78d534ba047048ec27d8d3159666584a52211de3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7736
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 include/spdk/bdev_module.h | 44 +++++++++++++++++++-------------------
 1 file changed, 22 insertions(+), 22 deletions(-)

diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index ac7739625..66116c6a5 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -161,6 +161,28 @@ struct spdk_bdev_module {
 	} internal;
 };
 
+/**
+ * Called by a bdev module to lay exclusive write claim to a bdev.
+ *
+ * Also upgrades that bdev's descriptor to have write access.
+ *
+ * \param bdev Block device to be claimed.
+ * \param desc Descriptor for the above block device.
+ * \param module Bdev module attempting to claim bdev.
+ *
+ * \return 0 on success
+ * \return -EPERM if the bdev is already claimed by another module.
+ */
+int spdk_bdev_module_claim_bdev(struct spdk_bdev *bdev, struct spdk_bdev_desc *desc,
+				struct spdk_bdev_module *module);
+
+/**
+ * Called to release a write claim on a block device.
+ *
+ * \param bdev Block device to be released.
+ */
+void spdk_bdev_module_release_bdev(struct spdk_bdev *bdev);
+
 typedef void (*spdk_bdev_unregister_cb)(void *cb_arg, int rc);
 
 /**
@@ -766,28 +788,6 @@ void spdk_bdev_module_init_done(struct spdk_bdev_module *module);
  */
 void spdk_bdev_module_finish_done(void);
 
-/**
- * Called by a bdev module to lay exclusive write claim to a bdev.
- *
- * Also upgrades that bdev's descriptor to have write access.
- *
- * \param bdev Block device to be claimed.
- * \param desc Descriptor for the above block device.
- * \param module Bdev module attempting to claim bdev.
- *
- * \return 0 on success
- * \return -EPERM if the bdev is already claimed by another module.
- */
-int spdk_bdev_module_claim_bdev(struct spdk_bdev *bdev, struct spdk_bdev_desc *desc,
-				struct spdk_bdev_module *module);
-
-/**
- * Called to release a write claim on a block device.
- *
- * \param bdev Block device to be released.
- */
-void spdk_bdev_module_release_bdev(struct spdk_bdev *bdev);
-
 /**
  * Add alias to block device names list.
  * Aliases can be add only to registered bdev.
-- 
2.26.2


From 2b9ec05ba7774a02b218f5a766fd9406e80ff334 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Tue, 4 May 2021 21:00:50 +0000
Subject: [PATCH 033/342] bdev: add __SPDK_BDEV_MODULE_ONLY to bdev_module.h

We have some cases where libraries need the
spdk_bdev_module structure definition and a couple
of related APIs, but not everything else (i.e.
spdk_bdev, spdk_bdev_io), for purposes of avoiding
abidiff errors.

For example, nvmf creates a dummy spdk_bdev_module,
and then uses it with the spdk_bdev_module_claim_bdev
API to ensure multiple subsystems cannot add the same
bdev as a namespace.

But when nvmf includes bdev_module.h, it pulls in the
spdk_bdev structure definition as well.  This means
when the spdk_bdev structure is modified, it requires
a major version bump since abidiff detects the
difference in the debug info.

Alternatives considered:

* We could add a specific suppression into our abidiff
script for nvmf and struct spdk_bdev, but it would be
a risk (albeit very very small one) that we could
add a real dependency on struct spdk_bdev in the future,
and the suppression would hide the difference.

* We could also break out bdev_module.h into multiple
header files, but the ways of doing that either result
in odd file naming, or modifying every bdev module to
include a new header.

* We could add a public bdev API to expose what the
bdev library needs, but that seemed even more intrusive
than this change. nvmf is kind of abusing the bdev_module
API here, and I'd prefer to not promote that kind of
usage by adding something to the bdev API.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ie8fdef8ea294d005b9ae7934dde49c62748420d1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7737
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 include/spdk/bdev_module.h | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index 66116c6a5..8fb50ce37 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -183,6 +183,14 @@ int spdk_bdev_module_claim_bdev(struct spdk_bdev *bdev, struct spdk_bdev_desc *d
  */
 void spdk_bdev_module_release_bdev(struct spdk_bdev *bdev);
 
+/* Libraries may define __SPDK_BDEV_MODULE_ONLY so that they include
+ * only the struct spdk_bdev_module definition, and the relevant APIs
+ * to claim/release a bdev. This may be useful in some cases to avoid
+ * abidiff errors related to including the struct spdk_bdev structure
+ * unnecessarily.
+ */
+#ifndef __SPDK_BDEV_MODULE_ONLY
+
 typedef void (*spdk_bdev_unregister_cb)(void *cb_arg, int rc);
 
 /**
@@ -1227,4 +1235,6 @@ static void __attribute__((constructor)) _spdk_bdev_module_register_##name(void)
 	spdk_bdev_module_list_add(module); \
 } \
 
+#endif /* __SPDK_BDEV_MODULE_ONLY */
+
 #endif /* SPDK_BDEV_MODULE_H */
-- 
2.26.2


From fa796437258aa051d2ac218bced7db70aa36ad73 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Tue, 4 May 2021 18:45:04 +0000
Subject: [PATCH 034/342] nvmf: remove struct spdk_bdev definition dependencies

1) use spdk_bdev_get_name() accessor
2) use __SPDK_BDEV_MODULE_ONLY #define

The latter allows nvmf to just get the spdk_bdev_module
definitions and APIs that it needs for claiming bdevs
for purposes of avoiding the same namespace used in
different subsystems.

This also ensures that future changes to structures
like spdk_bdev and spdk_bdev_io will not cause
lib/nvmf so version changes.

Note: we include bdev_module.h explicitly in the
nvmf/subsystem unit tests now, before including
subsystem.c, because the unit tests do depend on
knowing the internal structure of spdk_bdev.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I2f499a741d19f4749eadb402641f28137245fd23
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7738
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Anil Veerabhadrappa <anil.veerabhadrappa@broadcom.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/nvmf/subsystem.c                          | 3 ++-
 test/unit/lib/nvmf/fc.c/fc_ut.c               | 1 +
 test/unit/lib/nvmf/subsystem.c/subsystem_ut.c | 1 +
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/lib/nvmf/subsystem.c b/lib/nvmf/subsystem.c
index 457fa64d6..be9c12342 100644
--- a/lib/nvmf/subsystem.c
+++ b/lib/nvmf/subsystem.c
@@ -44,6 +44,7 @@
 #include "spdk/json.h"
 #include "spdk/file.h"
 
+#define __SPDK_BDEV_MODULE_ONLY
 #include "spdk/bdev_module.h"
 #include "spdk/log.h"
 #include "spdk_internal/utf.h"
@@ -1320,7 +1321,7 @@ nvmf_ns_event(enum spdk_bdev_event_type type,
 {
 	SPDK_DEBUGLOG(nvmf, "Bdev event: type %d, name %s, subsystem_id %d, ns_id %d\n",
 		      type,
-		      bdev->name,
+		      spdk_bdev_get_name(bdev),
 		      ((struct spdk_nvmf_ns *)event_ctx)->subsystem->id,
 		      ((struct spdk_nvmf_ns *)event_ctx)->nsid);
 
diff --git a/test/unit/lib/nvmf/fc.c/fc_ut.c b/test/unit/lib/nvmf/fc.c/fc_ut.c
index a7603a7bc..560505767 100644
--- a/test/unit/lib/nvmf/fc.c/fc_ut.c
+++ b/test/unit/lib/nvmf/fc.c/fc_ut.c
@@ -51,6 +51,7 @@
 #include "json/json_write.c"
 #include "nvmf/nvmf.c"
 #include "nvmf/transport.c"
+#include "spdk/bdev_module.h"
 #include "nvmf/subsystem.c"
 #include "nvmf/fc.c"
 #include "nvmf/fc_ls.c"
diff --git a/test/unit/lib/nvmf/subsystem.c/subsystem_ut.c b/test/unit/lib/nvmf/subsystem.c/subsystem_ut.c
index 3263eeb66..2c113acd5 100644
--- a/test/unit/lib/nvmf/subsystem.c/subsystem_ut.c
+++ b/test/unit/lib/nvmf/subsystem.c/subsystem_ut.c
@@ -37,6 +37,7 @@
 #include "spdk_cunit.h"
 #include "spdk_internal/mock.h"
 
+#include "spdk/bdev_module.h"
 #include "nvmf/subsystem.c"
 
 SPDK_LOG_REGISTER_COMPONENT(nvmf)
-- 
2.26.2


From 6cebe9d06b14ad173e45d2b9be49b04f64b5fba3 Mon Sep 17 00:00:00 2001
From: Swapnil Ingle <swapnil.ingle@nutanix.com>
Date: Fri, 9 Apr 2021 12:18:41 -0400
Subject: [PATCH 035/342] nvmf: Support physical block size if exposed by bdev

(Note: this patch was previously applied as b32cfc46 and then reverted
as 63642bef.)

Today the in-guest nvme device shows physical_block_size=512 even though
the backend iSCSI bdev supports physical_block_size=4K

iSCSI targets exposes physical block size using
logical_block_per_physical_block_exponent in READ_CAPACITY_16

NPWG is one of the way to let Linux nvme driver set
physical_block_size of the nvme block device.

This patch adds spdk_bdev.phys_blocklen which is updated if the iSCSI
backend exposes physical_block_size.
Later phys_blocklen is used in nvmf to set NPWG and NAWUPF to report
back during NS identity.
Linux driver uses min(nawupf, npwg) to set physical_block_size.

Similarly in scsi_bdev fill lbppbe in READ_CAP16 response
based on spdk_bdev.phys_blocklen.

Fixes #1884

Signed-off-by: Swapnil Ingle <swapnil.ingle@nutanix.com>
Change-Id: I0b6c81f1937e346d448f49c927eda8c79d2d75c0
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7739
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/nvme/identify/identify.c               |  4 ++++
 include/spdk/bdev.h                             |  8 ++++++++
 include/spdk/bdev_module.h                      |  3 +++
 lib/bdev/Makefile                               |  2 +-
 lib/bdev/bdev.c                                 | 10 ++++++++++
 lib/bdev/spdk_bdev.map                          |  1 +
 lib/nvmf/ctrlr_bdev.c                           | 10 ++++++++++
 lib/scsi/scsi_bdev.c                            |  7 +++++++
 module/bdev/iscsi/bdev_iscsi.c                  |  7 +++++--
 test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c |  3 +++
 test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c   |  3 +++
 11 files changed, 55 insertions(+), 3 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index f6ce6b73d..20a0d2d68 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -1014,6 +1014,10 @@ print_namespace(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
 			printf("  Atomic Write Unit (PFail):           %d\n", nsdata->nawupf + 1);
 		}
 
+		if (nsdata->npwg) {
+			printf("  Preferred Write Granularity:         %d\n", nsdata->npwg + 1);
+		}
+
 		if (nsdata->nacwu) {
 			printf("  Atomic Compare & Write Unit:         %d\n", nsdata->nacwu + 1);
 		}
diff --git a/include/spdk/bdev.h b/include/spdk/bdev.h
index 72f673b04..19b265735 100644
--- a/include/spdk/bdev.h
+++ b/include/spdk/bdev.h
@@ -590,6 +590,14 @@ bool spdk_bdev_is_zoned(const struct spdk_bdev *bdev);
  */
 uint32_t spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev);
 
+/**
+ * Get block device physical block size.
+ *
+ * \param bdev Block device to query.
+ * \return Size of physical block size for this bdev in bytes.
+ */
+uint32_t spdk_bdev_get_physical_block_size(const struct spdk_bdev *bdev);
+
 /**
  * Get DIF type of the block device.
  *
diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index 8fb50ce37..f30083ee1 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -295,6 +295,9 @@ struct spdk_bdev {
 	/** Size in bytes of a logical block for the backend */
 	uint32_t blocklen;
 
+	/** Size in bytes of a physical block for the backend */
+	uint32_t phys_blocklen;
+
 	/** Number of blocks */
 	uint64_t blockcnt;
 
diff --git a/lib/bdev/Makefile b/lib/bdev/Makefile
index 4b9f3f098..383332262 100644
--- a/lib/bdev/Makefile
+++ b/lib/bdev/Makefile
@@ -34,7 +34,7 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-SO_VER := 6
+SO_VER := 7
 SO_MINOR := 0
 
 ifeq ($(CONFIG_VTUNE),y)
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 9c741d001..9ede230c0 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -3291,6 +3291,12 @@ spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev)
 	}
 }
 
+uint32_t
+spdk_bdev_get_physical_block_size(const struct spdk_bdev *bdev)
+{
+	return bdev->phys_blocklen;
+}
+
 static uint32_t
 _bdev_get_block_size_with_md(const struct spdk_bdev *bdev)
 {
@@ -5464,6 +5470,10 @@ bdev_init(struct spdk_bdev *bdev)
 		bdev->acwu = 1;
 	}
 
+	if (bdev->phys_blocklen == 0) {
+		bdev->phys_blocklen = spdk_bdev_get_data_block_size(bdev);
+	}
+
 	TAILQ_INIT(&bdev->internal.open_descs);
 	TAILQ_INIT(&bdev->internal.locked_ranges);
 	TAILQ_INIT(&bdev->internal.pending_locked_ranges);
diff --git a/lib/bdev/spdk_bdev.map b/lib/bdev/spdk_bdev.map
index aec215d58..91d21d5db 100644
--- a/lib/bdev/spdk_bdev.map
+++ b/lib/bdev/spdk_bdev.map
@@ -40,6 +40,7 @@
 	spdk_bdev_is_md_separate;
 	spdk_bdev_is_zoned;
 	spdk_bdev_get_data_block_size;
+	spdk_bdev_get_physical_block_size;
 	spdk_bdev_get_dif_type;
 	spdk_bdev_is_dif_head_of_md;
 	spdk_bdev_is_dif_check_enabled;
diff --git a/lib/nvmf/ctrlr_bdev.c b/lib/nvmf/ctrlr_bdev.c
index a631b8003..b79254f79 100644
--- a/lib/nvmf/ctrlr_bdev.c
+++ b/lib/nvmf/ctrlr_bdev.c
@@ -140,6 +140,7 @@ nvmf_bdev_ctrlr_identify_ns(struct spdk_nvmf_ns *ns, struct spdk_nvme_ns_data *n
 {
 	struct spdk_bdev *bdev = ns->bdev;
 	uint64_t num_blocks;
+	uint32_t phys_blocklen;
 
 	num_blocks = spdk_bdev_get_num_blocks(bdev);
 
@@ -181,6 +182,15 @@ nvmf_bdev_ctrlr_identify_ns(struct spdk_nvmf_ns *ns, struct spdk_nvme_ns_data *n
 		nsdata->lbaf[0].ms = 0;
 		nsdata->lbaf[0].lbads = spdk_u32log2(spdk_bdev_get_data_block_size(bdev));
 	}
+
+	phys_blocklen = spdk_bdev_get_physical_block_size(bdev);
+	assert(phys_blocklen > 0);
+	/* Linux driver uses min(nawupf, npwg) to set physical_block_size */
+	nsdata->nsfeat.optperf = 1;
+	nsdata->nsfeat.ns_atomic_write_unit = 1;
+	nsdata->npwg = (phys_blocklen >> nsdata->lbaf[0].lbads) - 1;
+	nsdata->nawupf = nsdata->npwg;
+
 	nsdata->noiob = spdk_bdev_get_optimal_io_boundary(bdev);
 	nsdata->nmic.can_share = 1;
 	if (ns->ptpl_file != NULL) {
diff --git a/lib/scsi/scsi_bdev.c b/lib/scsi/scsi_bdev.c
index 06270eb5d..ba890af74 100644
--- a/lib/scsi/scsi_bdev.c
+++ b/lib/scsi/scsi_bdev.c
@@ -1620,9 +1620,16 @@ bdev_scsi_process_block(struct spdk_scsi_task *task)
 		switch (cdb[1] & 0x1f) { /* SERVICE ACTION */
 		case SPDK_SBC_SAI_READ_CAPACITY_16: {
 			uint8_t buffer[32] = {0};
+			uint32_t lbppb;
 
 			to_be64(&buffer[0], spdk_bdev_get_num_blocks(bdev) - 1);
 			to_be32(&buffer[8], spdk_bdev_get_data_block_size(bdev));
+			lbppb = spdk_bdev_get_physical_block_size(bdev) / spdk_bdev_get_data_block_size(bdev);
+			if (spdk_u32log2(lbppb) > 0xf) {
+				SPDK_ERRLOG("lbppbe(0x%x) > 0xf\n", spdk_u32log2(lbppb));
+			} else {
+				buffer[13] = spdk_u32log2(lbppb);
+			}
 			/*
 			 * Set the TPE bit to 1 to indicate thin provisioning.
 			 * The position of TPE bit is the 7th bit in 14th byte
diff --git a/module/bdev/iscsi/bdev_iscsi.c b/module/bdev/iscsi/bdev_iscsi.c
index 7516ea95e..edb537345 100644
--- a/module/bdev/iscsi/bdev_iscsi.c
+++ b/module/bdev/iscsi/bdev_iscsi.c
@@ -623,7 +623,8 @@ static const struct spdk_bdev_fn_table iscsi_fn_table = {
 static int
 create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *initiator_iqn,
 		 char *name,
-		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported)
+		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported,
+		 uint8_t lbppbe)
 {
 	struct bdev_iscsi_lun *lun;
 	int rc;
@@ -645,6 +646,7 @@ create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *ini
 	lun->bdev.product_name = "iSCSI LUN";
 	lun->bdev.module = &g_iscsi_bdev_module;
 	lun->bdev.blocklen = block_size;
+	lun->bdev.phys_blocklen = block_size * (1 << lbppbe);
 	lun->bdev.blockcnt = num_blocks;
 	lun->bdev.ctxt = lun;
 	lun->unmap_supported = unmap_supported;
@@ -691,7 +693,8 @@ iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,
 	}
 
 	status = create_iscsi_lun(req->context, req->lun, req->url, req->initiator_iqn, req->bdev_name,
-				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported);
+				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported,
+				  readcap16->lbppbe);
 	if (status) {
 		SPDK_ERRLOG("Unable to create iscsi bdev: %s (%d)\n", spdk_strerror(-status), status);
 	}
diff --git a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
index e3801b57d..7edb46dfc 100644
--- a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
+++ b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
@@ -51,6 +51,9 @@ DEFINE_STUB(spdk_bdev_get_acwu, uint16_t, (const struct spdk_bdev *bdev), 0);
 DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 512);
 
+DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
+	    (const struct spdk_bdev *bdev), 4096);
+
 DEFINE_STUB(nvmf_ctrlr_process_admin_cmd, int, (struct spdk_nvmf_request *req), 0);
 
 DEFINE_STUB(spdk_bdev_comparev_blocks, int, (struct spdk_bdev_desc *desc,
diff --git a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
index 87485b901..3e1705477 100644
--- a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
+++ b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
@@ -77,6 +77,9 @@ DEFINE_STUB(spdk_bdev_is_md_interleaved, bool,
 DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 512);
 
+DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
+	    (const struct spdk_bdev *bdev), 4096);
+
 uint64_t
 spdk_bdev_get_num_blocks(const struct spdk_bdev *bdev)
 {
-- 
2.26.2


From 20698a4a8dc0fb2585707e1b44b7cfb9de7fdeb6 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 13 Apr 2021 19:02:46 +0800
Subject: [PATCH 036/342] idxd: Split the idxd library into common and user
 space part.

Purpose: This patch is used to prepare to add the kernel
idxd support later.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: If89665f95d622c7342ab75050664158ec6fc615a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7330
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/idxd/Makefile                             |   3 +-
 lib/idxd/idxd.c                               | 467 ++-------------
 lib/idxd/idxd.h                               |  30 +-
 lib/idxd/idxd_user.c                          | 541 ++++++++++++++++++
 test/unit/lib/idxd/Makefile                   |   2 +-
 test/unit/lib/idxd/idxd.c/idxd_ut.c           | 211 +------
 test/unit/lib/idxd/idxd_user.c/.gitignore     |   1 +
 test/unit/lib/idxd/idxd_user.c/Makefile       |  38 ++
 test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c | 272 +++++++++
 test/unit/unittest.sh                         |   1 +
 10 files changed, 935 insertions(+), 631 deletions(-)
 create mode 100644 lib/idxd/idxd_user.c
 create mode 100644 test/unit/lib/idxd/idxd_user.c/.gitignore
 create mode 100644 test/unit/lib/idxd/idxd_user.c/Makefile
 create mode 100644 test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c

diff --git a/lib/idxd/Makefile b/lib/idxd/Makefile
index 08c19e83d..dde83af2c 100644
--- a/lib/idxd/Makefile
+++ b/lib/idxd/Makefile
@@ -37,7 +37,8 @@ include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 SO_VER := 4
 SO_MINOR := 0
 
-C_SRCS = idxd.c
+C_SRCS = idxd.c idxd_user.c
+
 LIBNAME = idxd
 
 SPDK_MAP_FILE = $(abspath $(CURDIR)/spdk_idxd.map)
diff --git a/lib/idxd/idxd.c b/lib/idxd/idxd.c
index f1683d940..69bd2a047 100644
--- a/lib/idxd/idxd.c
+++ b/lib/idxd/idxd.c
@@ -45,8 +45,10 @@
 #include "idxd.h"
 
 #define ALIGN_4K 0x1000
+#define USERSPACE_DRIVER_NAME "user"
 
-pthread_mutex_t	g_driver_lock = PTHREAD_MUTEX_INITIALIZER;
+static STAILQ_HEAD(, spdk_idxd_impl) g_idxd_impls = STAILQ_HEAD_INITIALIZER(g_idxd_impls);
+static struct spdk_idxd_impl *g_idxd_impl;
 
 /*
  * g_dev_cfg gives us 2 pre-set configurations of DSA to choose from
@@ -73,34 +75,16 @@ struct device_config g_dev_cfg1 = {
 	.total_engines = 4,
 };
 
-static uint32_t
-_idxd_read_4(struct spdk_idxd_device *idxd, uint32_t offset)
-{
-	return spdk_mmio_read_4((uint32_t *)(idxd->reg_base + offset));
-}
-
-static void
-_idxd_write_4(struct spdk_idxd_device *idxd, uint32_t offset, uint32_t value)
+bool
+spdk_idxd_device_needs_rebalance(struct spdk_idxd_device *idxd)
 {
-	spdk_mmio_write_4((uint32_t *)(idxd->reg_base + offset), value);
+	return idxd->needs_rebalance;
 }
 
 static uint64_t
-_idxd_read_8(struct spdk_idxd_device *idxd, uint32_t offset)
-{
-	return spdk_mmio_read_8((uint64_t *)(idxd->reg_base + offset));
-}
-
-static void
-_idxd_write_8(struct spdk_idxd_device *idxd, uint32_t offset, uint64_t value)
-{
-	spdk_mmio_write_8((uint64_t *)(idxd->reg_base + offset), value);
-}
-
-bool
-spdk_idxd_device_needs_rebalance(struct spdk_idxd_device *idxd)
+idxd_read_8(struct spdk_idxd_device *idxd, void *portal, uint32_t offset)
 {
-	return idxd->needs_rebalance;
+	return idxd->impl->read_8(idxd, portal, offset);
 }
 
 struct spdk_idxd_io_channel *
@@ -243,8 +227,7 @@ spdk_idxd_configure_chan(struct spdk_idxd_io_channel *chan)
 		}
 	}
 
-	/* Assign portal based on work queue chosen earlier. */
-	chan->portal = (char *)chan->idxd->portals + chan->idxd->wq_id * PORTAL_SIZE;
+	chan->portal = chan->idxd->impl->portal_get_addr(chan->idxd);
 
 	return 0;
 
@@ -264,34 +247,6 @@ err_desc:
 	return rc;
 }
 
-/* Used for control commands, not for descriptor submission. */
-static int
-idxd_wait_cmd(struct spdk_idxd_device *idxd, int _timeout)
-{
-	uint32_t timeout = _timeout;
-	union idxd_cmdsts_reg cmd_status = {};
-
-	cmd_status.raw = _idxd_read_4(idxd, IDXD_CMDSTS_OFFSET);
-	while (cmd_status.active && --timeout) {
-		usleep(1);
-		cmd_status.raw = _idxd_read_4(idxd, IDXD_CMDSTS_OFFSET);
-	}
-
-	/* Check for timeout */
-	if (timeout == 0 && cmd_status.active) {
-		SPDK_ERRLOG("Command timeout, waited %u\n", _timeout);
-		return -EBUSY;
-	}
-
-	/* Check for error */
-	if (cmd_status.err) {
-		SPDK_ERRLOG("Command status reg reports error 0x%x\n", cmd_status.err);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 static void
 _idxd_drain(struct spdk_idxd_io_channel *chan)
 {
@@ -347,10 +302,32 @@ spdk_idxd_reconfigure_chan(struct spdk_idxd_io_channel *chan)
 	return rc;
 }
 
+static inline struct spdk_idxd_impl *
+idxd_get_impl_by_name(const char *impl_name)
+{
+	struct spdk_idxd_impl *impl;
+
+	assert(impl_name != NULL);
+	STAILQ_FOREACH(impl, &g_idxd_impls, link) {
+		if (0 == strcmp(impl_name, impl->name)) {
+			return impl;
+		}
+	}
+
+	return NULL;
+}
+
 /* Called via RPC to select a pre-defined configuration. */
 void
 spdk_idxd_set_config(uint32_t config_num)
 {
+	g_idxd_impl = idxd_get_impl_by_name(USERSPACE_DRIVER_NAME);
+
+	if (g_idxd_impl == NULL) {
+		SPDK_ERRLOG("Cannot set the idxd implementation");
+		return;
+	}
+
 	switch (config_num) {
 	case 0:
 		g_dev_cfg = &g_dev_cfg0;
@@ -363,378 +340,27 @@ spdk_idxd_set_config(uint32_t config_num)
 		SPDK_ERRLOG("Invalid config, using default\n");
 		break;
 	}
-}
 
-static int
-idxd_unmap_pci_bar(struct spdk_idxd_device *idxd, int bar)
-{
-	int rc = 0;
-	void *addr = NULL;
-
-	if (bar == IDXD_MMIO_BAR) {
-		addr = (void *)idxd->reg_base;
-	} else if (bar == IDXD_WQ_BAR) {
-		addr = (void *)idxd->portals;
-	}
-
-	if (addr) {
-		rc = spdk_pci_device_unmap_bar(idxd->device, 0, addr);
-	}
-	return rc;
-}
-
-static int
-idxd_map_pci_bars(struct spdk_idxd_device *idxd)
-{
-	int rc;
-	void *addr;
-	uint64_t phys_addr, size;
-
-	rc = spdk_pci_device_map_bar(idxd->device, IDXD_MMIO_BAR, &addr, &phys_addr, &size);
-	if (rc != 0 || addr == NULL) {
-		SPDK_ERRLOG("pci_device_map_range failed with error code %d\n", rc);
-		return -1;
-	}
-	idxd->reg_base = addr;
-
-	rc = spdk_pci_device_map_bar(idxd->device, IDXD_WQ_BAR, &addr, &phys_addr, &size);
-	if (rc != 0 || addr == NULL) {
-		SPDK_ERRLOG("pci_device_map_range failed with error code %d\n", rc);
-		rc = idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
-		if (rc) {
-			SPDK_ERRLOG("unable to unmap MMIO bar\n");
-		}
-		return -EINVAL;
-	}
-	idxd->portals = addr;
-
-	return 0;
-}
-
-static int
-idxd_reset_dev(struct spdk_idxd_device *idxd)
-{
-	int rc;
-
-	_idxd_write_4(idxd, IDXD_CMD_OFFSET, IDXD_RESET_DEVICE << IDXD_CMD_SHIFT);
-	rc = idxd_wait_cmd(idxd, IDXD_REGISTER_TIMEOUT_US);
-	if (rc < 0) {
-		SPDK_ERRLOG("Error resetting device %u\n", rc);
-	}
-
-	return rc;
-}
-
-/*
- * Build group config based on getting info from the device combined
- * with the defined configuration. Once built, it is written to the
- * device.
- */
-static int
-idxd_group_config(struct spdk_idxd_device *idxd)
-{
-	int i;
-	uint64_t base_offset;
-	struct idxd_grpcfg *grpcfg;
-
-	assert(g_dev_cfg->num_groups <= idxd->registers.groupcap.num_groups);
-	idxd->groups = calloc(idxd->registers.groupcap.num_groups, sizeof(struct idxd_group));
-	if (idxd->groups == NULL) {
-		SPDK_ERRLOG("Failed to allocate group memory\n");
-		return -ENOMEM;
-	}
-
-	assert(g_dev_cfg->total_engines <= idxd->registers.enginecap.num_engines);
-	for (i = 0; i < g_dev_cfg->total_engines; i++) {
-		idxd->groups[i % g_dev_cfg->num_groups].grpcfg.engines |= (1 << i);
-	}
-
-	assert(g_dev_cfg->total_wqs <= idxd->registers.wqcap.num_wqs);
-	for (i = 0; i < g_dev_cfg->total_wqs; i++) {
-		idxd->groups[i % g_dev_cfg->num_groups].grpcfg.wqs[0] |= (1 << i);
-	}
-
-	for (i = 0; i < g_dev_cfg->num_groups; i++) {
-		idxd->groups[i].idxd = idxd;
-		idxd->groups[i].id = i;
-
-		/* Divide BW tokens evenly */
-		idxd->groups[i].grpcfg.flags.tokens_allowed =
-			idxd->registers.groupcap.total_tokens / g_dev_cfg->num_groups;
-	}
-
-	/*
-	 * Now write the group config to the device for all groups. We write
-	 * to the max number of groups in order to 0 out the ones we didn't
-	 * configure.
-	 */
-	for (i = 0 ; i < idxd->registers.groupcap.num_groups; i++) {
-
-		grpcfg = &idxd->groups[i].grpcfg;
-		if (i < g_dev_cfg->num_groups) {
-			SPDK_DEBUGLOG(idxd, "Group #%u: wqueue_cfg 0x%lx, engine_cfg 0x%lx, flags 0x%x\n", i,
-				      grpcfg->wqs[0], grpcfg->engines, grpcfg->flags.raw);
-		}
-
-		base_offset = idxd->grpcfg_offset + i * 64;
-
-		/* GRPWQCFG, work queues config */
-		_idxd_write_8(idxd, base_offset, grpcfg->wqs[0]);
-
-		/* GRPENGCFG, engine config */
-		_idxd_write_8(idxd, base_offset + CFG_ENGINE_OFFSET, grpcfg->engines);
-
-		/* GRPFLAGS, flags config */
-		_idxd_write_8(idxd, base_offset + CFG_FLAG_OFFSET, grpcfg->flags.raw);
-	}
-
-	return 0;
-}
-
-/*
- * Build work queue (WQ) config based on getting info from the device combined
- * with the defined configuration. Once built, it is written to the device.
- */
-static int
-idxd_wq_config(struct spdk_idxd_device *idxd)
-{
-	int i, j;
-	struct idxd_wq *queue;
-	u_int32_t wq_size = idxd->registers.wqcap.total_wq_size / g_dev_cfg->total_wqs;
-
-	SPDK_NOTICELOG("Total ring slots available space 0x%x, so per work queue is 0x%x\n",
-		       idxd->registers.wqcap.total_wq_size, wq_size);
-	assert(g_dev_cfg->total_wqs <= IDXD_MAX_QUEUES);
-	assert(g_dev_cfg->total_wqs <= idxd->registers.wqcap.num_wqs);
-	assert(LOG2_WQ_MAX_BATCH <= idxd->registers.gencap.max_batch_shift);
-	assert(LOG2_WQ_MAX_XFER <= idxd->registers.gencap.max_xfer_shift);
-
-	idxd->queues = calloc(1, idxd->registers.wqcap.num_wqs * sizeof(struct idxd_wq));
-	if (idxd->queues == NULL) {
-		SPDK_ERRLOG("Failed to allocate queue memory\n");
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < g_dev_cfg->total_wqs; i++) {
-		queue = &idxd->queues[i];
-		queue->wqcfg.wq_size = wq_size;
-		queue->wqcfg.mode = WQ_MODE_DEDICATED;
-		queue->wqcfg.max_batch_shift = LOG2_WQ_MAX_BATCH;
-		queue->wqcfg.max_xfer_shift = LOG2_WQ_MAX_XFER;
-		queue->wqcfg.wq_state = WQ_ENABLED;
-		queue->wqcfg.priority = WQ_PRIORITY_1;
-
-		/* Not part of the config struct */
-		queue->idxd = idxd;
-		queue->group = &idxd->groups[i % g_dev_cfg->num_groups];
-	}
-
-	/*
-	 * Now write the work queue config to the device for all wq space
-	 */
-	for (i = 0 ; i < idxd->registers.wqcap.num_wqs; i++) {
-		queue = &idxd->queues[i];
-		for (j = 0 ; j < WQCFG_NUM_DWORDS; j++) {
-			_idxd_write_4(idxd, idxd->wqcfg_offset + i * 32 + j * 4,
-				      queue->wqcfg.raw[j]);
-		}
-	}
-
-	return 0;
-}
-
-static int
-idxd_device_configure(struct spdk_idxd_device *idxd)
-{
-	int i, rc = 0;
-	union idxd_offsets_register offsets_reg;
-	union idxd_genstatus_register genstatus_reg;
-
-	/*
-	 * Map BAR0 and BAR2
-	 */
-	rc = idxd_map_pci_bars(idxd);
-	if (rc) {
-		return rc;
-	}
-
-	/*
-	 * Reset the device
-	 */
-	rc = idxd_reset_dev(idxd);
-	if (rc) {
-		goto err_reset;
-	}
-
-	/*
-	 * Read in config registers
-	 */
-	idxd->registers.version = _idxd_read_4(idxd, IDXD_VERSION_OFFSET);
-	idxd->registers.gencap.raw = _idxd_read_8(idxd, IDXD_GENCAP_OFFSET);
-	idxd->registers.wqcap.raw = _idxd_read_8(idxd, IDXD_WQCAP_OFFSET);
-	idxd->registers.groupcap.raw = _idxd_read_8(idxd, IDXD_GRPCAP_OFFSET);
-	idxd->registers.enginecap.raw = _idxd_read_8(idxd, IDXD_ENGCAP_OFFSET);
-	for (i = 0; i < IDXD_OPCAP_WORDS; i++) {
-		idxd->registers.opcap.raw[i] =
-			_idxd_read_8(idxd, i * sizeof(uint64_t) + IDXD_OPCAP_OFFSET);
-	}
-	offsets_reg.raw[0] = _idxd_read_8(idxd, IDXD_TABLE_OFFSET);
-	offsets_reg.raw[1] = _idxd_read_8(idxd, IDXD_TABLE_OFFSET + sizeof(uint64_t));
-	idxd->grpcfg_offset = offsets_reg.grpcfg * IDXD_TABLE_OFFSET_MULT;
-	idxd->wqcfg_offset = offsets_reg.wqcfg * IDXD_TABLE_OFFSET_MULT;
-	idxd->ims_offset = offsets_reg.ims * IDXD_TABLE_OFFSET_MULT;
-	idxd->msix_perm_offset = offsets_reg.msix_perm  * IDXD_TABLE_OFFSET_MULT;
-	idxd->perfmon_offset = offsets_reg.perfmon * IDXD_TABLE_OFFSET_MULT;
-
-	/*
-	 * Configure groups and work queues.
-	 */
-	rc = idxd_group_config(idxd);
-	if (rc) {
-		goto err_group_cfg;
-	}
-
-	rc = idxd_wq_config(idxd);
-	if (rc) {
-		goto err_wq_cfg;
-	}
-
-	/*
-	 * Enable the device
-	 */
-	genstatus_reg.raw = _idxd_read_4(idxd, IDXD_GENSTATUS_OFFSET);
-	assert(genstatus_reg.state == IDXD_DEVICE_STATE_DISABLED);
-
-	_idxd_write_4(idxd, IDXD_CMD_OFFSET, IDXD_ENABLE_DEV << IDXD_CMD_SHIFT);
-	rc = idxd_wait_cmd(idxd, IDXD_REGISTER_TIMEOUT_US);
-	genstatus_reg.raw = _idxd_read_4(idxd, IDXD_GENSTATUS_OFFSET);
-	if ((rc < 0) || (genstatus_reg.state != IDXD_DEVICE_STATE_ENABLED)) {
-		rc = -EINVAL;
-		SPDK_ERRLOG("Error enabling device %u\n", rc);
-		goto err_device_enable;
-	}
-
-	genstatus_reg.raw = spdk_mmio_read_4((uint32_t *)(idxd->reg_base + IDXD_GENSTATUS_OFFSET));
-	assert(genstatus_reg.state == IDXD_DEVICE_STATE_ENABLED);
-
-	/*
-	 * Enable the work queues that we've configured
-	 */
-	for (i = 0; i < g_dev_cfg->total_wqs; i++) {
-		_idxd_write_4(idxd, IDXD_CMD_OFFSET,
-			      (IDXD_ENABLE_WQ << IDXD_CMD_SHIFT) | i);
-		rc = idxd_wait_cmd(idxd, IDXD_REGISTER_TIMEOUT_US);
-		if (rc < 0) {
-			SPDK_ERRLOG("Error enabling work queues 0x%x\n", rc);
-			goto err_wq_enable;
-		}
-	}
-
-	if ((rc == 0) && (genstatus_reg.state == IDXD_DEVICE_STATE_ENABLED)) {
-		SPDK_NOTICELOG("Device enabled, version 0x%x gencap: 0x%lx\n",
-			       idxd->registers.version,
-			       idxd->registers.gencap.raw);
-
-	}
-
-	return rc;
-err_wq_enable:
-err_device_enable:
-	free(idxd->queues);
-err_wq_cfg:
-	free(idxd->groups);
-err_group_cfg:
-err_reset:
-	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
-	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
-
-	return rc;
+	g_idxd_impl->set_config(g_dev_cfg, config_num);
 }
 
 static void
 idxd_device_destruct(struct spdk_idxd_device *idxd)
 {
-	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
-	idxd_unmap_pci_bar(idxd, IDXD_WQ_BAR);
-	free(idxd->groups);
-	free(idxd->queues);
-	free(idxd);
-}
-
-/* Caller must hold g_driver_lock */
-static struct spdk_idxd_device *
-idxd_attach(struct spdk_pci_device *device)
-{
-	struct spdk_idxd_device *idxd;
-	uint32_t cmd_reg;
-	int rc;
-
-	idxd = calloc(1, sizeof(struct spdk_idxd_device));
-	if (idxd == NULL) {
-		SPDK_ERRLOG("Failed to allocate memory for idxd device.\n");
-		return NULL;
-	}
-
-	idxd->device = device;
-	pthread_mutex_init(&idxd->num_channels_lock, NULL);
+	assert(idxd->impl != NULL);
 
-	/* Enable PCI busmaster. */
-	spdk_pci_device_cfg_read32(device, &cmd_reg, 4);
-	cmd_reg |= 0x4;
-	spdk_pci_device_cfg_write32(device, cmd_reg, 4);
-
-	rc = idxd_device_configure(idxd);
-	if (rc) {
-		goto err;
-	}
-
-	return idxd;
-err:
-	idxd_device_destruct(idxd);
-	return NULL;
-}
-
-struct idxd_enum_ctx {
-	spdk_idxd_probe_cb probe_cb;
-	spdk_idxd_attach_cb attach_cb;
-	void *cb_ctx;
-};
-
-/* This function must only be called while holding g_driver_lock */
-static int
-idxd_enum_cb(void *ctx, struct spdk_pci_device *pci_dev)
-{
-	struct idxd_enum_ctx *enum_ctx = ctx;
-	struct spdk_idxd_device *idxd;
-
-	if (enum_ctx->probe_cb(enum_ctx->cb_ctx, pci_dev)) {
-		idxd = idxd_attach(pci_dev);
-		if (idxd == NULL) {
-			SPDK_ERRLOG("idxd_attach() failed\n");
-			return -EINVAL;
-		}
-
-		enum_ctx->attach_cb(enum_ctx->cb_ctx, pci_dev, idxd);
-	}
-
-	return 0;
+	idxd->impl->destruct(idxd);
 }
 
 int
 spdk_idxd_probe(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb)
 {
-	int rc;
-	struct idxd_enum_ctx enum_ctx;
-
-	enum_ctx.probe_cb = probe_cb;
-	enum_ctx.attach_cb = attach_cb;
-	enum_ctx.cb_ctx = cb_ctx;
-
-	pthread_mutex_lock(&g_driver_lock);
-	rc = spdk_pci_enumerate(spdk_pci_idxd_get_driver(), idxd_enum_cb, &enum_ctx);
-	pthread_mutex_unlock(&g_driver_lock);
+	if (g_idxd_impl == NULL) {
+		SPDK_ERRLOG("No idxd impl is selected\n");
+		return -1;
+	}
 
-	return rc;
+	return g_idxd_impl->probe(cb_ctx, probe_cb, attach_cb);
 }
 
 void
@@ -1180,11 +806,10 @@ _idxd_batch_prep_nop(struct spdk_idxd_io_channel *chan, struct idxd_batch *batch
 
 	/* Command specific. */
 	desc->opcode = IDXD_OPCODE_NOOP;
-	/* TODO: temp workaround for simulator.  Remove when fixed or w/silicon. */
-	if (chan->idxd->registers.gencap.raw == 0x1833f011f) {
+
+	if (chan->idxd->impl->nop_check && chan->idxd->impl->nop_check(chan->idxd)) {
 		desc->xfer_size = 1;
 	}
-
 	return 0;
 }
 
@@ -1369,7 +994,7 @@ _dump_error_reg(struct spdk_idxd_io_channel *chan)
 	uint64_t sw_error_0;
 	uint16_t i;
 
-	sw_error_0 = _idxd_read_8(chan->idxd, IDXD_SWERR_OFFSET);
+	sw_error_0 = idxd_read_8(chan->idxd, chan->portal, IDXD_SWERR_OFFSET);
 
 	SPDK_NOTICELOG("SW Error bits set:");
 	for (i = 0; i < CHAR_BIT; i++) {
@@ -1409,7 +1034,7 @@ spdk_idxd_process_events(struct spdk_idxd_io_channel *chan)
 			rc++;
 
 			if (spdk_unlikely(IDXD_FAILURE(comp_ctx->hw.status))) {
-				sw_error_0 = _idxd_read_8(chan->idxd, IDXD_SWERR_OFFSET);
+				sw_error_0 = idxd_read_8(chan->idxd, chan->portal, IDXD_SWERR_OFFSET);
 				if (IDXD_SW_ERROR(sw_error_0)) {
 					_dump_error_reg(chan);
 					status = -EINVAL;
@@ -1453,4 +1078,10 @@ spdk_idxd_process_events(struct spdk_idxd_io_channel *chan)
 	return rc;
 }
 
+void
+idxd_impl_register(struct spdk_idxd_impl *impl)
+{
+	STAILQ_INSERT_HEAD(&g_idxd_impls, impl, link);
+}
+
 SPDK_LOG_REGISTER_COMPONENT(idxd)
diff --git a/lib/idxd/idxd.h b/lib/idxd/idxd.h
index 10cb5b998..1fb45a953 100644
--- a/lib/idxd/idxd.h
+++ b/lib/idxd/idxd.h
@@ -178,26 +178,40 @@ struct idxd_wq {
 	union idxd_wqcfg		wqcfg;
 };
 
+struct spdk_idxd_impl {
+	const char *name;
+	void (*set_config)(struct device_config *g_dev_cfg, uint32_t config_num);
+	int (*probe)(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb);
+	void (*destruct)(struct spdk_idxd_device *idxd);
+	uint64_t (*read_8)(struct spdk_idxd_device *idxd, void *portal, uint32_t offset);
+	char *(*portal_get_addr)(struct spdk_idxd_device *idxd);
+	/* It is a workround for simulator */
+	bool (*nop_check)(struct spdk_idxd_device *idxd);
+
+	STAILQ_ENTRY(spdk_idxd_impl) link;
+};
+
 struct spdk_idxd_device {
 	struct spdk_pci_device		*device;
-	void				*reg_base;
+	struct spdk_idxd_impl		*impl;
 	void				*portals;
-	int				socket_id;
 	int				wq_id;
 	uint32_t			num_channels;
 	bool				needs_rebalance;
 	pthread_mutex_t			num_channels_lock;
 
-	struct idxd_registers		registers;
-	uint32_t			ims_offset;
-	uint32_t			msix_perm_offset;
-	uint32_t			wqcfg_offset;
-	uint32_t			grpcfg_offset;
-	uint32_t			perfmon_offset;
 	struct idxd_group		*groups;
 	struct idxd_wq			*queues;
 };
 
+void idxd_impl_register(struct spdk_idxd_impl *impl);
+
+#define SPDK_IDXD_IMPL_REGISTER(name, impl) \
+static void __attribute__((constructor)) idxd_impl_register_##name(void) \
+{ \
+	idxd_impl_register(impl); \
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/idxd/idxd_user.c b/lib/idxd/idxd_user.c
new file mode 100644
index 000000000..16dbb6285
--- /dev/null
+++ b/lib/idxd/idxd_user.c
@@ -0,0 +1,541 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "spdk/stdinc.h"
+
+#include "spdk/env.h"
+#include "spdk/util.h"
+#include "spdk/memory.h"
+#include "spdk/likely.h"
+
+#include "spdk/log.h"
+#include "spdk_internal/idxd.h"
+
+#include "idxd.h"
+
+struct spdk_user_idxd_device {
+	struct spdk_idxd_device	idxd;
+	int			sock_id;
+	struct idxd_registers	registers;
+	void			*reg_base;
+	uint32_t		wqcfg_offset;
+	uint32_t		grpcfg_offset;
+	uint32_t                        ims_offset;
+	uint32_t                        msix_perm_offset;
+	uint32_t                        perfmon_offset;
+};
+
+#define __user_idxd(idxd) (struct spdk_user_idxd_device *)idxd
+
+pthread_mutex_t	g_driver_lock = PTHREAD_MUTEX_INITIALIZER;
+static struct device_config g_user_dev_cfg = {};
+
+static struct spdk_idxd_device *idxd_attach(struct spdk_pci_device *device);
+
+static uint32_t
+_idxd_read_4(struct spdk_idxd_device *idxd, uint32_t offset)
+{
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	return spdk_mmio_read_4((uint32_t *)(user_idxd->reg_base + offset));
+}
+
+static void
+_idxd_write_4(struct spdk_idxd_device *idxd, uint32_t offset, uint32_t value)
+{
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	spdk_mmio_write_4((uint32_t *)(user_idxd->reg_base + offset), value);
+}
+
+static uint64_t
+_idxd_read_8(struct spdk_idxd_device *idxd, uint32_t offset)
+{
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	return spdk_mmio_read_8((uint64_t *)(user_idxd->reg_base + offset));
+}
+
+static uint64_t
+idxd_read_8(struct spdk_idxd_device *idxd, void *portal, uint32_t offset)
+{
+	return _idxd_read_8(idxd, offset);
+}
+
+static void
+_idxd_write_8(struct spdk_idxd_device *idxd, uint32_t offset, uint64_t value)
+{
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	spdk_mmio_write_8((uint64_t *)(user_idxd->reg_base + offset), value);
+}
+
+static void
+user_idxd_set_config(struct device_config *dev_cfg, uint32_t config_num)
+{
+	g_user_dev_cfg = *dev_cfg;
+}
+
+/* Used for control commands, not for descriptor submission. */
+static int
+idxd_wait_cmd(struct spdk_idxd_device *idxd, int _timeout)
+{
+	uint32_t timeout = _timeout;
+	union idxd_cmdsts_reg cmd_status = {};
+
+	cmd_status.raw = _idxd_read_4(idxd, IDXD_CMDSTS_OFFSET);
+	while (cmd_status.active && --timeout) {
+		usleep(1);
+		cmd_status.raw = _idxd_read_4(idxd, IDXD_CMDSTS_OFFSET);
+	}
+
+	/* Check for timeout */
+	if (timeout == 0 && cmd_status.active) {
+		SPDK_ERRLOG("Command timeout, waited %u\n", _timeout);
+		return -EBUSY;
+	}
+
+	/* Check for error */
+	if (cmd_status.err) {
+		SPDK_ERRLOG("Command status reg reports error 0x%x\n", cmd_status.err);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+idxd_unmap_pci_bar(struct spdk_idxd_device *idxd, int bar)
+{
+	int rc = 0;
+	void *addr = NULL;
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	if (bar == IDXD_MMIO_BAR) {
+		addr = (void *)user_idxd->reg_base;
+	} else if (bar == IDXD_WQ_BAR) {
+		addr = (void *)idxd->portals;
+	}
+
+	if (addr) {
+		rc = spdk_pci_device_unmap_bar(idxd->device, 0, addr);
+	}
+	return rc;
+}
+
+static int
+idxd_map_pci_bars(struct spdk_idxd_device *idxd)
+{
+	int rc;
+	void *addr;
+	uint64_t phys_addr, size;
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	rc = spdk_pci_device_map_bar(idxd->device, IDXD_MMIO_BAR, &addr, &phys_addr, &size);
+	if (rc != 0 || addr == NULL) {
+		SPDK_ERRLOG("pci_device_map_range failed with error code %d\n", rc);
+		return -1;
+	}
+	user_idxd->reg_base = addr;
+
+	rc = spdk_pci_device_map_bar(idxd->device, IDXD_WQ_BAR, &addr, &phys_addr, &size);
+	if (rc != 0 || addr == NULL) {
+		SPDK_ERRLOG("pci_device_map_range failed with error code %d\n", rc);
+		rc = idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
+		if (rc) {
+			SPDK_ERRLOG("unable to unmap MMIO bar\n");
+		}
+		return -EINVAL;
+	}
+	idxd->portals = addr;
+
+	return 0;
+}
+
+static int
+idxd_reset_dev(struct spdk_idxd_device *idxd)
+{
+	int rc;
+
+	_idxd_write_4(idxd, IDXD_CMD_OFFSET, IDXD_RESET_DEVICE << IDXD_CMD_SHIFT);
+	rc = idxd_wait_cmd(idxd, IDXD_REGISTER_TIMEOUT_US);
+	if (rc < 0) {
+		SPDK_ERRLOG("Error resetting device %u\n", rc);
+	}
+
+	return rc;
+}
+
+/*
+ * Build group config based on getting info from the device combined
+ * with the defined configuration. Once built, it is written to the
+ * device.
+ */
+static int
+idxd_group_config(struct spdk_idxd_device *idxd)
+{
+	int i;
+	uint64_t base_offset;
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	assert(g_user_dev_cfg.num_groups <= user_idxd->registers.groupcap.num_groups);
+	idxd->groups = calloc(user_idxd->registers.groupcap.num_groups, sizeof(struct idxd_group));
+	if (idxd->groups == NULL) {
+		SPDK_ERRLOG("Failed to allocate group memory\n");
+		return -ENOMEM;
+	}
+
+	assert(g_user_dev_cfg.total_engines <= user_idxd->registers.enginecap.num_engines);
+	for (i = 0; i < g_user_dev_cfg.total_engines; i++) {
+		idxd->groups[i % g_user_dev_cfg.num_groups].grpcfg.engines |= (1 << i);
+	}
+
+	assert(g_user_dev_cfg.total_wqs <= user_idxd->registers.wqcap.num_wqs);
+	for (i = 0; i < g_user_dev_cfg.total_wqs; i++) {
+		idxd->groups[i % g_user_dev_cfg.num_groups].grpcfg.wqs[0] |= (1 << i);
+	}
+
+	for (i = 0; i < g_user_dev_cfg.num_groups; i++) {
+		idxd->groups[i].idxd = idxd;
+		idxd->groups[i].id = i;
+
+		/* Divide BW tokens evenly */
+		idxd->groups[i].grpcfg.flags.tokens_allowed =
+			user_idxd->registers.groupcap.total_tokens / g_user_dev_cfg.num_groups;
+	}
+
+	/*
+	 * Now write the group config to the device for all groups. We write
+	 * to the max number of groups in order to 0 out the ones we didn't
+	 * configure.
+	 */
+	for (i = 0 ; i < user_idxd->registers.groupcap.num_groups; i++) {
+
+		base_offset = user_idxd->grpcfg_offset + i * 64;
+
+		/* GRPWQCFG, work queues config */
+		_idxd_write_8(idxd, base_offset, idxd->groups[i].grpcfg.wqs[0]);
+
+		/* GRPENGCFG, engine config */
+		_idxd_write_8(idxd, base_offset + CFG_ENGINE_OFFSET, idxd->groups[i].grpcfg.engines);
+
+		/* GRPFLAGS, flags config */
+		_idxd_write_8(idxd, base_offset + CFG_FLAG_OFFSET, idxd->groups[i].grpcfg.flags.raw);
+	}
+
+	return 0;
+}
+
+/*
+ * Build work queue (WQ) config based on getting info from the device combined
+ * with the defined configuration. Once built, it is written to the device.
+ */
+static int
+idxd_wq_config(struct spdk_user_idxd_device *user_idxd)
+{
+	int i, j;
+	struct idxd_wq *queue;
+	struct spdk_idxd_device *idxd = &user_idxd->idxd;
+	u_int32_t wq_size = user_idxd->registers.wqcap.total_wq_size / g_user_dev_cfg.total_wqs;
+
+	SPDK_NOTICELOG("Total ring slots available space 0x%x, so per work queue is 0x%x\n",
+		       user_idxd->registers.wqcap.total_wq_size, wq_size);
+	assert(g_user_dev_cfg.total_wqs <= IDXD_MAX_QUEUES);
+	assert(g_user_dev_cfg.total_wqs <= user_idxd->registers.wqcap.num_wqs);
+	assert(LOG2_WQ_MAX_BATCH <= user_idxd->registers.gencap.max_batch_shift);
+	assert(LOG2_WQ_MAX_XFER <= user_idxd->registers.gencap.max_xfer_shift);
+
+	idxd->queues = calloc(1, user_idxd->registers.wqcap.num_wqs * sizeof(struct idxd_wq));
+	if (idxd->queues == NULL) {
+		SPDK_ERRLOG("Failed to allocate queue memory\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < g_user_dev_cfg.total_wqs; i++) {
+		queue = &user_idxd->idxd.queues[i];
+		queue->wqcfg.wq_size = wq_size;
+		queue->wqcfg.mode = WQ_MODE_DEDICATED;
+		queue->wqcfg.max_batch_shift = LOG2_WQ_MAX_BATCH;
+		queue->wqcfg.max_xfer_shift = LOG2_WQ_MAX_XFER;
+		queue->wqcfg.wq_state = WQ_ENABLED;
+		queue->wqcfg.priority = WQ_PRIORITY_1;
+
+		/* Not part of the config struct */
+		queue->idxd = &user_idxd->idxd;
+		queue->group = &idxd->groups[i % g_user_dev_cfg.num_groups];
+	}
+
+	/*
+	 * Now write the work queue config to the device for all wq space
+	 */
+	for (i = 0 ; i < user_idxd->registers.wqcap.num_wqs; i++) {
+		queue = &idxd->queues[i];
+		for (j = 0 ; j < WQCFG_NUM_DWORDS; j++) {
+			_idxd_write_4(idxd, user_idxd->wqcfg_offset + i * 32 + j * 4,
+				      queue->wqcfg.raw[j]);
+		}
+	}
+
+	return 0;
+}
+
+static int
+idxd_device_configure(struct spdk_user_idxd_device *user_idxd)
+{
+	int i, rc = 0;
+	union idxd_offsets_register offsets_reg;
+	union idxd_genstatus_register genstatus_reg;
+	struct spdk_idxd_device *idxd = &user_idxd->idxd;
+
+	/*
+	 * Map BAR0 and BAR2
+	 */
+	rc = idxd_map_pci_bars(idxd);
+	if (rc) {
+		return rc;
+	}
+
+	/*
+	 * Reset the device
+	 */
+	rc = idxd_reset_dev(idxd);
+	if (rc) {
+		goto err_reset;
+	}
+
+	/*
+	 * Read in config registers
+	 */
+	user_idxd->registers.version = _idxd_read_4(idxd, IDXD_VERSION_OFFSET);
+	user_idxd->registers.gencap.raw = _idxd_read_8(idxd, IDXD_GENCAP_OFFSET);
+	user_idxd->registers.wqcap.raw = _idxd_read_8(idxd, IDXD_WQCAP_OFFSET);
+	user_idxd->registers.groupcap.raw = _idxd_read_8(idxd, IDXD_GRPCAP_OFFSET);
+	user_idxd->registers.enginecap.raw = _idxd_read_8(idxd, IDXD_ENGCAP_OFFSET);
+	for (i = 0; i < IDXD_OPCAP_WORDS; i++) {
+		user_idxd->registers.opcap.raw[i] =
+			_idxd_read_8(idxd, i * sizeof(uint64_t) + IDXD_OPCAP_OFFSET);
+	}
+	offsets_reg.raw[0] = _idxd_read_8(idxd, IDXD_TABLE_OFFSET);
+	offsets_reg.raw[1] = _idxd_read_8(idxd, IDXD_TABLE_OFFSET + sizeof(uint64_t));
+	user_idxd->grpcfg_offset = offsets_reg.grpcfg * IDXD_TABLE_OFFSET_MULT;
+	user_idxd->wqcfg_offset = offsets_reg.wqcfg * IDXD_TABLE_OFFSET_MULT;
+	user_idxd->ims_offset = offsets_reg.ims * IDXD_TABLE_OFFSET_MULT;
+	user_idxd->msix_perm_offset = offsets_reg.msix_perm  * IDXD_TABLE_OFFSET_MULT;
+	user_idxd->perfmon_offset = offsets_reg.perfmon * IDXD_TABLE_OFFSET_MULT;
+
+	/*
+	 * Configure groups and work queues.
+	 */
+	rc = idxd_group_config(idxd);
+	if (rc) {
+		goto err_group_cfg;
+	}
+
+	rc = idxd_wq_config(user_idxd);
+	if (rc) {
+		goto err_wq_cfg;
+	}
+
+	/*
+	 * Enable the device
+	 */
+	genstatus_reg.raw = _idxd_read_4(idxd, IDXD_GENSTATUS_OFFSET);
+	assert(genstatus_reg.state == IDXD_DEVICE_STATE_DISABLED);
+
+	_idxd_write_4(idxd, IDXD_CMD_OFFSET, IDXD_ENABLE_DEV << IDXD_CMD_SHIFT);
+	rc = idxd_wait_cmd(idxd, IDXD_REGISTER_TIMEOUT_US);
+	genstatus_reg.raw = _idxd_read_4(idxd, IDXD_GENSTATUS_OFFSET);
+	if ((rc < 0) || (genstatus_reg.state != IDXD_DEVICE_STATE_ENABLED)) {
+		rc = -EINVAL;
+		SPDK_ERRLOG("Error enabling device %u\n", rc);
+		goto err_device_enable;
+	}
+
+	genstatus_reg.raw = spdk_mmio_read_4((uint32_t *)(user_idxd->reg_base + IDXD_GENSTATUS_OFFSET));
+	assert(genstatus_reg.state == IDXD_DEVICE_STATE_ENABLED);
+
+	/*
+	 * Enable the work queues that we've configured
+	 */
+	for (i = 0; i < g_user_dev_cfg.total_wqs; i++) {
+		_idxd_write_4(idxd, IDXD_CMD_OFFSET,
+			      (IDXD_ENABLE_WQ << IDXD_CMD_SHIFT) | i);
+		rc = idxd_wait_cmd(idxd, IDXD_REGISTER_TIMEOUT_US);
+		if (rc < 0) {
+			SPDK_ERRLOG("Error enabling work queues 0x%x\n", rc);
+			goto err_wq_enable;
+		}
+	}
+
+	if ((rc == 0) && (genstatus_reg.state == IDXD_DEVICE_STATE_ENABLED)) {
+		SPDK_NOTICELOG("Device enabled, version 0x%x gencap: 0x%lx\n",
+			       user_idxd->registers.version,
+			       user_idxd->registers.gencap.raw);
+
+	}
+
+	return rc;
+err_wq_enable:
+err_device_enable:
+	free(idxd->queues);
+err_wq_cfg:
+	free(idxd->groups);
+err_group_cfg:
+err_reset:
+	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
+	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
+
+	return rc;
+}
+
+static void
+user_idxd_device_destruct(struct spdk_idxd_device *idxd)
+{
+	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
+	idxd_unmap_pci_bar(idxd, IDXD_WQ_BAR);
+	free(idxd->groups);
+	free(idxd->queues);
+
+	free(idxd);
+}
+
+struct idxd_enum_ctx {
+	spdk_idxd_probe_cb probe_cb;
+	spdk_idxd_attach_cb attach_cb;
+	void *cb_ctx;
+};
+
+/* This function must only be called while holding g_driver_lock */
+static int
+idxd_enum_cb(void *ctx, struct spdk_pci_device *pci_dev)
+{
+	struct idxd_enum_ctx *enum_ctx = ctx;
+	struct spdk_idxd_device *idxd;
+
+	if (enum_ctx->probe_cb(enum_ctx->cb_ctx, pci_dev)) {
+		idxd = idxd_attach(pci_dev);
+		if (idxd == NULL) {
+			SPDK_ERRLOG("idxd_attach() failed\n");
+			return -EINVAL;
+		}
+
+		enum_ctx->attach_cb(enum_ctx->cb_ctx, pci_dev, idxd);
+	}
+
+	return 0;
+}
+
+static int
+user_idxd_probe(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb)
+{
+	int rc;
+	struct idxd_enum_ctx enum_ctx;
+
+	enum_ctx.probe_cb = probe_cb;
+	enum_ctx.attach_cb = attach_cb;
+	enum_ctx.cb_ctx = cb_ctx;
+
+	pthread_mutex_lock(&g_driver_lock);
+	rc = spdk_pci_enumerate(spdk_pci_idxd_get_driver(), idxd_enum_cb, &enum_ctx);
+	pthread_mutex_unlock(&g_driver_lock);
+
+	return rc;
+}
+
+static char *
+user_idxd_portal_get_addr(struct spdk_idxd_device *idxd)
+{
+	return (char *)idxd->portals + idxd->wq_id * PORTAL_SIZE;
+}
+
+static bool
+user_idxd_nop_check(struct spdk_idxd_device *idxd)
+{
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
+	/* TODO: temp workaround for simulator.  Remove this function when fixed or w/silicon. */
+	if (user_idxd->registers.gencap.raw == 0x1833f011f) {
+		return true;
+	}
+
+	return false;
+}
+
+static struct spdk_idxd_impl g_user_idxd_impl = {
+	.name			= "user",
+	.set_config		= user_idxd_set_config,
+	.probe			= user_idxd_probe,
+	.destruct		= user_idxd_device_destruct,
+	.read_8			= idxd_read_8,
+	.portal_get_addr	= user_idxd_portal_get_addr,
+	.nop_check		= user_idxd_nop_check,
+};
+
+/* Caller must hold g_driver_lock */
+static struct spdk_idxd_device *
+idxd_attach(struct spdk_pci_device *device)
+{
+	struct spdk_user_idxd_device *user_idxd;
+	struct spdk_idxd_device *idxd;
+	uint32_t cmd_reg;
+	int rc;
+
+	user_idxd = calloc(1, sizeof(struct spdk_user_idxd_device));
+	if (user_idxd == NULL) {
+		SPDK_ERRLOG("Failed to allocate memory for user_idxd device.\n");
+		return NULL;
+	}
+
+	idxd = &user_idxd->idxd;
+	idxd->impl = &g_user_idxd_impl;
+	idxd->device = device;
+	pthread_mutex_init(&idxd->num_channels_lock, NULL);
+
+	/* Enable PCI busmaster. */
+	spdk_pci_device_cfg_read32(device, &cmd_reg, 4);
+	cmd_reg |= 0x4;
+	spdk_pci_device_cfg_write32(device, cmd_reg, 4);
+
+	rc = idxd_device_configure(user_idxd);
+	if (rc) {
+		goto err;
+	}
+
+	return idxd;
+err:
+	user_idxd_device_destruct(idxd);
+	return NULL;
+}
+
+SPDK_IDXD_IMPL_REGISTER(user, &g_user_idxd_impl);
diff --git a/test/unit/lib/idxd/Makefile b/test/unit/lib/idxd/Makefile
index e37cb22d9..67640e5d1 100644
--- a/test/unit/lib/idxd/Makefile
+++ b/test/unit/lib/idxd/Makefile
@@ -34,7 +34,7 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-DIRS-y = idxd.c
+DIRS-y = idxd.c idxd_user.c
 
 .PHONY: all clean $(DIRS-y)
 
diff --git a/test/unit/lib/idxd/idxd.c/idxd_ut.c b/test/unit/lib/idxd/idxd.c/idxd_ut.c
index d2dede924..0fc8d8be1 100644
--- a/test/unit/lib/idxd/idxd.c/idxd_ut.c
+++ b/test/unit/lib/idxd/idxd.c/idxd_ut.c
@@ -37,210 +37,17 @@
 #include "common/lib/test_env.c"
 
 #include "idxd/idxd.h"
-
-#define FAKE_REG_SIZE 0x800
-#define GRP_CFG_OFFSET 0x400
-#define MAX_TOKENS 0x40
-#define MAX_ARRAY_SIZE 0x20
-
-DEFINE_STUB(spdk_pci_idxd_get_driver, struct spdk_pci_driver *, (void), NULL);
-
-int
-spdk_pci_enumerate(struct spdk_pci_driver *driver, spdk_pci_enum_cb enum_cb, void *enum_ctx)
-{
-	return -1;
-}
-
-int
-spdk_pci_device_map_bar(struct spdk_pci_device *dev, uint32_t bar,
-			void **mapped_addr, uint64_t *phys_addr, uint64_t *size)
-{
-	*mapped_addr = NULL;
-	*phys_addr = 0;
-	*size = 0;
-	return 0;
-}
-
-int
-spdk_pci_device_unmap_bar(struct spdk_pci_device *dev, uint32_t bar, void *addr)
-{
-	return 0;
-}
-
-int
-spdk_pci_device_cfg_read32(struct spdk_pci_device *dev, uint32_t *value,
-			   uint32_t offset)
-{
-	*value = 0xFFFFFFFFu;
-	return 0;
-}
-
-int
-spdk_pci_device_cfg_write32(struct spdk_pci_device *dev, uint32_t value,
-			    uint32_t offset)
-{
-	return 0;
-}
-
-#define movdir64b mock_movdir64b
-static inline void
-mock_movdir64b(void *dst, const void *src)
-{
-	return;
-}
-
 #include "idxd/idxd.c"
 
-#define WQ_CFG_OFFSET 0x500
-#define TOTAL_WQE_SIZE 0x40
-static int
-test_idxd_wq_config(void)
-{
-	struct spdk_idxd_device idxd = {};
-	union idxd_wqcfg wqcfg = {};
-	uint32_t expected[8] = {0x40, 0, 0x11, 0x9e, 0, 0, 0x40000000, 0};
-	uint32_t wq_size;
-	int rc, i, j;
-
-	idxd.reg_base = calloc(1, FAKE_REG_SIZE);
-	SPDK_CU_ASSERT_FATAL(idxd.reg_base != NULL);
-
-	SPDK_CU_ASSERT_FATAL(g_dev_cfg->num_groups <= MAX_ARRAY_SIZE);
-	idxd.groups = calloc(g_dev_cfg->num_groups, sizeof(struct idxd_group));
-	SPDK_CU_ASSERT_FATAL(idxd.groups != NULL);
-
-	idxd.registers.wqcap.total_wq_size = TOTAL_WQE_SIZE;
-	idxd.registers.wqcap.num_wqs = g_dev_cfg->total_wqs;
-	idxd.registers.gencap.max_batch_shift = LOG2_WQ_MAX_BATCH;
-	idxd.registers.gencap.max_xfer_shift = LOG2_WQ_MAX_XFER;
-	idxd.wqcfg_offset = WQ_CFG_OFFSET;
-	wq_size = idxd.registers.wqcap.total_wq_size / g_dev_cfg->total_wqs;
-
-	rc = idxd_wq_config(&idxd);
-	CU_ASSERT(rc == 0);
-	for (i = 0; i < g_dev_cfg->total_wqs; i++) {
-		CU_ASSERT(idxd.queues[i].wqcfg.wq_size == wq_size);
-		CU_ASSERT(idxd.queues[i].wqcfg.mode == WQ_MODE_DEDICATED);
-		CU_ASSERT(idxd.queues[i].wqcfg.max_batch_shift == LOG2_WQ_MAX_BATCH);
-		CU_ASSERT(idxd.queues[i].wqcfg.max_xfer_shift == LOG2_WQ_MAX_XFER);
-		CU_ASSERT(idxd.queues[i].wqcfg.wq_state == WQ_ENABLED);
-		CU_ASSERT(idxd.queues[i].wqcfg.priority == WQ_PRIORITY_1);
-		CU_ASSERT(idxd.queues[i].idxd == &idxd);
-		CU_ASSERT(idxd.queues[i].group == &idxd.groups[i % g_dev_cfg->num_groups]);
-	}
-
-	for (i = 0 ; i < idxd.registers.wqcap.num_wqs; i++) {
-		for (j = 0 ; j < WQCFG_NUM_DWORDS; j++) {
-			wqcfg.raw[j] = spdk_mmio_read_4((uint32_t *)(idxd.reg_base + idxd.wqcfg_offset + i * 32 + j *
-							4));
-			CU_ASSERT(wqcfg.raw[j] == expected[j]);
-		}
-	}
-
-	free(idxd.queues);
-	free(idxd.reg_base);
-	free(idxd.groups);
-
-	return 0;
-}
-
-static int
-test_idxd_group_config(void)
+static void
+user_idxd_set_config(struct device_config *dev_cfg, uint32_t config_num)
 {
-	struct spdk_idxd_device idxd = {};
-	uint64_t wqs[MAX_ARRAY_SIZE] = {};
-	uint64_t engines[MAX_ARRAY_SIZE] = {};
-	union idxd_group_flags flags[MAX_ARRAY_SIZE] = {};
-	int rc, i;
-	uint64_t base_offset;
-
-	idxd.reg_base = calloc(1, FAKE_REG_SIZE);
-	SPDK_CU_ASSERT_FATAL(idxd.reg_base != NULL);
-
-	SPDK_CU_ASSERT_FATAL(g_dev_cfg->num_groups <= MAX_ARRAY_SIZE);
-	idxd.registers.groupcap.num_groups = g_dev_cfg->num_groups;
-	idxd.registers.enginecap.num_engines = g_dev_cfg->total_engines;
-	idxd.registers.wqcap.num_wqs = g_dev_cfg->total_wqs;
-	idxd.registers.groupcap.total_tokens = MAX_TOKENS;
-	idxd.grpcfg_offset = GRP_CFG_OFFSET;
-
-	rc = idxd_group_config(&idxd);
-	CU_ASSERT(rc == 0);
-	for (i = 0 ; i < idxd.registers.groupcap.num_groups; i++) {
-		base_offset = idxd.grpcfg_offset + i * 64;
-
-		wqs[i] = spdk_mmio_read_8((uint64_t *)(idxd.reg_base + base_offset));
-		engines[i] = spdk_mmio_read_8((uint64_t *)(idxd.reg_base + base_offset + CFG_ENGINE_OFFSET));
-		flags[i].raw = spdk_mmio_read_8((uint64_t *)(idxd.reg_base + base_offset + CFG_FLAG_OFFSET));
-	}
-	/* wqe and engine arrays are indexed by group id and are bitmaps of assigned elements. */
-	CU_ASSERT(wqs[0] == 0x1);
-	CU_ASSERT(engines[0] == 0xf);
-	CU_ASSERT(flags[0].tokens_allowed == MAX_TOKENS / g_dev_cfg->num_groups);
-
-	/* groups allocated by code under test. */
-	free(idxd.groups);
-	free(idxd.reg_base);
-
-	return 0;
-}
-
-static int
-test_idxd_reset_dev(void)
-{
-	struct spdk_idxd_device idxd = {};
-	union idxd_cmdsts_reg *fake_cmd_status_reg;
-	int rc;
-
-	idxd.reg_base = calloc(1, FAKE_REG_SIZE);
-	SPDK_CU_ASSERT_FATAL(idxd.reg_base != NULL);
-	fake_cmd_status_reg = idxd.reg_base + IDXD_CMDSTS_OFFSET;
-
-	/* Test happy path */
-	rc = idxd_reset_dev(&idxd);
-	CU_ASSERT(rc == 0);
-
-	/* Test error reported path */
-	fake_cmd_status_reg->err = 1;
-	rc = idxd_reset_dev(&idxd);
-	CU_ASSERT(rc == -EINVAL);
-
-	free(idxd.reg_base);
-
-	return 0;
 }
 
-static int
-test_idxd_wait_cmd(void)
-{
-	struct spdk_idxd_device idxd = {};
-	int timeout = 1;
-	union idxd_cmdsts_reg *fake_cmd_status_reg;
-	int rc;
-
-	idxd.reg_base = calloc(1, FAKE_REG_SIZE);
-	SPDK_CU_ASSERT_FATAL(idxd.reg_base != NULL);
-	fake_cmd_status_reg = idxd.reg_base + IDXD_CMDSTS_OFFSET;
-
-	/* Test happy path. */
-	rc = idxd_wait_cmd(&idxd, timeout);
-	CU_ASSERT(rc == 0);
-
-	/* Setup up our fake register to set the error bit. */
-	fake_cmd_status_reg->err = 1;
-	rc = idxd_wait_cmd(&idxd, timeout);
-	CU_ASSERT(rc == -EINVAL);
-	fake_cmd_status_reg->err = 0;
-
-	/* Setup up our fake register to set the active bit. */
-	fake_cmd_status_reg->active = 1;
-	rc = idxd_wait_cmd(&idxd, timeout);
-	CU_ASSERT(rc == -EBUSY);
-
-	free(idxd.reg_base);
-
-	return 0;
-}
+static struct spdk_idxd_impl g_user_idxd_impl = {
+	.name                   = "user",
+	.set_config	= user_idxd_set_config,
+};
 
 static int
 test_spdk_idxd_set_config(void)
@@ -283,6 +90,8 @@ test_spdk_idxd_reconfigure_chan(void)
 static int
 test_setup(void)
 {
+	idxd_impl_register(&g_user_idxd_impl);
+
 	g_dev_cfg = &g_dev_cfg0;
 	return 0;
 }
@@ -299,10 +108,6 @@ int main(int argc, char **argv)
 
 	CU_ADD_TEST(suite, test_spdk_idxd_reconfigure_chan);
 	CU_ADD_TEST(suite, test_spdk_idxd_set_config);
-	CU_ADD_TEST(suite, test_idxd_wait_cmd);
-	CU_ADD_TEST(suite, test_idxd_reset_dev);
-	CU_ADD_TEST(suite, test_idxd_group_config);
-	CU_ADD_TEST(suite, test_idxd_wq_config);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
diff --git a/test/unit/lib/idxd/idxd_user.c/.gitignore b/test/unit/lib/idxd/idxd_user.c/.gitignore
new file mode 100644
index 000000000..b118c291c
--- /dev/null
+++ b/test/unit/lib/idxd/idxd_user.c/.gitignore
@@ -0,0 +1 @@
+idxd_user_ut
diff --git a/test/unit/lib/idxd/idxd_user.c/Makefile b/test/unit/lib/idxd/idxd_user.c/Makefile
new file mode 100644
index 000000000..2bbfb920c
--- /dev/null
+++ b/test/unit/lib/idxd/idxd_user.c/Makefile
@@ -0,0 +1,38 @@
+#
+#  BSD LICENSE
+#
+#  Copyright (c) Intel Corporation.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Intel Corporation nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../../../..)
+
+TEST_FILE = idxd_user_ut.c
+
+include $(SPDK_ROOT_DIR)/mk/spdk.unittest.mk
diff --git a/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c b/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c
new file mode 100644
index 000000000..c7db07d36
--- /dev/null
+++ b/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c
@@ -0,0 +1,272 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "spdk_cunit.h"
+#include "spdk_internal/mock.h"
+#include "spdk_internal/idxd.h"
+#include "common/lib/test_env.c"
+
+#include "idxd/idxd.h"
+#include "idxd/idxd_user.c"
+
+#define FAKE_REG_SIZE 0x800
+#define GRP_CFG_OFFSET 0x400
+#define MAX_TOKENS 0x40
+#define MAX_ARRAY_SIZE 0x20
+
+DEFINE_STUB(spdk_pci_idxd_get_driver, struct spdk_pci_driver *, (void), NULL);
+DEFINE_STUB_V(idxd_impl_register, (struct spdk_idxd_impl *impl));
+
+int
+spdk_pci_enumerate(struct spdk_pci_driver *driver, spdk_pci_enum_cb enum_cb, void *enum_ctx)
+{
+	return -1;
+}
+
+int
+spdk_pci_device_map_bar(struct spdk_pci_device *dev, uint32_t bar,
+			void **mapped_addr, uint64_t *phys_addr, uint64_t *size)
+{
+	*mapped_addr = NULL;
+	*phys_addr = 0;
+	*size = 0;
+	return 0;
+}
+
+int
+spdk_pci_device_unmap_bar(struct spdk_pci_device *dev, uint32_t bar, void *addr)
+{
+	return 0;
+}
+
+int
+spdk_pci_device_cfg_read32(struct spdk_pci_device *dev, uint32_t *value,
+			   uint32_t offset)
+{
+	*value = 0xFFFFFFFFu;
+	return 0;
+}
+
+int
+spdk_pci_device_cfg_write32(struct spdk_pci_device *dev, uint32_t value,
+			    uint32_t offset)
+{
+	return 0;
+}
+
+#define WQ_CFG_OFFSET 0x500
+#define TOTAL_WQE_SIZE 0x40
+static int
+test_idxd_wq_config(void)
+{
+	struct spdk_user_idxd_device user_idxd = {};
+	struct spdk_idxd_device *idxd = &user_idxd.idxd;
+	union idxd_wqcfg wqcfg = {};
+	uint32_t expected[8] = {0x40, 0, 0x11, 0x9e, 0, 0, 0x40000000, 0};
+	uint32_t wq_size;
+	int rc, i, j;
+
+	user_idxd.reg_base = calloc(1, FAKE_REG_SIZE);
+	SPDK_CU_ASSERT_FATAL(user_idxd.reg_base != NULL);
+
+	SPDK_CU_ASSERT_FATAL(g_user_dev_cfg.num_groups <= MAX_ARRAY_SIZE);
+	idxd->groups = calloc(g_user_dev_cfg.num_groups, sizeof(struct idxd_group));
+	SPDK_CU_ASSERT_FATAL(idxd->groups != NULL);
+
+	user_idxd.registers.wqcap.total_wq_size = TOTAL_WQE_SIZE;
+	user_idxd.registers.wqcap.num_wqs = g_user_dev_cfg.total_wqs;
+	user_idxd.registers.gencap.max_batch_shift = LOG2_WQ_MAX_BATCH;
+	user_idxd.registers.gencap.max_xfer_shift = LOG2_WQ_MAX_XFER;
+	user_idxd.wqcfg_offset = WQ_CFG_OFFSET;
+	wq_size = user_idxd.registers.wqcap.total_wq_size / g_user_dev_cfg.total_wqs;
+
+	rc = idxd_wq_config(&user_idxd);
+	CU_ASSERT(rc == 0);
+	for (i = 0; i < g_user_dev_cfg.total_wqs; i++) {
+		CU_ASSERT(idxd->queues[i].wqcfg.wq_size == wq_size);
+		CU_ASSERT(idxd->queues[i].wqcfg.mode == WQ_MODE_DEDICATED);
+		CU_ASSERT(idxd->queues[i].wqcfg.max_batch_shift == LOG2_WQ_MAX_BATCH);
+		CU_ASSERT(idxd->queues[i].wqcfg.max_xfer_shift == LOG2_WQ_MAX_XFER);
+		CU_ASSERT(idxd->queues[i].wqcfg.wq_state == WQ_ENABLED);
+		CU_ASSERT(idxd->queues[i].wqcfg.priority == WQ_PRIORITY_1);
+		CU_ASSERT(idxd->queues[i].idxd == idxd);
+		CU_ASSERT(idxd->queues[i].group == &idxd->groups[i % g_user_dev_cfg.num_groups]);
+	}
+
+	for (i = 0 ; i < user_idxd.registers.wqcap.num_wqs; i++) {
+		for (j = 0 ; j < WQCFG_NUM_DWORDS; j++) {
+			wqcfg.raw[j] = spdk_mmio_read_4((uint32_t *)(user_idxd.reg_base + user_idxd.wqcfg_offset + i * 32 +
+							j *
+							4));
+			CU_ASSERT(wqcfg.raw[j] == expected[j]);
+		}
+	}
+
+	free(idxd->queues);
+	free(user_idxd.reg_base);
+	free(idxd->groups);
+
+	return 0;
+}
+
+static int
+test_idxd_group_config(void)
+{
+	struct spdk_user_idxd_device user_idxd = {};
+	struct spdk_idxd_device *idxd = &user_idxd.idxd;
+	uint64_t wqs[MAX_ARRAY_SIZE] = {};
+	uint64_t engines[MAX_ARRAY_SIZE] = {};
+	union idxd_group_flags flags[MAX_ARRAY_SIZE] = {};
+	int rc, i;
+	uint64_t base_offset;
+
+	user_idxd.reg_base = calloc(1, FAKE_REG_SIZE);
+	SPDK_CU_ASSERT_FATAL(user_idxd.reg_base != NULL);
+
+	SPDK_CU_ASSERT_FATAL(g_user_dev_cfg.num_groups <= MAX_ARRAY_SIZE);
+	user_idxd.registers.groupcap.num_groups = g_user_dev_cfg.num_groups;
+	user_idxd.registers.enginecap.num_engines = g_user_dev_cfg.total_engines;
+	user_idxd.registers.wqcap.num_wqs = g_user_dev_cfg.total_wqs;
+	user_idxd.registers.groupcap.total_tokens = MAX_TOKENS;
+	user_idxd.grpcfg_offset = GRP_CFG_OFFSET;
+
+	rc = idxd_group_config(idxd);
+	CU_ASSERT(rc == 0);
+	for (i = 0 ; i < user_idxd.registers.groupcap.num_groups; i++) {
+		base_offset = user_idxd.grpcfg_offset + i * 64;
+
+		wqs[i] = spdk_mmio_read_8((uint64_t *)(user_idxd.reg_base + base_offset));
+		engines[i] = spdk_mmio_read_8((uint64_t *)(user_idxd.reg_base + base_offset + CFG_ENGINE_OFFSET));
+		flags[i].raw = spdk_mmio_read_8((uint64_t *)(user_idxd.reg_base + base_offset + CFG_FLAG_OFFSET));
+	}
+	/* wqe and engine arrays are indexed by group id and are bitmaps of assigned elements. */
+	CU_ASSERT(wqs[0] == 0x1);
+	CU_ASSERT(engines[0] == 0xf);
+	CU_ASSERT(flags[0].tokens_allowed == MAX_TOKENS / g_user_dev_cfg.num_groups);
+
+	/* groups allocated by code under test. */
+	free(idxd->groups);
+	free(user_idxd.reg_base);
+
+	return 0;
+}
+
+static int
+test_idxd_reset_dev(void)
+{
+	struct spdk_user_idxd_device user_idxd = {};
+	union idxd_cmdsts_reg *fake_cmd_status_reg;
+	int rc;
+
+	user_idxd.reg_base = calloc(1, FAKE_REG_SIZE);
+	SPDK_CU_ASSERT_FATAL(user_idxd.reg_base != NULL);
+	fake_cmd_status_reg = user_idxd.reg_base + IDXD_CMDSTS_OFFSET;
+
+	/* Test happy path */
+	rc = idxd_reset_dev(&user_idxd.idxd);
+	CU_ASSERT(rc == 0);
+
+	/* Test error reported path */
+	fake_cmd_status_reg->err = 1;
+	rc = idxd_reset_dev(&user_idxd.idxd);
+	CU_ASSERT(rc == -EINVAL);
+
+	free(user_idxd.reg_base);
+
+	return 0;
+}
+
+static int
+test_idxd_wait_cmd(void)
+{
+	struct spdk_user_idxd_device user_idxd = {};
+	int timeout = 1;
+	union idxd_cmdsts_reg *fake_cmd_status_reg;
+	int rc;
+
+	user_idxd.reg_base = calloc(1, FAKE_REG_SIZE);
+	SPDK_CU_ASSERT_FATAL(user_idxd.reg_base != NULL);
+	fake_cmd_status_reg = user_idxd.reg_base + IDXD_CMDSTS_OFFSET;
+
+	/* Test happy path. */
+	rc = idxd_wait_cmd(&user_idxd.idxd, timeout);
+	CU_ASSERT(rc == 0);
+
+	/* Setup up our fake register to set the error bit. */
+	fake_cmd_status_reg->err = 1;
+	rc = idxd_wait_cmd(&user_idxd.idxd, timeout);
+	CU_ASSERT(rc == -EINVAL);
+	fake_cmd_status_reg->err = 0;
+
+	/* Setup up our fake register to set the active bit. */
+	fake_cmd_status_reg->active = 1;
+	rc = idxd_wait_cmd(&user_idxd.idxd, timeout);
+	CU_ASSERT(rc == -EBUSY);
+
+	free(user_idxd.reg_base);
+
+	return 0;
+}
+
+static int
+test_setup(void)
+{
+	g_user_dev_cfg.config_num = 0;
+	g_user_dev_cfg.num_groups = 1;
+	g_user_dev_cfg.total_wqs = 1;
+	g_user_dev_cfg.total_engines = 4;
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	CU_pSuite	suite = NULL;
+	unsigned int	num_failures;
+
+	CU_set_error_action(CUEA_ABORT);
+	CU_initialize_registry();
+
+	suite = CU_add_suite("idxd_user", test_setup, NULL);
+
+	CU_ADD_TEST(suite, test_idxd_wait_cmd);
+	CU_ADD_TEST(suite, test_idxd_reset_dev);
+	CU_ADD_TEST(suite, test_idxd_group_config);
+	CU_ADD_TEST(suite, test_idxd_wq_config);
+
+	CU_basic_set_mode(CU_BRM_VERBOSE);
+	CU_basic_run_tests();
+	num_failures = CU_get_number_of_failures();
+	CU_cleanup_registry();
+	return num_failures;
+}
diff --git a/test/unit/unittest.sh b/test/unit/unittest.sh
index 24d78b491..e9f688c0b 100755
--- a/test/unit/unittest.sh
+++ b/test/unit/unittest.sh
@@ -201,6 +201,7 @@ run_test "unittest_accel" $valgrind $testdir/lib/accel/accel.c/accel_engine_ut
 run_test "unittest_ioat" $valgrind $testdir/lib/ioat/ioat.c/ioat_ut
 if grep -q '#define SPDK_CONFIG_IDXD 1' $rootdir/include/spdk/config.h; then
 	run_test "unittest_idxd" $valgrind $testdir/lib/idxd/idxd.c/idxd_ut
+	run_test "unittest_idxd_user" $valgrind $testdir/lib/idxd/idxd_user.c/idxd_user_ut
 fi
 run_test "unittest_iscsi" unittest_iscsi
 run_test "unittest_json" unittest_json
-- 
2.26.2


From 518d28dba92fdef225b490508bccd6ef8ce09ab7 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Fri, 23 Apr 2021 22:53:38 +0800
Subject: [PATCH 037/342] scsi/bdev: free bdev_io when there are split requests

Only the last bdev_io can be freed without this fix.

Change-Id: I0d05b5d89e38ef60872ebc0f23aaed0c622593c4
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7571
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/scsi/scsi_bdev.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/scsi/scsi_bdev.c b/lib/scsi/scsi_bdev.c
index ba890af74..127391eca 100644
--- a/lib/scsi/scsi_bdev.c
+++ b/lib/scsi/scsi_bdev.c
@@ -1397,13 +1397,13 @@ bdev_scsi_task_complete_unmap_cmd(struct spdk_bdev_io *bdev_io, bool success,
 
 	ctx->count--;
 
-	task->bdev_io = bdev_io;
-
 	if (task->status == SPDK_SCSI_STATUS_GOOD) {
 		spdk_bdev_io_get_scsi_status(bdev_io, &sc, &sk, &asc, &ascq);
 		spdk_scsi_task_set_status(task, sc, sk, asc, ascq);
 	}
 
+	spdk_bdev_free_io(bdev_io);
+
 	if (ctx->count == 0) {
 		scsi_lun_complete_task(task->lun, task);
 		free(ctx);
-- 
2.26.2


From f6d5b9cd92a82c0efc973b9fd354eb1e6d5c9c21 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 20 Apr 2021 18:05:33 +0800
Subject: [PATCH 038/342] bdev: introduce unmap attributes to bdev layer

The backend device module can report such capabilities
to the bdev layer, and we can split unmap request into
multiple children requests in the bdev layer.

Change-Id: I81daf7e58b797a2673ef102f2a037de20771092e
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7515
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 include/spdk/bdev_module.h | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index f30083ee1..86876a4cc 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -343,6 +343,12 @@ struct spdk_bdev {
 	/* Maximum number of segments in a I/O */
 	uint32_t max_num_segments;
 
+	/* Maximum unmap in unit of logical block */
+	uint32_t max_unmap;
+
+	/* Maximum unmap block segments */
+	uint32_t max_unmap_segments;
+
 	/**
 	 * UUID for this bdev.
 	 *
-- 
2.26.2


From d4d5e20d296b3c81183f36d3a473698edf1d0d3d Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Wed, 21 Apr 2021 19:50:42 +0800
Subject: [PATCH 039/342] bdev: rename bdev_io_split to bdev_rw_split

This will help us to add unmap split function, also
remove bdev_io_type_can_split() because we changed
to use swith(io_type) ... case now.

Change-Id: I449d6a9f5bf2d0b43dd124bbfc9e1ca2afddc15a
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7516
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/bdev/bdev.c                     | 71 ++++++++++++++---------------
 test/unit/lib/bdev/bdev.c/bdev_ut.c |  1 +
 2 files changed, 34 insertions(+), 38 deletions(-)

diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 9ede230c0..5ca53e4e3 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -1953,26 +1953,7 @@ bdev_queue_io_wait_with_cb(struct spdk_bdev_io *bdev_io, spdk_bdev_io_wait_cb cb
 }
 
 static bool
-bdev_io_type_can_split(uint8_t type)
-{
-	assert(type != SPDK_BDEV_IO_TYPE_INVALID);
-	assert(type < SPDK_BDEV_NUM_IO_TYPES);
-
-	/* Only split READ and WRITE I/O.  Theoretically other types of I/O like
-	 * UNMAP could be split, but these types of I/O are typically much larger
-	 * in size (sometimes the size of the entire block device), and the bdev
-	 * module can more efficiently split these types of I/O.  Plus those types
-	 * of I/O do not have a payload, which makes the splitting process simpler.
-	 */
-	if (type == SPDK_BDEV_IO_TYPE_READ || type == SPDK_BDEV_IO_TYPE_WRITE) {
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool
-bdev_io_should_split(struct spdk_bdev_io *bdev_io)
+bdev_rw_should_split(struct spdk_bdev_io *bdev_io)
 {
 	uint32_t io_boundary = bdev_io->bdev->optimal_io_boundary;
 	uint32_t max_size = bdev_io->bdev->max_segment_size;
@@ -1984,10 +1965,6 @@ bdev_io_should_split(struct spdk_bdev_io *bdev_io)
 		return false;
 	}
 
-	if (!bdev_io_type_can_split(bdev_io->type)) {
-		return false;
-	}
-
 	if (io_boundary) {
 		uint64_t start_stripe, end_stripe;
 
@@ -2024,6 +2001,18 @@ bdev_io_should_split(struct spdk_bdev_io *bdev_io)
 	return false;
 }
 
+static bool
+bdev_io_should_split(struct spdk_bdev_io *bdev_io)
+{
+	switch (bdev_io->type) {
+	case SPDK_BDEV_IO_TYPE_READ:
+	case SPDK_BDEV_IO_TYPE_WRITE:
+		return bdev_rw_should_split(bdev_io);
+	default:
+		return false;
+	}
+}
+
 static uint32_t
 _to_next_boundary(uint64_t offset, uint32_t boundary)
 {
@@ -2034,7 +2023,7 @@ static void
 bdev_io_split_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg);
 
 static void
-_bdev_io_split(void *_bdev_io)
+_bdev_rw_split(void *_bdev_io)
 {
 	struct iovec *parent_iov, *iov;
 	struct spdk_bdev_io *bdev_io = _bdev_io;
@@ -2188,7 +2177,7 @@ _bdev_io_split(void *_bdev_io)
 			if (rc == -ENOMEM) {
 				if (bdev_io->u.bdev.split_outstanding == 0) {
 					/* No I/O is outstanding. Hence we should wait here. */
-					bdev_queue_io_wait_with_cb(bdev_io, _bdev_io_split);
+					bdev_queue_io_wait_with_cb(bdev_io, _bdev_rw_split);
 				}
 			} else {
 				bdev_io->internal.status = SPDK_BDEV_IO_STATUS_FAILED;
@@ -2240,40 +2229,46 @@ bdev_io_split_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)
 	 * Continue with the splitting process.  This function will complete the parent I/O if the
 	 * splitting is done.
 	 */
-	_bdev_io_split(parent_io);
+	_bdev_rw_split(parent_io);
 }
 
 static void
-bdev_io_split_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io, bool success);
+bdev_rw_split_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io, bool success);
 
 static void
 bdev_io_split(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
-	assert(bdev_io_type_can_split(bdev_io->type));
-
 	bdev_io->u.bdev.split_current_offset_blocks = bdev_io->u.bdev.offset_blocks;
 	bdev_io->u.bdev.split_remaining_num_blocks = bdev_io->u.bdev.num_blocks;
 	bdev_io->u.bdev.split_outstanding = 0;
 	bdev_io->internal.status = SPDK_BDEV_IO_STATUS_SUCCESS;
 
-	if (_is_buf_allocated(bdev_io->u.bdev.iovs)) {
-		_bdev_io_split(bdev_io);
-	} else {
-		assert(bdev_io->type == SPDK_BDEV_IO_TYPE_READ);
-		spdk_bdev_io_get_buf(bdev_io, bdev_io_split_get_buf_cb,
-				     bdev_io->u.bdev.num_blocks * bdev_io->bdev->blocklen);
+	switch (bdev_io->type) {
+	case SPDK_BDEV_IO_TYPE_READ:
+	case SPDK_BDEV_IO_TYPE_WRITE:
+		if (_is_buf_allocated(bdev_io->u.bdev.iovs)) {
+			_bdev_rw_split(bdev_io);
+		} else {
+			assert(bdev_io->type == SPDK_BDEV_IO_TYPE_READ);
+			spdk_bdev_io_get_buf(bdev_io, bdev_rw_split_get_buf_cb,
+					     bdev_io->u.bdev.num_blocks * bdev_io->bdev->blocklen);
+		}
+		break;
+	default:
+		assert(false);
+		break;
 	}
 }
 
 static void
-bdev_io_split_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io, bool success)
+bdev_rw_split_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io, bool success)
 {
 	if (!success) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
 	}
 
-	_bdev_io_split(bdev_io);
+	_bdev_rw_split(bdev_io);
 }
 
 /* Explicitly mark this inline, since it's used as a function pointer and otherwise won't
diff --git a/test/unit/lib/bdev/bdev.c/bdev_ut.c b/test/unit/lib/bdev/bdev.c/bdev_ut.c
index b5db551f0..da207559c 100644
--- a/test/unit/lib/bdev/bdev.c/bdev_ut.c
+++ b/test/unit/lib/bdev/bdev.c/bdev_ut.c
@@ -1021,6 +1021,7 @@ bdev_io_spans_split_test(void)
 	memset(&bdev, 0, sizeof(bdev));
 	bdev_io.u.bdev.iovs = iov;
 
+	bdev_io.type = SPDK_BDEV_IO_TYPE_READ;
 	bdev.optimal_io_boundary = 0;
 	bdev.max_segment_size = 0;
 	bdev.max_num_segments = 0;
-- 
2.26.2


From 4f1530c9eb62f0391f4134e685a764a919e84e18 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Wed, 21 Apr 2021 20:14:39 +0800
Subject: [PATCH 040/342] bdev: add bdev_unmap_should_split() function

Change-Id: I2680eef93da13d8378527349cdc5ba36859f89dc
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7517
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/bdev/bdev.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 5ca53e4e3..835660f92 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -2001,6 +2001,22 @@ bdev_rw_should_split(struct spdk_bdev_io *bdev_io)
 	return false;
 }
 
+static bool
+bdev_unmap_should_split(struct spdk_bdev_io *bdev_io)
+{
+	uint32_t num_unmap_segments;
+
+	if (!bdev_io->bdev->max_unmap || !bdev_io->bdev->max_unmap_segments) {
+		return false;
+	}
+	num_unmap_segments = spdk_divide_round_up(bdev_io->u.bdev.num_blocks, bdev_io->bdev->max_unmap);
+	if (num_unmap_segments > bdev_io->bdev->max_unmap_segments) {
+		return true;
+	}
+
+	return false;
+}
+
 static bool
 bdev_io_should_split(struct spdk_bdev_io *bdev_io)
 {
@@ -2008,6 +2024,8 @@ bdev_io_should_split(struct spdk_bdev_io *bdev_io)
 	case SPDK_BDEV_IO_TYPE_READ:
 	case SPDK_BDEV_IO_TYPE_WRITE:
 		return bdev_rw_should_split(bdev_io);
+	case SPDK_BDEV_IO_TYPE_UNMAP:
+		return bdev_unmap_should_split(bdev_io);
 	default:
 		return false;
 	}
-- 
2.26.2


From bbfbcc1967393f793f704307f69cd002a60d0076 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@nutanix.com>
Date: Wed, 21 Apr 2021 16:56:51 +0000
Subject: [PATCH 041/342] vfio-user: add disable-mappable-bar0 flag

It can be useful for testing or development purposes to force clients to write
to doorbells using vfio-user messages instead of directly into shared memory;
add a transport-specific option to disable the shared mapping.

Signed-off-by: John Levon <john.levon@nutanix.com>
Change-Id: I7ed062fbe211ba27c85d00b12d81a0f84a8322ed
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7554
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 lib/nvmf/vfio_user.c | 52 ++++++++++++++++++++++++++++++++++++--------
 1 file changed, 43 insertions(+), 9 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index 78c6baf1e..dde650924 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -193,8 +193,13 @@ struct nvmf_vfio_user_endpoint {
 	TAILQ_ENTRY(nvmf_vfio_user_endpoint)	link;
 };
 
+struct nvmf_vfio_user_transport_opts {
+	bool					disable_mappable_bar0;
+};
+
 struct nvmf_vfio_user_transport {
 	struct spdk_nvmf_transport		transport;
+	struct nvmf_vfio_user_transport_opts    transport_opts;
 	pthread_mutex_t				lock;
 	TAILQ_HEAD(, nvmf_vfio_user_endpoint)	endpoints;
 
@@ -324,6 +329,14 @@ nvmf_vfio_user_destroy(struct spdk_nvmf_transport *transport,
 	return 0;
 }
 
+static const struct spdk_json_object_decoder vfio_user_transport_opts_decoder[] = {
+	{
+		"disable-mappable-bar0",
+		offsetof(struct nvmf_vfio_user_transport, transport_opts.disable_mappable_bar0),
+		spdk_json_decode_bool, true
+	},
+};
+
 static struct spdk_nvmf_transport *
 nvmf_vfio_user_create(struct spdk_nvmf_transport_opts *opts)
 {
@@ -345,6 +358,18 @@ nvmf_vfio_user_create(struct spdk_nvmf_transport_opts *opts)
 	TAILQ_INIT(&vu_transport->endpoints);
 	TAILQ_INIT(&vu_transport->new_qps);
 
+	if (opts->transport_specific != NULL &&
+	    spdk_json_decode_object_relaxed(opts->transport_specific, vfio_user_transport_opts_decoder,
+					    SPDK_COUNTOF(vfio_user_transport_opts_decoder),
+					    vu_transport)) {
+		SPDK_ERRLOG("spdk_json_decode_object_relaxed failed\n");
+		free(vu_transport);
+		return NULL;
+	}
+
+	SPDK_DEBUGLOG(nvmf_vfio, "vfio_user transport: disable_mappable_bar0=%d\n",
+		      vu_transport->transport_opts.disable_mappable_bar0);
+
 	return &vu_transport->transport;
 
 err:
@@ -1330,10 +1355,10 @@ access_bar0_fn(vfu_ctx_t *vfu_ctx, char *buf, size_t count, loff_t pos,
 
 	if (pos >= NVMF_VFIO_USER_DOORBELLS_OFFSET) {
 		/*
-		 * XXX The fact that the doorbells can be memory mapped doesn't
-		 * mean thath the client (VFIO in QEMU) is obliged to memory
-		 * map them, it might still elect to access them via regular
-		 * read/write.
+		 * The fact that the doorbells can be memory mapped doesn't mean
+		 * that the client (VFIO in QEMU) is obliged to memory map them,
+		 * it might still elect to access them via regular read/write;
+		 * we might also have had disable_mappable_bar0 set.
 		 */
 		ret = handle_dbl_access(ctrlr, (uint32_t *)buf, count,
 					pos, is_write);
@@ -1442,7 +1467,8 @@ init_pci_config_space(vfu_pci_config_space_t *p)
 }
 
 static int
-vfio_user_dev_info_fill(struct nvmf_vfio_user_endpoint *endpoint)
+vfio_user_dev_info_fill(struct nvmf_vfio_user_transport *vu_transport,
+			struct nvmf_vfio_user_endpoint *endpoint)
 {
 	int ret;
 	ssize_t cap_offset;
@@ -1508,9 +1534,16 @@ vfio_user_dev_info_fill(struct nvmf_vfio_user_endpoint *endpoint)
 		return ret;
 	}
 
-	ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR0_REGION_IDX, NVME_REG_BAR0_SIZE,
-			       access_bar0_fn, VFU_REGION_FLAG_RW | VFU_REGION_FLAG_MEM,
-			       sparse_mmap, 1, endpoint->fd);
+	if (vu_transport->transport_opts.disable_mappable_bar0) {
+		ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR0_REGION_IDX, NVME_REG_BAR0_SIZE,
+				       access_bar0_fn, VFU_REGION_FLAG_RW | VFU_REGION_FLAG_MEM,
+				       NULL, 0, -1);
+	} else {
+		ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR0_REGION_IDX, NVME_REG_BAR0_SIZE,
+				       access_bar0_fn, VFU_REGION_FLAG_RW | VFU_REGION_FLAG_MEM,
+				       sparse_mmap, 1, endpoint->fd);
+	}
+
 	if (ret < 0) {
 		SPDK_ERRLOG("vfu_ctx %p failed to setup bar 0\n", vfu_ctx);
 		return ret;
@@ -1711,7 +1744,7 @@ nvmf_vfio_user_listen(struct spdk_nvmf_transport *transport,
 	vfu_setup_log(endpoint->vfu_ctx, vfio_user_log,
 		      SPDK_DEBUGLOG_FLAG_ENABLED("nvmf_vfio") ? LOG_DEBUG : LOG_ERR);
 
-	err = vfio_user_dev_info_fill(endpoint);
+	err = vfio_user_dev_info_fill(vu_transport, endpoint);
 	if (err < 0) {
 		goto out;
 	}
@@ -2452,6 +2485,7 @@ nvmf_vfio_user_opts_init(struct spdk_nvmf_transport_opts *opts)
 	opts->max_aq_depth =		NVMF_VFIO_USER_DEFAULT_AQ_DEPTH;
 	opts->num_shared_buffers =	NVMF_VFIO_USER_DEFAULT_NUM_SHARED_BUFFERS;
 	opts->buf_cache_size =		NVMF_VFIO_USER_DEFAULT_BUFFER_CACHE_SIZE;
+	opts->transport_specific =      NULL;
 }
 
 const struct spdk_nvmf_transport_ops spdk_nvmf_transport_vfio_user = {
-- 
2.26.2


From 3faf457f568666aa19f2cec43904822bea603298 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Mon, 3 May 2021 16:39:05 +0000
Subject: [PATCH 042/342] bdev/nvme: do not use DSM to emulate write zeroes

We cannot rely on DSM/DEALLOCATE as a write zeroes
alternative, even if DLFEAT reports that deallocated
blocks will be read as all zeroes.  DEALLOCATE is
advisory, meaning that blocks may not actually be
deallocated.  In cases where they are not deallocated,
they will not be read back later as zeroes.

QEMU 6.0 started reporting DLFEAT as returning zeroes
for deallocated blocks but for some of our write
zeroes tests, blocks aren't actually deallocated.

We may be able to add quirks in the future if we know
that a controller reliably deallocates blocks, but
for now we need to revert this completely.

Note that since bdev/nvme module now does not support
write zeroes in any cases, we need to disable the
write zeroes call in the unit tests.

Fixes issue #1932.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I79f0673774b621a9ffcc46891728cc7719e34cdb
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7723
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 module/bdev/nvme/bdev_nvme.c                  | 22 +++----------------
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  |  1 -
 2 files changed, 3 insertions(+), 20 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 5239f270d..e098535fd 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -803,13 +803,6 @@ _bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_
 						     bdev_io->u.bdev.offset_blocks,
 						     bdev->dif_check_flags);
 
-	case SPDK_BDEV_IO_TYPE_WRITE_ZEROES:
-		return bdev_nvme_unmap(nvme_ns->ns,
-				       qpair,
-				       nbdev_io,
-				       bdev_io->u.bdev.offset_blocks,
-				       bdev_io->u.bdev.num_blocks);
-
 	case SPDK_BDEV_IO_TYPE_UNMAP:
 		return bdev_nvme_unmap(nvme_ns->ns,
 				       qpair,
@@ -939,20 +932,11 @@ bdev_nvme_io_type_supported(void *ctx, enum spdk_bdev_io_type io_type)
 		return cdata->oncs.dsm;
 
 	case SPDK_BDEV_IO_TYPE_WRITE_ZEROES:
-		cdata = spdk_nvme_ctrlr_get_data(ctrlr);
-		/*
-		 * If an NVMe controller guarantees reading unallocated blocks returns zero,
-		 * we can implement WRITE_ZEROES as an NVMe deallocate command.
-		 */
-		if (cdata->oncs.dsm &&
-		    spdk_nvme_ns_get_dealloc_logical_block_read_value(ns) ==
-		    SPDK_NVME_DEALLOC_READ_00) {
-			return true;
-		}
 		/*
 		 * The NVMe controller write_zeroes function is currently not used by our driver.
-		 * If a user submits an arbitrarily large write_zeroes request to the controller, the request will fail.
-		 * Until this is resolved, we only claim support for write_zeroes if deallocated blocks return 0's when read.
+		 * NVMe write zeroes is limited to 16-bit block count, and the bdev layer currently
+		 * has no mechanism for reporting a max write zeroes block count, nor ability to
+		 * split a write zeroes request.
 		 */
 		return false;
 
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index 013b26d07..edf55299c 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -1875,7 +1875,6 @@ test_submit_nvme_cmd(void)
 	ut_test_submit_nvme_cmd(ch, bdev_io, SPDK_BDEV_IO_TYPE_READ);
 	ut_test_submit_nvme_cmd(ch, bdev_io, SPDK_BDEV_IO_TYPE_WRITE);
 	ut_test_submit_nvme_cmd(ch, bdev_io, SPDK_BDEV_IO_TYPE_COMPARE);
-	ut_test_submit_nvme_cmd(ch, bdev_io, SPDK_BDEV_IO_TYPE_WRITE_ZEROES);
 	ut_test_submit_nvme_cmd(ch, bdev_io, SPDK_BDEV_IO_TYPE_UNMAP);
 
 	ut_test_submit_nop(ch, bdev_io, SPDK_BDEV_IO_TYPE_FLUSH);
-- 
2.26.2


From 7e52eb740aa6efba1e986a78c010361624725697 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 21:22:55 +0000
Subject: [PATCH 043/342] iscsi: fix ISCSI_READ_PDU spdk_trace_record

This was accidentally moved to the wrong place as
part of some earlier iSCSI refactoring.  This trace
record should be executed when we have finished
reading all of the data for any PDU, not just those
with immediate data.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ib1d17e5e79ff220e9e9b3dd55e247e745bd58019
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7756
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/iscsi/iscsi.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/lib/iscsi/iscsi.c b/lib/iscsi/iscsi.c
index 7e54004bc..dcd2aa395 100644
--- a/lib/iscsi/iscsi.c
+++ b/lib/iscsi/iscsi.c
@@ -4703,10 +4703,6 @@ iscsi_pdu_payload_read(struct spdk_iscsi_conn *conn, struct spdk_iscsi_pdu *pdu)
 		}
 	}
 
-	/* All data for this PDU has now been read from the socket. */
-	spdk_trace_record(TRACE_ISCSI_READ_PDU, conn->id, pdu->data_valid_bytes,
-			  (uintptr_t)pdu, pdu->bhs.opcode);
-
 	/* check data digest */
 	if (conn->data_digest) {
 		_iscsi_pdu_calc_data_digest(pdu);
@@ -4843,6 +4839,10 @@ iscsi_read_pdu(struct spdk_iscsi_conn *conn)
 				}
 			}
 
+			/* All data for this PDU has now been read from the socket. */
+			spdk_trace_record(TRACE_ISCSI_READ_PDU, conn->id, pdu->data_valid_bytes,
+					  (uintptr_t)pdu, pdu->bhs.opcode);
+
 			if (!pdu->is_rejected) {
 				rc = iscsi_pdu_payload_handle(conn, pdu);
 			} else {
-- 
2.26.2


From b8fb7d67be94854108a529881f94c4709219975c Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 21:41:59 +0000
Subject: [PATCH 044/342] iscsi: track PDU object for WRITE_START/WRITE_DONE
 events

We already pass the PDU as arg1, so by changing the
trace register descriptions, we can map the PDUs to
more readable IDs when running the spdk_trace app.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Iad7106eeb0f5fe738f81da5ee174515d1cf4b6ce
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7757
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/iscsi/conn.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/iscsi/conn.c b/lib/iscsi/conn.c
index 4cbee1358..0f2b0a457 100644
--- a/lib/iscsi/conn.c
+++ b/lib/iscsi/conn.c
@@ -1650,9 +1650,9 @@ SPDK_TRACE_REGISTER_FN(iscsi_conn_trace, "iscsi_conn", TRACE_GROUP_ISCSI)
 	spdk_trace_register_description("ISCSI_READ_DONE", TRACE_ISCSI_READ_FROM_SOCKET_DONE,
 					OWNER_ISCSI_CONN, OBJECT_NONE, 0, 0, "");
 	spdk_trace_register_description("ISCSI_WRITE_START", TRACE_ISCSI_FLUSH_WRITEBUF_START,
-					OWNER_ISCSI_CONN, OBJECT_NONE, 0, 0, "iovec: ");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 1, 0, "iovec: ");
 	spdk_trace_register_description("ISCSI_WRITE_DONE", TRACE_ISCSI_FLUSH_WRITEBUF_DONE,
-					OWNER_ISCSI_CONN, OBJECT_NONE, 0, 0, "");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0, 0, "");
 	spdk_trace_register_description("ISCSI_READ_PDU", TRACE_ISCSI_READ_PDU,
 					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 1, 0, "opc:   ");
 	spdk_trace_register_description("ISCSI_TASK_DONE", TRACE_ISCSI_TASK_DONE,
-- 
2.26.2


From a4c37c6a56495affb6c67659d7fc5b944b5ac207 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 21:54:03 +0000
Subject: [PATCH 045/342] ftl: use SPDK_TRACE_ARG_TYPE #defines

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I10a0a2bf3f2bdcef0b4e4c76ee6958151c2b61e6
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7759
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/ftl/ftl_trace.c | 63 ++++++++++++++++++++++++++++++---------------
 1 file changed, 42 insertions(+), 21 deletions(-)

diff --git a/lib/ftl/ftl_trace.c b/lib/ftl/ftl_trace.c
index ba66323ad..646200ec9 100644
--- a/lib/ftl/ftl_trace.c
+++ b/lib/ftl/ftl_trace.c
@@ -89,72 +89,93 @@ SPDK_TRACE_REGISTER_FN(ftl_trace_func, "ftl", TRACE_GROUP_FTL)
 	for (i = 0; i < FTL_TRACE_SOURCE_MAX; ++i) {
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "band_defrag");
 		spdk_trace_register_description(descbuf, FTL_TRACE_BAND_DEFRAG(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "band: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "band: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "band_write");
 		spdk_trace_register_description(descbuf, FTL_TRACE_BAND_WRITE(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "band: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "band: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "limits");
 		spdk_trace_register_description(descbuf, FTL_TRACE_LIMITS(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "limits: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "limits: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "rwb_pop");
 		spdk_trace_register_description(descbuf, FTL_TRACE_WBUF_POP(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "md_read_sched");
 		spdk_trace_register_description(descbuf, FTL_TRACE_MD_READ_SCHEDULE(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "md_read_submit");
 		spdk_trace_register_description(descbuf, FTL_TRACE_MD_READ_SUBMISSION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "md_read_cmpl");
 		spdk_trace_register_description(descbuf, FTL_TRACE_MD_READ_COMPLETION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "md_write_sched");
 		spdk_trace_register_description(descbuf, FTL_TRACE_MD_WRITE_SCHEDULE(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "md_write_submit");
 		spdk_trace_register_description(descbuf, FTL_TRACE_MD_WRITE_SUBMISSION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "md_write_cmpl");
 		spdk_trace_register_description(descbuf, FTL_TRACE_MD_WRITE_COMPLETION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "read_sched");
 		spdk_trace_register_description(descbuf, FTL_TRACE_READ_SCHEDULE(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "read_submit");
 		spdk_trace_register_description(descbuf, FTL_TRACE_READ_SUBMISSION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "read_cmpl_invld");
 		spdk_trace_register_description(descbuf, FTL_TRACE_READ_COMPLETION_INVALID(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "read_cmpl_cache");
 		spdk_trace_register_description(descbuf, FTL_TRACE_READ_COMPLETION_CACHE(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "read_cmpl_ssd");
 		spdk_trace_register_description(descbuf, FTL_TRACE_READ_COMPLETION_DISK(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "write_sched");
 		spdk_trace_register_description(descbuf, FTL_TRACE_WRITE_SCHEDULE(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "rwb_fill");
 		spdk_trace_register_description(descbuf, FTL_TRACE_WRITE_WBUF_FILL(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "write_submit");
 		spdk_trace_register_description(descbuf, FTL_TRACE_WRITE_SUBMISSION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "write_cmpl");
 		spdk_trace_register_description(descbuf, FTL_TRACE_WRITE_COMPLETION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "lba: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "lba: ");
 
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "erase_submit");
 		spdk_trace_register_description(descbuf, FTL_TRACE_ERASE_SUBMISSION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 		snprintf(descbuf, sizeof(descbuf), "%c %s", source[i], "erase_cmpl");
 		spdk_trace_register_description(descbuf, FTL_TRACE_ERASE_COMPLETION(i),
-						OWNER_FTL, OBJECT_NONE, 0, 0, "addr: ");
+						OWNER_FTL, OBJECT_NONE, 0,
+						SPDK_TRACE_ARG_TYPE_INT, "addr: ");
 	}
 }
 
-- 
2.26.2


From 469a504baeefef5f07c3f04af31df3cd28945bab Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 22:06:41 +0000
Subject: [PATCH 046/342] bdev: use SPDK_TRACE_ARG_TYPE #defines

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Iddcc9ab7b5077368a4fbda72e650b381ef42b6cb
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7760
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/bdev/bdev.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 835660f92..757d8e78b 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -6869,7 +6869,9 @@ SPDK_TRACE_REGISTER_FN(bdev_trace, "bdev", TRACE_GROUP_BDEV)
 	spdk_trace_register_owner(OWNER_BDEV, 'b');
 	spdk_trace_register_object(OBJECT_BDEV_IO, 'i');
 	spdk_trace_register_description("BDEV_IO_START", TRACE_BDEV_IO_START, OWNER_BDEV,
-					OBJECT_BDEV_IO, 1, 0, "type:   ");
+					OBJECT_BDEV_IO, 1,
+					SPDK_TRACE_ARG_TYPE_INT, "type:   ");
 	spdk_trace_register_description("BDEV_IO_DONE", TRACE_BDEV_IO_DONE, OWNER_BDEV,
-					OBJECT_BDEV_IO, 0, 0, "");
+					OBJECT_BDEV_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 }
-- 
2.26.2


From 12cc5e2e50dfb7df263d79843a33bb06c685345f Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 22:08:00 +0000
Subject: [PATCH 047/342] doc: use SPDK_TRACE_ARG_TYPE #defines

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Idcffe9ae197fc0257b89ca0854fe722fbf1ca916
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7761
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 doc/nvmf_tracing.md | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/doc/nvmf_tracing.md b/doc/nvmf_tracing.md
index f23659fe8..71d540724 100644
--- a/doc/nvmf_tracing.md
+++ b/doc/nvmf_tracing.md
@@ -174,11 +174,13 @@ SPDK_TRACE_REGISTER_FN(nvmf_trace)
 	spdk_trace_register_object(OBJECT_NVMF_RDMA_IO, 'r');
 	spdk_trace_register_description("RDMA_REQ_NEW", "",
 					TRACE_RDMA_REQUEST_STATE_NEW,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 1, 1, "cmid:	");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 1,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:	");
 	...
 	spdk_trace_register_description("NEW_RDMA_REQ_NAME", "",
 					NEW_TRACE_POINT_NAME,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:	");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:	");
 }
 ~~~
 
-- 
2.26.2


From a7ea7cbc577b0ba8ef551993e1205195a4716955 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 22:08:59 +0000
Subject: [PATCH 048/342] iscsi: use SPDK_TRACE_ARG_TYPE #defines

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I033aa060feb0f6e4a9abedd8cf1335b25437fa99
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7762
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/iscsi/conn.c | 24 ++++++++++++++++--------
 1 file changed, 16 insertions(+), 8 deletions(-)

diff --git a/lib/iscsi/conn.c b/lib/iscsi/conn.c
index 0f2b0a457..acabc0601 100644
--- a/lib/iscsi/conn.c
+++ b/lib/iscsi/conn.c
@@ -1648,21 +1648,29 @@ SPDK_TRACE_REGISTER_FN(iscsi_conn_trace, "iscsi_conn", TRACE_GROUP_ISCSI)
 	spdk_trace_register_owner(OWNER_ISCSI_CONN, 'c');
 	spdk_trace_register_object(OBJECT_ISCSI_PDU, 'p');
 	spdk_trace_register_description("ISCSI_READ_DONE", TRACE_ISCSI_READ_FROM_SOCKET_DONE,
-					OWNER_ISCSI_CONN, OBJECT_NONE, 0, 0, "");
+					OWNER_ISCSI_CONN, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("ISCSI_WRITE_START", TRACE_ISCSI_FLUSH_WRITEBUF_START,
-					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 1, 0, "iovec: ");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 1,
+					SPDK_TRACE_ARG_TYPE_INT, "iovec: ");
 	spdk_trace_register_description("ISCSI_WRITE_DONE", TRACE_ISCSI_FLUSH_WRITEBUF_DONE,
-					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0, 0, "");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("ISCSI_READ_PDU", TRACE_ISCSI_READ_PDU,
-					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 1, 0, "opc:   ");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 1,
+					SPDK_TRACE_ARG_TYPE_INT, "opc:   ");
 	spdk_trace_register_description("ISCSI_TASK_DONE", TRACE_ISCSI_TASK_DONE,
-					OWNER_ISCSI_CONN, OBJECT_SCSI_TASK, 0, 0, "");
+					OWNER_ISCSI_CONN, OBJECT_SCSI_TASK, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("ISCSI_TASK_QUEUE", TRACE_ISCSI_TASK_QUEUE,
-					OWNER_ISCSI_CONN, OBJECT_SCSI_TASK, 1, 1, "pdu:   ");
+					OWNER_ISCSI_CONN, OBJECT_SCSI_TASK, 1,
+					SPDK_TRACE_ARG_TYPE_PTR, "pdu:   ");
 	spdk_trace_register_description("ISCSI_TASK_EXECUTED", TRACE_ISCSI_TASK_EXECUTED,
-					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0, 0, "");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("ISCSI_PDU_COMPLETED", TRACE_ISCSI_PDU_COMPLETED,
-					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0, 0, "");
+					OWNER_ISCSI_CONN, OBJECT_ISCSI_PDU, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 }
 
 void
-- 
2.26.2


From 40cf86f20abf3c7c0e214dd2ac3def40f9b69ba0 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 22:10:44 +0000
Subject: [PATCH 049/342] nvmf: use SPDK_TRACE_ARG_TYPE #defines

Note: a lot of the TCP and FC trace registers were
specifying '1' which means the arg type is a pointer,
but in reality it is always passing 0 for arg1.  So
this patch just changes them to SPDK_TRACE_ARG_TYPE_INT.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I18d3cedd21e516f16cb2cd0a7f8c16670b1895d7
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7763
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/nvmf/fc.c   | 48 ++++++++++++++++++++++++++++---------------
 lib/nvmf/rdma.c | 54 ++++++++++++++++++++++++++++++++-----------------
 lib/nvmf/tcp.c  | 39 +++++++++++++++++++++++------------
 3 files changed, 94 insertions(+), 47 deletions(-)

diff --git a/lib/nvmf/fc.c b/lib/nvmf/fc.c
index 88f82e8af..09c15c140 100644
--- a/lib/nvmf/fc.c
+++ b/lib/nvmf/fc.c
@@ -116,52 +116,68 @@ SPDK_TRACE_REGISTER_FN(nvmf_fc_trace, "nvmf_fc", TRACE_GROUP_NVMF_FC)
 	spdk_trace_register_object(OBJECT_NVMF_FC_IO, 'r');
 	spdk_trace_register_description("FC_REQ_NEW",
 					TRACE_FC_REQ_INIT,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 1, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 1,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_READ_SUBMIT_TO_BDEV",
 					TRACE_FC_REQ_READ_BDEV,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_READ_XFER_DATA",
 					TRACE_FC_REQ_READ_XFER,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_READ_RSP",
 					TRACE_FC_REQ_READ_RSP,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_WRITE_NEED_BUFFER",
 					TRACE_FC_REQ_WRITE_BUFFS,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_WRITE_XFER_DATA",
 					TRACE_FC_REQ_WRITE_XFER,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_WRITE_SUBMIT_TO_BDEV",
 					TRACE_FC_REQ_WRITE_BDEV,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_WRITE_RSP",
 					TRACE_FC_REQ_WRITE_RSP,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_NONE_SUBMIT_TO_BDEV",
 					TRACE_FC_REQ_NONE_BDEV,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_NONE_RSP",
 					TRACE_FC_REQ_NONE_RSP,
-					OWNER_NONE, OBJECT_NVMF_FC_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_FC_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_SUCCESS",
 					TRACE_FC_REQ_SUCCESS,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_FAILED",
 					TRACE_FC_REQ_FAILED,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_ABORTED",
 					TRACE_FC_REQ_ABORTED,
-					OWNER_NONE, OBJECT_NONE, 0, 1, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_ABORTED_SUBMIT_TO_BDEV",
 					TRACE_FC_REQ_BDEV_ABORTED,
-					OWNER_NONE, OBJECT_NONE, 0, 1, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_PENDING",
 					TRACE_FC_REQ_PENDING,
-					OWNER_NONE, OBJECT_NONE, 0, 1, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("FC_REQ_FUSED_WAITING",
 					TRACE_FC_REQ_FUSED_WAITING,
-					OWNER_NONE, OBJECT_NONE, 0, 1, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 }
 
 /**
diff --git a/lib/nvmf/rdma.c b/lib/nvmf/rdma.c
index e7f3f8ea6..199db50cd 100644
--- a/lib/nvmf/rdma.c
+++ b/lib/nvmf/rdma.c
@@ -158,52 +158,70 @@ SPDK_TRACE_REGISTER_FN(nvmf_trace, "nvmf_rdma", TRACE_GROUP_NVMF_RDMA)
 {
 	spdk_trace_register_object(OBJECT_NVMF_RDMA_IO, 'r');
 	spdk_trace_register_description("RDMA_REQ_NEW", TRACE_RDMA_REQUEST_STATE_NEW,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 1, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 1,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_NEED_BUFFER", TRACE_RDMA_REQUEST_STATE_NEED_BUFFER,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_TX_PENDING_C2H",
 					TRACE_RDMA_REQUEST_STATE_DATA_TRANSFER_TO_HOST_PENDING,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_TX_PENDING_H2C",
 					TRACE_RDMA_REQUEST_STATE_DATA_TRANSFER_TO_CONTROLLER_PENDING,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_TX_H2C",
 					TRACE_RDMA_REQUEST_STATE_TRANSFERRING_HOST_TO_CONTROLLER,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_RDY_TO_EXECUTE",
 					TRACE_RDMA_REQUEST_STATE_READY_TO_EXECUTE,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_EXECUTING",
 					TRACE_RDMA_REQUEST_STATE_EXECUTING,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_EXECUTED",
 					TRACE_RDMA_REQUEST_STATE_EXECUTED,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_RDY_TO_COMPL",
 					TRACE_RDMA_REQUEST_STATE_READY_TO_COMPLETE,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_COMPLETING_C2H",
 					TRACE_RDMA_REQUEST_STATE_TRANSFERRING_CONTROLLER_TO_HOST,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_COMPLETING",
 					TRACE_RDMA_REQUEST_STATE_COMPLETING,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 	spdk_trace_register_description("RDMA_REQ_COMPLETED",
 					TRACE_RDMA_REQUEST_STATE_COMPLETED,
-					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0, 1, "cmid:   ");
+					OWNER_NONE, OBJECT_NVMF_RDMA_IO, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "cmid:   ");
 
 	spdk_trace_register_description("RDMA_QP_CREATE", TRACE_RDMA_QP_CREATE,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("RDMA_IBV_ASYNC_EVENT", TRACE_RDMA_IBV_ASYNC_EVENT,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "type:   ");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "type:   ");
 	spdk_trace_register_description("RDMA_CM_ASYNC_EVENT", TRACE_RDMA_CM_ASYNC_EVENT,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "type:   ");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "type:   ");
 	spdk_trace_register_description("RDMA_QP_STATE_CHANGE", TRACE_RDMA_QP_STATE_CHANGE,
-					OWNER_NONE, OBJECT_NONE, 0, 1, "state:  ");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_PTR, "state:  ");
 	spdk_trace_register_description("RDMA_QP_DISCONNECT", TRACE_RDMA_QP_DISCONNECT,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("RDMA_QP_DESTROY", TRACE_RDMA_QP_DESTROY,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 }
 
 enum spdk_nvmf_rdma_wr_type {
diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index 57596cc11..74e2e0d8e 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -128,43 +128,56 @@ SPDK_TRACE_REGISTER_FN(nvmf_tcp_trace, "nvmf_tcp", TRACE_GROUP_NVMF_TCP)
 	spdk_trace_register_object(OBJECT_NVMF_TCP_IO, 'r');
 	spdk_trace_register_description("TCP_REQ_NEW",
 					TRACE_TCP_REQUEST_STATE_NEW,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 1, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 1,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_NEED_BUFFER",
 					TRACE_TCP_REQUEST_STATE_NEED_BUFFER,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_TX_H_TO_C",
 					TRACE_TCP_REQUEST_STATE_TRANSFERRING_HOST_TO_CONTROLLER,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_RDY_TO_EXECUTE",
 					TRACE_TCP_REQUEST_STATE_READY_TO_EXECUTE,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_EXECUTING",
 					TRACE_TCP_REQUEST_STATE_EXECUTING,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_EXECUTED",
 					TRACE_TCP_REQUEST_STATE_EXECUTED,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_RDY_TO_COMPLETE",
 					TRACE_TCP_REQUEST_STATE_READY_TO_COMPLETE,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_TRANSFER_C2H",
 					TRACE_TCP_REQUEST_STATE_TRANSFERRING_CONTROLLER_TO_HOST,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_COMPLETED",
 					TRACE_TCP_REQUEST_STATE_COMPLETED,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_WRITE_START",
 					TRACE_TCP_FLUSH_WRITEBUF_START,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_WRITE_DONE",
 					TRACE_TCP_FLUSH_WRITEBUF_DONE,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_READ_DONE",
 					TRACE_TCP_READ_FROM_SOCKET_DONE,
-					OWNER_NONE, OBJECT_NONE, 0, 0, "");
+					OWNER_NONE, OBJECT_NONE, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("TCP_REQ_AWAIT_R2T_ACK",
 					TRACE_TCP_REQUEST_STATE_AWAIT_R2T_ACK,
-					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0, 1, "");
+					OWNER_NONE, OBJECT_NVMF_TCP_IO, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 }
 
 struct spdk_nvmf_tcp_req  {
-- 
2.26.2


From de6e5c30c985708ac18b4ba029dd76ee84910fca Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 5 May 2021 22:51:45 +0000
Subject: [PATCH 050/342] scsi: use SPDK_TRACE_ARG_TYPE #defines

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ifc2a79891ab26643a2783d0e6482d58449a300f5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7764
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/scsi/scsi.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/lib/scsi/scsi.c b/lib/scsi/scsi.c
index 947d83d90..8aa129b7a 100644
--- a/lib/scsi/scsi.c
+++ b/lib/scsi/scsi.c
@@ -61,9 +61,11 @@ SPDK_TRACE_REGISTER_FN(scsi_trace, "scsi", TRACE_GROUP_SCSI)
 	spdk_trace_register_owner(OWNER_SCSI_DEV, 'd');
 	spdk_trace_register_object(OBJECT_SCSI_TASK, 't');
 	spdk_trace_register_description("SCSI_TASK_DONE", TRACE_SCSI_TASK_DONE,
-					OWNER_SCSI_DEV, OBJECT_SCSI_TASK, 0, 0, "");
+					OWNER_SCSI_DEV, OBJECT_SCSI_TASK, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 	spdk_trace_register_description("SCSI_TASK_START", TRACE_SCSI_TASK_START,
-					OWNER_SCSI_DEV, OBJECT_SCSI_TASK, 0, 0, "");
+					OWNER_SCSI_DEV, OBJECT_SCSI_TASK, 0,
+					SPDK_TRACE_ARG_TYPE_INT, "");
 }
 
 uint64_t
-- 
2.26.2


From 8e3d60a1164bd6acac17c60f8f6109183ee474e5 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Thu, 25 Mar 2021 18:37:22 +0800
Subject: [PATCH 051/342] test/nvme_pcie_common: cases for pcie qpair construct
 and destroy

Change-Id: I2ff57cec09139d54743a06d24dc5294f574d8378
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7059
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 .../nvme_pcie_common.c/nvme_pcie_common_ut.c  | 106 ++++++++++++++++++
 1 file changed, 106 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
index 411dfbe1e..f1f4823fa 100644
--- a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
@@ -99,6 +99,111 @@ test_nvme_pcie_ctrlr_alloc_cmb(void)
 	CU_ASSERT(vaddr == NULL);
 }
 
+static void
+test_nvme_pcie_qpair_construct_destroy(void)
+{
+	struct spdk_nvme_io_qpair_opts opts = {};
+	struct nvme_pcie_ctrlr pctrlr = {};
+	struct spdk_nvme_cpl cpl[2] = {};
+	struct nvme_pcie_qpair *pqpair = NULL;
+	int rc;
+
+	opts.sq.paddr = 0xDEADBEEF;
+	opts.cq.paddr = 0xDBADBEEF;
+	opts.sq.vaddr = (void *)0xDCADBEEF;
+	opts.cq.vaddr = cpl;
+
+	pctrlr.ctrlr.trid.trtype = SPDK_NVME_TRANSPORT_PCIE;
+	pctrlr.ctrlr.opts.transport_retry_count = 1;
+	pctrlr.cmb.mem_register_addr = NULL;
+	pctrlr.cmb.bar_va = (void *)0xF9000000;
+	pctrlr.cmb.bar_pa = 0xF8000000;
+	pctrlr.cmb.current_offset = 0x10;
+	pctrlr.cmb.size = 1 << 16;
+	pctrlr.doorbell_base = (void *)0xF7000000;
+	pctrlr.doorbell_stride_u32 = 1;
+
+	/* Allocate memory for destroying. */
+	pqpair = spdk_zmalloc(sizeof(*pqpair), 64, NULL,
+			      SPDK_ENV_SOCKET_ID_ANY, SPDK_MALLOC_SHARE);
+	SPDK_CU_ASSERT_FATAL(pqpair != NULL);
+	pqpair->qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair->num_entries = 2;
+	pqpair->qpair.id = 1;
+	pqpair->cpl = cpl;
+
+	/* Enable submission queue in controller memory buffer. */
+	pctrlr.ctrlr.opts.use_cmb_sqs = true;
+
+	rc = nvme_pcie_qpair_construct(&pqpair->qpair, &opts);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(pqpair->sq_vaddr == (void *)0xDCADBEEF);
+	CU_ASSERT(pqpair->cq_vaddr == cpl);
+	CU_ASSERT(pqpair->retry_count == 1);
+	CU_ASSERT(pqpair->max_completions_cap == 1);
+	CU_ASSERT(pqpair->sq_in_cmb == true);
+	CU_ASSERT(pqpair->cmd != NULL && pqpair->cmd != (void *)0xDCADBEEF);
+	CU_ASSERT(pqpair->cmd_bus_addr ==  0xF8001000);
+	CU_ASSERT(pqpair->sq_tdbl == (void *)0xF7000008);
+	CU_ASSERT(pqpair->cq_hdbl == (void *)0xF700000C);
+	CU_ASSERT(pqpair->flags.phase = 1);
+	CU_ASSERT(pqpair->tr != NULL);
+	CU_ASSERT(pqpair->tr == TAILQ_FIRST(&pqpair->free_tr));
+	nvme_pcie_qpair_destroy(&pqpair->qpair);
+
+	/* Disable submission queue in controller memory buffer. */
+	pctrlr.ctrlr.opts.use_cmb_sqs = false;
+	pqpair = spdk_zmalloc(sizeof(*pqpair), 64, NULL,
+			      SPDK_ENV_SOCKET_ID_ANY, SPDK_MALLOC_SHARE);
+	SPDK_CU_ASSERT_FATAL(pqpair != NULL);
+	pqpair->qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair->num_entries = 2;
+	pqpair->qpair.id = 1;
+	pqpair->cpl = cpl;
+
+	rc = nvme_pcie_qpair_construct(&pqpair->qpair, &opts);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(pqpair->sq_vaddr == (void *)0xDCADBEEF);
+	CU_ASSERT(pqpair->cq_vaddr == cpl);
+	CU_ASSERT(pqpair->retry_count == 1);
+	CU_ASSERT(pqpair->max_completions_cap == 1);
+	CU_ASSERT(pqpair->sq_in_cmb == false);
+	CU_ASSERT(pqpair->cmd == (void *)0xDCADBEEF);
+	CU_ASSERT(pqpair->cmd_bus_addr == 0xDEADBEEF);
+	CU_ASSERT(pqpair->sq_tdbl == (void *)0xF7000008);
+	CU_ASSERT(pqpair->cq_hdbl == (void *)0xF700000C);
+	CU_ASSERT(pqpair->flags.phase = 1);
+	CU_ASSERT(pqpair->tr != NULL);
+	CU_ASSERT(pqpair->tr == TAILQ_FIRST(&pqpair->free_tr));
+	nvme_pcie_qpair_destroy(&pqpair->qpair);
+
+	/* Disable submission queue in controller memory buffer, sq_vaddr and cq_vaddr invalid. */
+	pctrlr.ctrlr.opts.use_cmb_sqs = false;
+	pqpair = spdk_zmalloc(sizeof(*pqpair), 64, NULL,
+			      SPDK_ENV_SOCKET_ID_ANY, SPDK_MALLOC_SHARE);
+	SPDK_CU_ASSERT_FATAL(pqpair != NULL);
+	pqpair->qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair->num_entries = 2;
+	pqpair->qpair.id = 1;
+	pqpair->cpl = cpl;
+	MOCK_SET(spdk_vtophys, 0xDAADBEEF);
+
+	rc = nvme_pcie_qpair_construct(&pqpair->qpair, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(pqpair->retry_count == 1);
+	CU_ASSERT(pqpair->max_completions_cap == 1);
+	CU_ASSERT(pqpair->cmd != NULL && pqpair->cmd != (void *)0xDCADBEEF);
+	CU_ASSERT(pqpair->sq_in_cmb == false);
+	CU_ASSERT(pqpair->cmd_bus_addr == 0xDAADBEEF);
+	CU_ASSERT(pqpair->sq_tdbl == (void *)0xF7000008);
+	CU_ASSERT(pqpair->cq_hdbl == (void *)0xF700000c);
+	CU_ASSERT(pqpair->flags.phase = 1);
+	CU_ASSERT(pqpair->tr != NULL);
+	CU_ASSERT(pqpair->tr == TAILQ_FIRST(&pqpair->free_tr));
+	nvme_pcie_qpair_destroy(&pqpair->qpair);
+	MOCK_CLEAR(spdk_vtophys);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -109,6 +214,7 @@ int main(int argc, char **argv)
 
 	suite = CU_add_suite("nvme_pcie_common", NULL, NULL);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_alloc_cmb);
+	CU_ADD_TEST(suite, test_nvme_pcie_qpair_construct_destroy);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From c68200086f22c86571d8a194dd3f085f2e21ae75 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Thu, 29 Apr 2021 18:12:56 +0800
Subject: [PATCH 052/342] test/fabric: cases for fabric discovery

Change-Id: I00c7f6e827fc7d2cd4775129a6acd866245ecdb4
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7690
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../lib/nvme/nvme_fabric.c/nvme_fabric_ut.c   | 155 ++++++++++++++++--
 1 file changed, 141 insertions(+), 14 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
index 1df04c010..1a044720e 100644
--- a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
+++ b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
@@ -43,10 +43,6 @@ struct spdk_nvmf_fabric_prop_get_rsp g_ut_response = {};
 
 DEFINE_STUB_V(nvme_completion_poll_cb, (void *arg, const struct spdk_nvme_cpl *cpl));
 
-DEFINE_STUB(nvme_wait_for_completion, int,
-	    (struct spdk_nvme_qpair *qpair,
-	     struct nvme_completion_poll_status *status), 0);
-
 DEFINE_STUB_V(spdk_nvme_ctrlr_get_default_ctrlr_opts,
 	      (struct spdk_nvme_ctrlr_opts *opts, size_t opts_size));
 
@@ -71,9 +67,6 @@ DEFINE_STUB(spdk_nvme_ctrlr_cmd_get_log_page, int,
 	     uint32_t nsid, void *payload, uint32_t payload_size,
 	     uint64_t offset, spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
 
-DEFINE_STUB(spdk_nvme_transport_id_populate_trstring, int,
-	    (struct spdk_nvme_transport_id *trid, const char *trstring), 0);
-
 DEFINE_STUB(spdk_nvme_transport_available_by_name, bool,
 	    (const char *transport_name), true);
 
@@ -82,10 +75,6 @@ DEFINE_STUB(nvme_transport_ctrlr_construct, struct spdk_nvme_ctrlr *,
 	     const struct spdk_nvme_ctrlr_opts *opts,
 	     void *devhandle), NULL);
 
-DEFINE_STUB(nvme_ctrlr_probe, int,
-	    (const struct spdk_nvme_transport_id *trid,
-	     struct spdk_nvme_probe_ctx *probe_ctx, void *devhandle), 0);
-
 DEFINE_STUB(spdk_nvme_ctrlr_cmd_io_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
 		struct spdk_nvme_qpair *qpair, struct spdk_nvme_cmd *cmd, void *buf,
 		uint32_t len, spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
@@ -95,12 +84,77 @@ DEFINE_STUB(nvme_wait_for_completion_timeout, int,
 	     struct nvme_completion_poll_status *status,
 	     uint64_t timeout_in_usecs), 0);
 
-DEFINE_STUB(spdk_nvme_transport_id_trtype_str, const char *,
-	    (enum spdk_nvme_transport_type trtype), NULL);
-
 DEFINE_STUB(spdk_nvme_transport_id_adrfam_str, const char *,
 	    (enum spdk_nvmf_adrfam adrfam), NULL);
 
+int
+spdk_nvme_transport_id_populate_trstring(struct spdk_nvme_transport_id *trid, const char *trstring)
+{
+	int len, i, rc;
+
+	if (trstring == NULL) {
+		return -EINVAL;
+	}
+
+	len = strnlen(trstring, SPDK_NVMF_TRSTRING_MAX_LEN);
+	if (len == SPDK_NVMF_TRSTRING_MAX_LEN) {
+		return -EINVAL;
+	}
+
+	rc = snprintf(trid->trstring, SPDK_NVMF_TRSTRING_MAX_LEN, "%s", trstring);
+	if (rc < 0) {
+		return rc;
+	}
+
+	/* cast official trstring to uppercase version of input. */
+	for (i = 0; i < len; i++) {
+		trid->trstring[i] = toupper(trid->trstring[i]);
+	}
+	return 0;
+}
+
+static const struct spdk_nvme_transport_id *g_ut_trid;
+
+int
+nvme_ctrlr_probe(const struct spdk_nvme_transport_id *trid,
+		 struct spdk_nvme_probe_ctx *probe_ctx, void *devhandle)
+{
+	g_ut_trid = trid;
+
+	return 0;
+}
+
+const char *
+spdk_nvme_transport_id_trtype_str(enum spdk_nvme_transport_type trtype)
+{
+	switch (trtype) {
+	case SPDK_NVME_TRANSPORT_PCIE:
+		return "PCIe";
+	case SPDK_NVME_TRANSPORT_RDMA:
+		return "RDMA";
+	case SPDK_NVME_TRANSPORT_FC:
+		return "FC";
+	case SPDK_NVME_TRANSPORT_TCP:
+		return "TCP";
+	case SPDK_NVME_TRANSPORT_VFIOUSER:
+		return "VFIOUSER";
+	case SPDK_NVME_TRANSPORT_CUSTOM:
+		return "CUSTOM";
+	default:
+		return NULL;
+	}
+}
+
+DEFINE_RETURN_MOCK(nvme_wait_for_completion, int);
+int
+nvme_wait_for_completion(struct spdk_nvme_qpair *qpair,
+			 struct nvme_completion_poll_status *status)
+{
+	status->timed_out = false;
+	HANDLE_RETURN_MOCK(nvme_wait_for_completion);
+	return 0;
+}
+
 DEFINE_RETURN_MOCK(spdk_nvme_ctrlr_cmd_admin_raw, int);
 int
 spdk_nvme_ctrlr_cmd_admin_raw(struct spdk_nvme_ctrlr *ctrlr,
@@ -177,6 +231,77 @@ test_nvme_fabric_prop_get_cmd(void)
 	CU_ASSERT(g_ut_response.value.u64 == value);
 }
 
+static void
+test_nvme_fabric_get_discovery_log_page(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+	char buffer[4096] = {};
+	uint64_t offset = 0;
+	int rc;
+
+	rc = nvme_fabric_get_discovery_log_page(&ctrlr, buffer, sizeof(buffer), offset);
+	CU_ASSERT(rc == 0);
+
+	/* Get log page fail */
+	MOCK_SET(spdk_nvme_ctrlr_cmd_get_log_page, -EINVAL);
+
+	rc = nvme_fabric_get_discovery_log_page(&ctrlr, buffer, sizeof(buffer), offset);
+	CU_ASSERT(rc == -1);
+	MOCK_CLEAR(spdk_nvme_ctrlr_cmd_get_log_page);
+
+	/* Completion time out */
+	MOCK_SET(nvme_wait_for_completion, -1);
+
+	rc = nvme_fabric_get_discovery_log_page(&ctrlr, buffer, sizeof(buffer), offset);
+	CU_ASSERT(rc == -1);
+	MOCK_CLEAR(nvme_wait_for_completion);
+}
+
+static void
+test_nvme_fabric_discover_probe(void)
+{
+	struct spdk_nvmf_discovery_log_page_entry entry = {};
+	struct spdk_nvme_probe_ctx probe_ctx = {};
+	char hostnqn[256] = "nqn.2016-06.io.spdk:cnode1";
+	char traddr[SPDK_NVMF_TRADDR_MAX_LEN] = "192.168.100.8";
+	char trsvcid[SPDK_NVMF_TRSVCID_MAX_LEN] = "4420";
+	char trstring[SPDK_NVMF_TRSTRING_MAX_LEN + 1] = "RDMA";
+
+	entry.trtype = SPDK_NVME_TRANSPORT_RDMA;
+	entry.subtype = SPDK_NVMF_SUBTYPE_NVME;
+	entry.adrfam = SPDK_NVMF_ADRFAM_IPV4;
+
+	memcpy(entry.subnqn, hostnqn, 256);
+	memcpy(entry.traddr, traddr, SPDK_NVMF_TRADDR_MAX_LEN);
+	memcpy(entry.trsvcid, trsvcid, SPDK_NVMF_TRSVCID_MAX_LEN);
+	memcpy(probe_ctx.trid.trstring, trstring, sizeof(probe_ctx.trid.trstring));
+
+	g_ut_trid = NULL;
+	nvme_fabric_discover_probe(&entry, &probe_ctx, 1);
+	CU_ASSERT(g_ut_trid != NULL);
+	CU_ASSERT(g_ut_trid->trtype == SPDK_NVME_TRANSPORT_RDMA);
+	CU_ASSERT(g_ut_trid->adrfam == SPDK_NVMF_ADRFAM_IPV4);
+	CU_ASSERT(!strncmp(g_ut_trid->trstring, trstring, sizeof(trstring)));
+	CU_ASSERT(!strncmp(g_ut_trid->subnqn, hostnqn, sizeof(hostnqn)));
+	CU_ASSERT(!strncmp(g_ut_trid->traddr, traddr, sizeof(traddr)));
+	CU_ASSERT(!strncmp(g_ut_trid->trsvcid, trsvcid, sizeof(trsvcid)));
+	CU_ASSERT(g_ut_trid->priority == 1);
+
+	/* Entry type unsupported */
+	entry.subtype = SPDK_NVMF_SUBTYPE_DISCOVERY;
+	g_ut_trid = NULL;
+
+	nvme_fabric_discover_probe(&entry, &probe_ctx, 1);
+	CU_ASSERT(g_ut_trid == NULL);
+
+	/* Entry type invalid */
+	entry.subtype = 3;
+	g_ut_trid = NULL;
+
+	nvme_fabric_discover_probe(&entry, &probe_ctx, 1);
+	CU_ASSERT(g_ut_trid == NULL);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -188,6 +313,8 @@ int main(int argc, char **argv)
 	suite = CU_add_suite("nvme_fabric", NULL, NULL);
 	CU_ADD_TEST(suite, test_nvme_fabric_prop_set_cmd);
 	CU_ADD_TEST(suite, test_nvme_fabric_prop_get_cmd);
+	CU_ADD_TEST(suite, test_nvme_fabric_get_discovery_log_page);
+	CU_ADD_TEST(suite, test_nvme_fabric_discover_probe);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From f98623bb551177c39e3066eda04fdac3a51697d6 Mon Sep 17 00:00:00 2001
From: Scott Peterson <scott.d.peterson@intel.com>
Date: Tue, 2 Jul 2019 19:09:25 -0700
Subject: [PATCH 053/342] nvmf: define vendor specific log page range

Also add a macro to test a given log page ID.

Signed-off-by: Scott Peterson <scott.d.peterson@intel.com>
Change-Id: Id4d00f5c3d8af76b24ce010d6f922025a31312b4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/4115
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 include/spdk/nvme_spec.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/include/spdk/nvme_spec.h b/include/spdk/nvme_spec.h
index b715b41f5..df9471672 100644
--- a/include/spdk/nvme_spec.h
+++ b/include/spdk/nvme_spec.h
@@ -2794,8 +2794,12 @@ enum spdk_nvme_log_page {
 	/* 0x81-0xBF - I/O command set specific */
 
 	/* 0xC0-0xFF - vendor specific */
+	SPDK_NVME_LOG_VENDOR_SPECIFIC_START	= 0xc0,
+	SPDK_NVME_LOG_VENDOR_SPECIFIC_END	= 0xff,
 };
 
+#define spdk_nvme_log_page_is_vendor_specific(lid) ((lid) >= SPDK_NVME_LOG_VENDOR_SPECIFIC_START)
+
 /**
  * Error information log page (\ref SPDK_NVME_LOG_ERROR)
  */
-- 
2.26.2


From cd9619a3db68ed8b45bb55841dba1f0d3dda6ef8 Mon Sep 17 00:00:00 2001
From: sunshihao520 <sunshihao@huawei.com>
Date: Wed, 24 Mar 2021 11:35:32 +0800
Subject: [PATCH 054/342] bdev/bdev_nvme: Don't send abort cmd to ctrlr if the
 reset is running.

Signed-off-by: sunshihao <sunshihao@huawei.com>
Change-Id: Ib16cfaddc00ed0d461fa04b835134de403223553
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7024
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 module/bdev/nvme/bdev_nvme.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index e098535fd..071fcba4e 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -1092,7 +1092,7 @@ bdev_nvme_poll_group_destroy_cb(void *io_device, void *ctx_buf)
 
 	spdk_poller_unregister(&group->poller);
 	if (spdk_nvme_poll_group_destroy(group->group)) {
-		SPDK_ERRLOG("Unable to destroy a poll group for the NVMe bdev module.");
+		SPDK_ERRLOG("Unable to destroy a poll group for the NVMe bdev module.\n");
 		assert(false);
 	}
 }
@@ -1431,7 +1431,8 @@ nvme_abort_cpl(void *ctx, const struct spdk_nvme_cpl *cpl)
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = ctx;
 
 	if (spdk_nvme_cpl_is_error(cpl)) {
-		SPDK_WARNLOG("Abort failed. Resetting controller.\n");
+		SPDK_WARNLOG("Abort failed. Resetting controller. sc is %u, sct is %u.\n", cpl->status.sc,
+			     cpl->status.sct);
 		_bdev_nvme_reset(nvme_bdev_ctrlr);
 	}
 }
@@ -1465,13 +1466,22 @@ timeout_cb(void *cb_arg, struct spdk_nvme_ctrlr *ctrlr,
 	switch (g_opts.action_on_timeout) {
 	case SPDK_BDEV_NVME_TIMEOUT_ACTION_ABORT:
 		if (qpair) {
+			/* Don't send abort to ctrlr when reset is running. */
+			pthread_mutex_lock(&nvme_bdev_ctrlr->mutex);
+			if (nvme_bdev_ctrlr->resetting) {
+				pthread_mutex_unlock(&nvme_bdev_ctrlr->mutex);
+				SPDK_NOTICELOG("Quit abort. Ctrlr is in the process of reseting.\n");
+				return;
+			}
+			pthread_mutex_unlock(&nvme_bdev_ctrlr->mutex);
+
 			rc = spdk_nvme_ctrlr_cmd_abort(ctrlr, qpair, cid,
 						       nvme_abort_cpl, nvme_bdev_ctrlr);
 			if (rc == 0) {
 				return;
 			}
 
-			SPDK_ERRLOG("Unable to send abort. Resetting.\n");
+			SPDK_ERRLOG("Unable to send abort. Resetting, rc is %d.\n", rc);
 		}
 
 	/* FALLTHROUGH */
-- 
2.26.2


From d16c5b49dd5b3e204cd6ed0397a3ee43f9ae642c Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Wed, 28 Apr 2021 10:16:37 +0800
Subject: [PATCH 055/342] test/nvme_pcie: cases for cmb mapping

Change-Id: I8b781b519aca901f34697f9ff165a92d0511201c
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7490
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c | 100 +++++++++++++++++-
 1 file changed, 97 insertions(+), 3 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
index f7fa13ed1..a1be9f9a4 100644
--- a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
@@ -58,9 +58,6 @@ DEFINE_STUB(nvme_ctrlr_submit_admin_request, int, (struct spdk_nvme_ctrlr *ctrlr
 DEFINE_STUB_V(nvme_ctrlr_free_processes, (struct spdk_nvme_ctrlr *ctrlr));
 DEFINE_STUB(nvme_ctrlr_proc_get_devhandle, struct spdk_pci_device *,
 	    (struct spdk_nvme_ctrlr *ctrlr), NULL);
-
-DEFINE_STUB(spdk_pci_device_map_bar, int, (struct spdk_pci_device *dev, uint32_t bar,
-		void **mapped_addr, uint64_t *phys_addr, uint64_t *size), 0);
 DEFINE_STUB(spdk_pci_device_unmap_bar, int, (struct spdk_pci_device *dev, uint32_t bar, void *addr),
 	    0);
 DEFINE_STUB(spdk_pci_device_attach, int, (struct spdk_pci_driver *driver, spdk_pci_enum_cb enum_cb,
@@ -86,6 +83,12 @@ DEFINE_STUB(nvme_transport_get_name, const char *, (const struct spdk_nvme_trans
 
 SPDK_LOG_REGISTER_COMPONENT(nvme)
 
+struct dev_mem_resource {
+	uint64_t phys_addr;
+	uint64_t len;
+	void *addr;
+};
+
 struct nvme_pcie_ut_bdev_io {
 	struct iovec iovs[NVME_MAX_SGL_DESCRIPTORS];
 	int iovpos;
@@ -93,6 +96,19 @@ struct nvme_pcie_ut_bdev_io {
 
 struct nvme_driver *g_spdk_nvme_driver = NULL;
 
+int
+spdk_pci_device_map_bar(struct spdk_pci_device *dev, uint32_t bar,
+			void **mapped_addr, uint64_t *phys_addr, uint64_t *size)
+{
+	struct dev_mem_resource *dev_mem_res = (void *)dev;
+
+	*mapped_addr = dev_mem_res->addr;
+	*phys_addr = dev_mem_res->phys_addr;
+	*size = dev_mem_res->len;
+
+	return 0;
+}
+
 void
 nvme_ctrlr_fail(struct spdk_nvme_ctrlr *ctrlr, bool hot_remove)
 {
@@ -707,6 +723,82 @@ test_nvme_pcie_qpair_build_contig_request(void)
 	CU_ASSERT(rc == -EFAULT);
 }
 
+static void
+test_nvme_pcie_ctrlr_regs_get_set(void)
+{
+	struct nvme_pcie_ctrlr pctrlr = {};
+	volatile struct spdk_nvme_registers regs = {};
+	uint32_t value_4;
+	uint64_t value_8;
+	int rc;
+
+	pctrlr.regs = &regs;
+
+	rc = nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr, 8, 4);
+	CU_ASSERT(rc == 0);
+
+	rc = nvme_pcie_ctrlr_get_reg_4(&pctrlr.ctrlr, 8, &value_4);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(value_4 == 4);
+
+	rc = nvme_pcie_ctrlr_set_reg_8(&pctrlr.ctrlr, 0, 0x100000000);
+	CU_ASSERT(rc == 0);
+
+	rc = nvme_pcie_ctrlr_get_reg_8(&pctrlr.ctrlr, 0, &value_8);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(value_8 == 0x100000000);
+}
+
+static void
+test_nvme_pcie_ctrlr_map_unmap_cmb(void)
+{
+	struct nvme_pcie_ctrlr pctrlr = {};
+	volatile struct spdk_nvme_registers regs = {};
+	union spdk_nvme_cmbsz_register cmbsz = {};
+	union spdk_nvme_cmbloc_register cmbloc = {};
+	struct dev_mem_resource cmd_res = {};
+	int rc;
+
+	pctrlr.regs = &regs;
+	pctrlr.devhandle = (void *)&cmd_res;
+	cmd_res.addr = (void *)0x7f7c0080d000;
+	cmd_res.len = 0x800000;
+	cmd_res.phys_addr = 0xFC800000;
+	/* Configure cmb size with unit size 4k, offset 100, unsupported SQ */
+	cmbsz.bits.sz = 512;
+	cmbsz.bits.szu = 0;
+	cmbsz.bits.sqs = 0;
+	cmbloc.bits.bir = 0;
+	cmbloc.bits.ofst = 100;
+
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr, offsetof(struct spdk_nvme_registers, cmbsz.raw),
+				  cmbsz.raw);
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr, offsetof(struct spdk_nvme_registers, cmbloc.raw),
+				  cmbloc.raw);
+
+	nvme_pcie_ctrlr_map_cmb(&pctrlr);
+	CU_ASSERT(pctrlr.cmb.bar_va == (void *)0x7f7c0080d000);
+	CU_ASSERT(pctrlr.cmb.bar_pa == 0xFC800000);
+	CU_ASSERT(pctrlr.cmb.size == 512 * 4096);
+	CU_ASSERT(pctrlr.cmb.current_offset == 4096 * 100);
+	CU_ASSERT(pctrlr.ctrlr.opts.use_cmb_sqs == false);
+
+	rc = nvme_pcie_ctrlr_unmap_cmb(&pctrlr);
+	CU_ASSERT(rc == 0);
+
+	/* Invalid mapping information */
+	memset(&pctrlr.cmb, 0, sizeof(pctrlr.cmb));
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr, offsetof(struct spdk_nvme_registers, cmbsz.raw), 0);
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr, offsetof(struct spdk_nvme_registers, cmbloc.raw), 0);
+
+	nvme_pcie_ctrlr_map_cmb(&pctrlr);
+	CU_ASSERT(pctrlr.cmb.bar_va == NULL);
+	CU_ASSERT(pctrlr.cmb.bar_pa == 0);
+	CU_ASSERT(pctrlr.cmb.size == 0);
+	CU_ASSERT(pctrlr.cmb.current_offset == 0);
+	CU_ASSERT(pctrlr.ctrlr.opts.use_cmb_sqs == false);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -724,6 +816,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_prps_sgl_request);
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_hw_sgl_request);
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_contig_request);
+	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_regs_get_set);
+	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_map_unmap_cmb);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From f8ac678ec3fc5d416afde2d3fa0f9df60a9fb1c5 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Thu, 6 May 2021 20:49:36 +0800
Subject: [PATCH 056/342] lib/nvmf: Change the pdu_in_progress in tqpair to
 pointer.

This is used to prepare using the accel framework to calculate
the crc32 because some fields in this structure needs to be allocated
in DMA addressable memory.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: Ib8def5596e60f4702709da647145c4e2b6d6848f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7767
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvmf/tcp.c                    | 31 ++++++++++++++++---------------
 test/unit/lib/nvmf/tcp.c/tcp_ut.c |  9 +++++----
 2 files changed, 21 insertions(+), 19 deletions(-)

diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index 74e2e0d8e..cd684a015 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -223,7 +223,7 @@ struct spdk_nvmf_tcp_qpair {
 	enum nvme_tcp_qpair_state		state;
 
 	/* PDU being actively received */
-	struct nvme_tcp_pdu			pdu_in_progress;
+	struct nvme_tcp_pdu			*pdu_in_progress;
 
 	/* Queues to track the requests in all states */
 	TAILQ_HEAD(, spdk_nvmf_tcp_req)		tcp_req_working_queue;
@@ -909,7 +909,7 @@ nvmf_tcp_qpair_write_pdu(struct spdk_nvmf_tcp_qpair *tqpair,
 {
 	int hlen;
 
-	assert(&tqpair->pdu_in_progress != pdu);
+	assert(tqpair->pdu_in_progress != pdu);
 
 	hlen = pdu->hdr.common.hlen;
 	pdu->cb_fn = cb_fn;
@@ -960,8 +960,8 @@ nvmf_tcp_qpair_init_mem_resource(struct spdk_nvmf_tcp_qpair *tqpair)
 		}
 	}
 
-	/* Add addtional one member, which will be used for mgmt_pdu owned by the tqpair */
-	tqpair->pdus = spdk_dma_malloc((tqpair->resource_count + 1) * sizeof(*tqpair->pdus), 0x1000, NULL);
+	/* Add addtional 2 members, which will be used for mgmt_pdu and pdu_in_progress owned by the tqpair */
+	tqpair->pdus = spdk_dma_malloc((tqpair->resource_count + 2) * sizeof(*tqpair->pdus), 0x1000, NULL);
 	if (!tqpair->pdus) {
 		SPDK_ERRLOG("Unable to allocate pdu pool on tqpair =%p.\n", tqpair);
 		return -1;
@@ -993,6 +993,7 @@ nvmf_tcp_qpair_init_mem_resource(struct spdk_nvmf_tcp_qpair *tqpair)
 
 	tqpair->mgmt_pdu = &tqpair->pdus[i];
 	tqpair->mgmt_pdu->qpair = tqpair;
+	tqpair->pdu_in_progress = &tqpair->pdus[i + 1];
 
 	tqpair->recv_buf_size = (in_capsule_data_size + sizeof(struct spdk_nvme_tcp_cmd) + 2 *
 				 SPDK_NVME_TCP_DIGEST_LEN) * SPDK_NVMF_TCP_RECV_BUF_SIZE_FACTOR;
@@ -1271,7 +1272,7 @@ nvmf_tcp_qpair_set_recv_state(struct spdk_nvmf_tcp_qpair *tqpair,
 		break;
 	case NVME_TCP_PDU_RECV_STATE_ERROR:
 	case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY:
-		memset(&tqpair->pdu_in_progress, 0, sizeof(tqpair->pdu_in_progress));
+		memset(tqpair->pdu_in_progress, 0, sizeof(*(tqpair->pdu_in_progress)));
 		break;
 	default:
 		SPDK_ERRLOG("The state(%d) is invalid\n", state);
@@ -1671,7 +1672,7 @@ nvmf_tcp_pdu_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 	enum spdk_nvme_tcp_term_req_fes fes;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD);
-	pdu = &tqpair->pdu_in_progress;
+	pdu = tqpair->pdu_in_progress;
 
 	SPDK_DEBUGLOG(nvmf_tcp, "enter\n");
 	/* check data digest if need */
@@ -1790,7 +1791,7 @@ nvmf_tcp_pdu_psh_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 	enum spdk_nvme_tcp_term_req_fes fes;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH);
-	pdu = &tqpair->pdu_in_progress;
+	pdu = tqpair->pdu_in_progress;
 
 	SPDK_DEBUGLOG(nvmf_tcp, "pdu type of tqpair(%p) is %d\n", tqpair,
 		      pdu->hdr.common.pdu_type);
@@ -1824,7 +1825,7 @@ nvmf_tcp_pdu_psh_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 		break;
 
 	default:
-		SPDK_ERRLOG("Unexpected PDU type 0x%02x\n", tqpair->pdu_in_progress.hdr.common.pdu_type);
+		SPDK_ERRLOG("Unexpected PDU type 0x%02x\n", tqpair->pdu_in_progress->hdr.common.pdu_type);
 		fes = SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD;
 		error_offset = 1;
 		nvmf_tcp_send_c2h_term_req(tqpair, pdu, fes, error_offset);
@@ -1842,7 +1843,7 @@ nvmf_tcp_pdu_ch_handle(struct spdk_nvmf_tcp_qpair *tqpair)
 	bool plen_error = false, pdo_error = false;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_CH);
-	pdu = &tqpair->pdu_in_progress;
+	pdu = tqpair->pdu_in_progress;
 
 	if (pdu->hdr.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_IC_REQ) {
 		if (tqpair->state != NVME_TCP_QPAIR_STATE_INVALID) {
@@ -1918,7 +1919,7 @@ nvmf_tcp_pdu_ch_handle(struct spdk_nvmf_tcp_qpair *tqpair)
 		goto err;
 	} else {
 		nvmf_tcp_qpair_set_recv_state(tqpair, NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH);
-		nvme_tcp_pdu_calc_psh_len(&tqpair->pdu_in_progress, tqpair->host_hdgst_enable);
+		nvme_tcp_pdu_calc_psh_len(tqpair->pdu_in_progress, tqpair->host_hdgst_enable);
 		return;
 	}
 err:
@@ -1955,7 +1956,7 @@ nvmf_tcp_sock_process(struct spdk_nvmf_tcp_qpair *tqpair)
 		prev_state = tqpair->recv_state;
 		SPDK_DEBUGLOG(nvmf_tcp, "tqpair(%p) recv pdu entering state %d\n", tqpair, prev_state);
 
-		pdu = &tqpair->pdu_in_progress;
+		pdu = tqpair->pdu_in_progress;
 		switch (tqpair->recv_state) {
 		/* Wait for the common header  */
 		case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY:
@@ -2391,7 +2392,7 @@ nvmf_tcp_set_incapsule_data(struct spdk_nvmf_tcp_qpair *tqpair,
 	struct nvme_tcp_pdu *pdu;
 	uint32_t plen = 0;
 
-	pdu = &tqpair->pdu_in_progress;
+	pdu = tqpair->pdu_in_progress;
 	plen = pdu->hdr.common.hlen;
 
 	if (tqpair->host_hdgst_enable) {
@@ -2443,11 +2444,11 @@ nvmf_tcp_req_process(struct spdk_nvmf_tcp_transport *ttransport,
 			spdk_trace_record(TRACE_TCP_REQUEST_STATE_NEW, 0, 0, (uintptr_t)tcp_req, 0);
 
 			/* copy the cmd from the receive pdu */
-			tcp_req->cmd = tqpair->pdu_in_progress.hdr.capsule_cmd.ccsqe;
+			tcp_req->cmd = tqpair->pdu_in_progress->hdr.capsule_cmd.ccsqe;
 
 			if (spdk_unlikely(spdk_nvmf_request_get_dif_ctx(&tcp_req->req, &tcp_req->req.dif.dif_ctx))) {
 				tcp_req->req.dif.dif_insert_or_strip = true;
-				tqpair->pdu_in_progress.dif_ctx = &tcp_req->req.dif.dif_ctx;
+				tqpair->pdu_in_progress->dif_ctx = &tcp_req->req.dif.dif_ctx;
 			}
 
 			/* The next state transition depends on the data transfer needs of this request. */
@@ -2520,7 +2521,7 @@ nvmf_tcp_req_process(struct spdk_nvmf_tcp_transport *ttransport,
 
 					nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_TRANSFERRING_HOST_TO_CONTROLLER);
 
-					pdu = &tqpair->pdu_in_progress;
+					pdu = tqpair->pdu_in_progress;
 					SPDK_DEBUGLOG(nvmf_tcp, "Not need to send r2t for tcp_req(%p) on tqpair=%p\n", tcp_req,
 						      tqpair);
 					/* No need to send r2t, contained in the capsuled data */
diff --git a/test/unit/lib/nvmf/tcp.c/tcp_ut.c b/test/unit/lib/nvmf/tcp.c/tcp_ut.c
index f6a06ad3c..9ad670d62 100644
--- a/test/unit/lib/nvmf/tcp.c/tcp_ut.c
+++ b/test/unit/lib/nvmf/tcp.c/tcp_ut.c
@@ -682,7 +682,7 @@ test_nvmf_tcp_incapsule_data_handle(void)
 {
 	struct spdk_nvmf_tcp_transport ttransport = {};
 	struct spdk_nvmf_tcp_qpair tqpair = {};
-	struct nvme_tcp_pdu *pdu;
+	struct nvme_tcp_pdu *pdu, pdu_in_progress = {};
 	union nvmf_c2h_msg rsp0 = {};
 	union nvmf_c2h_msg rsp = {};
 
@@ -698,6 +698,7 @@ test_nvmf_tcp_incapsule_data_handle(void)
 	struct spdk_nvmf_tcp_poll_group tcp_group = {};
 	struct spdk_sock_group grp = {};
 
+	tqpair.pdu_in_progress = &pdu_in_progress;
 	ttransport.transport.opts.max_io_size = UT_MAX_IO_SIZE;
 	ttransport.transport.opts.io_unit_size = UT_IO_UNIT_SIZE;
 
@@ -733,7 +734,7 @@ test_nvmf_tcp_incapsule_data_handle(void)
 	tqpair.state_cntr[TCP_REQUEST_STATE_NEW]++;
 
 	/* init pdu, make pdu need sgl buff */
-	pdu = &tqpair.pdu_in_progress;
+	pdu = tqpair.pdu_in_progress;
 	capsule_data = &pdu->hdr.capsule_cmd;
 	nvmf_capsule_data = (struct spdk_nvmf_capsule_cmd *)&pdu->hdr.capsule_cmd.ccsqe;
 	sgl = &capsule_data->ccsqe.dptr.sgl1;
@@ -756,7 +757,7 @@ test_nvmf_tcp_incapsule_data_handle(void)
 	sgl->unkeyed.length = UT_IO_UNIT_SIZE - 1;
 
 	/* process tqpair capsule req. but we still remain req in pending_buff. */
-	nvmf_tcp_capsule_cmd_hdr_handle(&ttransport, &tqpair, &tqpair.pdu_in_progress);
+	nvmf_tcp_capsule_cmd_hdr_handle(&ttransport, &tqpair, tqpair.pdu_in_progress);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD);
 	CU_ASSERT(STAILQ_FIRST(&group->pending_buf_queue) == &tcp_req1.req);
 	STAILQ_FOREACH(req_temp, &group->pending_buf_queue, buf_link) {
@@ -765,7 +766,7 @@ test_nvmf_tcp_incapsule_data_handle(void)
 		}
 	}
 	CU_ASSERT(req_temp == NULL);
-	CU_ASSERT(tqpair.pdu_in_progress.req == (void *)&tcp_req2);
+	CU_ASSERT(tqpair.pdu_in_progress->req == (void *)&tcp_req2);
 }
 
 int main(int argc, char **argv)
-- 
2.26.2


From 82e4bfd346c23d94e7eb7e4878ff419e55937ae4 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Thu, 6 May 2021 22:13:11 +0800
Subject: [PATCH 057/342] nvme/tcp: Change the type of recv_pdu to pointer.

This is prepared for using the hardware offloading
engine in accel framework. And some fields in nvme_tcp_pdu
needs to be DMA addressable.

Change-Id: I75325e2cd7ff25fe938bea0ac9489a5027e3e0e9
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7770
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 lib/nvme/nvme_tcp.c                         | 27 +++----
 test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c | 82 +++++++++++----------
 2 files changed, 57 insertions(+), 52 deletions(-)

diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index 95b293c19..903e458ed 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -81,7 +81,7 @@ struct nvme_tcp_qpair {
 	TAILQ_HEAD(, nvme_tcp_req)		outstanding_reqs;
 
 	TAILQ_HEAD(, nvme_tcp_pdu)		send_queue;
-	struct nvme_tcp_pdu			recv_pdu;
+	struct nvme_tcp_pdu			*recv_pdu;
 	struct nvme_tcp_pdu			*send_pdu; /* only for error pdu and init pdu */
 	struct nvme_tcp_pdu			*send_pdus; /* Used by tcp_reqs */
 	enum nvme_tcp_pdu_recv_state		recv_state;
@@ -271,8 +271,8 @@ nvme_tcp_alloc_reqs(struct nvme_tcp_qpair *tqpair)
 		goto fail;
 	}
 
-	/* Add additional one member for the send_pdu owned by the tqpair */
-	tqpair->send_pdus = spdk_zmalloc((tqpair->num_entries + 1) * sizeof(struct nvme_tcp_pdu),
+	/* Add additional 2 member for the send_pdu, recv_pdu owned by the tqpair */
+	tqpair->send_pdus = spdk_zmalloc((tqpair->num_entries + 2) * sizeof(struct nvme_tcp_pdu),
 					 0x1000, NULL,
 					 SPDK_ENV_SOCKET_ID_ANY, SPDK_MALLOC_DMA);
 
@@ -293,6 +293,7 @@ nvme_tcp_alloc_reqs(struct nvme_tcp_qpair *tqpair)
 	}
 
 	tqpair->send_pdu = &tqpair->send_pdus[i];
+	tqpair->recv_pdu = &tqpair->send_pdus[i + 1];
 
 	return 0;
 fail:
@@ -819,7 +820,7 @@ nvme_tcp_qpair_set_recv_state(struct nvme_tcp_qpair *tqpair,
 	switch (state) {
 	case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY:
 	case NVME_TCP_PDU_RECV_STATE_ERROR:
-		memset(&tqpair->recv_pdu, 0, sizeof(struct nvme_tcp_pdu));
+		memset(tqpair->recv_pdu, 0, sizeof(struct nvme_tcp_pdu));
 		break;
 	case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_CH:
 	case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH:
@@ -882,7 +883,7 @@ nvme_tcp_pdu_ch_handle(struct nvme_tcp_qpair *tqpair)
 	uint32_t expected_hlen, hd_len = 0;
 	bool plen_error = false;
 
-	pdu = &tqpair->recv_pdu;
+	pdu = tqpair->recv_pdu;
 
 	SPDK_DEBUGLOG(nvme, "pdu type = %d\n", pdu->hdr.common.pdu_type);
 	if (pdu->hdr.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_IC_RESP) {
@@ -938,7 +939,7 @@ nvme_tcp_pdu_ch_handle(struct nvme_tcp_qpair *tqpair)
 			break;
 
 		default:
-			SPDK_ERRLOG("Unexpected PDU type 0x%02x\n", tqpair->recv_pdu.hdr.common.pdu_type);
+			SPDK_ERRLOG("Unexpected PDU type 0x%02x\n", tqpair->recv_pdu->hdr.common.pdu_type);
 			fes = SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD;
 			error_offset = offsetof(struct spdk_nvme_tcp_common_pdu_hdr, pdu_type);
 			goto err;
@@ -958,7 +959,7 @@ nvme_tcp_pdu_ch_handle(struct nvme_tcp_qpair *tqpair)
 		goto err;
 	} else {
 		nvme_tcp_qpair_set_recv_state(tqpair, NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH);
-		nvme_tcp_pdu_calc_psh_len(&tqpair->recv_pdu, tqpair->flags.host_hdgst_enable);
+		nvme_tcp_pdu_calc_psh_len(tqpair->recv_pdu, tqpair->flags.host_hdgst_enable);
 		return;
 	}
 err:
@@ -1050,7 +1051,7 @@ nvme_tcp_pdu_payload_handle(struct nvme_tcp_qpair *tqpair,
 	enum spdk_nvme_tcp_term_req_fes fes;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD);
-	pdu = &tqpair->recv_pdu;
+	pdu = tqpair->recv_pdu;
 
 	SPDK_DEBUGLOG(nvme, "enter\n");
 
@@ -1467,7 +1468,7 @@ nvme_tcp_pdu_psh_handle(struct nvme_tcp_qpair *tqpair, uint32_t *reaped)
 	enum spdk_nvme_tcp_term_req_fes fes;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH);
-	pdu = &tqpair->recv_pdu;
+	pdu = tqpair->recv_pdu;
 
 	SPDK_DEBUGLOG(nvme, "enter: pdu type =%u\n", pdu->hdr.common.pdu_type);
 	/* check header digest if needed */
@@ -1502,7 +1503,7 @@ nvme_tcp_pdu_psh_handle(struct nvme_tcp_qpair *tqpair, uint32_t *reaped)
 		break;
 
 	default:
-		SPDK_ERRLOG("Unexpected PDU type 0x%02x\n", tqpair->recv_pdu.hdr.common.pdu_type);
+		SPDK_ERRLOG("Unexpected PDU type 0x%02x\n", tqpair->recv_pdu->hdr.common.pdu_type);
 		fes = SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD;
 		error_offset = 1;
 		nvme_tcp_qpair_send_h2c_term_req(tqpair, pdu, fes, error_offset);
@@ -1529,7 +1530,7 @@ nvme_tcp_read_pdu(struct nvme_tcp_qpair *tqpair, uint32_t *reaped)
 			break;
 		/* common header */
 		case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_CH:
-			pdu = &tqpair->recv_pdu;
+			pdu = tqpair->recv_pdu;
 			if (pdu->ch_valid_bytes < sizeof(struct spdk_nvme_tcp_common_pdu_hdr)) {
 				rc = nvme_tcp_read_data(tqpair->sock,
 							sizeof(struct spdk_nvme_tcp_common_pdu_hdr) - pdu->ch_valid_bytes,
@@ -1550,7 +1551,7 @@ nvme_tcp_read_pdu(struct nvme_tcp_qpair *tqpair, uint32_t *reaped)
 			break;
 		/* Wait for the pdu specific header  */
 		case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH:
-			pdu = &tqpair->recv_pdu;
+			pdu = tqpair->recv_pdu;
 			rc = nvme_tcp_read_data(tqpair->sock,
 						pdu->psh_len - pdu->psh_valid_bytes,
 						(uint8_t *)&pdu->hdr.raw + sizeof(struct spdk_nvme_tcp_common_pdu_hdr) + pdu->psh_valid_bytes);
@@ -1569,7 +1570,7 @@ nvme_tcp_read_pdu(struct nvme_tcp_qpair *tqpair, uint32_t *reaped)
 			nvme_tcp_pdu_psh_handle(tqpair, reaped);
 			break;
 		case NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD:
-			pdu = &tqpair->recv_pdu;
+			pdu = tqpair->recv_pdu;
 			/* check whether the data is valid, if not we just return */
 			if (!pdu->data_len) {
 				return NVME_TCP_PDU_IN_PROGRESS;
diff --git a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
index 72c6067cf..dcd42e24c 100644
--- a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
+++ b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
@@ -800,6 +800,9 @@ test_nvme_tcp_qpair_set_recv_state(void)
 {
 	struct nvme_tcp_qpair tqpair = {};
 	enum nvme_tcp_pdu_recv_state state;
+	struct nvme_tcp_pdu recv_pdu = {};
+
+	tqpair.recv_pdu = &recv_pdu;
 
 	/* case1: The recv state of tqpair is same with the state to be set */
 	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_ERROR;
@@ -809,17 +812,17 @@ test_nvme_tcp_qpair_set_recv_state(void)
 
 	/* case2: The recv state of tqpair is different with the state to be set */
 	/* state is NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY or NVME_TCP_PDU_RECV_STATE_ERROR, tqpair->recv_pdu will be cleared */
-	tqpair.recv_pdu.cb_arg = (void *)0xDEADBEEF;
+	tqpair.recv_pdu->cb_arg = (void *)0xDEADBEEF;
 	state = NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY;
 	nvme_tcp_qpair_set_recv_state(&tqpair, state);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
-	CU_ASSERT(tqpair.recv_pdu.cb_arg == (void *)0x0);
+	CU_ASSERT(tqpair.recv_pdu->cb_arg == (void *)0x0);
 
-	tqpair.recv_pdu.cb_arg = (void *)0xDEADBEEF;
+	tqpair.recv_pdu->cb_arg = (void *)0xDEADBEEF;
 	state = NVME_TCP_PDU_RECV_STATE_ERROR;
 	nvme_tcp_qpair_set_recv_state(&tqpair, state);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
-	CU_ASSERT(tqpair.recv_pdu.cb_arg == (void *)0x0);
+	CU_ASSERT(tqpair.recv_pdu->cb_arg == (void *)0x0);
 
 	/* state is NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_CH or NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH or NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD or default */
 	state = NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_CH;
@@ -894,12 +897,12 @@ static void
 test_nvme_tcp_qpair_send_h2c_term_req(void)
 {
 	struct nvme_tcp_qpair tqpair = {};
-	struct nvme_tcp_pdu pdu = {};
-	struct nvme_tcp_pdu send_pdu = {};
+	struct nvme_tcp_pdu pdu = {}, recv_pdu = {}, send_pdu = {};
 	enum spdk_nvme_tcp_term_req_fes fes = SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD;
 	uint32_t error_offset = 1;
 
 	tqpair.send_pdu = &send_pdu;
+	tqpair.recv_pdu = &recv_pdu;
 	TAILQ_INIT(&tqpair.send_queue);
 	/* case1: hlen < SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE, Except: copy_len == hlen */
 	pdu.hdr.common.hlen = 64;
@@ -924,12 +927,13 @@ static void
 test_nvme_tcp_pdu_ch_handle(void)
 {
 	struct nvme_tcp_qpair tqpair = {};
-	struct nvme_tcp_pdu send_pdu = {};
+	struct nvme_tcp_pdu send_pdu = {}, recv_pdu = {};
 
 	tqpair.send_pdu = &send_pdu;
+	tqpair.recv_pdu = &recv_pdu;
 	TAILQ_INIT(&tqpair.send_queue);
 	/* case 1: Already received IC_RESP PDU. Expect: fail */
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
 	tqpair.state = NVME_TCP_QPAIR_STATE_INITIALIZING;
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
@@ -938,10 +942,10 @@ test_nvme_tcp_pdu_ch_handle(void)
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.plen == tqpair.send_pdu->hdr.term_req.common.hlen);
 
 	/* case 2: Expected PDU header length and received are different. Expect: fail */
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
 	tqpair.state = NVME_TCP_QPAIR_STATE_INVALID;
-	tqpair.recv_pdu.hdr.common.plen = sizeof(struct spdk_nvme_tcp_ic_resp);
-	tqpair.recv_pdu.hdr.common.hlen = 0;
+	tqpair.recv_pdu->hdr.common.plen = sizeof(struct spdk_nvme_tcp_ic_resp);
+	tqpair.recv_pdu->hdr.common.hlen = 0;
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -950,10 +954,10 @@ test_nvme_tcp_pdu_ch_handle(void)
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.fei[0] == 2);
 
 	/* case 3: The TCP/IP tqpair connection is not negotitated. Expect: fail */
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_CAPSULE_RESP;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_CAPSULE_RESP;
 	tqpair.state = NVME_TCP_QPAIR_STATE_INVALID;
-	tqpair.recv_pdu.hdr.common.plen = sizeof(struct spdk_nvme_tcp_ic_resp);
-	tqpair.recv_pdu.hdr.common.hlen = 0;
+	tqpair.recv_pdu->hdr.common.plen = sizeof(struct spdk_nvme_tcp_ic_resp);
+	tqpair.recv_pdu->hdr.common.hlen = 0;
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -961,10 +965,10 @@ test_nvme_tcp_pdu_ch_handle(void)
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.plen == tqpair.send_pdu->hdr.term_req.common.hlen);
 
 	/* case 4: Unexpected PDU type. Expect: fail */
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_REQ;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_REQ;
 	tqpair.state = NVME_TCP_QPAIR_STATE_RUNNING;
-	tqpair.recv_pdu.hdr.common.plen = 0;
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_ic_resp);
+	tqpair.recv_pdu->hdr.common.plen = 0;
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_ic_resp);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -973,10 +977,10 @@ test_nvme_tcp_pdu_ch_handle(void)
 		  (unsigned)SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE);
 
 	/* case 5: plen error. Expect: fail */
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
 	tqpair.state = NVME_TCP_QPAIR_STATE_INVALID;
-	tqpair.recv_pdu.hdr.common.plen = 0;
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_ic_resp);
+	tqpair.recv_pdu->hdr.common.plen = 0;
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_ic_resp);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -985,11 +989,11 @@ test_nvme_tcp_pdu_ch_handle(void)
 		  (unsigned)SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.fei[0] == 4);
 
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_CAPSULE_RESP;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_CAPSULE_RESP;
 	tqpair.state = NVME_TCP_QPAIR_STATE_RUNNING;
-	tqpair.recv_pdu.hdr.common.flags = SPDK_NVME_TCP_CH_FLAGS_HDGSTF;
-	tqpair.recv_pdu.hdr.common.plen = 0;
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_rsp);
+	tqpair.recv_pdu->hdr.common.flags = SPDK_NVME_TCP_CH_FLAGS_HDGSTF;
+	tqpair.recv_pdu->hdr.common.plen = 0;
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_rsp);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -998,11 +1002,11 @@ test_nvme_tcp_pdu_ch_handle(void)
 		  (unsigned)sizeof(struct spdk_nvme_tcp_term_req_hdr));
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.fei[0] == 4);
 
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_C2H_DATA;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_C2H_DATA;
 	tqpair.state = NVME_TCP_QPAIR_STATE_RUNNING;
-	tqpair.recv_pdu.hdr.common.plen = 0;
-	tqpair.recv_pdu.hdr.common.pdo = 64;
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_c2h_data_hdr);
+	tqpair.recv_pdu->hdr.common.plen = 0;
+	tqpair.recv_pdu->hdr.common.pdo = 64;
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_c2h_data_hdr);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -1011,10 +1015,10 @@ test_nvme_tcp_pdu_ch_handle(void)
 		  (unsigned)sizeof(struct spdk_nvme_tcp_term_req_hdr));
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.fei[0] == 4);
 
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ;
 	tqpair.state = NVME_TCP_QPAIR_STATE_RUNNING;
-	tqpair.recv_pdu.hdr.common.plen = 0;
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_term_req_hdr);
+	tqpair.recv_pdu->hdr.common.plen = 0;
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_term_req_hdr);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -1023,11 +1027,11 @@ test_nvme_tcp_pdu_ch_handle(void)
 		  (unsigned)sizeof(struct spdk_nvme_tcp_term_req_hdr));
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.fei[0] == 4);
 
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_R2T;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_R2T;
 	tqpair.state = NVME_TCP_QPAIR_STATE_RUNNING;
-	tqpair.recv_pdu.hdr.common.flags = SPDK_NVME_TCP_CH_FLAGS_HDGSTF;
-	tqpair.recv_pdu.hdr.common.plen = 0;
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_r2t_hdr);
+	tqpair.recv_pdu->hdr.common.flags = SPDK_NVME_TCP_CH_FLAGS_HDGSTF;
+	tqpair.recv_pdu->hdr.common.plen = 0;
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_r2t_hdr);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
@@ -1037,13 +1041,13 @@ test_nvme_tcp_pdu_ch_handle(void)
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.fei[0] == 4);
 
 	/* case 6: Expect:  PASS */
-	tqpair.recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
+	tqpair.recv_pdu->hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_IC_RESP;
 	tqpair.state = NVME_TCP_QPAIR_STATE_INVALID;
-	tqpair.recv_pdu.hdr.common.plen = sizeof(struct spdk_nvme_tcp_ic_resp);
-	tqpair.recv_pdu.hdr.common.hlen = sizeof(struct spdk_nvme_tcp_ic_resp);
+	tqpair.recv_pdu->hdr.common.plen = sizeof(struct spdk_nvme_tcp_ic_resp);
+	tqpair.recv_pdu->hdr.common.hlen = sizeof(struct spdk_nvme_tcp_ic_resp);
 	nvme_tcp_pdu_ch_handle(&tqpair);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH);
-	CU_ASSERT(tqpair.recv_pdu.psh_len == tqpair.recv_pdu.hdr.common.hlen - sizeof(
+	CU_ASSERT(tqpair.recv_pdu->psh_len == tqpair.recv_pdu->hdr.common.hlen - sizeof(
 			  struct spdk_nvme_tcp_common_pdu_hdr));
 }
 
-- 
2.26.2


From af7296551980f28f4f7395c8869df2cdcd23bdaf Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Tue, 4 May 2021 07:11:53 +0000
Subject: [PATCH 058/342] bdev/fio_plugin: fix scan-build error

spdk_fio_init_thread() assigns td->io_ops_data.
spdk_fio_init_thread() can return an error, but currently lacks error
handling code.

Add error handling code, and add an assertion that fio_thread
(td->io_ops_data) is assigned when spdk_fio_init_thread() didn't return
an error.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: I8de7d59db0373599c90aa57fffa476c6707b6104
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7732
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/bdev/fio_plugin/fio_plugin.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index 8d82e0363..8b12d3b26 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -539,10 +539,15 @@ static int
 spdk_fio_init(struct thread_data *td)
 {
 	struct spdk_fio_thread *fio_thread;
+	int rc;
 
-	spdk_fio_init_thread(td);
+	rc = spdk_fio_init_thread(td);
+	if (rc) {
+		return rc;
+	}
 
 	fio_thread = td->io_ops_data;
+	assert(fio_thread);
 	fio_thread->failed = false;
 
 	spdk_thread_send_msg(fio_thread->thread, spdk_fio_bdev_open, td);
-- 
2.26.2


From 36728cd80d8ee47a481689fd384bf9fdc881369a Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Mon, 3 May 2021 10:49:15 +0000
Subject: [PATCH 059/342] bdev/fio_plugin: implement callbacks needed for fio
 --zonemode=zbd

Implement callbacks needed for fio --zonemode=zbd, so that we can use fio
to exercise the bdev-zone layer in SPDK.

spdk_fio_report_zones() will be called before SPDK normally initializes
the threads.

spdk_fio_report_zones() simply initializes its spdk thread when called.
Threads not running against a zoned block device are not affected.

Each spdk thread is still destroyed after the fio run has completed,
as normal. If spdk_fio_report_zones() encounters an error, we have
to call spdk_fio_cleanup() so that the thread is added to the global
list of spdk threads that are cleaned up after main loop exit.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: Ia094eae8c9e44d8cfc66a5d9b7100f09f9db456a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7725
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/bdev/fio_plugin/fio_plugin.c | 267 ++++++++++++++++++++++++++
 1 file changed, 267 insertions(+)

diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index 8b12d3b26..fa19f7fbc 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -34,6 +34,7 @@
 #include "spdk/stdinc.h"
 
 #include "spdk/bdev.h"
+#include "spdk/bdev_zone.h"
 #include "spdk/accel_engine.h"
 #include "spdk/env.h"
 #include "spdk/thread.h"
@@ -48,6 +49,12 @@
 #include "fio.h"
 #include "optgroup.h"
 
+#ifdef for_each_rw_ddir
+#define FIO_HAS_ZBD (FIO_IOOPS_VERSION >= 26)
+#else
+#define FIO_HAS_ZBD (0)
+#endif
+
 /* FreeBSD is missing CLOCK_MONOTONIC_RAW,
  * so alternative is provided. */
 #ifndef CLOCK_MONOTONIC_RAW /* Defined in glibc bits/time.h */
@@ -89,6 +96,15 @@ struct spdk_fio_thread {
 	TAILQ_ENTRY(spdk_fio_thread)	link;
 };
 
+struct spdk_fio_zone_cb_arg {
+	struct spdk_fio_target *target;
+	struct spdk_bdev_zone_info *spdk_zones;
+	int completed;
+	uint64_t offset_blocks;
+	struct zbd_zone *fio_zones;
+	unsigned int nr_zones;
+};
+
 static bool g_spdk_env_initialized = false;
 static const char *g_json_config_file = NULL;
 
@@ -534,6 +550,12 @@ spdk_fio_bdev_open(void *arg)
 
 /* Called for each thread, on that thread, shortly after the thread
  * starts.
+ *
+ * Also called by spdk_fio_report_zones(), since we need an I/O channel
+ * in order to get the zone report. (fio calls the .report_zones callback
+ * before it calls the .init callback.)
+ * Therefore, if fio was run with --zonemode=zbd, the thread will already
+ * be initialized by the time that fio calls the .init callback.
  */
 static int
 spdk_fio_init(struct thread_data *td)
@@ -541,6 +563,11 @@ spdk_fio_init(struct thread_data *td)
 	struct spdk_fio_thread *fio_thread;
 	int rc;
 
+	/* If thread has already been initialized, do nothing. */
+	if (td->io_ops_data) {
+		return 0;
+	}
+
 	rc = spdk_fio_init_thread(td);
 	if (rc) {
 		return rc;
@@ -760,6 +787,241 @@ spdk_fio_invalidate(struct thread_data *td, struct fio_file *f)
 	return 0;
 }
 
+#if FIO_HAS_ZBD
+static int
+spdk_fio_get_zoned_model(struct thread_data *td, struct fio_file *f, enum zbd_zoned_model *model)
+{
+	struct spdk_bdev *bdev;
+
+	bdev = spdk_bdev_get_by_name(f->file_name);
+	if (!bdev) {
+		SPDK_ERRLOG("Cannot get zoned model, no bdev with name: %s\n", f->file_name);
+		return -ENODEV;
+	}
+
+	if (spdk_bdev_is_zoned(bdev)) {
+		*model = ZBD_HOST_MANAGED;
+	} else {
+		*model = ZBD_NONE;
+	}
+
+	return 0;
+}
+
+static void
+spdk_fio_bdev_get_zone_info_done(struct spdk_bdev_io *bdev_io, bool success, void *arg)
+{
+	struct spdk_fio_zone_cb_arg *cb_arg = arg;
+	unsigned int i;
+	int handled_zones = 0;
+
+	if (!success) {
+		spdk_bdev_free_io(bdev_io);
+		cb_arg->completed = -EIO;
+		return;
+	}
+
+	for (i = 0; i < cb_arg->nr_zones; i++) {
+		struct spdk_bdev_zone_info *zone_src = &cb_arg->spdk_zones[handled_zones];
+		struct zbd_zone *zone_dest = &cb_arg->fio_zones[handled_zones];
+		uint32_t block_size = spdk_bdev_get_block_size(cb_arg->target->bdev);
+
+		zone_dest->type = ZBD_ZONE_TYPE_SWR;
+		zone_dest->len = spdk_bdev_get_zone_size(cb_arg->target->bdev) * block_size;
+		zone_dest->capacity = zone_src->capacity * block_size;
+		zone_dest->start = zone_src->zone_id * block_size;
+		zone_dest->wp = zone_src->write_pointer * block_size;
+
+		switch (zone_src->state) {
+		case SPDK_BDEV_ZONE_STATE_EMPTY:
+			zone_dest->cond = ZBD_ZONE_COND_EMPTY;
+			break;
+		case SPDK_BDEV_ZONE_STATE_IMP_OPEN:
+			zone_dest->cond = ZBD_ZONE_COND_IMP_OPEN;
+			break;
+		case SPDK_BDEV_ZONE_STATE_EXP_OPEN:
+			zone_dest->cond = ZBD_ZONE_COND_EXP_OPEN;
+			break;
+		case SPDK_BDEV_ZONE_STATE_FULL:
+			zone_dest->cond = ZBD_ZONE_COND_FULL;
+			break;
+		case SPDK_BDEV_ZONE_STATE_CLOSED:
+			zone_dest->cond = ZBD_ZONE_COND_CLOSED;
+			break;
+		case SPDK_BDEV_ZONE_STATE_READ_ONLY:
+			zone_dest->cond = ZBD_ZONE_COND_READONLY;
+			break;
+		case SPDK_BDEV_ZONE_STATE_OFFLINE:
+			zone_dest->cond = ZBD_ZONE_COND_OFFLINE;
+			break;
+		default:
+			spdk_bdev_free_io(bdev_io);
+			cb_arg->completed = -EIO;
+			return;
+		}
+		handled_zones++;
+	}
+
+	spdk_bdev_free_io(bdev_io);
+	cb_arg->completed = handled_zones;
+}
+
+static void
+spdk_fio_bdev_get_zone_info(void *arg)
+{
+	struct spdk_fio_zone_cb_arg *cb_arg = arg;
+	struct spdk_fio_target *target = cb_arg->target;
+	int rc;
+
+	rc = spdk_bdev_get_zone_info(target->desc, target->ch, cb_arg->offset_blocks,
+				     cb_arg->nr_zones, cb_arg->spdk_zones,
+				     spdk_fio_bdev_get_zone_info_done, cb_arg);
+	if (rc < 0) {
+		cb_arg->completed = rc;
+	}
+}
+
+static int
+spdk_fio_report_zones(struct thread_data *td, struct fio_file *f, uint64_t offset,
+		      struct zbd_zone *zones, unsigned int nr_zones)
+{
+	struct spdk_fio_target *target;
+	struct spdk_fio_thread *fio_thread;
+	struct spdk_fio_zone_cb_arg cb_arg;
+	uint32_t block_size;
+	int rc;
+
+	if (nr_zones == 0) {
+		return 0;
+	}
+
+	/* spdk_fio_report_zones() is only called before the bdev I/O channels have been created.
+	 * Since we need an I/O channel for report_zones(), call spdk_fio_init() to initialize
+	 * the thread early.
+	 * spdk_fio_report_zones() might be called several times by fio, if e.g. the zone report
+	 * for all zones does not fit in the buffer that fio has allocated for the zone report.
+	 * It is safe to call spdk_fio_init(), even if the thread has already been initialized.
+	 */
+	rc = spdk_fio_init(td);
+	if (rc) {
+		return rc;
+	}
+	fio_thread = td->io_ops_data;
+	target = f->engine_data;
+
+	assert(fio_thread);
+	assert(target);
+
+	block_size = spdk_bdev_get_block_size(target->bdev);
+
+	cb_arg.target = target;
+	cb_arg.completed = 0;
+	cb_arg.offset_blocks = offset / block_size;
+	cb_arg.fio_zones = zones;
+	cb_arg.nr_zones = spdk_min(nr_zones, spdk_bdev_get_num_zones(target->bdev));
+
+	cb_arg.spdk_zones = calloc(1, sizeof(*cb_arg.spdk_zones) * cb_arg.nr_zones);
+	if (!cb_arg.spdk_zones) {
+		SPDK_ERRLOG("Could not allocate memory for zone report!\n");
+		rc = -ENOMEM;
+		goto cleanup_thread;
+	}
+
+	spdk_thread_send_msg(fio_thread->thread, spdk_fio_bdev_get_zone_info, &cb_arg);
+	do {
+		spdk_fio_poll_thread(fio_thread);
+	} while (!cb_arg.completed);
+
+	/* Free cb_arg.spdk_zones. The report in fio format is stored in cb_arg.fio_zones/zones. */
+	free(cb_arg.spdk_zones);
+
+	rc = cb_arg.completed;
+	if (rc < 0) {
+		SPDK_ERRLOG("Failed to get zone info: %d\n", rc);
+		goto cleanup_thread;
+	}
+
+	/* Return the amount of zones successfully copied. */
+	return rc;
+
+cleanup_thread:
+	spdk_fio_cleanup(td);
+
+	return rc;
+}
+
+static void
+spdk_fio_bdev_zone_reset_done(struct spdk_bdev_io *bdev_io, bool success, void *arg)
+{
+	struct spdk_fio_zone_cb_arg *cb_arg = arg;
+
+	spdk_bdev_free_io(bdev_io);
+
+	if (!success) {
+		cb_arg->completed = -EIO;
+	} else {
+		cb_arg->completed = 1;
+	}
+}
+
+static void
+spdk_fio_bdev_zone_reset(void *arg)
+{
+	struct spdk_fio_zone_cb_arg *cb_arg = arg;
+	struct spdk_fio_target *target = cb_arg->target;
+	int rc;
+
+	rc = spdk_bdev_zone_management(target->desc, target->ch, cb_arg->offset_blocks,
+				       SPDK_BDEV_ZONE_RESET,
+				       spdk_fio_bdev_zone_reset_done, cb_arg);
+	if (rc < 0) {
+		cb_arg->completed = rc;
+	}
+}
+
+static int
+spdk_fio_reset_zones(struct spdk_fio_thread *fio_thread, struct spdk_fio_target *target,
+		     uint64_t offset, uint64_t length)
+{
+	uint64_t zone_size_bytes;
+	uint32_t block_size;
+	int rc;
+
+	assert(fio_thread);
+	assert(target);
+
+	block_size = spdk_bdev_get_block_size(target->bdev);
+	zone_size_bytes = spdk_bdev_get_zone_size(target->bdev) * block_size;
+
+	for (uint64_t cur = offset; cur < offset + length; cur += zone_size_bytes) {
+		struct spdk_fio_zone_cb_arg cb_arg = {
+			.target = target,
+			.completed = 0,
+			.offset_blocks = cur / block_size,
+		};
+
+		spdk_thread_send_msg(fio_thread->thread, spdk_fio_bdev_zone_reset, &cb_arg);
+		do {
+			spdk_fio_poll_thread(fio_thread);
+		} while (!cb_arg.completed);
+
+		rc = cb_arg.completed;
+		if (rc < 0) {
+			SPDK_ERRLOG("Failed to reset zone: %d\n", rc);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int
+spdk_fio_reset_wp(struct thread_data *td, struct fio_file *f, uint64_t offset, uint64_t length)
+{
+	return spdk_fio_reset_zones(td->io_ops_data, f->engine_data, offset, length);
+}
+#endif
+
 static struct fio_option options[] = {
 	{
 		.name		= "spdk_conf",
@@ -828,6 +1090,11 @@ struct ioengine_ops ioengine = {
 	.iomem_free		= spdk_fio_iomem_free,
 	.io_u_init		= spdk_fio_io_u_init,
 	.io_u_free		= spdk_fio_io_u_free,
+#if FIO_HAS_ZBD
+	.get_zoned_model	= spdk_fio_get_zoned_model,
+	.report_zones		= spdk_fio_report_zones,
+	.reset_wp		= spdk_fio_reset_wp,
+#endif
 	.option_struct_size	= sizeof(struct spdk_fio_options),
 	.options		= options,
 };
-- 
2.26.2


From e3997dc23b212aa7b3c1ad73d517e3c92a68dbbf Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Mon, 3 May 2021 14:48:25 +0000
Subject: [PATCH 060/342] bdev/fio_plugin: add support for --initial_zone_reset

--initial_zone_reset has to be done before fio creates its threads.
Since --zonemode=zbd only supports --create_serialize=1 (default),
this is possible.

Since this requires an I/O channel, and is called before threads
are created, follow the same pattern as spdk_fio_report_zones()
and simply initialize the thread early if this option is used.

Just like spdk_fio_report_zones(), thread cleanup has to be
called explicitly in case of error. (Since fio will only call
.cleanup() on threads that it has called .init() on.)

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: I7d4dedce88309e4c6e5800ed3d56cd5ccb297551
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7726
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/bdev/fio_plugin/fio_plugin.c | 42 +++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index fa19f7fbc..9f5b32b9b 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -67,6 +67,7 @@ struct spdk_fio_options {
 	char *json_conf;
 	unsigned mem_mb;
 	int mem_single_seg;
+	int initial_zone_reset;
 };
 
 struct spdk_fio_request {
@@ -111,6 +112,8 @@ static const char *g_json_config_file = NULL;
 static int spdk_fio_init(struct thread_data *td);
 static void spdk_fio_cleanup(struct thread_data *td);
 static size_t spdk_fio_poll_thread(struct spdk_fio_thread *fio_thread);
+static int spdk_fio_handle_options(struct thread_data *td, struct fio_file *f,
+				   struct spdk_bdev *bdev);
 
 static pthread_t g_init_thread_id = 0;
 static pthread_mutex_t g_init_mtx = PTHREAD_MUTEX_INITIALIZER;
@@ -471,6 +474,7 @@ spdk_fio_setup(struct thread_data *td)
 
 	for_each_file(td, f, i) {
 		struct spdk_bdev *bdev;
+		int rc;
 
 		if (strcmp(f->file_name, "*") == 0) {
 			continue;
@@ -485,6 +489,10 @@ spdk_fio_setup(struct thread_data *td)
 		f->real_file_size = spdk_bdev_get_num_blocks(bdev) *
 				    spdk_bdev_get_block_size(bdev);
 
+		rc = spdk_fio_handle_options(td, f, bdev);
+		if (rc) {
+			return rc;
+		}
 	}
 
 	return 0;
@@ -1022,6 +1030,30 @@ spdk_fio_reset_wp(struct thread_data *td, struct fio_file *f, uint64_t offset, u
 }
 #endif
 
+static int
+spdk_fio_handle_options(struct thread_data *td, struct fio_file *f, struct spdk_bdev *bdev)
+{
+	struct spdk_fio_options *fio_options = td->eo;
+
+	if (fio_options->initial_zone_reset && spdk_bdev_is_zoned(bdev)) {
+#if FIO_HAS_ZBD
+		int rc = spdk_fio_init(td);
+		if (rc) {
+			return rc;
+		}
+		rc = spdk_fio_reset_zones(td->io_ops_data, f->engine_data, 0, f->real_file_size);
+		if (rc) {
+			spdk_fio_cleanup(td);
+			return rc;
+		}
+#else
+		SPDK_ERRLOG("fio version is too old to support zoned block devices\n");
+#endif
+	}
+
+	return 0;
+}
+
 static struct fio_option options[] = {
 	{
 		.name		= "spdk_conf",
@@ -1060,6 +1092,16 @@ static struct fio_option options[] = {
 		.category	= FIO_OPT_C_ENGINE,
 		.group		= FIO_OPT_G_INVALID,
 	},
+	{
+		.name		= "initial_zone_reset",
+		.lname		= "Reset Zones on initialization",
+		.type		= FIO_OPT_INT,
+		.off1		= offsetof(struct spdk_fio_options, initial_zone_reset),
+		.def		= "0",
+		.help		= "Reset Zones on initialization (0=disable, 1=Reset All Zones)",
+		.category	= FIO_OPT_C_ENGINE,
+		.group		= FIO_OPT_G_INVALID,
+	},
 	{
 		.name		= NULL,
 	},
-- 
2.26.2


From cf41deae8b473010452eb9bb1e86a1f713a0fc15 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Sat, 8 May 2021 06:03:58 +0800
Subject: [PATCH 061/342] idxd: update the major so version for libspdk_idxd

Change-Id: I6ad71a65244526e99a36920c630096cc9739d94d
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7809
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/idxd/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/idxd/Makefile b/lib/idxd/Makefile
index dde83af2c..1c3178d76 100644
--- a/lib/idxd/Makefile
+++ b/lib/idxd/Makefile
@@ -34,7 +34,7 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-SO_VER := 4
+SO_VER := 5
 SO_MINOR := 0
 
 C_SRCS = idxd.c idxd_user.c
-- 
2.26.2


From a7c37873b40e7b1b1054eafcaa7c80ac493f68d4 Mon Sep 17 00:00:00 2001
From: Konrad Sztyber <konrad.sztyber@intel.com>
Date: Wed, 28 Apr 2021 14:27:05 +0200
Subject: [PATCH 062/342] module/zone_block: don't align size to optimal open
 zones

There's no good reason to reduce the capacity by aligning it to the
number of optimal open zones.  If such alignment is required by the
users of the zone block bdev, it should be done on their own layer.

Signed-off-by: Konrad Sztyber <konrad.sztyber@intel.com>
Change-Id: Ic8614a82715e9f064619aa8fdb75d1a0b851490c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7656
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Niklas Cassel <niklas.cassel@wdc.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 module/bdev/zone_block/vbdev_zone_block.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/module/bdev/zone_block/vbdev_zone_block.c b/module/bdev/zone_block/vbdev_zone_block.c
index d6fd296d0..81a9dc33e 100644
--- a/module/bdev/zone_block/vbdev_zone_block.c
+++ b/module/bdev/zone_block/vbdev_zone_block.c
@@ -776,8 +776,6 @@ zone_block_register(const char *base_bdev_name)
 		bdev_node->zone_shift = spdk_u64log2(zone_size);
 		bdev_node->num_zones = base_bdev->blockcnt / zone_size;
 
-		/* Align num_zones to optimal_open_zones */
-		bdev_node->num_zones -= bdev_node->num_zones % name->optimal_open_zones;
 		bdev_node->zones = calloc(bdev_node->num_zones, sizeof(struct block_zone));
 		if (!bdev_node->zones) {
 			rc = -ENOMEM;
-- 
2.26.2


From 4e0ca20a8aa02f26ad3327749de7c10c8ddcb47d Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 13 Apr 2021 19:30:07 +0800
Subject: [PATCH 063/342] idxd: Do not present pci device info in
 accel_engine_idxd.c module

Purpose: We will also support the kernel idxd driver, so we do not
need export this feature in the module file.

Change-Id: I965e031497920f527962ba187bccd81de6977b8f
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7336
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 CHANGELOG.md                                  |  5 ++
 include/spdk/idxd.h                           | 17 +------
 lib/idxd/idxd.c                               |  4 +-
 lib/idxd/idxd.h                               |  3 +-
 lib/idxd/idxd_user.c                          | 43 ++++++++++++++---
 module/accel/idxd/accel_engine_idxd.c         | 48 +------------------
 test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c | 13 +++++
 7 files changed, 61 insertions(+), 72 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5c76c4126..d3cbf94f5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,11 @@
 
 ## v21.07: (Upcoming Release)
 
+### idxd
+
+Remove the probe_cb parameter in spdk_idxd_probe function. And remove the definition
+of spdk_idxd_probe_cb function pointer. It should be implemented in idxd_user.c.
+
 ## v21.04:
 
 ### accel
diff --git a/include/spdk/idxd.h b/include/spdk/idxd.h
index b7674627e..4ff0e05d8 100644
--- a/include/spdk/idxd.h
+++ b/include/spdk/idxd.h
@@ -86,26 +86,14 @@ int spdk_idxd_reconfigure_chan(struct spdk_idxd_io_channel *chan);
  */
 typedef void (*spdk_idxd_req_cb)(void *arg, int status);
 
-/**
- * Callback for spdk_idxd_probe() enumeration.
- *
- * \param cb_ctx User-specified opaque value corresponding to cb_ctx from spdk_idxd_probe().
- * \param pci_dev PCI device that is being probed.
- *
- * \return true to attach to this device.
- */
-typedef bool (*spdk_idxd_probe_cb)(void *cb_ctx, struct spdk_pci_device *pci_dev);
-
 /**
  * Callback for spdk_idxd_probe() to report a device that has been attached to
  * the userspace IDXD driver.
  *
  * \param cb_ctx User-specified opaque value corresponding to cb_ctx from spdk_idxd_probe().
- * \param pci_dev PCI device that was attached to the driver.
  * \param idxd IDXD device that was attached to the driver.
  */
-typedef void (*spdk_idxd_attach_cb)(void *cb_ctx, struct spdk_pci_device *pci_dev,
-				    struct spdk_idxd_device *idxd);
+typedef void (*spdk_idxd_attach_cb)(void *cb_ctx, struct spdk_idxd_device *idxd);
 
 /**
  * Enumerate the IDXD devices attached to the system and attach the userspace
@@ -119,13 +107,12 @@ typedef void (*spdk_idxd_attach_cb)(void *cb_ctx, struct spdk_pci_device *pci_de
  *
  * \param cb_ctx Opaque value which will be passed back in cb_ctx parameter of
  * the callbacks.
- * \param probe_cb will be called once per IDXD device found in the system.
  * \param attach_cb will be called for devices for which probe_cb returned true
  * once the IDXD controller has been attached to the userspace driver.
  *
  * \return 0 on success, -1 on failure.
  */
-int spdk_idxd_probe(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb);
+int spdk_idxd_probe(void *cb_ctx, spdk_idxd_attach_cb attach_cb);
 
 /**
  * Detach specified device returned by spdk_idxd_probe() from the IDXD driver.
diff --git a/lib/idxd/idxd.c b/lib/idxd/idxd.c
index 69bd2a047..5e1fbe1ba 100644
--- a/lib/idxd/idxd.c
+++ b/lib/idxd/idxd.c
@@ -353,14 +353,14 @@ idxd_device_destruct(struct spdk_idxd_device *idxd)
 }
 
 int
-spdk_idxd_probe(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb)
+spdk_idxd_probe(void *cb_ctx, spdk_idxd_attach_cb attach_cb)
 {
 	if (g_idxd_impl == NULL) {
 		SPDK_ERRLOG("No idxd impl is selected\n");
 		return -1;
 	}
 
-	return g_idxd_impl->probe(cb_ctx, probe_cb, attach_cb);
+	return g_idxd_impl->probe(cb_ctx, attach_cb);
 }
 
 void
diff --git a/lib/idxd/idxd.h b/lib/idxd/idxd.h
index 1fb45a953..9ee8e817c 100644
--- a/lib/idxd/idxd.h
+++ b/lib/idxd/idxd.h
@@ -181,7 +181,7 @@ struct idxd_wq {
 struct spdk_idxd_impl {
 	const char *name;
 	void (*set_config)(struct device_config *g_dev_cfg, uint32_t config_num);
-	int (*probe)(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb);
+	int (*probe)(void *cb_ctx, spdk_idxd_attach_cb attach_cb);
 	void (*destruct)(struct spdk_idxd_device *idxd);
 	uint64_t (*read_8)(struct spdk_idxd_device *idxd, void *portal, uint32_t offset);
 	char *(*portal_get_addr)(struct spdk_idxd_device *idxd);
@@ -192,7 +192,6 @@ struct spdk_idxd_impl {
 };
 
 struct spdk_idxd_device {
-	struct spdk_pci_device		*device;
 	struct spdk_idxd_impl		*impl;
 	void				*portals;
 	int				wq_id;
diff --git a/lib/idxd/idxd_user.c b/lib/idxd/idxd_user.c
index 16dbb6285..04262f88a 100644
--- a/lib/idxd/idxd_user.c
+++ b/lib/idxd/idxd_user.c
@@ -46,6 +46,7 @@
 
 struct spdk_user_idxd_device {
 	struct spdk_idxd_device	idxd;
+	struct spdk_pci_device	*device;
 	int			sock_id;
 	struct idxd_registers	registers;
 	void			*reg_base;
@@ -56,6 +57,8 @@ struct spdk_user_idxd_device {
 	uint32_t                        perfmon_offset;
 };
 
+typedef bool (*spdk_idxd_probe_cb)(void *cb_ctx, struct spdk_pci_device *pci_dev);
+
 #define __user_idxd(idxd) (struct spdk_user_idxd_device *)idxd
 
 pthread_mutex_t	g_driver_lock = PTHREAD_MUTEX_INITIALIZER;
@@ -149,7 +152,7 @@ idxd_unmap_pci_bar(struct spdk_idxd_device *idxd, int bar)
 	}
 
 	if (addr) {
-		rc = spdk_pci_device_unmap_bar(idxd->device, 0, addr);
+		rc = spdk_pci_device_unmap_bar(user_idxd->device, 0, addr);
 	}
 	return rc;
 }
@@ -162,14 +165,14 @@ idxd_map_pci_bars(struct spdk_idxd_device *idxd)
 	uint64_t phys_addr, size;
 	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
 
-	rc = spdk_pci_device_map_bar(idxd->device, IDXD_MMIO_BAR, &addr, &phys_addr, &size);
+	rc = spdk_pci_device_map_bar(user_idxd->device, IDXD_MMIO_BAR, &addr, &phys_addr, &size);
 	if (rc != 0 || addr == NULL) {
 		SPDK_ERRLOG("pci_device_map_range failed with error code %d\n", rc);
 		return -1;
 	}
 	user_idxd->reg_base = addr;
 
-	rc = spdk_pci_device_map_bar(idxd->device, IDXD_WQ_BAR, &addr, &phys_addr, &size);
+	rc = spdk_pci_device_map_bar(user_idxd->device, IDXD_WQ_BAR, &addr, &phys_addr, &size);
 	if (rc != 0 || addr == NULL) {
 		SPDK_ERRLOG("pci_device_map_range failed with error code %d\n", rc);
 		rc = idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
@@ -422,12 +425,15 @@ err_reset:
 static void
 user_idxd_device_destruct(struct spdk_idxd_device *idxd)
 {
+	struct spdk_user_idxd_device *user_idxd = __user_idxd(idxd);
+
 	idxd_unmap_pci_bar(idxd, IDXD_MMIO_BAR);
 	idxd_unmap_pci_bar(idxd, IDXD_WQ_BAR);
 	free(idxd->groups);
 	free(idxd->queues);
 
-	free(idxd);
+	spdk_pci_device_detach(user_idxd->device);
+	free(user_idxd);
 }
 
 struct idxd_enum_ctx {
@@ -450,14 +456,37 @@ idxd_enum_cb(void *ctx, struct spdk_pci_device *pci_dev)
 			return -EINVAL;
 		}
 
-		enum_ctx->attach_cb(enum_ctx->cb_ctx, pci_dev, idxd);
+		enum_ctx->attach_cb(enum_ctx->cb_ctx, idxd);
 	}
 
 	return 0;
 }
 
+
+static bool
+probe_cb(void *cb_ctx, struct spdk_pci_device *pci_dev)
+{
+	struct spdk_pci_addr pci_addr = spdk_pci_device_get_addr(pci_dev);
+
+	SPDK_NOTICELOG(
+		" Found matching device at %04x:%02x:%02x.%x vendor:0x%04x device:0x%04x\n",
+		pci_addr.domain,
+		pci_addr.bus,
+		pci_addr.dev,
+		pci_addr.func,
+		spdk_pci_device_get_vendor_id(pci_dev),
+		spdk_pci_device_get_device_id(pci_dev));
+
+	/* Claim the device in case conflict with other process */
+	if (spdk_pci_device_claim(pci_dev) < 0) {
+		return false;
+	}
+
+	return true;
+}
+
 static int
-user_idxd_probe(void *cb_ctx, spdk_idxd_probe_cb probe_cb, spdk_idxd_attach_cb attach_cb)
+user_idxd_probe(void *cb_ctx, spdk_idxd_attach_cb attach_cb)
 {
 	int rc;
 	struct idxd_enum_ctx enum_ctx;
@@ -518,8 +547,8 @@ idxd_attach(struct spdk_pci_device *device)
 	}
 
 	idxd = &user_idxd->idxd;
+	user_idxd->device = device;
 	idxd->impl = &g_user_idxd_impl;
-	idxd->device = device;
 	pthread_mutex_init(&idxd->num_channels_lock, NULL);
 
 	/* Enable PCI busmaster. */
diff --git a/module/accel/idxd/accel_engine_idxd.c b/module/accel/idxd/accel_engine_idxd.c
index 44a2f742d..64e7133c4 100644
--- a/module/accel/idxd/accel_engine_idxd.c
+++ b/module/accel/idxd/accel_engine_idxd.c
@@ -58,12 +58,6 @@ enum channel_state {
 
 static bool g_idxd_initialized = false;
 
-struct pci_device {
-	struct spdk_pci_device *pci_dev;
-	TAILQ_ENTRY(pci_device) tailq;
-};
-static TAILQ_HEAD(, pci_device) g_pci_devices = TAILQ_HEAD_INITIALIZER(g_pci_devices);
-
 struct idxd_device {
 	struct				spdk_idxd_device *idxd;
 	TAILQ_ENTRY(idxd_device)	tailq;
@@ -396,38 +390,8 @@ idxd_get_io_channel(void)
 	return spdk_get_io_channel(&idxd_accel_engine);
 }
 
-static bool
-probe_cb(void *cb_ctx, struct spdk_pci_device *pci_dev)
-{
-	struct spdk_pci_addr pci_addr = spdk_pci_device_get_addr(pci_dev);
-	struct pci_device *pdev;
-
-	SPDK_NOTICELOG(
-		" Found matching device at %04x:%02x:%02x.%x vendor:0x%04x device:0x%04x\n",
-		pci_addr.domain,
-		pci_addr.bus,
-		pci_addr.dev,
-		pci_addr.func,
-		spdk_pci_device_get_vendor_id(pci_dev),
-		spdk_pci_device_get_device_id(pci_dev));
-
-	pdev = calloc(1, sizeof(*pdev));
-	if (pdev == NULL) {
-		return false;
-	}
-	pdev->pci_dev = pci_dev;
-	TAILQ_INSERT_TAIL(&g_pci_devices, pdev, tailq);
-
-	/* Claim the device in case conflict with other process */
-	if (spdk_pci_device_claim(pci_dev) < 0) {
-		return false;
-	}
-
-	return true;
-}
-
 static void
-attach_cb(void *cb_ctx, struct spdk_pci_device *pci_dev, struct spdk_idxd_device *idxd)
+attach_cb(void *cb_ctx, struct spdk_idxd_device *idxd)
 {
 	struct idxd_device *dev;
 
@@ -465,7 +429,7 @@ accel_engine_idxd_init(void)
 		return -EINVAL;
 	}
 
-	if (spdk_idxd_probe(NULL, probe_cb, attach_cb) != 0) {
+	if (spdk_idxd_probe(NULL, attach_cb) != 0) {
 		SPDK_ERRLOG("spdk_idxd_probe() failed\n");
 		return -EINVAL;
 	}
@@ -483,7 +447,6 @@ static void
 accel_engine_idxd_exit(void *ctx)
 {
 	struct idxd_device *dev;
-	struct pci_device *pci_dev;
 
 	if (g_idxd_initialized) {
 		spdk_io_device_unregister(&idxd_accel_engine, NULL);
@@ -496,13 +459,6 @@ accel_engine_idxd_exit(void *ctx)
 		free(dev);
 	}
 
-	while (!TAILQ_EMPTY(&g_pci_devices)) {
-		pci_dev = TAILQ_FIRST(&g_pci_devices);
-		TAILQ_REMOVE(&g_pci_devices, pci_dev, tailq);
-		spdk_pci_device_detach(pci_dev->pci_dev);
-		free(pci_dev);
-	}
-
 	spdk_accel_engine_module_finish();
 }
 
diff --git a/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c b/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c
index c7db07d36..c8328c690 100644
--- a/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c
+++ b/test/unit/lib/idxd/idxd_user.c/idxd_user_ut.c
@@ -46,6 +46,19 @@
 
 DEFINE_STUB(spdk_pci_idxd_get_driver, struct spdk_pci_driver *, (void), NULL);
 DEFINE_STUB_V(idxd_impl_register, (struct spdk_idxd_impl *impl));
+DEFINE_STUB_V(spdk_pci_device_detach, (struct spdk_pci_device *device));
+DEFINE_STUB(spdk_pci_device_claim, int, (struct spdk_pci_device *dev), 0);
+DEFINE_STUB(spdk_pci_device_get_device_id, uint16_t, (struct spdk_pci_device *dev), 0);
+DEFINE_STUB(spdk_pci_device_get_vendor_id, uint16_t, (struct spdk_pci_device *dev), 0);
+
+struct spdk_pci_addr
+spdk_pci_device_get_addr(struct spdk_pci_device *pci_dev)
+{
+	struct spdk_pci_addr pci_addr;
+
+	memset(&pci_addr, 0, sizeof(pci_addr));
+	return pci_addr;
+}
 
 int
 spdk_pci_enumerate(struct spdk_pci_driver *driver, spdk_pci_enum_cb enum_cb, void *enum_ctx)
-- 
2.26.2


From bc35dab91cfca91de57aaded580290c134f42bdd Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 7 May 2021 18:28:03 +0800
Subject: [PATCH 064/342] lib/nvmf: Refactor the code to generate
 _nvmf_tcp_pdu_payload_handle

The purpose is to prepared for implement the async crc32 caculation
in the future patch.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: I49f84ea1966f0acdd6f5aeb7192896f91fd16dee
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7793
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/nvmf/tcp.c | 43 ++++++++++++++++++++++++++-----------------
 1 file changed, 26 insertions(+), 17 deletions(-)

diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index cd684a015..506c7de29 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -1662,6 +1662,31 @@ nvmf_tcp_h2c_term_req_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 	nvmf_tcp_qpair_set_recv_state(tqpair, NVME_TCP_PDU_RECV_STATE_ERROR);
 }
 
+static void
+_nvmf_tcp_pdu_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
+			     struct spdk_nvmf_tcp_transport *ttransport)
+{
+	struct nvme_tcp_pdu *pdu = tqpair->pdu_in_progress;
+
+	switch (pdu->hdr.common.pdu_type) {
+	case SPDK_NVME_TCP_PDU_TYPE_CAPSULE_CMD:
+		nvmf_tcp_capsule_cmd_payload_handle(ttransport, tqpair, pdu);
+		break;
+	case SPDK_NVME_TCP_PDU_TYPE_H2C_DATA:
+		nvmf_tcp_h2c_data_payload_handle(ttransport, tqpair, pdu);
+		break;
+
+	case SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ:
+		nvmf_tcp_h2c_term_req_payload_handle(tqpair, pdu);
+		break;
+
+	default:
+		/* The code should not go to here */
+		SPDK_ERRLOG("The code should not go to here\n");
+		break;
+	}
+}
+
 static void
 nvmf_tcp_pdu_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 			    struct spdk_nvmf_tcp_transport *ttransport)
@@ -1688,23 +1713,7 @@ nvmf_tcp_pdu_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 		}
 	}
 
-	switch (pdu->hdr.common.pdu_type) {
-	case SPDK_NVME_TCP_PDU_TYPE_CAPSULE_CMD:
-		nvmf_tcp_capsule_cmd_payload_handle(ttransport, tqpair, pdu);
-		break;
-	case SPDK_NVME_TCP_PDU_TYPE_H2C_DATA:
-		nvmf_tcp_h2c_data_payload_handle(ttransport, tqpair, pdu);
-		break;
-
-	case SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ:
-		nvmf_tcp_h2c_term_req_payload_handle(tqpair, pdu);
-		break;
-
-	default:
-		/* The code should not go to here */
-		SPDK_ERRLOG("The code should not go to here\n");
-		break;
-	}
+	_nvmf_tcp_pdu_payload_handle(tqpair, ttransport);
 }
 
 static void
-- 
2.26.2


From bcbccf8bb55ed4fd2540606ef32191e1dabd90df Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 7 May 2021 18:34:35 +0800
Subject: [PATCH 065/342] lib/nvme_tcp: Refactor the code to generate
 _nvme_tcp_pdu_payload_handle

The purpose is to prepared for implement the async crc32 caculation
in the future patch.

Change-Id: Ia75f28154c49f08b527d48c63b9da79a6bdfede8
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7794
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/nvme/nvme_tcp.c | 39 +++++++++++++++++++++++++--------------
 1 file changed, 25 insertions(+), 14 deletions(-)

diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index 903e458ed..ce9fc0b92 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -1041,6 +1041,30 @@ nvme_tcp_c2h_term_req_payload_handle(struct nvme_tcp_qpair *tqpair,
 	nvme_tcp_qpair_set_recv_state(tqpair, NVME_TCP_PDU_RECV_STATE_ERROR);
 }
 
+static void
+_nvme_tcp_pdu_payload_handle(struct nvme_tcp_qpair *tqpair, uint32_t *reaped)
+{
+	struct nvme_tcp_pdu *pdu;
+
+	assert(tqpair != NULL);
+	pdu = tqpair->recv_pdu;
+
+	switch (pdu->hdr.common.pdu_type) {
+	case SPDK_NVME_TCP_PDU_TYPE_C2H_DATA:
+		nvme_tcp_c2h_data_payload_handle(tqpair, pdu, reaped);
+		break;
+
+	case SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ:
+		nvme_tcp_c2h_term_req_payload_handle(tqpair, pdu);
+		break;
+
+	default:
+		/* The code should not go to here */
+		SPDK_ERRLOG("The code should not go to here\n");
+		break;
+	}
+}
+
 static void
 nvme_tcp_pdu_payload_handle(struct nvme_tcp_qpair *tqpair,
 			    uint32_t *reaped)
@@ -1067,20 +1091,7 @@ nvme_tcp_pdu_payload_handle(struct nvme_tcp_qpair *tqpair,
 		}
 	}
 
-	switch (pdu->hdr.common.pdu_type) {
-	case SPDK_NVME_TCP_PDU_TYPE_C2H_DATA:
-		nvme_tcp_c2h_data_payload_handle(tqpair, pdu, reaped);
-		break;
-
-	case SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ:
-		nvme_tcp_c2h_term_req_payload_handle(tqpair, pdu);
-		break;
-
-	default:
-		/* The code should not go to here */
-		SPDK_ERRLOG("The code should not go to here\n");
-		break;
-	}
+	_nvme_tcp_pdu_payload_handle(tqpair, reaped);
 }
 
 static void
-- 
2.26.2


From 0ba168fe39c571b9c01b179d023cd3252fe66c39 Mon Sep 17 00:00:00 2001
From: Curt Bruns <curt.e.bruns@gmail.com>
Date: Fri, 30 Apr 2021 13:53:22 -0400
Subject: [PATCH 066/342] nvme: add SPDK_DEBUGLOG support for nvme_cuse

It is useful to have debug log information in the nvme_cuse
path when debugging IOCTls and flows.

Signed-off-by: Curt Bruns <curt.e.bruns@gmail.com>
Change-Id: Ifef1bb82c96438e2fcbb9ad2fafe3f3eb66bed51
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7707
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvme/nvme_cuse.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index 0d7696a71..60327fec0 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -557,10 +557,12 @@ cuse_ctrlr_ioctl(fuse_req_t req, int cmd, void *arg,
 
 	switch ((unsigned int)cmd) {
 	case NVME_IOCTL_ADMIN_CMD:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_ADMIN_CMD\n");
 		cuse_nvme_admin_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case NVME_IOCTL_RESET:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_RESET\n");
 		cuse_nvme_reset(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
@@ -582,27 +584,33 @@ cuse_ns_ioctl(fuse_req_t req, int cmd, void *arg,
 
 	switch ((unsigned int)cmd) {
 	case NVME_IOCTL_ADMIN_CMD:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_ADMIN_CMD\n");
 		cuse_nvme_admin_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case NVME_IOCTL_SUBMIT_IO:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_SUBMIT_IO\n");
 		cuse_nvme_submit_io(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case NVME_IOCTL_ID:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_ID\n");
 		cuse_getid(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case BLKPBSZGET:
+		SPDK_DEBUGLOG(nvme_cuse, "BLKPBSZGET\n");
 		cuse_blkpbszget(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case BLKGETSIZE:
+		SPDK_DEBUGLOG(nvme_cuse, "BLKGETSIZE\n");
 		/* Returns the device size as a number of 512-byte blocks (returns pointer to long) */
 		cuse_blkgetsize(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case BLKGETSIZE64:
+		SPDK_DEBUGLOG(nvme_cuse, "BLKGETSIZE64\n");
 		/* Returns the device size in sectors (returns pointer to uint64_t) */
 		cuse_blkgetsize64(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
@@ -1103,3 +1111,5 @@ spdk_nvme_cuse_get_ns_name(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, char *n
 
 	return 0;
 }
+
+SPDK_LOG_REGISTER_COMPONENT(nvme_cuse)
-- 
2.26.2


From 4c19332b0cda0cc46721aa13f4ad0187bd0fc4c6 Mon Sep 17 00:00:00 2001
From: Curt Bruns <curt.e.bruns@gmail.com>
Date: Fri, 30 Apr 2021 14:00:59 -0400
Subject: [PATCH 067/342] nvme: add cuse support for BLKSSZGET IOCTL

Nvme-cli uses BLKSSZGET so support needs to be added for
nvme cuse devices.

Signed-off-by: Curt Bruns <curt.e.bruns@gmail.com>
Change-Id: Ic8316713b2d017c8ff32a225efff6bcb95842799
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7708
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/nvme/nvme_cuse.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index 60327fec0..5b8f44e6d 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -535,6 +535,22 @@ cuse_blkgetsize(fuse_req_t req, int cmd, void *arg,
 	fuse_reply_ioctl(req, 0, &size, sizeof(size));
 }
 
+static void
+cuse_blkgetsectorsize(fuse_req_t req, int cmd, void *arg,
+		      struct fuse_file_info *fi, unsigned flags,
+		      const void *in_buf, size_t in_bufsz, size_t out_bufsz)
+{
+	int ssize;
+	struct spdk_nvme_ns *ns;
+	struct cuse_device *cuse_device = fuse_req_userdata(req);
+
+	FUSE_REPLY_CHECK_BUFFER(req, arg, out_bufsz, ssize);
+
+	ns = spdk_nvme_ctrlr_get_ns(cuse_device->ctrlr, cuse_device->nsid);
+	ssize = spdk_nvme_ns_get_sector_size(ns);
+	fuse_reply_ioctl(req, 0, &ssize, sizeof(ssize));
+}
+
 static void
 cuse_getid(fuse_req_t req, int cmd, void *arg,
 	   struct fuse_file_info *fi, unsigned flags,
@@ -603,6 +619,11 @@ cuse_ns_ioctl(fuse_req_t req, int cmd, void *arg,
 		cuse_blkpbszget(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
+	case BLKSSZGET:
+		SPDK_DEBUGLOG(nvme_cuse, "BLKSSZGET\n");
+		cuse_blkgetsectorsize(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
+		break;
+
 	case BLKGETSIZE:
 		SPDK_DEBUGLOG(nvme_cuse, "BLKGETSIZE\n");
 		/* Returns the device size as a number of 512-byte blocks (returns pointer to long) */
-- 
2.26.2


From f3edd7a3597b337177b0f7a8493936f5b3f59db0 Mon Sep 17 00:00:00 2001
From: Curt Bruns <curt.e.bruns@gmail.com>
Date: Tue, 4 May 2021 20:25:31 -0400
Subject: [PATCH 068/342] nvme: rename "admin" to "passthru" for cuse

The nvme cuse IOCTLs are actually creating passthru commands
that can be either IO passthru commands or admin commands.
Renaming the routines to correctly reflect that should limit
the confusion when reading the code.  Passthru commands that
are admin commands will go to the spdk_nvme_ctrlr_cmd_admin_raw
interface and passthru commands that are IO will be sent to the
spdk_nvme_ctrlr_cmd_io_raw interface.

Signed-off-by: Curt Bruns <curt.e.bruns@gmail.com>
Change-Id: I8d427fe8b5f503fdb2d193236c77d410d5b13886
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7740
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvme/nvme_cuse.c                          | 79 ++++++++++---------
 test/nvme/cuse/cuse.c                         |  4 +
 test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c |  4 +
 3 files changed, 50 insertions(+), 37 deletions(-)

diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index 5b8f44e6d..e421d92a2 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -96,7 +96,7 @@ cuse_io_ctx_free(struct cuse_io_ctx *ctx)
 	}
 
 static void
-cuse_nvme_admin_cmd_cb(void *arg, const struct spdk_nvme_cpl *cpl)
+cuse_nvme_passthru_cmd_cb(void *arg, const struct spdk_nvme_cpl *cpl)
 {
 	struct cuse_io_ctx *ctx = arg;
 	struct iovec out_iov[2];
@@ -124,13 +124,18 @@ cuse_nvme_admin_cmd_cb(void *arg, const struct spdk_nvme_cpl *cpl)
 }
 
 static void
-cuse_nvme_admin_cmd_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, void *arg)
+cuse_nvme_passthru_cmd_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, void *arg)
 {
 	int rc;
 	struct cuse_io_ctx *ctx = arg;
 
-	rc = spdk_nvme_ctrlr_cmd_admin_raw(ctrlr, &ctx->nvme_cmd, ctx->data, ctx->data_len,
-					   cuse_nvme_admin_cmd_cb, (void *)ctx);
+	if (nsid != 0) {
+		rc = spdk_nvme_ctrlr_cmd_io_raw(ctrlr, ctrlr->external_io_msgs_qpair, &ctx->nvme_cmd, ctx->data,
+						ctx->data_len, cuse_nvme_passthru_cmd_cb, (void *)ctx);
+	} else {
+		rc = spdk_nvme_ctrlr_cmd_admin_raw(ctrlr, &ctx->nvme_cmd, ctx->data, ctx->data_len,
+						   cuse_nvme_passthru_cmd_cb, (void *)ctx);
+	}
 	if (rc < 0) {
 		fuse_reply_err(ctx->req, EINVAL);
 		cuse_io_ctx_free(ctx);
@@ -138,8 +143,8 @@ cuse_nvme_admin_cmd_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, void *
 }
 
 static void
-cuse_nvme_admin_cmd_send(fuse_req_t req, struct nvme_admin_cmd *admin_cmd,
-			 const void *data)
+cuse_nvme_passthru_cmd_send(fuse_req_t req, struct nvme_passthru_cmd *passthru_cmd,
+			    const void *data)
 {
 	struct cuse_io_ctx *ctx;
 	struct cuse_device *cuse_device = fuse_req_userdata(req);
@@ -153,19 +158,19 @@ cuse_nvme_admin_cmd_send(fuse_req_t req, struct nvme_admin_cmd *admin_cmd,
 	}
 
 	ctx->req = req;
-	ctx->data_transfer = spdk_nvme_opc_get_data_transfer(admin_cmd->opcode);
+	ctx->data_transfer = spdk_nvme_opc_get_data_transfer(passthru_cmd->opcode);
 
 	memset(&ctx->nvme_cmd, 0, sizeof(ctx->nvme_cmd));
-	ctx->nvme_cmd.opc = admin_cmd->opcode;
-	ctx->nvme_cmd.nsid = admin_cmd->nsid;
-	ctx->nvme_cmd.cdw10 = admin_cmd->cdw10;
-	ctx->nvme_cmd.cdw11 = admin_cmd->cdw11;
-	ctx->nvme_cmd.cdw12 = admin_cmd->cdw12;
-	ctx->nvme_cmd.cdw13 = admin_cmd->cdw13;
-	ctx->nvme_cmd.cdw14 = admin_cmd->cdw14;
-	ctx->nvme_cmd.cdw15 = admin_cmd->cdw15;
+	ctx->nvme_cmd.opc = passthru_cmd->opcode;
+	ctx->nvme_cmd.nsid = passthru_cmd->nsid;
+	ctx->nvme_cmd.cdw10 = passthru_cmd->cdw10;
+	ctx->nvme_cmd.cdw11 = passthru_cmd->cdw11;
+	ctx->nvme_cmd.cdw12 = passthru_cmd->cdw12;
+	ctx->nvme_cmd.cdw13 = passthru_cmd->cdw13;
+	ctx->nvme_cmd.cdw14 = passthru_cmd->cdw14;
+	ctx->nvme_cmd.cdw15 = passthru_cmd->cdw15;
 
-	ctx->data_len = admin_cmd->data_len;
+	ctx->data_len = passthru_cmd->data_len;
 
 	if (ctx->data_len > 0) {
 		ctx->data = spdk_malloc(ctx->data_len, 4096, NULL, SPDK_ENV_LCORE_ID_ANY, SPDK_MALLOC_DMA);
@@ -180,7 +185,7 @@ cuse_nvme_admin_cmd_send(fuse_req_t req, struct nvme_admin_cmd *admin_cmd,
 		}
 	}
 
-	rv = nvme_io_msg_send(cuse_device->ctrlr, 0, cuse_nvme_admin_cmd_execute, ctx);
+	rv = nvme_io_msg_send(cuse_device->ctrlr, 0, cuse_nvme_passthru_cmd_execute, ctx);
 	if (rv) {
 		SPDK_ERRLOG("Cannot send io msg to the controller\n");
 		fuse_reply_err(req, -rv);
@@ -190,44 +195,44 @@ cuse_nvme_admin_cmd_send(fuse_req_t req, struct nvme_admin_cmd *admin_cmd,
 }
 
 static void
-cuse_nvme_admin_cmd(fuse_req_t req, int cmd, void *arg,
-		    struct fuse_file_info *fi, unsigned flags,
-		    const void *in_buf, size_t in_bufsz, size_t out_bufsz)
+cuse_nvme_passthru_cmd(fuse_req_t req, int cmd, void *arg,
+		       struct fuse_file_info *fi, unsigned flags,
+		       const void *in_buf, size_t in_bufsz, size_t out_bufsz)
 {
-	struct nvme_admin_cmd *admin_cmd;
+	struct nvme_passthru_cmd *passthru_cmd;
 	struct iovec in_iov[2], out_iov[2];
 
 	in_iov[0].iov_base = (void *)arg;
-	in_iov[0].iov_len = sizeof(*admin_cmd);
+	in_iov[0].iov_len = sizeof(*passthru_cmd);
 	if (in_bufsz == 0) {
 		fuse_reply_ioctl_retry(req, in_iov, 1, NULL, 0);
 		return;
 	}
 
-	admin_cmd = (struct nvme_admin_cmd *)in_buf;
+	passthru_cmd = (struct nvme_passthru_cmd *)in_buf;
 
-	switch (spdk_nvme_opc_get_data_transfer(admin_cmd->opcode)) {
+	switch (spdk_nvme_opc_get_data_transfer(passthru_cmd->opcode)) {
 	case SPDK_NVME_DATA_HOST_TO_CONTROLLER:
-		if (admin_cmd->addr != 0) {
-			in_iov[1].iov_base = (void *)admin_cmd->addr;
-			in_iov[1].iov_len = admin_cmd->data_len;
-			if (in_bufsz == sizeof(*admin_cmd)) {
+		if (passthru_cmd->addr != 0) {
+			in_iov[1].iov_base = (void *)passthru_cmd->addr;
+			in_iov[1].iov_len = passthru_cmd->data_len;
+			if (in_bufsz == sizeof(*passthru_cmd)) {
 				fuse_reply_ioctl_retry(req, in_iov, 2, NULL, 0);
 				return;
 			}
-			cuse_nvme_admin_cmd_send(req, admin_cmd, in_buf + sizeof(*admin_cmd));
+			cuse_nvme_passthru_cmd_send(req, passthru_cmd, in_buf + sizeof(*passthru_cmd));
 		} else {
-			cuse_nvme_admin_cmd_send(req, admin_cmd, NULL);
+			cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL);
 		}
 		return;
 	case SPDK_NVME_DATA_NONE:
 	case SPDK_NVME_DATA_CONTROLLER_TO_HOST:
 		if (out_bufsz == 0) {
-			out_iov[0].iov_base = &((struct nvme_admin_cmd *)arg)->result;
+			out_iov[0].iov_base = &((struct nvme_passthru_cmd *)arg)->result;
 			out_iov[0].iov_len = sizeof(uint32_t);
-			if (admin_cmd->data_len > 0) {
-				out_iov[1].iov_base = (void *)admin_cmd->addr;
-				out_iov[1].iov_len = admin_cmd->data_len;
+			if (passthru_cmd->data_len > 0) {
+				out_iov[1].iov_base = (void *)passthru_cmd->addr;
+				out_iov[1].iov_len = passthru_cmd->data_len;
 				fuse_reply_ioctl_retry(req, in_iov, 1, out_iov, 2);
 			} else {
 				fuse_reply_ioctl_retry(req, in_iov, 1, out_iov, 1);
@@ -235,7 +240,7 @@ cuse_nvme_admin_cmd(fuse_req_t req, int cmd, void *arg,
 			return;
 		}
 
-		cuse_nvme_admin_cmd_send(req, admin_cmd, NULL);
+		cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL);
 
 		return;
 	case SPDK_NVME_DATA_BIDIRECTIONAL:
@@ -574,7 +579,7 @@ cuse_ctrlr_ioctl(fuse_req_t req, int cmd, void *arg,
 	switch ((unsigned int)cmd) {
 	case NVME_IOCTL_ADMIN_CMD:
 		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_ADMIN_CMD\n");
-		cuse_nvme_admin_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
+		cuse_nvme_passthru_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case NVME_IOCTL_RESET:
@@ -601,7 +606,7 @@ cuse_ns_ioctl(fuse_req_t req, int cmd, void *arg,
 	switch ((unsigned int)cmd) {
 	case NVME_IOCTL_ADMIN_CMD:
 		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_ADMIN_CMD\n");
-		cuse_nvme_admin_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
+		cuse_nvme_passthru_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
 	case NVME_IOCTL_SUBMIT_IO:
diff --git a/test/nvme/cuse/cuse.c b/test/nvme/cuse/cuse.c
index 9a1c38562..fe63a0940 100644
--- a/test/nvme/cuse/cuse.c
+++ b/test/nvme/cuse/cuse.c
@@ -47,6 +47,10 @@ DEFINE_STUB(spdk_nvme_ctrlr_cmd_admin_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
 		struct spdk_nvme_cmd *cmd, void *buf, uint32_t len,
 		spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
 
+DEFINE_STUB(spdk_nvme_ctrlr_cmd_io_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
+		struct spdk_nvme_qpair *qpair, struct spdk_nvme_cmd *cmd, void *buf, uint32_t len,
+		spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
+
 DEFINE_STUB(spdk_nvme_ctrlr_get_num_ns, uint32_t, (struct spdk_nvme_ctrlr *ctrlr), 128);
 
 static uint32_t g_active_num_ns = 4;
diff --git a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
index 1ec7a5190..a8a7f3b41 100644
--- a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
+++ b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
@@ -45,6 +45,10 @@ DEFINE_STUB(spdk_nvme_ctrlr_cmd_admin_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
 		struct spdk_nvme_cmd *cmd, void *buf, uint32_t len,
 		spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
 
+DEFINE_STUB(spdk_nvme_ctrlr_cmd_io_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
+		struct spdk_nvme_qpair *qpair, struct spdk_nvme_cmd *cmd, void *buf, uint32_t len,
+		spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
+
 DEFINE_STUB(spdk_nvme_ctrlr_get_num_ns, uint32_t,
 	    (struct spdk_nvme_ctrlr *ctrlr), 128);
 
-- 
2.26.2


From b89ad845327a441031a248afed41fe4b12107630 Mon Sep 17 00:00:00 2001
From: Curt Bruns <curt.e.bruns@gmail.com>
Date: Tue, 4 May 2021 20:52:57 -0400
Subject: [PATCH 069/342] nvme: add support for NVME_IOCTL_IO_CMD for cuse

Nvme-cli uses NVME_IOCTL_IO_CMDs for "io-passthru"
commands to cuse devices.  This patch adds support
for that IOCTL.

Signed-off-by: Curt Bruns <curt.e.bruns@gmail.com>
Change-Id: I20e0ac91ba08fce91bc5da1f4a1e454058cdd1e7
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7741
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/nvme/nvme_cuse.c                          | 21 ++++++--
 test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c | 54 +++++++++++++++++++
 2 files changed, 70 insertions(+), 5 deletions(-)

diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index e421d92a2..faeaf8faa 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -144,7 +144,7 @@ cuse_nvme_passthru_cmd_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, voi
 
 static void
 cuse_nvme_passthru_cmd_send(fuse_req_t req, struct nvme_passthru_cmd *passthru_cmd,
-			    const void *data)
+			    const void *data, int cmd)
 {
 	struct cuse_io_ctx *ctx;
 	struct cuse_device *cuse_device = fuse_req_userdata(req);
@@ -185,7 +185,13 @@ cuse_nvme_passthru_cmd_send(fuse_req_t req, struct nvme_passthru_cmd *passthru_c
 		}
 	}
 
-	rv = nvme_io_msg_send(cuse_device->ctrlr, 0, cuse_nvme_passthru_cmd_execute, ctx);
+	if ((unsigned int)cmd != NVME_IOCTL_ADMIN_CMD) {
+		/* Send NS for IO IOCTLs */
+		rv = nvme_io_msg_send(cuse_device->ctrlr, passthru_cmd->nsid, cuse_nvme_passthru_cmd_execute, ctx);
+	} else {
+		/* NS == 0 for Admin IOCTLs */
+		rv = nvme_io_msg_send(cuse_device->ctrlr, 0, cuse_nvme_passthru_cmd_execute, ctx);
+	}
 	if (rv) {
 		SPDK_ERRLOG("Cannot send io msg to the controller\n");
 		fuse_reply_err(req, -rv);
@@ -220,9 +226,9 @@ cuse_nvme_passthru_cmd(fuse_req_t req, int cmd, void *arg,
 				fuse_reply_ioctl_retry(req, in_iov, 2, NULL, 0);
 				return;
 			}
-			cuse_nvme_passthru_cmd_send(req, passthru_cmd, in_buf + sizeof(*passthru_cmd));
+			cuse_nvme_passthru_cmd_send(req, passthru_cmd, in_buf + sizeof(*passthru_cmd), cmd);
 		} else {
-			cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL);
+			cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL, cmd);
 		}
 		return;
 	case SPDK_NVME_DATA_NONE:
@@ -240,7 +246,7 @@ cuse_nvme_passthru_cmd(fuse_req_t req, int cmd, void *arg,
 			return;
 		}
 
-		cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL);
+		cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL, cmd);
 
 		return;
 	case SPDK_NVME_DATA_BIDIRECTIONAL:
@@ -614,6 +620,11 @@ cuse_ns_ioctl(fuse_req_t req, int cmd, void *arg,
 		cuse_nvme_submit_io(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
+	case NVME_IOCTL_IO_CMD:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_IO_CMD\n");
+		cuse_nvme_passthru_cmd(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
+		break;
+
 	case NVME_IOCTL_ID:
 		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_ID\n");
 		cuse_getid(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
diff --git a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
index a8a7f3b41..7a2cc9674 100644
--- a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
+++ b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
@@ -101,6 +101,14 @@ nvme_io_msg_send(struct spdk_nvme_ctrlr *ctrlr,
 	return 0;
 }
 
+struct cuse_device *g_cuse_device;
+DEFINE_RETURN_MOCK(fuse_req_userdata, void *);
+void *
+fuse_req_userdata(fuse_req_t req)
+{
+	return g_cuse_device;
+}
+
 static void
 test_cuse_nvme_submit_io_read_write(void)
 {
@@ -151,6 +159,51 @@ test_cuse_nvme_submit_io_read_write(void)
 	free(user_io);
 }
 
+static void
+test_cuse_nvme_submit_passthru_cmd(void)
+{
+	struct nvme_passthru_cmd *passthru_cmd = NULL;
+	fuse_req_t req = (void *)0xDEEACDFF;
+
+	passthru_cmd = calloc(1, sizeof(struct nvme_passthru_cmd));
+	g_cuse_device = calloc(1, sizeof(struct cuse_device));
+
+	/* Use fatal or we'll segfault if we didn't get memory */
+	SPDK_CU_ASSERT_FATAL(passthru_cmd != NULL);
+	SPDK_CU_ASSERT_FATAL(g_cuse_device != NULL);
+	g_cuse_device->ctrlr = (void *)0xDEADBEEF;
+
+	g_ut_ctx = NULL;
+	/* Passthrough command */
+	passthru_cmd->opcode   = SPDK_NVME_DATA_CONTROLLER_TO_HOST;
+	passthru_cmd->nsid     = 1;
+	passthru_cmd->data_len = 512;
+	passthru_cmd->cdw10    = 0xc0de1010;
+	passthru_cmd->cdw11    = 0xc0de1111;
+	passthru_cmd->cdw12    = 0xc0de1212;
+	passthru_cmd->cdw13    = 0xc0de1313;
+	passthru_cmd->cdw14    = 0xc0de1414;
+	passthru_cmd->cdw15    = 0xc0de1515;
+
+	/* Send IO Command IOCTL */
+	cuse_nvme_passthru_cmd_send(req, passthru_cmd, NULL, NVME_IOCTL_IO_CMD);
+	SPDK_CU_ASSERT_FATAL(g_ut_ctx != NULL);
+	CU_ASSERT(g_ut_ctx->data != NULL);
+	CU_ASSERT(g_ut_ctx->req               == req);
+	CU_ASSERT(g_ut_ctx->data_len          == 512);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.opc      == SPDK_NVME_DATA_CONTROLLER_TO_HOST);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.nsid     == 1);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.cdw10    == 0xc0de1010);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.cdw11    == 0xc0de1111);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.cdw12    == 0xc0de1212);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.cdw13    == 0xc0de1313);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.cdw14    == 0xc0de1414);
+	CU_ASSERT(g_ut_ctx->nvme_cmd.cdw15    == 0xc0de1515);
+
+	cuse_io_ctx_free(g_ut_ctx);
+	free(passthru_cmd);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -161,6 +214,7 @@ int main(int argc, char **argv)
 
 	suite = CU_add_suite("nvme_cuse", NULL, NULL);
 	CU_ADD_TEST(suite, test_cuse_nvme_submit_io_read_write);
+	CU_ADD_TEST(suite, test_cuse_nvme_submit_passthru_cmd);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From e8fc521f7d4db54872504669a6f3e35726421fff Mon Sep 17 00:00:00 2001
From: paul luse <paul.e.luse@intel.com>
Date: Mon, 3 May 2021 18:25:11 -0400
Subject: [PATCH 070/342] lib/idxd: set error status on any completion error.

Not just one with extra available info.  Also remove the extra
read of the error register, not required.

fixes: #1927

Signed-off-by: paul luse <paul.e.luse@intel.com>
Change-Id: I28badb45d8cc8d16b72f7019bd2a2044998fc402
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7729
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Krzysztof Karas <krzysztof.karas@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 lib/idxd/idxd.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/lib/idxd/idxd.c b/lib/idxd/idxd.c
index 5e1fbe1ba..dbe925179 100644
--- a/lib/idxd/idxd.c
+++ b/lib/idxd/idxd.c
@@ -1023,7 +1023,6 @@ int
 spdk_idxd_process_events(struct spdk_idxd_io_channel *chan)
 {
 	struct idxd_comp *comp_ctx, *tmp;
-	uint64_t sw_error_0;
 	int status = 0;
 	int rc = 0;
 
@@ -1034,11 +1033,8 @@ spdk_idxd_process_events(struct spdk_idxd_io_channel *chan)
 			rc++;
 
 			if (spdk_unlikely(IDXD_FAILURE(comp_ctx->hw.status))) {
-				sw_error_0 = idxd_read_8(chan->idxd, chan->portal, IDXD_SWERR_OFFSET);
-				if (IDXD_SW_ERROR(sw_error_0)) {
-					_dump_error_reg(chan);
-					status = -EINVAL;
-				}
+				status = -EINVAL;
+				_dump_error_reg(chan);
 			}
 
 			switch (comp_ctx->desc->opcode) {
-- 
2.26.2


From 19faf91293db36b98452da977a093ee9829bb99f Mon Sep 17 00:00:00 2001
From: Jonas Pfefferle <pepperjo@japf.ch>
Date: Wed, 14 Apr 2021 13:17:42 +0200
Subject: [PATCH 071/342] nvmf: ctrlr_create - fix missing free qpair_mask on
 error

This patch fixes missing free of qpair_mask when a listener error
occurs in ctrlr_create.

Signed-off-by: Jonas Pfefferle <pepperjo@japf.ch>
Change-Id: I09162b86d8ac73bf9fc2006a08dcc0a955f222b3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7818
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 lib/nvmf/ctrlr.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/lib/nvmf/ctrlr.c b/lib/nvmf/ctrlr.c
index 4fe815d06..bcef8de6a 100644
--- a/lib/nvmf/ctrlr.c
+++ b/lib/nvmf/ctrlr.c
@@ -336,8 +336,7 @@ nvmf_ctrlr_create(struct spdk_nvmf_subsystem *subsystem,
 	ctrlr->qpair_mask = spdk_bit_array_create(transport->opts.max_qpairs_per_ctrlr);
 	if (!ctrlr->qpair_mask) {
 		SPDK_ERRLOG("Failed to allocate controller qpair mask\n");
-		free(ctrlr);
-		return NULL;
+		goto err_qpair_mask;
 	}
 
 	nvmf_ctrlr_cdata_init(transport, subsystem, &ctrlr->cdata);
@@ -431,15 +430,13 @@ nvmf_ctrlr_create(struct spdk_nvmf_subsystem *subsystem,
 	if (ctrlr->subsys->subtype == SPDK_NVMF_SUBTYPE_NVME) {
 		if (spdk_nvmf_qpair_get_listen_trid(req->qpair, &listen_trid) != 0) {
 			SPDK_ERRLOG("Could not get listener transport ID\n");
-			free(ctrlr);
-			return NULL;
+			goto err_listener;
 		}
 
 		ctrlr->listener = nvmf_subsystem_find_listener(ctrlr->subsys, &listen_trid);
 		if (!ctrlr->listener) {
 			SPDK_ERRLOG("Listener was not found\n");
-			free(ctrlr);
-			return NULL;
+			goto err_listener;
 		}
 	}
 
@@ -447,6 +444,11 @@ nvmf_ctrlr_create(struct spdk_nvmf_subsystem *subsystem,
 	spdk_thread_send_msg(subsystem->thread, _nvmf_subsystem_add_ctrlr, req);
 
 	return ctrlr;
+err_listener:
+	spdk_bit_array_free(&ctrlr->qpair_mask);
+err_qpair_mask:
+	free(ctrlr);
+	return NULL;
 }
 
 static void
-- 
2.26.2


From c94648ff9191e4adb87bc88f88f10e9abdd38dbc Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Mon, 3 May 2021 19:57:53 +0800
Subject: [PATCH 072/342] lib/accel: Add the missed seed assignment for chain
 crc32c support.

We did not find this issue, because we always use seed = 0 to test.
Definitely, we need to assign the seed value.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: I6bec1b6d61480cdd7c9e27578dcaf5de2f65cf44
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7716
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 lib/accel/accel_engine.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/accel/accel_engine.c b/lib/accel/accel_engine.c
index 450595120..eac01219a 100644
--- a/lib/accel/accel_engine.c
+++ b/lib/accel/accel_engine.c
@@ -382,6 +382,7 @@ spdk_accel_submit_crc32cv(struct spdk_io_channel *ch, uint32_t *dst, struct iove
 	accel_task->v.iovs = iov;
 	accel_task->v.iovcnt = iov_cnt;
 	accel_task->dst = (void *)dst;
+	accel_task->seed = seed;
 	accel_task->op_code = ACCEL_OPCODE_CRC32C;
 
 	if (_is_supported(accel_ch->engine, ACCEL_CRC32C)) {
-- 
2.26.2


From d20f41881b35b13959692b3c37522860277e2d52 Mon Sep 17 00:00:00 2001
From: Robert Baldyga <robert.baldyga@intel.com>
Date: Thu, 11 Mar 2021 13:35:04 +0100
Subject: [PATCH 073/342] spdk_zmalloc: Remove unnecessary memset()

Normally, unless RTE_MALLOC_DEBUG is set, DPDK zeroes memory in rte_free().
If RTE_MALLOC_DEBUG rte_free() fills memory with poison pattern, but then
(and only then) the memory is zeroed in rte_zmalloc_socket(). Relying on
this behavior allows to avoid unnecessary memset() in spdk_zmalloc() path.

Signed-off-by: Robert Baldyga <robert.baldyga@intel.com>
Change-Id: If3efa4dd22f1568949c3fb529b604bd597ceb32f
Signed-off-by: Rafal Stefanowski <rafal.stefanowski@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6975
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 lib/env_dpdk/env.c | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/lib/env_dpdk/env.c b/lib/env_dpdk/env.c
index c2801da2e..b51020c7e 100644
--- a/lib/env_dpdk/env.c
+++ b/lib/env_dpdk/env.c
@@ -71,7 +71,7 @@ spdk_malloc(size_t size, size_t align, uint64_t *phys_addr, int socket_id, uint3
 	buf = rte_malloc_socket(NULL, size, align, socket_id);
 	if (buf && phys_addr) {
 #ifdef DEBUG
-		SPDK_ERRLOG("phys_addr param in spdk_*malloc() is deprecated\n");
+		SPDK_ERRLOG("phys_addr param in spdk_malloc() is deprecated\n");
 #endif
 		*phys_addr = virt_to_phys(buf);
 	}
@@ -81,9 +81,19 @@ spdk_malloc(size_t size, size_t align, uint64_t *phys_addr, int socket_id, uint3
 void *
 spdk_zmalloc(size_t size, size_t align, uint64_t *phys_addr, int socket_id, uint32_t flags)
 {
-	void *buf = spdk_malloc(size, align, phys_addr, socket_id, flags);
-	if (buf) {
-		memset(buf, 0, size);
+	void *buf;
+
+	if (flags == 0) {
+		return NULL;
+	}
+
+	align = spdk_max(align, RTE_CACHE_LINE_SIZE);
+	buf = rte_zmalloc_socket(NULL, size, align, socket_id);
+	if (buf && phys_addr) {
+#ifdef DEBUG
+		SPDK_ERRLOG("phys_addr param in spdk_zmalloc() is deprecated\n");
+#endif
+		*phys_addr = virt_to_phys(buf);
 	}
 	return buf;
 }
-- 
2.26.2


From 47c4304d83bea9b122aa659aede1407492bd8564 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 23 Mar 2021 07:10:10 -0400
Subject: [PATCH 074/342] subsystem/nvmf: remove cpu_mask hint when creating
 poll group

Passing cpu_mask hints that match only single core were
usefull to prevent any accidents when doing round-robin
in case of 'static' scheduler.
In practice this is not required in case of 'static' scheduler,
the threads will be spread out over all reactors anyway.

This hinders other schedulers which try to respect the cpu_mask
hints, as they would not move the thread to any reactor.
Preventing bunching up less used threads on single reactor.

Drawback of this patch is that poll group names will not match
the cores they are on.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I5fb308362dd045228ea9fcca24f988388854c054
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7028
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 mk/spdk.lib_deps.mk                     | 2 +-
 module/event/subsystems/nvmf/nvmf_tgt.c | 6 +-----
 test/scheduler/idle.sh                  | 8 ++------
 3 files changed, 4 insertions(+), 12 deletions(-)

diff --git a/mk/spdk.lib_deps.mk b/mk/spdk.lib_deps.mk
index ece8233ff..7b2912e06 100644
--- a/mk/spdk.lib_deps.mk
+++ b/mk/spdk.lib_deps.mk
@@ -166,7 +166,7 @@ DEPDIRS-event_vmd := event vmd $(JSON_LIBS) log thread
 DEPDIRS-event_bdev := event bdev event_accel event_vmd event_sock
 
 DEPDIRS-event_nbd := event nbd event_bdev
-DEPDIRS-event_nvmf := event nvmf event_bdev event_sock $(BDEV_DEPS_THREAD)
+DEPDIRS-event_nvmf := event nvmf event_bdev event_sock thread log bdev $(JSON_LIBS)
 DEPDIRS-event_scsi := event scsi event_bdev
 
 DEPDIRS-event_iscsi := event iscsi event_scsi event_sock
diff --git a/module/event/subsystems/nvmf/nvmf_tgt.c b/module/event/subsystems/nvmf/nvmf_tgt.c
index 5f5ea5dbd..4ac81f3e5 100644
--- a/module/event/subsystems/nvmf/nvmf_tgt.c
+++ b/module/event/subsystems/nvmf/nvmf_tgt.c
@@ -38,7 +38,6 @@
 #include "spdk/log.h"
 #include "spdk/nvme.h"
 #include "spdk/nvmf_cmd.h"
-#include "spdk/util.h"
 
 enum nvmf_tgt_state {
 	NVMF_TGT_INIT_NONE = 0,
@@ -186,7 +185,6 @@ nvmf_tgt_create_poll_group(void *ctx)
 static void
 nvmf_tgt_create_poll_groups(void)
 {
-	struct spdk_cpuset tmp_cpumask = {};
 	uint32_t i;
 	char thread_name[32];
 	struct spdk_thread *thread;
@@ -195,11 +193,9 @@ nvmf_tgt_create_poll_groups(void)
 	assert(g_tgt_init_thread != NULL);
 
 	SPDK_ENV_FOREACH_CORE(i) {
-		spdk_cpuset_zero(&tmp_cpumask);
-		spdk_cpuset_set_cpu(&tmp_cpumask, i, true);
 		snprintf(thread_name, sizeof(thread_name), "nvmf_tgt_poll_group_%u", i);
 
-		thread = spdk_thread_create(thread_name, &tmp_cpumask);
+		thread = spdk_thread_create(thread_name, NULL);
 		assert(thread != NULL);
 
 		spdk_thread_send_msg(thread, nvmf_tgt_create_poll_group, NULL);
diff --git a/test/scheduler/idle.sh b/test/scheduler/idle.sh
index 23f4d2852..830580241 100755
--- a/test/scheduler/idle.sh
+++ b/test/scheduler/idle.sh
@@ -38,13 +38,10 @@ idle() {
 	# The expectation here is that when SPDK app is idle the following is true:
 	# - all threads are assigned to main lcore
 	# - threads are not being moved between lcores
-	# - each thread has a mask pinned to a single cpu
-
-	local all_set
 
 	xtrace_disable
 	while ((samples++ < 5)); do
-		all_set=0 cpusmask=0
+		cpusmask=0
 		reactor_framework=$(rpc_cmd framework_get_reactors | jq -r '.reactors[]')
 		threads=($(
 			jq -r "select(.lcore == $spdk_main_core) | .lw_threads[].name" <<< "$reactor_framework"
@@ -56,10 +53,9 @@ idle() {
 		done
 
 		printf 'SPDK cpumask: %x Threads cpumask: %x\n' "$spdk_cpusmask" "$cpusmask"
-		thread_stats && ((cpusmask == spdk_cpusmask)) && all_set=1
+		thread_stats
 	done
 
-	((all_set == 1))
 	xtrace_restore
 }
 
-- 
2.26.2


From f99d46d5f7037bcc1f3de07e9d2c0588b2012247 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Wed, 28 Apr 2021 23:10:13 +0800
Subject: [PATCH 075/342] bdev/aio: move disk free operation in
 spdk_io_device_unregister's call back

Recently, checked the spdk_io_device_unregister function,
it will have deferred free behaviour, and the io_device
will possibly be freed in put_io_channel function.

And this means that it is not safe to directly call:
    spdk_io_device_unregister (io_device, NULL);
    Then free io_device relately resource.

Because there will be channel to use the resources associated
with io_device. Then we will possibly cause a NULL pointer access.

I found this issue in bdev rbd module, and I think that the
same issue could happen in other modules. So it is better to put the
resource free function as the call back function.

Change-Id: Icc1f86d72b672faefb3b7f416030b818a8cf45ce
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7646
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/aio/bdev_aio.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/module/bdev/aio/bdev_aio.c b/module/bdev/aio/bdev_aio.c
index b9925ede6..f7c26d885 100644
--- a/module/bdev/aio/bdev_aio.c
+++ b/module/bdev/aio/bdev_aio.c
@@ -246,10 +246,10 @@ bdev_aio_flush(struct file_disk *fdisk, struct bdev_aio_task *aio_task)
 	}
 }
 
-static int
-bdev_aio_destruct(void *ctx)
+static void
+bdev_aio_destruct_cb(void *io_device)
 {
-	struct file_disk *fdisk = ctx;
+	struct file_disk *fdisk = io_device;
 	int rc = 0;
 
 	TAILQ_REMOVE(&g_aio_disk_head, fdisk, link);
@@ -257,9 +257,18 @@ bdev_aio_destruct(void *ctx)
 	if (rc < 0) {
 		SPDK_ERRLOG("bdev_aio_close() failed\n");
 	}
-	spdk_io_device_unregister(fdisk, NULL);
+
 	aio_free_disk(fdisk);
-	return rc;
+}
+
+static int
+bdev_aio_destruct(void *ctx)
+{
+	struct file_disk *fdisk = ctx;
+
+	spdk_io_device_unregister(fdisk, bdev_aio_destruct_cb);
+
+	return 0;
 }
 
 static int
-- 
2.26.2


From eb4b79919ac93f1ec09a28ada6840253733c0ea1 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 21 Apr 2021 20:20:31 +0200
Subject: [PATCH 076/342] pkgdep/git: Bump vanilla qemu to v6.0.0

Older version wasn't providing full support for PMR setup, this one
does.

Rewrite get-pmr such that it supports CMB/PMR sizes greater than 4GB.
Also, since CMB and PMR can coexist in newer versions of qemu try to
detect both under single device.

E.g.:

nvme0:0000:00:04.0:64-bit:prefetchable:0x700000000:0x707ffffff:0x08000000:cmb
nvme0:0000:00:04.0:64-bit:prefetchable:0x400000000:0x5ffffffff:0x200000000:pmr
nvme1:0000:00:05.0:64-bit:prefetchable:0x708000000:0x70fffffff:0x08000000:cmb
nvme2:0000:00:06.0:64-bit:prefetchable:0x600000000:0x6ffffffff:0x100000000:cmb

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Ic159f5c12d3ef39db77617f7d64f825356c255a4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7539
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/get-pmr               | 55 ++++++++++++++++++++++++++---------
 test/common/config/pkgdep/git |  8 ++++-
 2 files changed, 49 insertions(+), 14 deletions(-)

diff --git a/scripts/get-pmr b/scripts/get-pmr
index 76fd18662..a4c2e8cec 100755
--- a/scripts/get-pmr
+++ b/scripts/get-pmr
@@ -1,13 +1,14 @@
 #!/usr/bin/env bash
 # We simply check if BAR2 is present as that's where PMR or CMB is
 # meant to be located under qemu. If found, print some stats then exit.
+shopt -s nullglob
 
 [[ $(uname -s) == Linux ]] || exit 0
 # Use MSR instead?
 [[ $(< /sys/class/dmi/id/chassis_vendor) == QEMU ]] || exit 0
 
-get_bar2() {
-	echo "0x$(setpci -s "$1" 0x18.L)"
+get_bar() {
+	echo "0x$(setpci -s "$1" "$2.L")"
 }
 
 get_size() {
@@ -22,29 +23,57 @@ get_size() {
 			return 0
 		fi
 	done < /proc/iomem
-	echo "unknown"
+	echo "unknown/unassigned"
 }
 
 info() {
-	local bar=$1
+	local dev=$1
 
 	local pref loc
 
+	local base_addr2
+	local base_addr4
+
+	local bar local bar2 bar3 bar4 bar5
+	local bar_type2
+
 	pref[0]=non-prefetchable
 	pref[1]=prefetchable
 
-	loc[0]=32-bit
-	loc[1]="<1MiB"
-	loc[2]=64-bit
+	print_info() {
+		local bar=$1 base_addr=$2 bar_type=$3
+
+		printf '%s:%s:%s:%s:%s:%s\n' \
+			"${nvme##*/}" \
+			"$dev" \
+			"64-bit" \
+			"${pref[bar & 1 << 3 ? 1 : 0]}" \
+			"$(get_size "$base_addr")" \
+			"$bar_type"
+	}
 
-	echo "${loc[(bar >> 1) & 0x3]}:${pref[bar & 1 << 3 ? 1 : 0]}:$(get_size $((bar & ~0xf)))"
+	bar2=$(get_bar "$dev" 0x18)
+	bar3=$(get_bar "$dev" 0x1c)
+	bar4=$(get_bar "$dev" 0x20)
+	bar5=$(get_bar "$dev" 0x24)
+
+	# QEMU uses 64-bit BARs
+	if ((bar2 & 1 << 2)); then
+		bar_type2=pmr
+		if [[ -e $nvme/cmb ]]; then
+			bar_type2=cmb
+		fi
+		base_addr2=$(((bar2 & ~0xf) + (bar3 << 32)))
+		print_info "$bar2" "$base_addr2" "$bar_type2"
+	fi
+	# QEMU uses 64-bit BARs
+	if ((bar4 & 1 << 2)); then
+		base_addr4=$(((bar4 & ~0xf) + (bar5 << 32)))
+		print_info "$bar4" "$base_addr4" pmr
+	fi
 }
 
 for nvme in /sys/class/nvme/nvme*; do
 	pci=$(readlink -f "$nvme/device") pci=${pci##*/}
-	bar2=$(get_bar2 "$pci") || continue
-	((bar2 != 0x0)) || continue
-	bar=pmr
-	[[ -e $nvme/cmb ]] && bar=cmb
-	echo "${nvme##*/}:$pci:$(info "$bar2"):$bar"
+	info "$pci"
 done
diff --git a/test/common/config/pkgdep/git b/test/common/config/pkgdep/git
index 749819ba7..618856251 100644
--- a/test/common/config/pkgdep/git
+++ b/test/common/config/pkgdep/git
@@ -295,6 +295,12 @@ function _install_qemu() {
 	fi
 	opt_params+=("--extra-cflags=${extra_cflags[*]}")
 
+	if [[ $prefix == vanilla ]]; then
+		# Latest qemu seems to take sysconfdir from the prefix and instead of checking /etc
+		# it looks under /usr/local/qemu/vanilla*/bin/../etc which is a bit peculiar. Fix it.
+		opt_params+=("--sysconfdir=/etc/")
+	fi
+
 	# The qemu configure script places several output files in the CWD.
 	(cd "$repo_dir" && ./configure "${opt_params[@]}" --target-list="x86_64-softmmu" --enable-kvm --enable-linux-aio --enable-numa)
 
@@ -316,7 +322,7 @@ function install_qemu() {
 	# Forked QEMUs
 	SPDK_QEMU_BRANCH=spdk-5.0.0
 	VFIO_QEMU_BRANCH=vfio-user-v0.6
-	VANILLA_QEMU_BRANCH=v5.1.0
+	VANILLA_QEMU_BRANCH=v6.0.0
 
 	_install_qemu $GIT_REPO_QEMU_SPDK $SPDK_QEMU_BRANCH
 	_install_qemu $GIT_REPO_QEMU_VFIO $VFIO_QEMU_BRANCH
-- 
2.26.2


From 8fcb8b966d93950e0aaccce886d6722e865833a6 Mon Sep 17 00:00:00 2001
From: Rafal Stefanowski <rafal.stefanowski@intel.com>
Date: Mon, 26 Apr 2021 16:45:56 +0200
Subject: [PATCH 077/342] bdev/ocf: Improve cache line size handling

- Use consistent cache line size units in KiB across RPC calls
and config files. The KiB units are much easier to use then
the bytes units and are more human readable.
- Properly handle cache start when cache line size is incorrect.
- Add test to check if cache line size value is reported correctly.
- Add cache line size info to JSON RPC documentation.

Fixes #1858

Signed-off-by: Rafal Stefanowski <rafal.stefanowski@intel.com>
Change-Id: Iec9ede85f6884b64605d2d112947b3f175cbd938
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7614
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 doc/jsonrpc.md                              |  4 ++-
 module/bdev/ocf/utils.c                     |  6 ++++
 module/bdev/ocf/utils.h                     |  3 ++
 module/bdev/ocf/vbdev_ocf.c                 | 11 +++++--
 test/ocf/management/configuration-change.sh | 33 +++++++++++++++++++--
 test/ocf/management/create-destruct.sh      |  4 +--
 6 files changed, 52 insertions(+), 9 deletions(-)

diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index e5e4d748a..572802b86 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -2107,6 +2107,7 @@ Name                    | Optional | Type        | Description
 ----------------------- | -------- | ----------- | -----------
 name                    | Required | string      | Bdev name to use
 mode                    | Required | string      | OCF cache mode: wb, wt, pt, wa, wi, wo
+cache_line_size         | Optional | int         | OCF cache line size in KiB: 4, 8, 16, 32, 64
 cache_bdev_name         | Required | string      | Name of underlying cache bdev
 core_bdev_name          | Required | string      | Name of underlying core bdev
 
@@ -2123,7 +2124,8 @@ Example request:
   "params": {
     "name": "ocf0",
     "mode": "wt",
-    "cache_bdev_name": "Nvme0n1"
+    "cache_line_size": 64,
+    "cache_bdev_name": "Nvme0n1",
     "core_bdev_name": "aio0"
   },
   "jsonrpc": "2.0",
diff --git a/module/bdev/ocf/utils.c b/module/bdev/ocf/utils.c
index 3a1df3c9e..dacab10b7 100644
--- a/module/bdev/ocf/utils.c
+++ b/module/bdev/ocf/utils.c
@@ -69,6 +69,12 @@ ocf_get_cache_modename(ocf_cache_mode_t mode)
 	}
 }
 
+int
+ocf_get_cache_line_size(ocf_cache_t cache)
+{
+	return ocf_cache_get_line_size(cache) / KiB;
+}
+
 int
 vbdev_ocf_mngt_start(struct vbdev_ocf *vbdev, vbdev_ocf_mngt_fn *path,
 		     vbdev_ocf_mngt_callback cb, void *cb_arg)
diff --git a/module/bdev/ocf/utils.h b/module/bdev/ocf/utils.h
index 73bf6c93a..eb9f26d31 100644
--- a/module/bdev/ocf/utils.h
+++ b/module/bdev/ocf/utils.h
@@ -40,6 +40,9 @@
 ocf_cache_mode_t ocf_get_cache_mode(const char *cache_mode);
 const char *ocf_get_cache_modename(ocf_cache_mode_t mode);
 
+/* Get cache line size in KiB units */
+int ocf_get_cache_line_size(ocf_cache_t cache);
+
 /* Initiate management operation
  * Receives NULL terminated array of functions (path)
  * and callback (cb)
diff --git a/module/bdev/ocf/vbdev_ocf.c b/module/bdev/ocf/vbdev_ocf.c
index fcc7ef3ee..04491a0c1 100644
--- a/module/bdev/ocf/vbdev_ocf.c
+++ b/module/bdev/ocf/vbdev_ocf.c
@@ -198,7 +198,11 @@ static void
 unregister_finish(struct vbdev_ocf *vbdev)
 {
 	spdk_bdev_destruct_done(&vbdev->exp_bdev, vbdev->state.stop_status);
-	ocf_mngt_cache_put(vbdev->ocf_cache);
+
+	if (vbdev->ocf_cache) {
+		ocf_mngt_cache_put(vbdev->ocf_cache);
+	}
+
 	vbdev_ocf_cache_ctx_put(vbdev->cache_ctx);
 	vbdev_ocf_mngt_continue(vbdev, 0);
 }
@@ -740,7 +744,7 @@ vbdev_ocf_dump_info_json(void *opaque, struct spdk_json_write_ctx *w)
 	spdk_json_write_named_string(w, "mode",
 				     ocf_get_cache_modename(ocf_cache_get_mode(vbdev->ocf_cache)));
 	spdk_json_write_named_uint32(w, "cache_line_size",
-				     ocf_cache_get_line_size(vbdev->ocf_cache));
+				     ocf_get_cache_line_size(vbdev->ocf_cache));
 	spdk_json_write_named_bool(w, "metadata_volatile",
 				   vbdev->cfg.cache.metadata_volatile);
 
@@ -761,7 +765,7 @@ vbdev_ocf_write_json_config(struct spdk_bdev *bdev, struct spdk_json_write_ctx *
 	spdk_json_write_named_string(w, "mode",
 				     ocf_get_cache_modename(ocf_cache_get_mode(vbdev->ocf_cache)));
 	spdk_json_write_named_uint32(w, "cache_line_size",
-				     ocf_cache_get_line_size(vbdev->ocf_cache));
+				     ocf_get_cache_line_size(vbdev->ocf_cache));
 	spdk_json_write_named_string(w, "cache_bdev_name", vbdev->cache.name);
 	spdk_json_write_named_string(w, "core_bdev_name", vbdev->core.name);
 	spdk_json_write_object_end(w);
@@ -1092,6 +1096,7 @@ start_cache(struct vbdev_ocf *vbdev)
 
 	rc = ocf_mngt_cache_start(vbdev_ocf_ctx, &vbdev->ocf_cache, &vbdev->cfg.cache);
 	if (rc) {
+		SPDK_ERRLOG("Could not start cache %s: %d\n", vbdev->name, rc);
 		vbdev_ocf_mngt_exit(vbdev, unregister_path_dirty, rc);
 		return;
 	}
diff --git a/test/ocf/management/configuration-change.sh b/test/ocf/management/configuration-change.sh
index e307d9b41..faccebc9d 100755
--- a/test/ocf/management/configuration-change.sh
+++ b/test/ocf/management/configuration-change.sh
@@ -5,6 +5,7 @@ rootdir=$(readlink -f $curdir/../../..)
 source $rootdir/test/common/autotest_common.sh
 
 rpc_py=$rootdir/scripts/rpc.py
+cache_line_sizes=(4 8 16 32 64)
 cache_modes=(wt wb pt wa wi wo)
 
 $SPDK_BIN_DIR/iscsi_tgt &
@@ -12,17 +13,43 @@ spdk_pid=$!
 
 waitforlisten $spdk_pid
 
-# Prepare OCF cache
+# Create OCF cache with different cache line sizes
+for cache_line_size in "${cache_line_sizes[@]}"; do
+	$rpc_py bdev_malloc_create 101 512 -b Malloc0
+	$rpc_py bdev_malloc_create 101 512 -b Malloc1
+	$rpc_py bdev_ocf_create Cache0 wt Malloc0 Malloc1 --cache-line-size $cache_line_size
+
+	$rpc_py bdev_ocf_get_bdevs | jq -e \
+		'.[0] | .started and .cache.attached and .core.attached'
+
+	# Check if cache line size values are reported correctly
+	$rpc_py bdev_get_bdevs -b Cache0 | jq -e \
+		".[0] | .driver_specific.cache_line_size == $cache_line_size"
+	$rpc_py save_subsystem_config -n bdev | jq -e \
+		".config | .[] | select(.method == \"bdev_ocf_create\") | .params.cache_line_size == $cache_line_size"
+
+	$rpc_py bdev_ocf_delete Cache0
+	$rpc_py bdev_malloc_delete Malloc0
+	$rpc_py bdev_malloc_delete Malloc1
+done
+
+# Prepare OCF cache for dynamic configuration switching
 $rpc_py bdev_malloc_create 101 512 -b Malloc0
 $rpc_py bdev_malloc_create 101 512 -b Malloc1
-$rpc_py bdev_ocf_create Cache wt Malloc0 Malloc1
+$rpc_py bdev_ocf_create Cache0 wt Malloc0 Malloc1
 
 $rpc_py bdev_ocf_get_bdevs | jq -e \
 	'.[0] | .started and .cache.attached and .core.attached'
 
 # Change cache mode
 for cache_mode in "${cache_modes[@]}"; do
-	$rpc_py bdev_ocf_set_cache_mode Cache $cache_mode
+	$rpc_py bdev_ocf_set_cache_mode Cache0 $cache_mode
+
+	# Check if cache mode values are reported correctly
+	$rpc_py bdev_get_bdevs -b Cache0 | jq -e \
+		".[0] | .driver_specific.mode == \"$cache_mode\""
+	$rpc_py save_subsystem_config -n bdev | jq -e \
+		".config | .[] | select(.method == \"bdev_ocf_create\") | .params.mode == \"$cache_mode\""
 done
 
 trap - SIGINT SIGTERM EXIT
diff --git a/test/ocf/management/create-destruct.sh b/test/ocf/management/create-destruct.sh
index c1fd66b36..162f7a679 100755
--- a/test/ocf/management/create-destruct.sh
+++ b/test/ocf/management/create-destruct.sh
@@ -43,7 +43,7 @@ if bdev_check_claimed Malloc0; then
 	exit 1
 fi
 
-$rpc_py bdev_ocf_create FullCache wt Malloc0 Malloc1 --cache-line-size 8
+$rpc_py bdev_ocf_create FullCache wt Malloc0 Malloc1
 
 $rpc_py bdev_ocf_get_bdevs FullCache | jq -e \
 	'.[0] | .started and .cache.attached and .core.attached'
@@ -59,7 +59,7 @@ if bdev_check_claimed Malloc0 && bdev_check_claimed Malloc1; then
 	exit 1
 fi
 
-$rpc_py bdev_ocf_create HotCache wt Malloc0 Malloc1 --cache-line-size 16
+$rpc_py bdev_ocf_create HotCache wt Malloc0 Malloc1
 
 if ! (bdev_check_claimed Malloc0 && bdev_check_claimed Malloc1); then
 	echo >&2 "Base devices expected to be claimed now"
-- 
2.26.2


From eef5159387781026afe11fd72ab65c06df3349e9 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 7 May 2021 17:34:18 +0000
Subject: [PATCH 078/342] module/blob/bdev: use __SPDK_BDEV_MODULE_ONLY

This module only requires the spdk_bdev_module
APIs, so use this #define to avoid having to
bump so version when spdk_bdev is modified.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I292c38e60cbf21d0d5a6583cb2a2b097c524f3d1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7811
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 module/blob/bdev/blob_bdev.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/module/blob/bdev/blob_bdev.c b/module/blob/bdev/blob_bdev.c
index 1b788c5bf..32c1a59d8 100644
--- a/module/blob/bdev/blob_bdev.c
+++ b/module/blob/bdev/blob_bdev.c
@@ -38,6 +38,7 @@
 #include "spdk/thread.h"
 #include "spdk/log.h"
 #include "spdk/endian.h"
+#define __SPDK_BDEV_MODULE_ONLY
 #include "spdk/bdev_module.h"
 
 struct blob_bdev {
-- 
2.26.2


From 8a12e2e715a13d30a8c921c48e7ce67704c37044 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 7 May 2021 17:36:23 +0000
Subject: [PATCH 079/342] scsi: don't include bdev_module.h

The library itself doesn't need it. The unit tests
do need it, so just include it there.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I9aefd303ae12928d45141029436509f185105bd3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7812
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/scsi/scsi_bdev.c                          | 6 ------
 test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c | 1 +
 2 files changed, 1 insertion(+), 6 deletions(-)

diff --git a/lib/scsi/scsi_bdev.c b/lib/scsi/scsi_bdev.c
index 127391eca..e135296e0 100644
--- a/lib/scsi/scsi_bdev.c
+++ b/lib/scsi/scsi_bdev.c
@@ -34,12 +34,6 @@
 
 #include "scsi_internal.h"
 
-/*
- * TODO: move bdev SCSI error code translation tests to bdev unit test
- * and remove this include.
- */
-#include "spdk/bdev_module.h"
-
 #include "spdk/env.h"
 #include "spdk/bdev.h"
 #include "spdk/endian.h"
diff --git a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
index 3e1705477..195ed8be9 100644
--- a/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
+++ b/test/unit/lib/scsi/scsi_bdev.c/scsi_bdev_ut.c
@@ -40,6 +40,7 @@
 #include "spdk_cunit.h"
 
 #include "spdk_internal/mock.h"
+#include "spdk/bdev_module.h"
 
 SPDK_LOG_REGISTER_COMPONENT(scsi)
 
-- 
2.26.2


From 53447f060f30fcf3119f840e09f525529d8625ae Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 7 May 2021 18:14:04 +0000
Subject: [PATCH 080/342] nvmf: remove a bdev_module.h #include

ctrlr_discovery.c doesn't need this #include.
Including it causes bdev_module.h types to be
emitted to the debug symbols at least with some
compilers, which can result in unwanted abidiff
errors.

The unit tests do need it, so just include it
there instead.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Iad28f9778ce08b11b52325658583ae9032295f3a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7813
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvmf/ctrlr_discovery.c                                | 1 -
 test/unit/lib/nvmf/ctrlr_discovery.c/ctrlr_discovery_ut.c | 1 +
 2 files changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/nvmf/ctrlr_discovery.c b/lib/nvmf/ctrlr_discovery.c
index 7e7be6b63..a24538165 100644
--- a/lib/nvmf/ctrlr_discovery.c
+++ b/lib/nvmf/ctrlr_discovery.c
@@ -44,7 +44,6 @@
 #include "spdk/trace.h"
 #include "spdk/nvmf_spec.h"
 
-#include "spdk/bdev_module.h"
 #include "spdk/log.h"
 
 void
diff --git a/test/unit/lib/nvmf/ctrlr_discovery.c/ctrlr_discovery_ut.c b/test/unit/lib/nvmf/ctrlr_discovery.c/ctrlr_discovery_ut.c
index a21489a57..ad627818d 100644
--- a/test/unit/lib/nvmf/ctrlr_discovery.c/ctrlr_discovery_ut.c
+++ b/test/unit/lib/nvmf/ctrlr_discovery.c/ctrlr_discovery_ut.c
@@ -37,6 +37,7 @@
 #include "spdk_internal/mock.h"
 
 #include "common/lib/test_env.c"
+#include "spdk/bdev_module.h"
 #include "nvmf/ctrlr_discovery.c"
 #include "nvmf/subsystem.c"
 
-- 
2.26.2


From 646f41476d3dfe20ff076909c16b18004ebcdccc Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 11 May 2021 04:13:49 +0900
Subject: [PATCH 081/342] ut/nvme_fabric: Fix access to local variable after
 returning from the function

Fix issue #1936

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Iaa2b8060053d3f798001a6b207a6fcb0335c4b23
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7833
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 .../lib/nvme/nvme_fabric.c/nvme_fabric_ut.c   | 32 ++++++++++---------
 1 file changed, 17 insertions(+), 15 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
index 1a044720e..0aa87cfe0 100644
--- a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
+++ b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
@@ -113,13 +113,15 @@ spdk_nvme_transport_id_populate_trstring(struct spdk_nvme_transport_id *trid, co
 	return 0;
 }
 
-static const struct spdk_nvme_transport_id *g_ut_trid;
+static struct spdk_nvme_transport_id g_ut_trid;
+static bool g_ut_ctrlr_is_probed;
 
 int
 nvme_ctrlr_probe(const struct spdk_nvme_transport_id *trid,
 		 struct spdk_nvme_probe_ctx *probe_ctx, void *devhandle)
 {
-	g_ut_trid = trid;
+	g_ut_trid = *trid;
+	g_ut_ctrlr_is_probed = true;
 
 	return 0;
 }
@@ -276,30 +278,30 @@ test_nvme_fabric_discover_probe(void)
 	memcpy(entry.trsvcid, trsvcid, SPDK_NVMF_TRSVCID_MAX_LEN);
 	memcpy(probe_ctx.trid.trstring, trstring, sizeof(probe_ctx.trid.trstring));
 
-	g_ut_trid = NULL;
 	nvme_fabric_discover_probe(&entry, &probe_ctx, 1);
-	CU_ASSERT(g_ut_trid != NULL);
-	CU_ASSERT(g_ut_trid->trtype == SPDK_NVME_TRANSPORT_RDMA);
-	CU_ASSERT(g_ut_trid->adrfam == SPDK_NVMF_ADRFAM_IPV4);
-	CU_ASSERT(!strncmp(g_ut_trid->trstring, trstring, sizeof(trstring)));
-	CU_ASSERT(!strncmp(g_ut_trid->subnqn, hostnqn, sizeof(hostnqn)));
-	CU_ASSERT(!strncmp(g_ut_trid->traddr, traddr, sizeof(traddr)));
-	CU_ASSERT(!strncmp(g_ut_trid->trsvcid, trsvcid, sizeof(trsvcid)));
-	CU_ASSERT(g_ut_trid->priority == 1);
+	CU_ASSERT(g_ut_ctrlr_is_probed == true);
+	CU_ASSERT(g_ut_trid.trtype == SPDK_NVME_TRANSPORT_RDMA);
+	CU_ASSERT(g_ut_trid.adrfam == SPDK_NVMF_ADRFAM_IPV4);
+	CU_ASSERT(!strncmp(g_ut_trid.trstring, trstring, sizeof(trstring)));
+	CU_ASSERT(!strncmp(g_ut_trid.subnqn, hostnqn, sizeof(hostnqn)));
+	CU_ASSERT(!strncmp(g_ut_trid.traddr, traddr, sizeof(traddr)));
+	CU_ASSERT(!strncmp(g_ut_trid.trsvcid, trsvcid, sizeof(trsvcid)));
+	CU_ASSERT(g_ut_trid.priority == 1);
+
+	g_ut_ctrlr_is_probed = false;
+	memset(&g_ut_trid, 0, sizeof(g_ut_trid));
 
 	/* Entry type unsupported */
 	entry.subtype = SPDK_NVMF_SUBTYPE_DISCOVERY;
-	g_ut_trid = NULL;
 
 	nvme_fabric_discover_probe(&entry, &probe_ctx, 1);
-	CU_ASSERT(g_ut_trid == NULL);
+	CU_ASSERT(g_ut_ctrlr_is_probed == false);
 
 	/* Entry type invalid */
 	entry.subtype = 3;
-	g_ut_trid = NULL;
 
 	nvme_fabric_discover_probe(&entry, &probe_ctx, 1);
-	CU_ASSERT(g_ut_trid == NULL);
+	CU_ASSERT(g_ut_ctrlr_is_probed == false);
 }
 
 int main(int argc, char **argv)
-- 
2.26.2


From 2421e998491decb1ab3e25f298ee6291575fad36 Mon Sep 17 00:00:00 2001
From: Swapnil Ingle <swapnil.ingle@nutanix.com>
Date: Fri, 7 May 2021 06:35:15 -0400
Subject: [PATCH 082/342] scsi: Cache physical block size locally

Addressing review comment from 6cebe9d0.
Minor optimisation to cache result of spdk_u32log2() into local variable
instead of calling it multiple times.

Signed-off-by: Swapnil Ingle <swapnil.ingle@nutanix.com>
Change-Id: I2fd6afd1e3ee461662de3f9d278958664224e106
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7806
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: sunshihao <sunshihao@huawei.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
---
 lib/scsi/scsi_bdev.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/lib/scsi/scsi_bdev.c b/lib/scsi/scsi_bdev.c
index e135296e0..fe6b1d204 100644
--- a/lib/scsi/scsi_bdev.c
+++ b/lib/scsi/scsi_bdev.c
@@ -1614,15 +1614,16 @@ bdev_scsi_process_block(struct spdk_scsi_task *task)
 		switch (cdb[1] & 0x1f) { /* SERVICE ACTION */
 		case SPDK_SBC_SAI_READ_CAPACITY_16: {
 			uint8_t buffer[32] = {0};
-			uint32_t lbppb;
+			uint32_t lbppb, lbppbe;
 
 			to_be64(&buffer[0], spdk_bdev_get_num_blocks(bdev) - 1);
 			to_be32(&buffer[8], spdk_bdev_get_data_block_size(bdev));
 			lbppb = spdk_bdev_get_physical_block_size(bdev) / spdk_bdev_get_data_block_size(bdev);
-			if (spdk_u32log2(lbppb) > 0xf) {
-				SPDK_ERRLOG("lbppbe(0x%x) > 0xf\n", spdk_u32log2(lbppb));
+			lbppbe = spdk_u32log2(lbppb);
+			if (lbppbe > 0xf) {
+				SPDK_ERRLOG("lbppbe(0x%x) > 0xf\n", lbppbe);
 			} else {
-				buffer[13] = spdk_u32log2(lbppb);
+				buffer[13] = lbppbe;
 			}
 			/*
 			 * Set the TPE bit to 1 to indicate thin provisioning.
-- 
2.26.2


From 980a1396311a92c2d4d12b80d314fa68d5ebcd41 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Fri, 7 May 2021 15:58:32 +0800
Subject: [PATCH 083/342] test/nvmf/ctrlr_bdev: cases for identify namespace

Change-Id: I315f48185268da696e4047e1c7ac5cf2a4221765
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7285
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 .../lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c     | 155 ++++++++++++++----
 1 file changed, 127 insertions(+), 28 deletions(-)

diff --git a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
index 7edb46dfc..6f6bc0837 100644
--- a/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
+++ b/test/unit/lib/nvmf/ctrlr_bdev.c/ctrlr_bdev_ut.c
@@ -39,6 +39,7 @@
 
 #include "nvmf/ctrlr_bdev.c"
 
+#include "spdk/bdev_module.h"
 
 SPDK_LOG_REGISTER_COMPONENT(nvmf)
 
@@ -46,11 +47,6 @@ DEFINE_STUB(spdk_nvmf_request_complete, int, (struct spdk_nvmf_request *req), -1
 
 DEFINE_STUB(spdk_bdev_get_name, const char *, (const struct spdk_bdev *bdev), "test");
 
-DEFINE_STUB(spdk_bdev_get_acwu, uint16_t, (const struct spdk_bdev *bdev), 0);
-
-DEFINE_STUB(spdk_bdev_get_data_block_size, uint32_t,
-	    (const struct spdk_bdev *bdev), 512);
-
 DEFINE_STUB(spdk_bdev_get_physical_block_size, uint32_t,
 	    (const struct spdk_bdev *bdev), 4096);
 
@@ -70,35 +66,69 @@ DEFINE_STUB(spdk_bdev_abort, int,
 	    (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
 	     void *bio_cb_arg, spdk_bdev_io_completion_cb cb, void *cb_arg), 0);
 
-struct spdk_bdev {
-	uint32_t blocklen;
-	uint64_t num_blocks;
-	uint32_t md_len;
-};
+uint32_t
+spdk_bdev_get_optimal_io_boundary(const struct spdk_bdev *bdev)
+{
+	return bdev->optimal_io_boundary;
+}
 
 uint32_t
-spdk_bdev_get_block_size(const struct spdk_bdev *bdev)
+spdk_bdev_get_md_size(const struct spdk_bdev *bdev)
 {
-	return bdev->blocklen;
+	return bdev->md_len;
 }
 
-uint64_t
-spdk_bdev_get_num_blocks(const struct spdk_bdev *bdev)
+bool
+spdk_bdev_is_md_interleaved(const struct spdk_bdev *bdev)
+{
+	return (bdev->md_len != 0) && bdev->md_interleave;
+}
+
+enum spdk_dif_type spdk_bdev_get_dif_type(const struct spdk_bdev *bdev)
 {
-	return bdev->num_blocks;
+	if (bdev->md_len != 0) {
+		return bdev->dif_type;
+	} else {
+		return SPDK_DIF_DISABLE;
+	}
+}
+
+bool
+spdk_bdev_is_dif_head_of_md(const struct spdk_bdev *bdev)
+{
+	if (spdk_bdev_get_dif_type(bdev) != SPDK_DIF_DISABLE) {
+		return bdev->dif_is_head_of_md;
+	} else {
+		return false;
+	}
 }
 
 uint32_t
-spdk_bdev_get_optimal_io_boundary(const struct spdk_bdev *bdev)
+spdk_bdev_get_data_block_size(const struct spdk_bdev *bdev)
 {
-	abort();
-	return 0;
+	if (spdk_bdev_is_md_interleaved(bdev)) {
+		return bdev->blocklen - bdev->md_len;
+	} else {
+		return bdev->blocklen;
+	}
+}
+
+uint16_t
+spdk_bdev_get_acwu(const struct spdk_bdev *bdev)
+{
+	return bdev->acwu;
 }
 
 uint32_t
-spdk_bdev_get_md_size(const struct spdk_bdev *bdev)
+spdk_bdev_get_block_size(const struct spdk_bdev *bdev)
 {
-	return bdev->md_len;
+	return bdev->blocklen;
+}
+
+uint64_t
+spdk_bdev_get_num_blocks(const struct spdk_bdev *bdev)
+{
+	return bdev->blockcnt;
 }
 
 DEFINE_STUB(spdk_bdev_comparev_and_writev_blocks, int,
@@ -114,13 +144,6 @@ DEFINE_STUB(nvmf_ctrlr_process_io_cmd, int, (struct spdk_nvmf_request *req), 0);
 DEFINE_STUB_V(spdk_bdev_io_get_nvme_fused_status, (const struct spdk_bdev_io *bdev_io,
 		uint32_t *cdw0, int *cmp_sct, int *cmp_sc, int *wr_sct, int *wr_sc));
 
-DEFINE_STUB(spdk_bdev_is_md_interleaved, bool, (const struct spdk_bdev *bdev), false);
-
-DEFINE_STUB(spdk_bdev_get_dif_type, enum spdk_dif_type,
-	    (const struct spdk_bdev *bdev), SPDK_DIF_DISABLE);
-
-DEFINE_STUB(spdk_bdev_is_dif_head_of_md, bool, (const struct spdk_bdev *bdev), false);
-
 DEFINE_STUB(spdk_bdev_is_dif_check_enabled, bool,
 	    (const struct spdk_bdev *bdev, enum spdk_dif_check_type check_type), false);
 
@@ -314,7 +337,7 @@ test_spdk_nvmf_bdev_ctrlr_compare_and_write_cmd(void)
 	struct spdk_nvmf_subsystem_pg_ns_info ns_info = {};
 
 	bdev.blocklen = 512;
-	bdev.num_blocks = 10;
+	bdev.blockcnt = 10;
 	ns.bdev = &bdev;
 
 	subsystem.id = 0;
@@ -415,6 +438,81 @@ test_spdk_nvmf_bdev_ctrlr_compare_and_write_cmd(void)
 	CU_ASSERT(write_rsp.nvme_cpl.status.sc == SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID);
 }
 
+static void
+test_nvmf_bdev_ctrlr_identify_ns(void)
+{
+	struct spdk_nvmf_ns ns = {};
+	struct spdk_nvme_ns_data nsdata = {};
+	struct spdk_bdev bdev = {};
+	uint8_t ns_g_id[16] = "abcdefgh";
+	uint8_t eui64[8] = "12345678";
+
+	ns.bdev = &bdev;
+	ns.ptpl_file = (void *)0xDEADBEEF;
+	memcpy(ns.opts.nguid, ns_g_id, 16);
+	memcpy(ns.opts.eui64, eui64, 8);
+
+	bdev.blockcnt = 10;
+	bdev.acwu = 0;
+	bdev.md_len = 512;
+	bdev.dif_type = SPDK_DIF_TYPE1;
+	bdev.blocklen = 4096;
+	bdev.md_interleave = 0;
+	bdev.optimal_io_boundary = BDEV_IO_NUM_CHILD_IOV;
+	bdev.dif_is_head_of_md = true;
+
+	nvmf_bdev_ctrlr_identify_ns(&ns, &nsdata, false);
+	CU_ASSERT(nsdata.nsze == 10);
+	CU_ASSERT(nsdata.ncap == 10);
+	CU_ASSERT(nsdata.nuse == 10);
+	CU_ASSERT(nsdata.nlbaf == 0);
+	CU_ASSERT(nsdata.flbas.format == 0);
+	CU_ASSERT(nsdata.nacwu == 0);
+	CU_ASSERT(nsdata.lbaf[0].lbads == spdk_u32log2(4096));
+	CU_ASSERT(nsdata.lbaf[0].ms == 512);
+	CU_ASSERT(nsdata.dpc.pit1 == 1);
+	CU_ASSERT(nsdata.dps.pit == SPDK_NVME_FMT_NVM_PROTECTION_TYPE1);
+	CU_ASSERT(nsdata.noiob == BDEV_IO_NUM_CHILD_IOV);
+	CU_ASSERT(nsdata.nmic.can_share == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.persist == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.write_exclusive == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.exclusive_access == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.write_exclusive_reg_only == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.exclusive_access_reg_only == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.write_exclusive_all_reg == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.exclusive_access_all_reg == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.ignore_existing_key == 1);
+	CU_ASSERT(nsdata.flbas.extended == 1);
+	CU_ASSERT(nsdata.mc.extended == 1);
+	CU_ASSERT(nsdata.mc.pointer == 0);
+	CU_ASSERT(nsdata.dps.md_start == true);
+	CU_ASSERT(!strncmp(nsdata.nguid, ns_g_id, 16));
+	CU_ASSERT(!strncmp((uint8_t *)&nsdata.eui64, eui64, 8));
+
+	memset(&nsdata, 0, sizeof(nsdata));
+	nvmf_bdev_ctrlr_identify_ns(&ns, &nsdata, true);
+	CU_ASSERT(nsdata.nsze == 10);
+	CU_ASSERT(nsdata.ncap == 10);
+	CU_ASSERT(nsdata.nuse == 10);
+	CU_ASSERT(nsdata.nlbaf == 0);
+	CU_ASSERT(nsdata.flbas.format == 0);
+	CU_ASSERT(nsdata.nacwu == 0);
+	CU_ASSERT(nsdata.lbaf[0].lbads == spdk_u32log2(4096));
+	CU_ASSERT(nsdata.noiob == BDEV_IO_NUM_CHILD_IOV);
+	CU_ASSERT(nsdata.nmic.can_share == 1);
+	CU_ASSERT(nsdata.lbaf[0].ms == 0);
+	CU_ASSERT(nsdata.nsrescap.rescap.persist == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.write_exclusive == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.exclusive_access == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.write_exclusive_reg_only == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.exclusive_access_reg_only == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.write_exclusive_all_reg == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.exclusive_access_all_reg == 1);
+	CU_ASSERT(nsdata.nsrescap.rescap.ignore_existing_key == 1);
+	CU_ASSERT(!strncmp(nsdata.nguid, ns_g_id, 16));
+	CU_ASSERT(!strncmp((uint8_t *)&nsdata.eui64, eui64, 8));
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -428,6 +526,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_get_rw_params);
 	CU_ADD_TEST(suite, test_lba_in_range);
 	CU_ADD_TEST(suite, test_get_dif_ctx);
+	CU_ADD_TEST(suite, test_nvmf_bdev_ctrlr_identify_ns);
 
 	CU_ADD_TEST(suite, test_spdk_nvmf_bdev_ctrlr_compare_and_write_cmd);
 
-- 
2.26.2


From 64debe0453499f55ce068d9dd261b567dcac0d38 Mon Sep 17 00:00:00 2001
From: jiaqizho <jiaqi.zhou@intel.com>
Date: Wed, 3 Mar 2021 15:24:46 +0800
Subject: [PATCH 084/342] rpc: add a command parser

The changes in the nvmf_create_transport show
how this command parser work. And there have
two benefit for this changed.

1. Simplify the definition of rpc method. no need add
so many args anymore. Also it retains its original
functions, so we can also check the input args.

2. Make the rpc call more versatile, for example.
when user extend the subparsers(add new args
into subparsers), they can pass some private args
into the rpc method by command parser.

Signed-off-by: jiaqizho <jiaqi.zhou@intel.com>
Change-Id: Iaf916e3454f23715cf9216794bb80c65b2b4603f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6652
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 CHANGELOG.md              |  5 +++
 scripts/rpc.py            | 31 +------------
 scripts/rpc/cmd_parser.py | 31 +++++++++++++
 scripts/rpc/nvmf.py       | 92 ++++++---------------------------------
 4 files changed, 52 insertions(+), 107 deletions(-)
 create mode 100644 scripts/rpc/cmd_parser.py

diff --git a/CHANGELOG.md b/CHANGELOG.md
index d3cbf94f5..a7f7d358a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -173,6 +173,11 @@ use `enable-zerocopy-send-server` or `enable-zerocopy-send-client` instead.
 Parameter `disable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,
 use `disable-zerocopy-send-server` or `disable-zerocopy-send-client` instead.
 
+Added cmd_parser.py used to parse the args from argparse. There are
+two benefit to use command parser:
+- Simplify the definition of rpc method. It will reduce the rpc method code.
+- Make the rpc call more versatile. User can add private args into rpc method.
+
 ### rpm
 
 Added support for new RPM spec, rpmbuild/spdk.spec, which can be used for packaging the
diff --git a/scripts/rpc.py b/scripts/rpc.py
index f60863cb0..1e4f57bf3 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -1864,28 +1864,7 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
     p.set_defaults(func=nvmf_set_config)
 
     def nvmf_create_transport(args):
-        rpc.nvmf.nvmf_create_transport(args.client,
-                                       trtype=args.trtype,
-                                       tgt_name=args.tgt_name,
-                                       max_queue_depth=args.max_queue_depth,
-                                       max_qpairs_per_ctrlr=args.max_qpairs_per_ctrlr,
-                                       max_io_qpairs_per_ctrlr=args.max_io_qpairs_per_ctrlr,
-                                       in_capsule_data_size=args.in_capsule_data_size,
-                                       max_io_size=args.max_io_size,
-                                       io_unit_size=args.io_unit_size,
-                                       max_aq_depth=args.max_aq_depth,
-                                       num_shared_buffers=args.num_shared_buffers,
-                                       buf_cache_size=args.buf_cache_size,
-                                       num_cqe=args.num_cqe,
-                                       max_srq_depth=args.max_srq_depth,
-                                       no_srq=args.no_srq,
-                                       c2h_success=args.c2h_success,
-                                       dif_insert_or_strip=args.dif_insert_or_strip,
-                                       sock_priority=args.sock_priority,
-                                       acceptor_backlog=args.acceptor_backlog,
-                                       abort_timeout_sec=args.abort_timeout_sec,
-                                       no_wr_batching=args.no_wr_batching,
-                                       control_msg_num=args.control_msg_num)
+        rpc.nvmf.nvmf_create_transport(**vars(args))
 
     p = subparsers.add_parser('nvmf_create_transport', help='Create NVMf transport')
     p.add_argument('-t', '--trtype', help='Transport type (ex. RDMA)', type=str, required=True)
@@ -1969,13 +1948,7 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
     p.set_defaults(func=nvmf_delete_subsystem)
 
     def nvmf_subsystem_add_listener(args):
-        rpc.nvmf.nvmf_subsystem_add_listener(args.client,
-                                             nqn=args.nqn,
-                                             trtype=args.trtype,
-                                             traddr=args.traddr,
-                                             tgt_name=args.tgt_name,
-                                             adrfam=args.adrfam,
-                                             trsvcid=args.trsvcid)
+        rpc.nvmf.nvmf_subsystem_add_listener(**vars(args))
 
     p = subparsers.add_parser('nvmf_subsystem_add_listener', help='Add a listener to an NVMe-oF subsystem')
     p.add_argument('nqn', help='NVMe-oF subsystem NQN')
diff --git a/scripts/rpc/cmd_parser.py b/scripts/rpc/cmd_parser.py
new file mode 100644
index 000000000..4cf728f75
--- /dev/null
+++ b/scripts/rpc/cmd_parser.py
@@ -0,0 +1,31 @@
+args_global = ['server_addr', 'port', 'timeout', 'verbose', 'dry_run', 'conn_retries',
+               'is_server', 'rpc_plugin', 'called_rpc_name', 'func', 'client']
+
+
+def strip_globals(kwargs):
+    for arg in args_global:
+        kwargs.pop(arg, None)
+
+
+def remove_null(kwargs):
+    keys = []
+    for key, value in kwargs.items():
+        if value is None:
+            keys.append(key)
+
+    for key in keys:
+        kwargs.pop(key, None)
+
+
+def apply_defaults(kwargs, **defaults):
+    for key, value in defaults.items():
+        if key not in kwargs:
+            kwargs[key] = value
+
+
+def group_as(kwargs, name, values):
+    group = {}
+    for arg in values:
+        if arg in kwargs and kwargs[arg] is not None:
+            group[arg] = kwargs.pop(arg, None)
+    kwargs[name] = group
diff --git a/scripts/rpc/nvmf.py b/scripts/rpc/nvmf.py
index bd8eb3497..3070e49e0 100644
--- a/scripts/rpc/nvmf.py
+++ b/scripts/rpc/nvmf.py
@@ -1,4 +1,5 @@
 from .helpers import deprecated_alias
+from .cmd_parser import *
 
 
 @deprecated_alias('set_nvmf_target_max_subsystems')
@@ -91,28 +92,7 @@ def nvmf_get_targets(client):
     return client.call("nvmf_get_targets")
 
 
-def nvmf_create_transport(client,
-                          trtype,
-                          tgt_name=None,
-                          max_queue_depth=None,
-                          max_qpairs_per_ctrlr=None,
-                          max_io_qpairs_per_ctrlr=None,
-                          in_capsule_data_size=None,
-                          max_io_size=None,
-                          io_unit_size=None,
-                          max_aq_depth=None,
-                          num_shared_buffers=None,
-                          buf_cache_size=None,
-                          num_cqe=None,
-                          max_srq_depth=None,
-                          no_srq=False,
-                          c2h_success=True,
-                          dif_insert_or_strip=None,
-                          sock_priority=None,
-                          acceptor_backlog=None,
-                          abort_timeout_sec=None,
-                          no_wr_batching=None,
-                          control_msg_num=None):
+def nvmf_create_transport(client, **params):
     """NVMf Transport Create options.
 
     Args:
@@ -138,50 +118,14 @@ def nvmf_create_transport(client,
     Returns:
         True or False
     """
-    params = {}
 
-    params['trtype'] = trtype
-    if tgt_name:
-        params['tgt_name'] = tgt_name
-    if max_queue_depth:
-        params['max_queue_depth'] = max_queue_depth
-    if max_qpairs_per_ctrlr:
+    strip_globals(params)
+    apply_defaults(params, no_srq=False, c2h_success=True)
+    remove_null(params)
+
+    if 'max_qpairs_per_ctrlr' in params:
         print("WARNING: max_qpairs_per_ctrlr is deprecated, please use max_io_qpairs_per_ctrlr.")
-        params['max_qpairs_per_ctrlr'] = max_qpairs_per_ctrlr
-    if max_io_qpairs_per_ctrlr:
-        params['max_io_qpairs_per_ctrlr'] = max_io_qpairs_per_ctrlr
-    if in_capsule_data_size is not None:
-        params['in_capsule_data_size'] = in_capsule_data_size
-    if max_io_size:
-        params['max_io_size'] = max_io_size
-    if io_unit_size:
-        params['io_unit_size'] = io_unit_size
-    if max_aq_depth:
-        params['max_aq_depth'] = max_aq_depth
-    if num_shared_buffers:
-        params['num_shared_buffers'] = num_shared_buffers
-    if buf_cache_size is not None:
-        params['buf_cache_size'] = buf_cache_size
-    if num_cqe:
-        params['num_cqe'] = num_cqe
-    if max_srq_depth:
-        params['max_srq_depth'] = max_srq_depth
-    if no_srq:
-        params['no_srq'] = no_srq
-    if c2h_success is not None:
-        params['c2h_success'] = c2h_success
-    if dif_insert_or_strip:
-        params['dif_insert_or_strip'] = dif_insert_or_strip
-    if sock_priority is not None:
-        params['sock_priority'] = sock_priority
-    if acceptor_backlog is not None:
-        params['acceptor_backlog'] = acceptor_backlog
-    if abort_timeout_sec:
-        params['abort_timeout_sec'] = abort_timeout_sec
-    if no_wr_batching is not None:
-        params['no_wr_batching'] = no_wr_batching
-    if control_msg_num is not None:
-        params['control_msg_num'] = control_msg_num
+
     return client.call('nvmf_create_transport', params)
 
 
@@ -274,7 +218,8 @@ def nvmf_create_subsystem(client,
     return client.call('nvmf_create_subsystem', params)
 
 
-def nvmf_subsystem_add_listener(client, nqn, trtype, traddr, trsvcid, adrfam, tgt_name=None):
+def nvmf_subsystem_add_listener(client, **params):
+
     """Add a new listen address to an NVMe-oF subsystem.
 
     Args:
@@ -288,20 +233,11 @@ def nvmf_subsystem_add_listener(client, nqn, trtype, traddr, trsvcid, adrfam, tg
     Returns:
         True or False
     """
-    listen_address = {'trtype': trtype,
-                      'traddr': traddr}
-
-    if trsvcid:
-        listen_address['trsvcid'] = trsvcid
 
-    if adrfam:
-        listen_address['adrfam'] = adrfam
-
-    params = {'nqn': nqn,
-              'listen_address': listen_address}
-
-    if tgt_name:
-        params['tgt_name'] = tgt_name
+    strip_globals(params)
+    apply_defaults(params, tgt_name=None)
+    group_as(params, 'listen_address', ['trtype', 'traddr', 'trsvcid', 'adrfam'])
+    remove_null(params)
 
     return client.call('nvmf_subsystem_add_listener', params)
 
-- 
2.26.2


From e6db8e02e51a56b24c6780cfb6c1bcb7a3ed8eaf Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Sun, 25 Apr 2021 22:56:10 +0800
Subject: [PATCH 085/342] bdev: add a helper function to process IO split
 submission

Both UNMAP and R/W will share the some logic to process the submission,
so combine them to a helper function first.

Change-Id: Ia4f234c6a58f078d3e9f88cacaf1510a17f07acc
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7606
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/bdev/bdev.c | 105 ++++++++++++++++++++++++++++++------------------
 1 file changed, 67 insertions(+), 38 deletions(-)

diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 757d8e78b..14240a875 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -2040,6 +2040,70 @@ _to_next_boundary(uint64_t offset, uint32_t boundary)
 static void
 bdev_io_split_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg);
 
+static void
+_bdev_rw_split(void *_bdev_io);
+
+static int
+bdev_io_split_submit(struct spdk_bdev_io *bdev_io, struct iovec *iov, int iovcnt, void *md_buf,
+		     uint64_t num_blocks, uint64_t *offset, uint64_t *remaining)
+{
+	int rc;
+	uint64_t current_offset, current_remaining;
+
+	current_offset = *offset;
+	current_remaining = *remaining;
+
+	bdev_io->u.bdev.split_outstanding++;
+
+	switch (bdev_io->type) {
+	case SPDK_BDEV_IO_TYPE_READ:
+		rc = bdev_readv_blocks_with_md(bdev_io->internal.desc,
+					       spdk_io_channel_from_ctx(bdev_io->internal.ch),
+					       iov, iovcnt, md_buf, current_offset,
+					       num_blocks,
+					       bdev_io_split_done, bdev_io);
+		break;
+	case SPDK_BDEV_IO_TYPE_WRITE:
+		rc = bdev_writev_blocks_with_md(bdev_io->internal.desc,
+						spdk_io_channel_from_ctx(bdev_io->internal.ch),
+						iov, iovcnt, md_buf, current_offset,
+						num_blocks,
+						bdev_io_split_done, bdev_io);
+		break;
+	default:
+		assert(false);
+		rc = -EINVAL;
+		break;
+	}
+
+	if (rc == 0) {
+		current_offset += num_blocks;
+		current_remaining -= num_blocks;
+		bdev_io->u.bdev.split_current_offset_blocks = current_offset;
+		bdev_io->u.bdev.split_remaining_num_blocks = current_remaining;
+		*offset = current_offset;
+		*remaining = current_remaining;
+	} else {
+		bdev_io->u.bdev.split_outstanding--;
+		if (rc == -ENOMEM) {
+			if (bdev_io->u.bdev.split_outstanding == 0) {
+				/* No I/O is outstanding. Hence we should wait here. */
+				bdev_queue_io_wait_with_cb(bdev_io, _bdev_rw_split);
+			}
+		} else {
+			bdev_io->internal.status = SPDK_BDEV_IO_STATUS_FAILED;
+			if (bdev_io->u.bdev.split_outstanding == 0) {
+				spdk_trace_record_tsc(spdk_get_ticks(), TRACE_BDEV_IO_DONE, 0, 0,
+						      (uintptr_t)bdev_io, 0);
+				TAILQ_REMOVE(&bdev_io->internal.ch->io_submitted, bdev_io, internal.ch_link);
+				bdev_io->internal.cb(bdev_io, false, bdev_io->internal.caller_ctx);
+			}
+		}
+	}
+
+	return rc;
+}
+
 static void
 _bdev_rw_split(void *_bdev_io)
 {
@@ -2169,44 +2233,9 @@ _bdev_rw_split(void *_bdev_io)
 			to_next_boundary -= to_next_boundary_bytes / blocklen;
 		}
 
-		bdev_io->u.bdev.split_outstanding++;
-
-		if (bdev_io->type == SPDK_BDEV_IO_TYPE_READ) {
-			rc = bdev_readv_blocks_with_md(bdev_io->internal.desc,
-						       spdk_io_channel_from_ctx(bdev_io->internal.ch),
-						       iov, iovcnt, md_buf, current_offset,
-						       to_next_boundary,
-						       bdev_io_split_done, bdev_io);
-		} else {
-			rc = bdev_writev_blocks_with_md(bdev_io->internal.desc,
-							spdk_io_channel_from_ctx(bdev_io->internal.ch),
-							iov, iovcnt, md_buf, current_offset,
-							to_next_boundary,
-							bdev_io_split_done, bdev_io);
-		}
-
-		if (rc == 0) {
-			current_offset += to_next_boundary;
-			remaining -= to_next_boundary;
-			bdev_io->u.bdev.split_current_offset_blocks = current_offset;
-			bdev_io->u.bdev.split_remaining_num_blocks = remaining;
-		} else {
-			bdev_io->u.bdev.split_outstanding--;
-			if (rc == -ENOMEM) {
-				if (bdev_io->u.bdev.split_outstanding == 0) {
-					/* No I/O is outstanding. Hence we should wait here. */
-					bdev_queue_io_wait_with_cb(bdev_io, _bdev_rw_split);
-				}
-			} else {
-				bdev_io->internal.status = SPDK_BDEV_IO_STATUS_FAILED;
-				if (bdev_io->u.bdev.split_outstanding == 0) {
-					spdk_trace_record_tsc(spdk_get_ticks(), TRACE_BDEV_IO_DONE, 0, 0,
-							      (uintptr_t)bdev_io, 0);
-					TAILQ_REMOVE(&bdev_io->internal.ch->io_submitted, bdev_io, internal.ch_link);
-					bdev_io->internal.cb(bdev_io, false, bdev_io->internal.caller_ctx);
-				}
-			}
-
+		rc = bdev_io_split_submit(bdev_io, iov, iovcnt, md_buf, to_next_boundary,
+					  &current_offset, &remaining);
+		if (spdk_unlikely(rc)) {
 			return;
 		}
 	}
-- 
2.26.2


From 218d6ac8ccb7bf4866726b30fd38d420e9f5cb72 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Wed, 21 Apr 2021 20:18:22 +0800
Subject: [PATCH 086/342] bdev: add bdev_unmap_split() support

Also for the purpose to avoid a burst of children unmap request,
we will submit at most up to 8 children request at a time for
a big UNMAP command.

Change-Id: Iaf0f18b07517e0a8f84dc04e8c93b95691a1a43c
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7518
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/bdev/bdev.c | 65 +++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 63 insertions(+), 2 deletions(-)

diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 14240a875..19599bae3 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -84,6 +84,11 @@ int __itt_init_ittlib(const char *, __itt_group_id);
 
 #define SPDK_BDEV_POOL_ALIGNMENT 512
 
+/* The maximum number of children requests for a UNMAP command when splitting
+ * into children requests at a time.
+ */
+#define SPDK_BDEV_MAX_CHILDREN_UNMAP_REQS (8)
+
 static const char *qos_rpc_type[] = {"rw_ios_per_sec",
 				     "rw_mbytes_per_sec", "r_mbytes_per_sec", "w_mbytes_per_sec"
 				    };
@@ -2043,18 +2048,29 @@ bdev_io_split_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg);
 static void
 _bdev_rw_split(void *_bdev_io);
 
+static void
+bdev_unmap_split(struct spdk_bdev_io *bdev_io);
+
+static void
+_bdev_unmap_split(void *_bdev_io)
+{
+	return bdev_unmap_split((struct spdk_bdev_io *)_bdev_io);
+}
+
 static int
 bdev_io_split_submit(struct spdk_bdev_io *bdev_io, struct iovec *iov, int iovcnt, void *md_buf,
 		     uint64_t num_blocks, uint64_t *offset, uint64_t *remaining)
 {
 	int rc;
 	uint64_t current_offset, current_remaining;
+	spdk_bdev_io_wait_cb io_wait_fn;
 
 	current_offset = *offset;
 	current_remaining = *remaining;
 
 	bdev_io->u.bdev.split_outstanding++;
 
+	io_wait_fn = _bdev_rw_split;
 	switch (bdev_io->type) {
 	case SPDK_BDEV_IO_TYPE_READ:
 		rc = bdev_readv_blocks_with_md(bdev_io->internal.desc,
@@ -2070,6 +2086,13 @@ bdev_io_split_submit(struct spdk_bdev_io *bdev_io, struct iovec *iov, int iovcnt
 						num_blocks,
 						bdev_io_split_done, bdev_io);
 		break;
+	case SPDK_BDEV_IO_TYPE_UNMAP:
+		io_wait_fn = _bdev_unmap_split;
+		rc = spdk_bdev_unmap_blocks(bdev_io->internal.desc,
+					    spdk_io_channel_from_ctx(bdev_io->internal.ch),
+					    current_offset, num_blocks,
+					    bdev_io_split_done, bdev_io);
+		break;
 	default:
 		assert(false);
 		rc = -EINVAL;
@@ -2088,7 +2111,7 @@ bdev_io_split_submit(struct spdk_bdev_io *bdev_io, struct iovec *iov, int iovcnt
 		if (rc == -ENOMEM) {
 			if (bdev_io->u.bdev.split_outstanding == 0) {
 				/* No I/O is outstanding. Hence we should wait here. */
-				bdev_queue_io_wait_with_cb(bdev_io, _bdev_rw_split);
+				bdev_queue_io_wait_with_cb(bdev_io, io_wait_fn);
 			}
 		} else {
 			bdev_io->internal.status = SPDK_BDEV_IO_STATUS_FAILED;
@@ -2241,6 +2264,30 @@ _bdev_rw_split(void *_bdev_io)
 	}
 }
 
+static void
+bdev_unmap_split(struct spdk_bdev_io *bdev_io)
+{
+	uint64_t offset, unmap_blocks, remaining, max_unmap_blocks;
+	uint32_t num_children_reqs = 0;
+	int rc;
+
+	offset = bdev_io->u.bdev.split_current_offset_blocks;
+	remaining = bdev_io->u.bdev.split_remaining_num_blocks;
+	max_unmap_blocks = bdev_io->bdev->max_unmap * bdev_io->bdev->max_unmap_segments;
+
+	while (remaining && (num_children_reqs < SPDK_BDEV_MAX_CHILDREN_UNMAP_REQS)) {
+		unmap_blocks = spdk_min(remaining, max_unmap_blocks);
+
+		rc = bdev_io_split_submit(bdev_io, NULL, 0, NULL, unmap_blocks,
+					  &offset, &remaining);
+		if (spdk_likely(rc == 0)) {
+			num_children_reqs++;
+		} else {
+			return;
+		}
+	}
+}
+
 static void
 bdev_io_split_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)
 {
@@ -2276,7 +2323,18 @@ bdev_io_split_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)
 	 * Continue with the splitting process.  This function will complete the parent I/O if the
 	 * splitting is done.
 	 */
-	_bdev_rw_split(parent_io);
+	switch (parent_io->type) {
+	case SPDK_BDEV_IO_TYPE_READ:
+	case SPDK_BDEV_IO_TYPE_WRITE:
+		_bdev_rw_split(parent_io);
+		break;
+	case SPDK_BDEV_IO_TYPE_UNMAP:
+		bdev_unmap_split(parent_io);
+		break;
+	default:
+		assert(false);
+		break;
+	}
 }
 
 static void
@@ -2301,6 +2359,9 @@ bdev_io_split(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 					     bdev_io->u.bdev.num_blocks * bdev_io->bdev->blocklen);
 		}
 		break;
+	case SPDK_BDEV_IO_TYPE_UNMAP:
+		bdev_unmap_split(bdev_io);
+		break;
 	default:
 		assert(false);
 		break;
-- 
2.26.2


From d0b4deab2bfd741927b55f3f08da422a3fa3351d Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Sat, 24 Apr 2021 00:49:40 +0800
Subject: [PATCH 087/342] UT/bdev: add unmap UT to cover the split case

Change-Id: I902c9ce113cfbb2549ecb720951403496dec6d06
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7579
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 test/unit/lib/bdev/bdev.c/bdev_ut.c | 101 ++++++++++++++++++++++++++++
 1 file changed, 101 insertions(+)

diff --git a/test/unit/lib/bdev/bdev.c/bdev_ut.c b/test/unit/lib/bdev/bdev.c/bdev_ut.c
index da207559c..16656dae6 100644
--- a/test/unit/lib/bdev/bdev.c/bdev_ut.c
+++ b/test/unit/lib/bdev/bdev.c/bdev_ut.c
@@ -4262,6 +4262,106 @@ bdev_io_abort(void)
 	poll_threads();
 }
 
+static void
+bdev_unmap(void)
+{
+	struct spdk_bdev *bdev;
+	struct spdk_bdev_desc *desc = NULL;
+	struct spdk_io_channel *ioch;
+	struct spdk_bdev_channel *bdev_ch;
+	struct ut_expected_io *expected_io;
+	struct spdk_bdev_opts bdev_opts = {};
+	uint32_t i, num_outstanding;
+	uint64_t offset, num_blocks, max_unmap_blocks, num_children;
+	int rc;
+
+	spdk_bdev_get_opts(&bdev_opts, sizeof(bdev_opts));
+	bdev_opts.bdev_io_pool_size = 512;
+	bdev_opts.bdev_io_cache_size = 64;
+	rc = spdk_bdev_set_opts(&bdev_opts);
+	CU_ASSERT(rc == 0);
+
+	spdk_bdev_initialize(bdev_init_cb, NULL);
+	bdev = allocate_bdev("bdev");
+
+	rc = spdk_bdev_open_ext("bdev", true, bdev_ut_event_cb, NULL, &desc);
+	CU_ASSERT_EQUAL(rc, 0);
+	SPDK_CU_ASSERT_FATAL(desc != NULL);
+	CU_ASSERT(bdev == spdk_bdev_desc_get_bdev(desc));
+	ioch = spdk_bdev_get_io_channel(desc);
+	SPDK_CU_ASSERT_FATAL(ioch != NULL);
+	bdev_ch = spdk_io_channel_get_ctx(ioch);
+	CU_ASSERT(TAILQ_EMPTY(&bdev_ch->io_submitted));
+
+	fn_table.submit_request = stub_submit_request;
+	g_io_exp_status = SPDK_BDEV_IO_STATUS_SUCCESS;
+
+	/* Case 1: First test the request won't be split */
+	num_blocks = 32;
+
+	g_io_done = false;
+	expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_UNMAP, 0, num_blocks, 0);
+	TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+	rc = spdk_bdev_unmap_blocks(desc, ioch, 0, num_blocks, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	CU_ASSERT(g_io_done == false);
+	CU_ASSERT(g_bdev_ut_channel->outstanding_io_count == 1);
+	stub_complete_io(1);
+	CU_ASSERT(g_io_done == true);
+	CU_ASSERT(g_bdev_ut_channel->outstanding_io_count == 0);
+
+	/* Case 2: Test the split with 2 children requests */
+	bdev->max_unmap = 8;
+	bdev->max_unmap_segments = 2;
+	max_unmap_blocks = bdev->max_unmap * bdev->max_unmap_segments;
+	num_blocks = max_unmap_blocks * 2;
+	offset = 0;
+
+	g_io_done = false;
+	for (i = 0; i < 2; i++) {
+		expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_UNMAP, offset, max_unmap_blocks, 0);
+		TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+		offset += max_unmap_blocks;
+	}
+
+	rc = spdk_bdev_unmap_blocks(desc, ioch, 0, num_blocks, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	CU_ASSERT(g_io_done == false);
+	CU_ASSERT(g_bdev_ut_channel->outstanding_io_count == 2);
+	stub_complete_io(2);
+	CU_ASSERT(g_io_done == true);
+	CU_ASSERT(g_bdev_ut_channel->outstanding_io_count == 0);
+
+	/* Case 3: Test the split with 15 children requests, will finish 8 requests first */
+	num_children = 15;
+	num_blocks = max_unmap_blocks * num_children;
+	g_io_done = false;
+	offset = 0;
+	for (i = 0; i < num_children; i++) {
+		expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_UNMAP, offset, max_unmap_blocks, 0);
+		TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+		offset += max_unmap_blocks;
+	}
+
+	rc = spdk_bdev_unmap_blocks(desc, ioch, 0, num_blocks, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	CU_ASSERT(g_io_done == false);
+
+	while (num_children > 0) {
+		num_outstanding = spdk_min(num_children, SPDK_BDEV_MAX_CHILDREN_UNMAP_REQS);
+		CU_ASSERT(g_bdev_ut_channel->outstanding_io_count == num_outstanding);
+		stub_complete_io(num_outstanding);
+		num_children -= num_outstanding;
+	}
+	CU_ASSERT(g_io_done == true);
+
+	spdk_put_io_channel(ioch);
+	spdk_bdev_close(desc);
+	free_bdev(bdev);
+	spdk_bdev_finish(bdev_fini_cb, NULL);
+	poll_threads();
+}
+
 static void
 bdev_set_options_test(void)
 {
@@ -4338,6 +4438,7 @@ main(int argc, char **argv)
 	CU_ADD_TEST(suite, lock_lba_range_with_io_outstanding);
 	CU_ADD_TEST(suite, lock_lba_range_overlapped);
 	CU_ADD_TEST(suite, bdev_io_abort);
+	CU_ADD_TEST(suite, bdev_unmap);
 	CU_ADD_TEST(suite, bdev_set_options_test);
 
 	allocate_cores(1);
-- 
2.26.2


From 958364b4a0c11c8a2fe792653ed7d5a58e94ce4a Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 27 Apr 2021 09:54:55 -0400
Subject: [PATCH 088/342] lib/blob: only verify cluster allocation when I/O is
 not frozen

During snapshot creation the original blob becomes
a thin provisioned blob that will only the diff of data after
snapshot creation.

Despite the comment in the UT the number of polls before issuing
blob write was hitting blob BEFORE it swapped with new one.

Issuing I/O during this period shall check for io freeze
before checking cluster allocation.

Otherwise bs_io_unit_is_allocated() hits assert for thin
provisioned blob. This is because cluster map of blob is
empty, but properties have not been updated yet.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I742e1a50b14d456ae1e6de13b5111caec3e8322c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7641
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/blob/blobstore.c                | 4 ++--
 test/unit/lib/blob/blob.c/blob_ut.c | 7 +++----
 2 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/lib/blob/blobstore.c b/lib/blob/blobstore.c
index 0278eab80..d7e3bbb03 100644
--- a/lib/blob/blobstore.c
+++ b/lib/blob/blobstore.c
@@ -2612,8 +2612,6 @@ blob_request_submit_op_single(struct spdk_io_channel *_ch, struct spdk_blob *blo
 	cpl.u.blob_basic.cb_fn = cb_fn;
 	cpl.u.blob_basic.cb_arg = cb_arg;
 
-	is_allocated = blob_calculate_lba_and_lba_count(blob, offset, length, &lba, &lba_count);
-
 	if (blob->frozen_refcnt) {
 		/* This blob I/O is frozen */
 		spdk_bs_user_op_t *op;
@@ -2630,6 +2628,8 @@ blob_request_submit_op_single(struct spdk_io_channel *_ch, struct spdk_blob *blo
 		return;
 	}
 
+	is_allocated = blob_calculate_lba_and_lba_count(blob, offset, length, &lba, &lba_count);
+
 	switch (op_type) {
 	case SPDK_BLOB_READ: {
 		spdk_bs_batch_t *batch;
diff --git a/test/unit/lib/blob/blob.c/blob_ut.c b/test/unit/lib/blob/blob.c/blob_ut.c
index a63031bac..1494de29c 100644
--- a/test/unit/lib/blob/blob.c/blob_ut.c
+++ b/test/unit/lib/blob/blob.c/blob_ut.c
@@ -821,7 +821,7 @@ blob_snapshot_freeze_io(void)
 	/* This is implementation specific.
 	 * Flag 'frozen_io' is set in _spdk_bs_snapshot_freeze_cpl callback.
 	 * Four async I/O operations happen before that. */
-	poll_thread_times(0, 3);
+	poll_thread_times(0, 4);
 
 	CU_ASSERT(TAILQ_EMPTY(&bs_channel->queued_io));
 
@@ -833,9 +833,8 @@ blob_snapshot_freeze_io(void)
 
 	/* Verify that I/O is queued */
 	CU_ASSERT(!TAILQ_EMPTY(&bs_channel->queued_io));
-	/* Verify that payload is not written to disk */
-	CU_ASSERT(memcmp(payload_zero, &g_dev_buffer[blob->active.clusters[0]*SPDK_BS_PAGE_SIZE],
-			 SPDK_BS_PAGE_SIZE) == 0);
+	/* Verify that payload is not written to disk, at this point the blobs already switched */
+	CU_ASSERT(blob->active.clusters[0] == 0);
 
 	/* Finish all operations including spdk_bs_create_snapshot */
 	poll_threads();
-- 
2.26.2


From a8fe601853640b1a1820de48652d75e731ab66c9 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 27 Apr 2021 10:17:15 -0400
Subject: [PATCH 089/342] lib/blob: delay executing blob persist completions

This helps in next patch in series where multiple
completions will be executing.

UT is adjusted since one additional poll is required.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: Id72377ddef91e40cdbc2bdea6f33c23309b0ca3d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7642
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/blob/blobstore.c                | 20 ++++++++++++++------
 test/unit/lib/blob/blob.c/blob_ut.c |  2 +-
 2 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/lib/blob/blobstore.c b/lib/blob/blobstore.c
index d7e3bbb03..225fa11db 100644
--- a/lib/blob/blobstore.c
+++ b/lib/blob/blobstore.c
@@ -1619,6 +1619,19 @@ bs_batch_clear_dev(struct spdk_blob_persist_ctx *ctx, spdk_bs_batch_t *batch, ui
 
 static void blob_persist_check_dirty(struct spdk_blob_persist_ctx *ctx);
 
+static void
+blob_persist_complete_cb(void *arg)
+{
+	struct spdk_blob_persist_ctx *ctx = arg;
+
+	/* Call user callback */
+	ctx->cb_fn(ctx->seq, ctx->cb_arg, 0);
+
+	/* Free the memory */
+	spdk_free(ctx->pages);
+	free(ctx);
+}
+
 static void
 blob_persist_complete(spdk_bs_sequence_t *seq, struct spdk_blob_persist_ctx *ctx, int bserrno)
 {
@@ -1634,12 +1647,7 @@ blob_persist_complete(spdk_bs_sequence_t *seq, struct spdk_blob_persist_ctx *ctx
 
 	next_persist = TAILQ_FIRST(&blob->pending_persists);
 
-	/* Call user callback */
-	ctx->cb_fn(seq, ctx->cb_arg, bserrno);
-
-	/* Free the memory */
-	spdk_free(ctx->pages);
-	free(ctx);
+	spdk_thread_send_msg(spdk_get_thread(), blob_persist_complete_cb, ctx);
 
 	if (next_persist != NULL) {
 		blob->state = SPDK_BLOB_STATE_DIRTY;
diff --git a/test/unit/lib/blob/blob.c/blob_ut.c b/test/unit/lib/blob/blob.c/blob_ut.c
index 1494de29c..b11e002d4 100644
--- a/test/unit/lib/blob/blob.c/blob_ut.c
+++ b/test/unit/lib/blob/blob.c/blob_ut.c
@@ -821,7 +821,7 @@ blob_snapshot_freeze_io(void)
 	/* This is implementation specific.
 	 * Flag 'frozen_io' is set in _spdk_bs_snapshot_freeze_cpl callback.
 	 * Four async I/O operations happen before that. */
-	poll_thread_times(0, 4);
+	poll_thread_times(0, 5);
 
 	CU_ASSERT(TAILQ_EMPTY(&bs_channel->queued_io));
 
-- 
2.26.2


From 1f5bae841a9c405bca44c1753a027cd87d227b4c Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Mon, 10 May 2021 15:12:00 +0000
Subject: [PATCH 090/342] build: also look for vfio-user libraries in 'lib'

At least on some Ubuntu distributions, default
vfio-user install puts libs in usr/local/lib instead
of usr/local/lib64.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ib312d8ca9b4ce9e858a9a9e76525fc8afd48ced5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7825
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 mk/spdk.common.mk | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/mk/spdk.common.mk b/mk/spdk.common.mk
index 897be4d21..e3f7b3a75 100644
--- a/mk/spdk.common.mk
+++ b/mk/spdk.common.mk
@@ -198,6 +198,12 @@ endif
 VFIO_USER_INSTALL_DIR=$(VFIO_USER_DIR)/build
 VFIO_USER_INCLUDE_DIR=$(VFIO_USER_INSTALL_DIR)/usr/local/include
 VFIO_USER_LIBRARY_DIR=$(VFIO_USER_INSTALL_DIR)/usr/local/lib64
+ifeq (,$(wildcard $(VFIO_USER_LIBRARY_DIR)/.))
+# Some Linux distros use lib instead of lib64
+# for default installations
+VFIO_USER_LIBRARY_DIR=$(VFIO_USER_INSTALL_DIR)/usr/local/lib
+endif
+
 CFLAGS += -I$(VFIO_USER_INCLUDE_DIR)
 LDFLAGS += -L$(VFIO_USER_LIBRARY_DIR)
 SYS_LIBS += -Wl,-Bstatic -lvfio-user -Wl,-Bdynamic -ljson-c
-- 
2.26.2


From b549f4113c8ba742b5e2bdd0fb75381203a60f58 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Mon, 10 May 2021 15:30:26 +0000
Subject: [PATCH 091/342] build: relink apps when vfio-user library is updated

Look for 'vfio_user' in SPDK_LIB_FILES to determine
whether the target application actually needs to be
rebuilt.

Fixes issue #1930.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: If3f699c91972e20dc4520e25c655ed11f6843be0
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7826
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 mk/spdk.app.mk | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/mk/spdk.app.mk b/mk/spdk.app.mk
index 61a23d5e7..5020a20ab 100644
--- a/mk/spdk.app.mk
+++ b/mk/spdk.app.mk
@@ -52,6 +52,10 @@ LIBS += $(SPDK_LIB_LINKER_ARGS)
 
 CLEAN_FILES = $(APP)
 
+ifeq ($(findstring vfio_user,$(SPDK_LIB_FILES)),vfio_user)
+VFIO_USER_LIB_FILE=$(VFIO_USER_LIBRARY_DIR)/libvfio-user.a
+endif
+
 all : $(APP)
 	@:
 
@@ -63,7 +67,7 @@ uninstall: empty_rule
 empty_rule:
 	@:
 
-$(APP) : $(OBJS) $(SPDK_LIB_FILES) $(ENV_LIBS)
+$(APP) : $(OBJS) $(SPDK_LIB_FILES) $(ENV_LIBS) $(VFIO_USER_LIB_FILE)
 	$(LINK_C)
 
 clean :
-- 
2.26.2


From 78a794b9a3a65ee25e7d1840f3a4b4b98a053bb3 Mon Sep 17 00:00:00 2001
From: Krishna Kanth Reddy <krish.reddy@samsung.com>
Date: Fri, 30 Apr 2021 14:26:43 +0530
Subject: [PATCH 092/342] examples/identify: Identification of Simple Copy
 Command support

Signed-off-by: Krishna Kanth Reddy <krish.reddy@samsung.com>
Change-Id: I251f3b1a6c7e36b946ddc8bd8a07b0f588e23c9e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7693
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 examples/nvme/identify/identify.c |  8 +++++++
 include/spdk/nvme_spec.h          | 40 ++++++++++++++++++++++++++++---
 test/make/check_so_deps.sh        |  4 ++++
 3 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index 20a0d2d68..c75762ee5 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -1027,6 +1027,12 @@ print_namespace(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
 		printf("  Atomic Boundary Offset:              %d\n", nsdata->nabo);
 	}
 
+	if (cdata->oncs.copy) {
+		printf("Maximum Single Source Range Length:    %d\n", nsdata->mssrl);
+		printf("Maximum Copy Length:                   %d\n", nsdata->mcl);
+		printf("Maximum Source Range Count:            %d\n", nsdata->msrc + 1);
+	}
+
 	printf("NGUID/EUI64 Never Reused:              %s\n",
 	       nsdata->nsfeat.guid_never_reused ? "Yes" : "No");
 
@@ -1463,6 +1469,8 @@ print_controller(struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_transport
 	       cdata->oncs.reservations ? "Supported" : "Not Supported");
 	printf("Timestamp:                   %s\n",
 	       cdata->oncs.timestamp ? "Supported" : "Not Supported");
+	printf("Copy:                        %s\n",
+	       cdata->oncs.copy ? "Supported" : "Not Supported");
 	printf("Volatile Write Cache:        %s\n",
 	       cdata->vwc.present ? "Present" : "Not Present");
 	printf("Atomic Write Unit (Normal):  %d\n", cdata->awun + 1);
diff --git a/include/spdk/nvme_spec.h b/include/spdk/nvme_spec.h
index df9471672..5cab10183 100644
--- a/include/spdk/nvme_spec.h
+++ b/include/spdk/nvme_spec.h
@@ -1338,6 +1338,21 @@ struct spdk_nvme_dsm_range {
 };
 SPDK_STATIC_ASSERT(sizeof(struct spdk_nvme_dsm_range) == 16, "Incorrect size");
 
+/**
+ * Simple Copy Command source range
+ */
+struct spdk_nvme_scc_source_range {
+	uint64_t reserved0;
+	uint64_t slba;
+	uint16_t nlb;
+	uint16_t reserved18;
+	uint32_t reserved20;
+	uint32_t eilbrt;
+	uint16_t elbat;
+	uint16_t elbatm;
+};
+SPDK_STATIC_ASSERT(sizeof(struct spdk_nvme_scc_source_range) == 32, "Incorrect size");
+
 /**
  * Status code types
  */
@@ -1443,6 +1458,7 @@ enum spdk_nvme_command_specific_status_code {
 	SPDK_NVME_SC_CONFLICTING_ATTRIBUTES		= 0x80,
 	SPDK_NVME_SC_INVALID_PROTECTION_INFO		= 0x81,
 	SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_RANGE	= 0x82,
+	SPDK_NVME_SC_CMD_SIZE_LIMIT_SIZE_EXCEEDED	= 0x83,
 };
 
 /**
@@ -1539,6 +1555,8 @@ enum spdk_nvme_nvm_opcode {
 
 	SPDK_NVME_OPC_RESERVATION_ACQUIRE		= 0x11,
 	SPDK_NVME_OPC_RESERVATION_RELEASE		= 0x15,
+
+	SPDK_NVME_OPC_COPY				= 0x19,
 };
 
 /**
@@ -2149,7 +2167,9 @@ struct __attribute__((packed)) __attribute__((aligned)) spdk_nvme_ctrlr_data {
 		uint16_t	set_features_save: 1;
 		uint16_t	reservations: 1;
 		uint16_t	timestamp: 1;
-		uint16_t	reserved: 9;
+		uint16_t	verify: 1;
+		uint16_t	copy: 1;
+		uint16_t	reserved9: 7;
 	} oncs;
 
 	/** fused operation support */
@@ -2187,7 +2207,12 @@ struct __attribute__((packed)) __attribute__((aligned)) spdk_nvme_ctrlr_data {
 	/** atomic compare & write unit */
 	uint16_t		acwu;
 
-	uint16_t		reserved534;
+	/** optional copy formats supported */
+	struct {
+		uint16_t	copy_format0 : 1;
+		uint16_t	reserved1: 15;
+	} ocfs;
+
 
 	struct spdk_nvme_cdata_sgls sgls;
 
@@ -2479,7 +2504,16 @@ struct spdk_nvme_ns_data {
 	/** Namespace Optimal Write Size */
 	uint16_t                nows;
 
-	uint8_t			reserved64[18];
+	/** Maximum Single Source Range Length */
+	uint16_t                mssrl;
+
+	/** Maximum Copy Length */
+	uint32_t                mcl;
+
+	/** Maximum Source Range Count */
+	uint8_t	                msrc;
+
+	uint8_t			reserved64[11];
 
 	/** ANA group identifier */
 	uint32_t		anagrpid;
diff --git a/test/make/check_so_deps.sh b/test/make/check_so_deps.sh
index c53ccc25f..a42c68338 100755
--- a/test/make/check_so_deps.sh
+++ b/test/make/check_so_deps.sh
@@ -49,6 +49,10 @@ function confirm_abi_deps() {
 	fi
 
 	cat << EOF > ${suppression_file}
+[suppress_type]
+	name = spdk_nvme_ns_data
+[suppress_type]
+	name = spdk_nvme_ctrlr_data
 EOF
 
 	for object in "$libdir"/libspdk_*.so; do
-- 
2.26.2


From 55189bee6b8255a29c6164c8b8a018730d405687 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Fri, 7 May 2021 17:48:20 +0800
Subject: [PATCH 093/342] libvfio-user: update submodule

This update will stop using `struct vfio_device_info` from
<linux/vfio.h>.

Fix issue #1922.

Change-Id: Ia7ad745db8d7ed8f5248ca13e3188ebd540b0e40
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7831
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 include/spdk/vfio_user_spec.h      | 8 ++++++++
 lib/vfio_user/vfio_user.c          | 4 ++--
 lib/vfio_user/vfio_user_internal.h | 3 ++-
 lib/vfio_user/vfio_user_pci.c      | 2 +-
 libvfio-user                       | 2 +-
 5 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/include/spdk/vfio_user_spec.h b/include/spdk/vfio_user_spec.h
index ac87ba181..1da127b98 100644
--- a/include/spdk/vfio_user_spec.h
+++ b/include/spdk/vfio_user_spec.h
@@ -81,6 +81,14 @@ struct vfio_user_version {
 	uint8_t		data[];
 } __attribute__((packed));
 
+struct vfio_user_device_info {
+	uint32_t    argsz;
+	/* VFIO_DEVICE_FLAGS_* */
+	uint32_t    flags;
+	uint32_t    num_regions;
+	uint32_t    num_irqs;
+} __attribute__((packed));
+
 struct vfio_user_dma_region {
 	uint64_t	addr;
 	uint64_t	size;
diff --git a/lib/vfio_user/vfio_user.c b/lib/vfio_user/vfio_user.c
index 4024dc105..53f297001 100644
--- a/lib/vfio_user/vfio_user.c
+++ b/lib/vfio_user/vfio_user.c
@@ -285,10 +285,10 @@ vfio_user_get_dev_region_info(struct vfio_device *dev, struct vfio_region_info *
 }
 
 int
-vfio_user_get_dev_info(struct vfio_device *dev, struct vfio_device_info *dev_info,
+vfio_user_get_dev_info(struct vfio_device *dev, struct vfio_user_device_info *dev_info,
 		       size_t buf_len)
 {
-	dev_info->argsz = sizeof(struct vfio_device_info);
+	dev_info->argsz = sizeof(struct vfio_user_device_info);
 	return vfio_user_dev_send_request(dev, VFIO_USER_DEVICE_GET_INFO,
 					  dev_info, dev_info->argsz, buf_len, NULL, 0);
 }
diff --git a/lib/vfio_user/vfio_user_internal.h b/lib/vfio_user/vfio_user_internal.h
index f14cc87a4..d03b328e5 100644
--- a/lib/vfio_user/vfio_user_internal.h
+++ b/lib/vfio_user/vfio_user_internal.h
@@ -34,6 +34,7 @@
 #define _VFIO_INTERNAL_H
 
 #include <linux/vfio.h>
+#include "spdk/vfio_user_spec.h"
 
 #define VFIO_USER_MAJOR_VER			0
 #define VFIO_USER_MINOR_VER			1
@@ -85,7 +86,7 @@ struct vfio_device {
 };
 
 int vfio_user_dev_setup(struct vfio_device *dev);
-int vfio_user_get_dev_info(struct vfio_device *dev, struct vfio_device_info *dev_info,
+int vfio_user_get_dev_info(struct vfio_device *dev, struct vfio_user_device_info *dev_info,
 			   size_t buf_len);
 int vfio_user_get_dev_region_info(struct vfio_device *dev, struct vfio_region_info *region_info,
 				  size_t buf_len, int *fds, int num_fds);
diff --git a/lib/vfio_user/vfio_user_pci.c b/lib/vfio_user/vfio_user_pci.c
index 6e3b2c34e..37758e293 100644
--- a/lib/vfio_user/vfio_user_pci.c
+++ b/lib/vfio_user/vfio_user_pci.c
@@ -369,7 +369,7 @@ spdk_vfio_user_setup(const char *path)
 {
 	int ret;
 	struct vfio_device *device = NULL;
-	struct vfio_device_info dev_info = {};
+	struct vfio_user_device_info dev_info = {};
 
 	device = calloc(1, sizeof(*device));
 	if (!device) {
diff --git a/libvfio-user b/libvfio-user
index 3acb97477..702a4cad4 160000
--- a/libvfio-user
+++ b/libvfio-user
@@ -1 +1 @@
-Subproject commit 3acb97477f261bf11c866b5764deabe693607bc3
+Subproject commit 702a4cad49c40406ff498e0da4a80c6d07b4fc83
-- 
2.26.2


From 19f0c9a0d06b00f380a649e5a837e4a10267a629 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Thu, 29 Apr 2021 15:29:46 +0200
Subject: [PATCH 094/342] autotest: Replace fio.py with a bash wrapper in tests

fio.py simply wraps itself around fio and doesn't do anything that
would require python to be in use. Having it in a simple bash form
makes it easier to integrate it with autotest's common sh tooling
and to debug any potential issues with the underlying tests.

This also fixes #1919 by making sure only proper nvme devices are
selected for the nvmf targets.

Fixes: #1919.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I111d00df3c7b2517f431cae865e258a665c2ecb3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7684
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/fio-wrapper                           | 139 ++++++++++++++++++
 test/iscsi_tgt/digests/digests.sh             |   2 +-
 test/iscsi_tgt/fio/fio.sh                     |   2 +-
 test/iscsi_tgt/ip_migration/ip_migration.sh   |   2 +-
 .../login_redirection/login_redirection.sh    |   2 +-
 test/iscsi_tgt/lvol/iscsi_lvol.sh             |   2 +-
 .../multiconnection/multiconnection.sh        |   2 +-
 test/iscsi_tgt/nvme_remote/fio_remote_nvme.sh |   2 +-
 test/iscsi_tgt/pmem/iscsi_pmem.sh             |   2 +-
 test/iscsi_tgt/qos/qos.sh                     |   2 +-
 test/iscsi_tgt/rbd/rbd.sh                     |   2 +-
 test/iscsi_tgt/reset/reset.sh                 |   2 +-
 test/iscsi_tgt/trace_record/trace_record.sh   |   2 +-
 test/nvmf/target/fio.sh                       |  10 +-
 test/nvmf/target/initiator_timeout.sh         |   2 +-
 test/nvmf/target/multiconnection.sh           |   4 +-
 test/nvmf/target/multipath.sh                 |   4 +-
 test/nvmf/target/nmic.sh                      |   2 +-
 test/nvmf/target/srq_overwhelm.sh             |   2 +-
 19 files changed, 163 insertions(+), 24 deletions(-)
 create mode 100755 scripts/fio-wrapper

diff --git a/scripts/fio-wrapper b/scripts/fio-wrapper
new file mode 100755
index 000000000..34030c195
--- /dev/null
+++ b/scripts/fio-wrapper
@@ -0,0 +1,139 @@
+#!/usr/bin/env bash
+rootdir=$(readlink -f "$(dirname "$0")/../")
+
+shopt -s nullglob extglob
+
+fio_config() {
+	local devs=("$@") dev
+
+	cat <<- FIO
+		[global]
+		thread=1
+		invalidate=1
+		rw=$testtype
+		time_based=1
+		runtime=$runtime
+		ioengine=libaio
+		direct=1
+		bs=$blocksize
+		iodepth=$iodepth
+		norandommap=$((verify == 1 ? 0 : 1))
+		numjobs=$numjobs
+		verify_dump=1
+	FIO
+
+	if ((verify == 1)); then
+		cat <<- FIO
+			do_verify=$verify
+			verify=crc32c-intel
+		FIO
+	fi
+
+	for dev in "${!devs[@]}"; do
+		cat <<- FIO
+			[job$dev]
+			filename=/dev/${devs[dev]}
+		FIO
+	done
+}
+
+run_fio() {
+	fio_config "$@" | fio -
+}
+
+get_iscsi() {
+	while read -r; do
+		[[ $REPLY =~ "Attached scsi disk "(sd[a-z]+) ]] && echo "${BASH_REMATCH[1]}"
+	done < <(iscsiadm -m session -P 3)
+}
+
+get_nvme() {
+	local blocks nvme nvme_sub
+	for nvme in /sys/class/nvme/nvme+([0-9]); do
+		# Make sure we touch only the block devices which belong to bdev subsystem and
+		# use supported protocols.
+		[[ $(< "$nvme/transport") == tcp || $(< "$nvme/transport") == rdma ]] || continue
+		for nvme_sub in /sys/class/nvme-subsystem/nvme-subsys+([0-9]); do
+			[[ -e $nvme_sub/${nvme##*/} ]] || continue
+			[[ $(< "$nvme_sub/model") == "SPDK bdev Controller"* ]] || continue
+			blocks+=("$nvme_sub/${nvme##*/}"n*)
+		done
+	done
+	printf '%s\n' "${blocks[@]##*/}"
+}
+
+get_devices() {
+	local devs=("$@")
+
+	if ((${#devs[@]} == 0)); then
+		case "$protocol" in
+			iscsi) devs=($(get_iscsi)) ;;
+			nvmf) devs=($(get_nvme)) ;;
+			*) ;;
+		esac
+	fi
+	printf '%s\n' "${devs[@]}"
+}
+
+configure_devices() {
+	local devs=("$@") dev qd
+
+	for dev in "${devs[@]}"; do
+		qd=128
+		# Disable all merge tries"
+		echo 2 > "/sys/block/$dev/queue/nomerges"
+		# FIXME: nr_requests already has its default value at 128. Also, when no
+		# scheduler is associated with the device this value cannot be changed
+		# and is automatically adjusted as well.
+		# echo 128 > "/sys/block/$dev/queue/nr_requests"
+		if [[ -e /sys/block/$dev/device/queue_depth ]]; then
+			# FIXME: Is this really needed though? Can't we use the default? This is not
+			# very deterministic as depending on the device we may end up with different
+			# qd in the range of 1-128.
+			while ((qd > 0)) && ! echo "$qd" > "/sys/block/$dev/device/queue_depth"; do
+				((--qd))
+			done 2> /dev/null
+			if ((qd == 0)); then
+				printf 'Failed to set queue_depth (%s)\n' "$dev"
+				return 1
+			fi
+			printf 'queue_depth set to %u (%s)\n' "$qd" "$dev"
+		else
+			printf 'Could not set queue depth (%s)\n' "$dev" >&2
+		fi
+		echo none > "/sys/block/$dev/queue/scheduler"
+	done
+}
+
+# Defaults
+blocksize=4096
+iodepth=1
+numjobs=1
+protocol="nvmf"
+runtime=1
+testtype="read"
+verify=0
+
+# Keep short args compatible with fio.py
+while getopts :i:d:n:p:r:t:v arg; do
+	case "$arg" in
+		i) blocksize=$OPTARG ;;
+		d) iodepth=$OPTARG ;;
+		n) numjobs=$OPTARG ;;
+		p) protocol=$OPTARG ;;
+		r) runtime=$OPTARG ;;
+		t) testtype=$OPTARG ;;
+		v) verify=1 ;;
+		*) ;;
+	esac
+done
+shift $((OPTIND - 1))
+
+devices=($(get_devices "$@"))
+if ((${#devices[@]} == 0)); then
+	printf '* No devices were found for the test, aborting\n' >&2
+	exit 1
+fi
+
+fio_config "${devices[@]}"
+configure_devices "${devices[@]}" && run_fio "${devices[@]}"
diff --git a/test/iscsi_tgt/digests/digests.sh b/test/iscsi_tgt/digests/digests.sh
index 0d46c5dbb..6bbedd3e3 100755
--- a/test/iscsi_tgt/digests/digests.sh
+++ b/test/iscsi_tgt/digests/digests.sh
@@ -47,7 +47,7 @@ MALLOC_BDEV_SIZE=64
 MALLOC_BLOCK_SIZE=512
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_tgt
 
diff --git a/test/iscsi_tgt/fio/fio.sh b/test/iscsi_tgt/fio/fio.sh
index dc072620f..4710de1f6 100755
--- a/test/iscsi_tgt/fio/fio.sh
+++ b/test/iscsi_tgt/fio/fio.sh
@@ -56,7 +56,7 @@ MALLOC_BDEV_SIZE=64
 MALLOC_BLOCK_SIZE=4096
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_tgt
 
diff --git a/test/iscsi_tgt/ip_migration/ip_migration.sh b/test/iscsi_tgt/ip_migration/ip_migration.sh
index 402f676f7..44dd766ec 100755
--- a/test/iscsi_tgt/ip_migration/ip_migration.sh
+++ b/test/iscsi_tgt/ip_migration/ip_migration.sh
@@ -8,7 +8,7 @@ source $rootdir/test/iscsi_tgt/common.sh
 iscsitestinit
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 source "$rootdir/test/common/applications.sh"
 NETMASK=127.0.0.0/24
diff --git a/test/iscsi_tgt/login_redirection/login_redirection.sh b/test/iscsi_tgt/login_redirection/login_redirection.sh
index 824eb2e64..c9fb998cb 100755
--- a/test/iscsi_tgt/login_redirection/login_redirection.sh
+++ b/test/iscsi_tgt/login_redirection/login_redirection.sh
@@ -11,7 +11,7 @@ NULL_BDEV_SIZE=64
 NULL_BLOCK_SIZE=512
 
 rpc_py=$rootdir/scripts/rpc.py
-fio_py=$rootdir/scripts/fio.py
+fio_py=$rootdir/scripts/fio-wrapper
 
 rpc_addr1="/var/tmp/spdk0.sock"
 rpc_addr2="/var/tmp/spdk1.sock"
diff --git a/test/iscsi_tgt/lvol/iscsi_lvol.sh b/test/iscsi_tgt/lvol/iscsi_lvol.sh
index ad975c636..39ff87a41 100755
--- a/test/iscsi_tgt/lvol/iscsi_lvol.sh
+++ b/test/iscsi_tgt/lvol/iscsi_lvol.sh
@@ -18,7 +18,7 @@ else
 fi
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_tgt
 
diff --git a/test/iscsi_tgt/multiconnection/multiconnection.sh b/test/iscsi_tgt/multiconnection/multiconnection.sh
index 09cc9a2fb..a1fc43933 100755
--- a/test/iscsi_tgt/multiconnection/multiconnection.sh
+++ b/test/iscsi_tgt/multiconnection/multiconnection.sh
@@ -8,7 +8,7 @@ source $rootdir/test/iscsi_tgt/common.sh
 iscsitestinit
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 CONNECTION_NUMBER=30
 
diff --git a/test/iscsi_tgt/nvme_remote/fio_remote_nvme.sh b/test/iscsi_tgt/nvme_remote/fio_remote_nvme.sh
index 65a2a1681..47aa5a595 100755
--- a/test/iscsi_tgt/nvme_remote/fio_remote_nvme.sh
+++ b/test/iscsi_tgt/nvme_remote/fio_remote_nvme.sh
@@ -10,7 +10,7 @@ nvmftestinit
 iscsitestinit
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 # Namespaces are NOT used here on purpose. Rxe_cfg utilility used for NVMf tests do not support namespaces.
 TARGET_IP=127.0.0.1
diff --git a/test/iscsi_tgt/pmem/iscsi_pmem.sh b/test/iscsi_tgt/pmem/iscsi_pmem.sh
index da6fd77f4..5765bedfe 100755
--- a/test/iscsi_tgt/pmem/iscsi_pmem.sh
+++ b/test/iscsi_tgt/pmem/iscsi_pmem.sh
@@ -13,7 +13,7 @@ PMEM_BLOCK_SIZE=512
 TGT_NR=10
 PMEM_PER_TGT=1
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_target
 "${ISCSI_APP[@]}" -m $ISCSI_TEST_CORE_MASK --wait-for-rpc &
diff --git a/test/iscsi_tgt/qos/qos.sh b/test/iscsi_tgt/qos/qos.sh
index 6690c1549..31092d5f3 100755
--- a/test/iscsi_tgt/qos/qos.sh
+++ b/test/iscsi_tgt/qos/qos.sh
@@ -53,7 +53,7 @@ MALLOC_BLOCK_SIZE=512
 IOPS_RESULT=
 BANDWIDTH_RESULT=
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_tgt
 
diff --git a/test/iscsi_tgt/rbd/rbd.sh b/test/iscsi_tgt/rbd/rbd.sh
index 7ab0e0352..8a2a9a702 100755
--- a/test/iscsi_tgt/rbd/rbd.sh
+++ b/test/iscsi_tgt/rbd/rbd.sh
@@ -13,7 +13,7 @@ trap 'rbd_cleanup; exit 1' SIGINT SIGTERM EXIT
 timing_exit rbd_setup
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_tgt
 
diff --git a/test/iscsi_tgt/reset/reset.sh b/test/iscsi_tgt/reset/reset.sh
index 7b1d8ada7..5ed96eea8 100755
--- a/test/iscsi_tgt/reset/reset.sh
+++ b/test/iscsi_tgt/reset/reset.sh
@@ -11,7 +11,7 @@ MALLOC_BDEV_SIZE=64
 MALLOC_BLOCK_SIZE=512
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 if ! hash sg_reset; then
 	exit 1
diff --git a/test/iscsi_tgt/trace_record/trace_record.sh b/test/iscsi_tgt/trace_record/trace_record.sh
index 7e13838ba..5a411e3ae 100755
--- a/test/iscsi_tgt/trace_record/trace_record.sh
+++ b/test/iscsi_tgt/trace_record/trace_record.sh
@@ -31,7 +31,7 @@ MALLOC_BDEV_SIZE=64
 MALLOC_BLOCK_SIZE=4096
 
 rpc_py="$rootdir/scripts/rpc.py"
-fio_py="$rootdir/scripts/fio.py"
+fio_py="$rootdir/scripts/fio-wrapper"
 
 timing_enter start_iscsi_tgt
 
diff --git a/test/nvmf/target/fio.sh b/test/nvmf/target/fio.sh
index 4e98d7083..d50853155 100755
--- a/test/nvmf/target/fio.sh
+++ b/test/nvmf/target/fio.sh
@@ -35,15 +35,15 @@ nvme connect -t $TEST_TRANSPORT -n "nqn.2016-06.io.spdk:cnode1" -a "$NVMF_FIRST_
 
 waitforserial $NVMF_SERIAL 3
 
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 1 -t write -r 1 -v
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 1 -t randwrite -r 1 -v
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 128 -t write -r 1 -v
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 128 -t randwrite -r 1 -v
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 1 -t write -r 1 -v
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 1 -t randwrite -r 1 -v
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 128 -t write -r 1 -v
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 128 -t randwrite -r 1 -v
 
 sync
 
 #start hotplug test case
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 1 -t read -r 10 &
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 1 -t read -r 10 &
 fio_pid=$!
 
 sleep 3
diff --git a/test/nvmf/target/initiator_timeout.sh b/test/nvmf/target/initiator_timeout.sh
index 199983be5..12c759c64 100755
--- a/test/nvmf/target/initiator_timeout.sh
+++ b/test/nvmf/target/initiator_timeout.sh
@@ -30,7 +30,7 @@ nvme connect -t $TEST_TRANSPORT -n "nqn.2016-06.io.spdk:cnode1" -a "$NVMF_FIRST_
 waitforserial "$NVMF_SERIAL"
 
 # Once our timed out I/O complete, we will still have 10 sec of I/O.
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 1 -t write -r 60 -v &
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 1 -t write -r 60 -v &
 fio_pid=$!
 
 sleep 3
diff --git a/test/nvmf/target/multiconnection.sh b/test/nvmf/target/multiconnection.sh
index d7e490861..9befe2543 100755
--- a/test/nvmf/target/multiconnection.sh
+++ b/test/nvmf/target/multiconnection.sh
@@ -37,8 +37,8 @@ for i in $(seq 1 $NVMF_SUBSYS); do
 	waitforserial SPDK$i
 done
 
-$rootdir/scripts/fio.py -p nvmf -i 262144 -d 64 -t read -r 10
-$rootdir/scripts/fio.py -p nvmf -i 262144 -d 64 -t randwrite -r 10
+$rootdir/scripts/fio-wrapper -p nvmf -i 262144 -d 64 -t read -r 10
+$rootdir/scripts/fio-wrapper -p nvmf -i 262144 -d 64 -t randwrite -r 10
 
 sync
 for i in $(seq 1 $NVMF_SUBSYS); do
diff --git a/test/nvmf/target/multipath.sh b/test/nvmf/target/multipath.sh
index 8594b5226..2ed09be7e 100755
--- a/test/nvmf/target/multipath.sh
+++ b/test/nvmf/target/multipath.sh
@@ -50,7 +50,7 @@ ctrl2_id=$(nvme list-subsys | sed -n "s/traddr=$NVMF_SECOND_TARGET_IP trsvcid=$N
 # Set IO policy to numa
 echo numa > /sys/class/nvme-subsystem/nvme-subsys$subsys_id/iopolicy
 
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 128 -t randrw -r 6 -v &
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 128 -t randrw -r 6 -v &
 fio_pid=$!
 
 sleep 1
@@ -84,7 +84,7 @@ sleep 1
 # Set IO policy to round-robin
 echo round-robin > /sys/class/nvme-subsystem/nvme-subsys$subsys_id/iopolicy
 
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 128 -t randrw -r 6 -v &
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 128 -t randrw -r 6 -v &
 fio_pid=$!
 
 sleep 1
diff --git a/test/nvmf/target/nmic.sh b/test/nvmf/target/nmic.sh
index f8501343d..dd0b07479 100755
--- a/test/nvmf/target/nmic.sh
+++ b/test/nvmf/target/nmic.sh
@@ -42,7 +42,7 @@ nvme connect -t $TEST_TRANSPORT -n "nqn.2016-06.io.spdk:cnode1" -a "$NVMF_FIRST_
 
 waitforserial "$NVMF_SERIAL"
 
-$rootdir/scripts/fio.py -p nvmf -i 4096 -d 1 -t write -r 1 -v
+$rootdir/scripts/fio-wrapper -p nvmf -i 4096 -d 1 -t write -r 1 -v
 
 nvme disconnect -n "nqn.2016-06.io.spdk:cnode1"
 
diff --git a/test/nvmf/target/srq_overwhelm.sh b/test/nvmf/target/srq_overwhelm.sh
index 98af97aab..832cbce08 100755
--- a/test/nvmf/target/srq_overwhelm.sh
+++ b/test/nvmf/target/srq_overwhelm.sh
@@ -31,7 +31,7 @@ done
 # working even at very high queue depths because the rdma qpair doesn't fail.
 # It is normal to see the initiator timeout and reconnect waiting for completions from an overwhelmmed target,
 # but the connection should come up and FIO should complete without errors.
-$rootdir/scripts/fio.py -p nvmf -i 1048576 -d 128 -t read -r 10 -n 13
+$rootdir/scripts/fio-wrapper -p nvmf -i 1048576 -d 128 -t read -r 10 -n 13
 
 sync
 
-- 
2.26.2


From b96ec35dc84b0b1c7c7818fae3491c2c81968e4a Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 30 Apr 2021 15:00:00 +0200
Subject: [PATCH 095/342] scripts: Remove fio.py

With https://review.spdk.io/gerrit/c/spdk/spdk/+/7684 there are no
more active uses of it in the test suites.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: If6f8227b68f1fe1a4038cec2b6107eac82ad44de
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7698
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/fio.py | 164 -------------------------------------------------
 1 file changed, 164 deletions(-)
 delete mode 100755 scripts/fio.py

diff --git a/scripts/fio.py b/scripts/fio.py
deleted file mode 100755
index 56816436a..000000000
--- a/scripts/fio.py
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env python3
-
-from subprocess import check_call, call, check_output, Popen, PIPE, CalledProcessError
-import re
-import sys
-import signal
-import os.path
-import time
-import argparse
-
-fio_template = """
-[global]
-thread=1
-invalidate=1
-rw=%(testtype)s
-time_based=1
-runtime=%(runtime)s
-ioengine=libaio
-direct=1
-bs=%(blocksize)d
-iodepth=%(iodepth)d
-norandommap=%(norandommap)d
-numjobs=%(numjobs)s
-%(verify)s
-verify_dump=1
-
-"""
-
-verify_template = """
-do_verify=1
-verify=crc32c-intel
-"""
-
-
-fio_job_template = """
-[job%(jobnumber)d]
-filename=%(device)s
-
-"""
-
-
-def interrupt_handler(signum, frame):
-    fio.terminate()
-    print("FIO terminated")
-    sys.exit(0)
-
-
-def main(io_size, protocol, queue_depth, test_type, runtime, num_jobs, verify):
-    global fio
-
-    if protocol == "nvmf":
-        devices = get_nvmf_target_devices()
-    elif protocol == "iscsi":
-        devices = get_iscsi_target_devices()
-
-    configure_devices(devices)
-    try:
-        fio_executable = check_output("which fio", shell=True).split()[0]
-    except CalledProcessError as e:
-        sys.stderr.write(str(e))
-        sys.stderr.write("\nCan't find the fio binary, please install it.\n")
-        sys.exit(1)
-
-    device_paths = ['/dev/' + dev for dev in devices]
-    print("Device paths:")
-    print(device_paths)
-    sys.stdout.flush()
-    signal.signal(signal.SIGTERM, interrupt_handler)
-    signal.signal(signal.SIGINT, interrupt_handler)
-    fio = Popen([fio_executable, '-'], stdin=PIPE)
-    fio.communicate(create_fio_config(io_size, queue_depth, device_paths, test_type, runtime, num_jobs, verify).encode())
-    fio.stdin.close()
-    rc = fio.wait()
-    print("FIO completed with code %d\n" % rc)
-    sys.stdout.flush()
-    sys.exit(rc)
-
-
-def get_iscsi_target_devices():
-    output = check_output('iscsiadm -m session -P 3', shell=True)
-    return re.findall("Attached scsi disk (sd[a-z]+)", output.decode("ascii"))
-
-
-def get_nvmf_target_devices():
-    output = str(check_output('lsblk -l -o NAME', shell=True).decode())
-    return re.findall("(nvme[0-9]+n[0-9]+)\n", output)
-
-
-def create_fio_config(size, q_depth, devices, test, run_time, num_jobs, verify):
-    norandommap = 0
-    if not verify:
-        verifyfio = ""
-        norandommap = 1
-    else:
-        verifyfio = verify_template
-    fiofile = fio_template % {"blocksize": size, "iodepth": q_depth,
-                              "testtype": test, "runtime": run_time,
-                              "norandommap": norandommap, "verify": verifyfio,
-                              "numjobs": num_jobs}
-    for (i, dev) in enumerate(devices):
-        fiofile += fio_job_template % {"jobnumber": i, "device": dev}
-    return fiofile
-
-
-def set_device_parameter(devices, filename_template, value):
-    valid_value = True
-
-    for dev in devices:
-        filename = filename_template % dev
-        f = open(filename, 'r+b')
-        try:
-            f.write(value.encode())
-            f.close()
-        except OSError:
-            valid_value = False
-            continue
-
-    return valid_value
-
-
-def configure_devices(devices):
-
-    for dev in devices:
-        retry = 30
-        while retry > 0:
-            if os.path.exists("/sys/block/%s/queue/nomerges" % dev):
-                break
-            else:
-                retry = retry - 1
-                time.sleep(0.1)
-
-    set_device_parameter(devices, "/sys/block/%s/queue/nomerges", "2")
-    set_device_parameter(devices, "/sys/block/%s/queue/nr_requests", "128")
-    requested_qd = 128
-    qd = requested_qd
-    while qd > 0:
-        try:
-            set_device_parameter(devices, "/sys/block/%s/device/queue_depth", str(qd))
-            break
-        except IOError:
-            qd = qd - 1
-    if qd == 0:
-        print("Could not set block device queue depths.")
-    elif qd < requested_qd:
-        print("Requested queue_depth {} but only {} is supported.".format(str(requested_qd), str(qd)))
-    if not set_device_parameter(devices, "/sys/block/%s/queue/scheduler", "noop"):
-        set_device_parameter(devices, "/sys/block/%s/queue/scheduler", "none")
-
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(description="fio.py")
-    parser.add_argument("-i", "--io-size", type=int, help="The desired I/O size in bytes.", required=True)
-    parser.add_argument("-p", "--protocol", type=str, help="The protocol we are testing against. One of iscsi or nvmf.", required=True)
-    parser.add_argument("-d", "--queue-depth", type=int, help="The desired queue depth for each job.", required=True)
-    parser.add_argument("-t", "--test-type", type=str, help="The fio I/O pattern to run. e.g. read, randwrite, randrw.", required=True)
-    parser.add_argument("-r", "--runtime", type=int, help="Time in seconds to run the workload.", required=True)
-    parser.add_argument("-n", "--num-jobs", type=int, help="The number of fio jobs to run in your workload. default 1.", default=1)
-    parser.add_argument("-v", "--verify", action="store_true", help="Supply this argument to verify the I/O.", default=False)
-    args = parser.parse_args()
-
-    if args.protocol.lower() != "nvmf" and args.protocol.lower() != "iscsi":
-        parser.error("Protocol must be one of the following: nvmf, iscsi.")
-
-    main(args.io_size, args.protocol, args.queue_depth, args.test_type, args.runtime, args.num_jobs, args.verify)
-- 
2.26.2


From 744f401cc9ec66adc29cc7f96fac4fd47d075c06 Mon Sep 17 00:00:00 2001
From: ChengqiangMeng <chengqiangx.meng@intel.com>
Date: Wed, 12 May 2021 08:04:02 +0800
Subject: [PATCH 096/342] test/nvme_fabric: Remove priority assert check for
 rdma.

It's only for tcp now, but the transport here is rdma. So there is no need to assert.

Signed-off-by: ChengqiangMeng <chengqiangx.meng@intel.com>
Change-Id: Ieffaac9d31a8f9c79a0d9fd226d74268986b7a77
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7823
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
---
 test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
index 0aa87cfe0..fecb4b272 100644
--- a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
+++ b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
@@ -286,7 +286,6 @@ test_nvme_fabric_discover_probe(void)
 	CU_ASSERT(!strncmp(g_ut_trid.subnqn, hostnqn, sizeof(hostnqn)));
 	CU_ASSERT(!strncmp(g_ut_trid.traddr, traddr, sizeof(traddr)));
 	CU_ASSERT(!strncmp(g_ut_trid.trsvcid, trsvcid, sizeof(trsvcid)));
-	CU_ASSERT(g_ut_trid.priority == 1);
 
 	g_ut_ctrlr_is_probed = false;
 	memset(&g_ut_trid, 0, sizeof(g_ut_trid));
-- 
2.26.2


From 67eb36c7faa5a3296f61f19c0ba01ada64ea26c4 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Fri, 7 May 2021 23:12:13 +0800
Subject: [PATCH 097/342] nvme: remove aligned attribute

When testing vfio-user target with QEMU, there is following error log:

ctrlr.c:2143:31: runtime error: member access within misaligned address 0x7fe526a73d98 for type 'struct spdk_nvme_ctrlr_data', which requires 16 byte alignment

For vfio-user transport, the memory buffer is allocated by clients, so
we can't assume the memory is always aligned, just remove the
aligned attribute.

Change-Id: Ie80530415013ebd7bcb8cdabca97d7d0e34857f9
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7797
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 examples/nvme/identify/identify.c | 12 ++++++------
 include/spdk/nvme_spec.h          |  2 +-
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index c75762ee5..d7812cb11 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -1659,18 +1659,18 @@ print_controller(struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_transport
 		printf("Number of Power States:      %u\n", cdata->npss + 1);
 		printf("Current Power State:         Power State #%u\n", ps);
 		for (i = 0; i <= cdata->npss; i++) {
-			const struct spdk_nvme_power_state *psd = &cdata->psd[i];
+			const struct spdk_nvme_power_state psd = cdata->psd[i];
 			printf("Power State #%u:  ", i);
-			if (psd->mps) {
+			if (psd.mps) {
 				/* MP scale is 0.0001 W */
 				printf("Max Power: %u.%04u W\n",
-				       psd->mp / 10000,
-				       psd->mp % 10000);
+				       psd.mp / 10000,
+				       psd.mp % 10000);
 			} else {
 				/* MP scale is 0.01 W */
 				printf("Max Power: %3u.%02u W\n",
-				       psd->mp / 100,
-				       psd->mp % 100);
+				       psd.mp / 100,
+				       psd.mp % 100);
 			}
 			/* TODO: print other power state descriptor fields */
 		}
diff --git a/include/spdk/nvme_spec.h b/include/spdk/nvme_spec.h
index 5cab10183..d817a250a 100644
--- a/include/spdk/nvme_spec.h
+++ b/include/spdk/nvme_spec.h
@@ -1840,7 +1840,7 @@ struct spdk_nvme_cdata_sgls {
 	uint32_t	reserved2 : 10;
 };
 
-struct __attribute__((packed)) __attribute__((aligned)) spdk_nvme_ctrlr_data {
+struct __attribute__((packed)) spdk_nvme_ctrlr_data {
 	/* bytes 0-255: controller capabilities and features */
 
 	/** pci vendor id */
-- 
2.26.2


From b940247b3e9b8f0b5a00f64c3a9bc4111a2f06ec Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 23 Apr 2021 20:30:43 +0800
Subject: [PATCH 098/342] bdev/rbd: Use the same Rados cluster object in the
 same RBD bdev

This patch is design to use the single Rados Cluster
object in the same RBD if there are multiple I/O channels created.

And this patch will be prepared for the next patch to share
the same cluster among different RBD bdevs.

Change-Id: I1509f29a9c1088da308a3f88980f0c7fed26476f
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7601
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 module/bdev/rbd/bdev_rbd.c | 78 +++++++++++++++++++++++---------------
 1 file changed, 48 insertions(+), 30 deletions(-)

diff --git a/module/bdev/rbd/bdev_rbd.c b/module/bdev/rbd/bdev_rbd.c
index 26adc96ef..5a334b255 100644
--- a/module/bdev/rbd/bdev_rbd.c
+++ b/module/bdev/rbd/bdev_rbd.c
@@ -62,6 +62,7 @@ struct bdev_rbd {
 	char *user_id;
 	char *pool_name;
 	char **config;
+	rados_t cluster;
 	rbd_image_info_t info;
 	TAILQ_ENTRY(bdev_rbd) tailq;
 	struct spdk_poller *reset_timer;
@@ -75,7 +76,6 @@ struct bdev_rbd_group_channel {
 
 struct bdev_rbd_io_channel {
 	rados_ioctx_t io_ctx;
-	rados_t cluster;
 	int pfd;
 	rbd_image_t image;
 	struct bdev_rbd *disk;
@@ -93,6 +93,10 @@ bdev_rbd_free(struct bdev_rbd *rbd)
 		return;
 	}
 
+	if (rbd->cluster) {
+		rados_shutdown(rbd->cluster);
+	}
+
 	free(rbd->disk.name);
 	free(rbd->rbd_name);
 	free(rbd->user_id);
@@ -138,8 +142,8 @@ bdev_rbd_dup_config(const char *const *config)
 }
 
 static int
-bdev_rados_context_init(const char *user_id, const char *rbd_pool_name, const char *const *config,
-			rados_t *cluster, rados_ioctx_t *io_ctx)
+bdev_rados_cluster_init(const char *user_id, const char *const *config,
+			rados_t *cluster)
 {
 	int ret;
 
@@ -176,30 +180,44 @@ bdev_rados_context_init(const char *user_id, const char *rbd_pool_name, const ch
 		return -1;
 	}
 
-	ret = rados_ioctx_create(*cluster, rbd_pool_name, io_ctx);
+	return 0;
+}
 
-	if (ret < 0) {
-		SPDK_ERRLOG("Failed to create ioctx\n");
-		rados_shutdown(*cluster);
-		return -1;
+static void *
+bdev_rbd_cluster_handle(void *arg)
+{
+	struct bdev_rbd *rbd = arg;
+	void *ret = arg;
+	int rc;
+
+	rc = bdev_rados_cluster_init(rbd->user_id, (const char *const *)rbd->config,
+				     &rbd->cluster);
+	if (rc < 0) {
+		SPDK_ERRLOG("Failed to create rados cluster for user_id=%s and rbd_pool=%s\n",
+			    rbd->user_id ? rbd->user_id : "admin (the default)", rbd->pool_name);
+		ret = NULL;
 	}
 
-	return 0;
+	return ret;
 }
 
 static int
 bdev_rbd_init(struct bdev_rbd *rbd)
 {
 	int ret = 0;
-	rados_t cluster = NULL;
 	rados_ioctx_t io_ctx = NULL;
 	rbd_image_t image = NULL;
 
-	ret = bdev_rados_context_init(rbd->user_id, rbd->pool_name, (const char *const *)rbd->config,
-				      &cluster, &io_ctx);
+	/* Cluster should be created in non-SPDK thread to avoid conflict between
+	 * Rados and SPDK thread */
+	if (spdk_call_unaffinitized(bdev_rbd_cluster_handle, rbd) == NULL) {
+		SPDK_ERRLOG("Cannot create the rados object on rbd=%p\n", rbd);
+		return -1;
+	}
+
+	ret = rados_ioctx_create(rbd->cluster, rbd->pool_name, &io_ctx);
 	if (ret < 0) {
-		SPDK_ERRLOG("Failed to create rados context for user_id=%s and rbd_pool=%s\n",
-			    rbd->user_id ? rbd->user_id : "admin (the default)", rbd->pool_name);
+		SPDK_ERRLOG("Failed to create ioctx\n");
 		return -1;
 	}
 
@@ -216,7 +234,6 @@ bdev_rbd_init(struct bdev_rbd *rbd)
 
 end:
 	rados_ioctx_destroy(io_ctx);
-	rados_shutdown(cluster);
 	return ret;
 }
 
@@ -325,14 +342,23 @@ bdev_rbd_reset(struct bdev_rbd *disk, struct spdk_bdev_io *bdev_io)
 	disk->reset_timer = SPDK_POLLER_REGISTER(bdev_rbd_reset_timer, disk, 1 * 1000 * 1000);
 }
 
+static void
+bdev_rbd_free_cb(void *io_device)
+{
+	struct bdev_rbd *rbd = io_device;
+
+	assert(rbd != NULL);
+
+	bdev_rbd_free((struct bdev_rbd *)rbd);
+}
+
 static int
 bdev_rbd_destruct(void *ctx)
 {
 	struct bdev_rbd *rbd = ctx;
 
-	spdk_io_device_unregister(rbd, NULL);
+	spdk_io_device_unregister(rbd, bdev_rbd_free_cb);
 
-	bdev_rbd_free(rbd);
 	return 0;
 }
 
@@ -447,10 +473,6 @@ bdev_rbd_free_channel(struct bdev_rbd_io_channel *ch)
 		rados_ioctx_destroy(ch->io_ctx);
 	}
 
-	if (ch->cluster) {
-		rados_shutdown(ch->cluster);
-	}
-
 	if (ch->pfd >= 0) {
 		close(ch->pfd);
 	}
@@ -465,16 +487,13 @@ bdev_rbd_handle(void *arg)
 {
 	struct bdev_rbd_io_channel *ch = arg;
 	void *ret = arg;
-	int rc;
 
-	rc = bdev_rados_context_init(ch->disk->user_id, ch->disk->pool_name,
-				     (const char *const *)ch->disk->config,
-				     &ch->cluster, &ch->io_ctx);
-	if (rc < 0) {
-		SPDK_ERRLOG("Failed to create rados context for user_id %s and rbd_pool=%s\n",
-			    ch->disk->user_id ? ch->disk->user_id : "admin (the default)", ch->disk->pool_name);
+	assert(ch->disk->cluster != NULL);
+
+	if (rados_ioctx_create(ch->disk->cluster, ch->disk->pool_name, &ch->io_ctx) < 0) {
+		SPDK_ERRLOG("Failed to create ioctx\n");
 		ret = NULL;
-		goto end;
+		return ret;
 	}
 
 	if (rbd_open(ch->io_ctx, ch->disk->rbd_name, &ch->image, NULL) < 0) {
@@ -482,7 +501,6 @@ bdev_rbd_handle(void *arg)
 		ret = NULL;
 	}
 
-end:
 	return ret;
 }
 
-- 
2.26.2


From 3067ecaa0ceb9df1dc39a8217cfe882442427a88 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Thu, 6 May 2021 15:54:58 +0800
Subject: [PATCH 099/342] nvme/ctrlr: fix namespaces indexed overflow risk

Change-Id: Ied1de194621a02f6eeaafc23ce5ff467760a71aa
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7772
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvme/nvme_ctrlr.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index d15ebdd73..2684d2d70 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -3771,6 +3771,10 @@ spdk_nvme_ctrlr_attach_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid,
 	int					res;
 	struct spdk_nvme_ns			*ns;
 
+	if (nsid == 0) {
+		return -EINVAL;
+	}
+
 	status = calloc(1, sizeof(*status));
 	if (!status) {
 		NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate status tracker\n");
@@ -3809,6 +3813,10 @@ spdk_nvme_ctrlr_detach_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid,
 	int					res;
 	struct spdk_nvme_ns			*ns;
 
+	if (nsid == 0) {
+		return -EINVAL;
+	}
+
 	status = calloc(1, sizeof(*status));
 	if (!status) {
 		NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate status tracker\n");
@@ -3870,8 +3878,11 @@ spdk_nvme_ctrlr_create_ns(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns_dat
 	}
 
 	nsid = status->cpl.cdw0;
-	ns = &ctrlr->ns[nsid - 1];
 	free(status);
+
+	assert(nsid > 0);
+
+	ns = &ctrlr->ns[nsid - 1];
 	/* Inactive NS */
 	res = nvme_ns_construct(ns, nsid, ctrlr);
 	if (res) {
@@ -3889,6 +3900,10 @@ spdk_nvme_ctrlr_delete_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
 	int					res;
 	struct spdk_nvme_ns			*ns;
 
+	if (nsid == 0) {
+		return -EINVAL;
+	}
+
 	status = calloc(1, sizeof(*status));
 	if (!status) {
 		NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate status tracker\n");
-- 
2.26.2


From e415c253a31e11c1cee709c1f024d2b37de015c6 Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Mon, 3 May 2021 15:27:21 +0000
Subject: [PATCH 100/342] bdev/fio_plugin: add support for --zone_append

Add support for using zone append commands instead of write command,
for bdevs that support it.

In the SPDK NVMe plugin, the target struct (called spdk_fio_qpair) is
allocated in .setup(), but the qpair is first created in .open_file.

In the SPDK bdev plugin, the target struct (called spdk_fio_target)
is allocated in spdk_fio_bdev_open(). This function also creates the
I/O channel. (spdk_fio_bdev_open() is called by .init().)

Since certain options has to be saved in the struct spdk_fio_target,
which is allocated quite late, we cannot reuse spdk_fio_handle_options(),
which has to be called before threads are created.

Therefore, we unfortunately need another option parsing function in the
SPDK bdev plugin.

If we fail to handle any of the per target options, the target is never
added to the list of targets, and is freed immediately.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: Iacd1924c8f0d3d324f2a6f1b0a54f86459f39d31
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7727
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/bdev/fio_plugin/fio_plugin.c | 75 +++++++++++++++++++++++++--
 1 file changed, 72 insertions(+), 3 deletions(-)

diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index 9f5b32b9b..fba1ea2dd 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -68,6 +68,7 @@ struct spdk_fio_options {
 	unsigned mem_mb;
 	int mem_single_seg;
 	int initial_zone_reset;
+	int zone_append;
 };
 
 struct spdk_fio_request {
@@ -79,6 +80,7 @@ struct spdk_fio_target {
 	struct spdk_bdev	*bdev;
 	struct spdk_bdev_desc	*desc;
 	struct spdk_io_channel	*ch;
+	bool zone_append_enabled;
 
 	TAILQ_ENTRY(spdk_fio_target) link;
 };
@@ -114,6 +116,7 @@ static void spdk_fio_cleanup(struct thread_data *td);
 static size_t spdk_fio_poll_thread(struct spdk_fio_thread *fio_thread);
 static int spdk_fio_handle_options(struct thread_data *td, struct fio_file *f,
 				   struct spdk_bdev *bdev);
+static int spdk_fio_handle_options_per_target(struct thread_data *td, struct fio_file *f);
 
 static pthread_t g_init_thread_id = 0;
 static pthread_mutex_t g_init_mtx = PTHREAD_MUTEX_INITIALIZER;
@@ -552,6 +555,17 @@ spdk_fio_bdev_open(void *arg)
 
 		f->engine_data = target;
 
+		rc = spdk_fio_handle_options_per_target(td, f);
+		if (rc) {
+			SPDK_ERRLOG("Failed to handle options for: %s\n", f->file_name);
+			f->engine_data = NULL;
+			spdk_put_io_channel(target->ch);
+			spdk_bdev_close(target->desc);
+			free(target);
+			fio_thread->failed = true;
+			return;
+		}
+
 		TAILQ_INSERT_TAIL(&fio_thread->targets, target, link);
 	}
 }
@@ -684,6 +698,17 @@ typedef enum fio_q_status fio_q_status_t;
 typedef int fio_q_status_t;
 #endif
 
+static uint64_t
+spdk_fio_zone_bytes_to_blocks(struct spdk_bdev *bdev, uint64_t offset_bytes, uint64_t *zone_start,
+			      uint64_t num_bytes, uint64_t *num_blocks)
+{
+	uint32_t block_size = spdk_bdev_get_block_size(bdev);
+	*zone_start = (offset_bytes / (spdk_bdev_get_zone_size(bdev) * block_size)) *
+		      spdk_bdev_get_zone_size(bdev);
+	*num_blocks = num_bytes / block_size;
+	return (offset_bytes % block_size) | (num_bytes % block_size);
+}
+
 static fio_q_status_t
 spdk_fio_queue(struct thread_data *td, struct io_u *io_u)
 {
@@ -706,9 +731,21 @@ spdk_fio_queue(struct thread_data *td, struct io_u *io_u)
 				    spdk_fio_completion_cb, fio_req);
 		break;
 	case DDIR_WRITE:
-		rc = spdk_bdev_write(target->desc, target->ch,
-				     io_u->buf, io_u->offset, io_u->xfer_buflen,
-				     spdk_fio_completion_cb, fio_req);
+		if (!target->zone_append_enabled) {
+			rc = spdk_bdev_write(target->desc, target->ch,
+					     io_u->buf, io_u->offset, io_u->xfer_buflen,
+					     spdk_fio_completion_cb, fio_req);
+		} else {
+			uint64_t zone_start, num_blocks;
+			if (spdk_fio_zone_bytes_to_blocks(target->bdev, io_u->offset, &zone_start,
+							  io_u->xfer_buflen, &num_blocks) != 0) {
+				rc = -EINVAL;
+				break;
+			}
+			rc = spdk_bdev_zone_append(target->desc, target->ch, io_u->buf,
+						   zone_start, num_blocks, spdk_fio_completion_cb,
+						   fio_req);
+		}
 		break;
 	case DDIR_TRIM:
 		rc = spdk_bdev_unmap(target->desc, target->ch,
@@ -1054,6 +1091,26 @@ spdk_fio_handle_options(struct thread_data *td, struct fio_file *f, struct spdk_
 	return 0;
 }
 
+static int
+spdk_fio_handle_options_per_target(struct thread_data *td, struct fio_file *f)
+{
+	struct spdk_fio_target *target = f->engine_data;
+	struct spdk_fio_options *fio_options = td->eo;
+
+	if (fio_options->zone_append && spdk_bdev_is_zoned(target->bdev)) {
+		if (spdk_bdev_io_type_supported(target->bdev, SPDK_BDEV_IO_TYPE_ZONE_APPEND)) {
+			SPDK_DEBUGLOG(fio_bdev, "Using zone appends instead of writes on: '%s'\n",
+				      f->file_name);
+			target->zone_append_enabled = true;
+		} else {
+			SPDK_WARNLOG("Falling back to writes on: '%s' - bdev lacks zone append cmd\n",
+				     f->file_name);
+		}
+	}
+
+	return 0;
+}
+
 static struct fio_option options[] = {
 	{
 		.name		= "spdk_conf",
@@ -1102,6 +1159,16 @@ static struct fio_option options[] = {
 		.category	= FIO_OPT_C_ENGINE,
 		.group		= FIO_OPT_G_INVALID,
 	},
+	{
+		.name		= "zone_append",
+		.lname		= "Use zone append instead of write",
+		.type		= FIO_OPT_INT,
+		.off1		= offsetof(struct spdk_fio_options, zone_append),
+		.def		= "0",
+		.help		= "Use zone append instead of write (1=zone append, 0=write)",
+		.category	= FIO_OPT_C_ENGINE,
+		.group		= FIO_OPT_G_INVALID,
+	},
 	{
 		.name		= NULL,
 	},
@@ -1166,3 +1233,5 @@ static void fio_exit spdk_fio_unregister(void)
 	}
 	unregister_ioengine(&ioengine);
 }
+
+SPDK_LOG_REGISTER_COMPONENT(fio_bdev)
-- 
2.26.2


From 367784a6418fcfcf5a2fb924f357f4abab21c926 Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Wed, 5 May 2021 21:25:35 +0000
Subject: [PATCH 101/342] bdev/fio_plugin: update README.md and add example zbd
 config

Update README.md with information specific to zoned block devices.
Additionally, add an example config that can be used to test the
--zonemode=zbd fio option using the virtual zoned block device
SPDK module on top of a Malloc bdev.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: I68bbc07ab70ad1ce8e38abc91dd8c15c49f90656
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7758
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 examples/bdev/fio_plugin/README.md       | 46 ++++++++++++++++++++++++
 examples/bdev/fio_plugin/bdev_zoned.json | 26 ++++++++++++++
 examples/bdev/fio_plugin/zbd_example.fio | 18 ++++++++++
 3 files changed, 90 insertions(+)
 create mode 100644 examples/bdev/fio_plugin/bdev_zoned.json
 create mode 100644 examples/bdev/fio_plugin/zbd_example.fio

diff --git a/examples/bdev/fio_plugin/README.md b/examples/bdev/fio_plugin/README.md
index 1c968a513..ee9519926 100644
--- a/examples/bdev/fio_plugin/README.md
+++ b/examples/bdev/fio_plugin/README.md
@@ -71,3 +71,49 @@ engine's full path via the ioengine parameter - LD_PRELOAD is recommended to avo
 When testing random workloads, it is recommended to set norandommap=1.  fio's random map
 processing consumes extra CPU cycles which will degrade performance over time with
 the fio_plugin since all I/O are submitted and completed on a single CPU core.
+
+# Zoned Block Devices
+
+SPDK has a zoned block device API (bdev_zone.h) which currently supports Open-channel SSDs,
+NVMe Zoned Namespaces (ZNS), and the virtual zoned block device SPDK module.
+
+If you wish to run fio against a SPDK zoned block device, you can use the fio option:
+
+    zonemode=zbd
+
+It is recommended to use a fio version newer than version 3.26, if using --numjobs > 1.
+If using --numjobs=1, fio version >= 3.23 should suffice.
+
+See zbd_example.fio in this directory for a zoned block device example config.
+
+## Maximum Open Zones
+
+Most zoned block devices have a resource constraint on the amount of zones which can be in an opened
+state at any point in time. It is very important to not exceed this limit.
+
+You can control how many zones fio will keep in an open state by using the
+``--max_open_zones`` option.
+
+## Maximum Active Zones
+
+Zoned block devices may also have a resource constraint on the number of zones that can be active at
+any point in time. Unlike ``max_open_zones``, fio currently does not manage this constraint, and
+there is thus no option to limit it either.
+
+Since the max active zones limit (by definition) has to be greater than or equal to the max active
+zones limit, the easiest way to work around that fio does not manage this constraint, is to start
+with a clean state each run (except for read-only workloads), by resetting all zones before fio
+starts running its jobs by using the engine option:
+
+    --initial_zone_reset=1
+
+## Zone Append
+
+When running fio against a zoned block device you need to specify --iodepth=1 to avoid
+"Zone Invalid Write: The write to a zone was not at the write pointer." I/O errors.
+However, if your zoned block device supports Zone Append, you can use the engine option:
+
+    --zone_append=1
+
+To send zone append commands instead of write commands to the zoned block device.
+When using zone append, you will be able to specify a --iodepth greater than 1.
diff --git a/examples/bdev/fio_plugin/bdev_zoned.json b/examples/bdev/fio_plugin/bdev_zoned.json
new file mode 100644
index 000000000..d09ce18a1
--- /dev/null
+++ b/examples/bdev/fio_plugin/bdev_zoned.json
@@ -0,0 +1,26 @@
+{
+  "subsystems": [
+    {
+      "subsystem": "bdev",
+      "config": [
+        {
+          "method": "bdev_malloc_create",
+          "params": {
+            "name": "Malloc0",
+            "num_blocks": 2097152,
+            "block_size": 512
+          }
+        },
+        {
+          "method": "bdev_zone_block_create",
+          "params": {
+            "base_bdev": "Malloc0",
+            "name": "Zone0",
+            "zone_capacity": 262144,
+            "optimal_open_zones": 8
+          }
+        }
+      ]
+    }
+  ]
+}
diff --git a/examples/bdev/fio_plugin/zbd_example.fio b/examples/bdev/fio_plugin/zbd_example.fio
new file mode 100644
index 000000000..f026564e8
--- /dev/null
+++ b/examples/bdev/fio_plugin/zbd_example.fio
@@ -0,0 +1,18 @@
+[global]
+ioengine=spdk_bdev
+spdk_json_conf=./examples/bdev/fio_plugin/bdev_zoned.json
+thread=1
+direct=1
+time_based
+runtime=10
+rw=randwrite
+bs=16K
+zonemode=zbd
+max_open_zones=8
+initial_zone_reset=1
+zone_append=1
+iodepth=64
+
+[test]
+filename=Zone0
+numjobs=1
-- 
2.26.2


From acca0749df43a8f42bad22de2ed8a0fc302b71de Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Fri, 7 May 2021 08:06:40 +0000
Subject: [PATCH 102/342] nvme/fio_plugin: change zone append print to
 SPDK_DEBUGLOG

Change zone append print to SPDK_DEBUGLOG() instead of an unconditional
print. Since we already print a warning when zone append isn't supported,
there is no need to unconditionally print something for the success case.
This also matches the behavior of the SPDK fio bdev plugin.

Also improve the zone append help text to match the SPDK fio bdev plugin.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: Ic7604ea4bdf17e0cddfe2638f3db7944ee652474
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7804
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/nvme/fio_plugin/fio_plugin.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/examples/nvme/fio_plugin/fio_plugin.c b/examples/nvme/fio_plugin/fio_plugin.c
index 14f5b9f10..c09b8993f 100644
--- a/examples/nvme/fio_plugin/fio_plugin.c
+++ b/examples/nvme/fio_plugin/fio_plugin.c
@@ -426,12 +426,12 @@ attach_cb(void *cb_ctx, const struct spdk_nvme_transport_id *trid,
 
 	if (fio_options->zone_append && spdk_nvme_ns_get_csi(ns) == SPDK_NVME_CSI_ZNS) {
 		if (spdk_nvme_ctrlr_get_flags(ctrlr) & SPDK_NVME_CTRLR_ZONE_APPEND_SUPPORTED) {
-			fprintf(stdout, "Using zone appends instead of writes on: '%s'\n",
-				fio_qpair->f->file_name);
+			SPDK_DEBUGLOG(fio_nvme, "Using zone appends instead of writes on: '%s'\n",
+				      f->file_name);
 			fio_qpair->zone_append_enabled = true;
 		} else {
 			SPDK_WARNLOG("Falling back to writes on: '%s' - ns lacks zone append cmd\n",
-				     fio_qpair->f->file_name);
+				     f->file_name);
 		}
 	}
 
@@ -1634,7 +1634,7 @@ static struct fio_option options[] = {
 		.type		= FIO_OPT_INT,
 		.off1		= offsetof(struct spdk_fio_options, zone_append),
 		.def		= "0",
-		.help		= "Use zone append instead of write (zone_append=1 or zone_append=0)",
+		.help		= "Use zone append instead of write (1=zone append, 0=write)",
 		.category	= FIO_OPT_C_ENGINE,
 		.group		= FIO_OPT_G_INVALID,
 	},
@@ -1688,3 +1688,5 @@ static void fio_exit fio_spdk_unregister(void)
 {
 	unregister_ioengine(&ioengine);
 }
+
+SPDK_LOG_REGISTER_COMPONENT(fio_nvme)
-- 
2.26.2


From be6a01efb31aa1e88cdd9a7b02b6c43ef41e4886 Mon Sep 17 00:00:00 2001
From: Jonathan Teh <jonathan.teh@mayadata.io>
Date: Mon, 12 Apr 2021 12:01:16 +0100
Subject: [PATCH 103/342] nvmf: Allow configurable controller ID range

Add {min,max}_cntlid to spdk_nvmf_subsystem, defaulting to 1 and
0xFFEF, respectively, and add nvmf_subsystem_set_cntlid_range() to
allow the controller range to be configured in the range [min_cntlid,
max_cntlid].

Also add {min,max}_cntlid to the nvmf_create_subsystem RPC to allow
the controller ID range to be specified when creating an nvmf
subsystem.

Signed-off-by: Jonathan Teh <jonathan.teh@mayadata.io>
Change-Id: I936db3bb0c9a38569063a6fd3c11df262dfad776
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7322
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 CHANGELOG.md                 |  4 +++
 doc/jsonrpc.md               |  2 ++
 include/spdk/nvmf.h          | 18 ++++++++++++++
 lib/nvmf/Makefile            |  2 +-
 lib/nvmf/nvmf.c              |  3 +++
 lib/nvmf/nvmf_internal.h     | 22 +++++++++++++++++
 lib/nvmf/nvmf_rpc.c          | 17 +++++++++++++
 lib/nvmf/spdk_nvmf.map       |  2 ++
 lib/nvmf/subsystem.c         | 48 ++++++++++++++++++++++++++++++++----
 scripts/rpc.py               |  6 ++++-
 scripts/rpc/nvmf.py          | 12 ++++++++-
 test/nvmf/target/invalid.sh  | 14 +++++++++++
 test/nvmf/target/nvme_cli.sh |  7 +++++-
 13 files changed, 148 insertions(+), 9 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index a7f7d358a..13aa1d56a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -7,6 +7,10 @@
 Remove the probe_cb parameter in spdk_idxd_probe function. And remove the definition
 of spdk_idxd_probe_cb function pointer. It should be implemented in idxd_user.c.
 
+### nvmf
+
+Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the controller ID range.
+
 ## v21.04:
 
 ### accel
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 572802b86..370d0efe4 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -5911,6 +5911,8 @@ model_number            | Optional | string      | Model number of virtual contr
 max_namespaces          | Optional | number      | Maximum number of namespaces that can be attached to the subsystem. Default: 0 (Unlimited)
 allow_any_host          | Optional | boolean     | Allow any host (`true`) or enforce allowed host list (`false`). Default: `false`.
 ana_reporting           | Optional | boolean     | Enable ANA reporting feature (default: `false`).
+min_cntlid              | Optional | number      | Minimum controller ID. Default: 1
+max_cntlid              | Optional | number      | Maximum controller ID. Default: 0xffef
 
 ### Example
 
diff --git a/include/spdk/nvmf.h b/include/spdk/nvmf.h
index 89435622b..cf8b52ad4 100644
--- a/include/spdk/nvmf.h
+++ b/include/spdk/nvmf.h
@@ -844,6 +844,24 @@ struct spdk_nvmf_ns *spdk_nvmf_subsystem_get_ns(struct spdk_nvmf_subsystem *subs
  */
 uint32_t spdk_nvmf_subsystem_get_max_namespaces(const struct spdk_nvmf_subsystem *subsystem);
 
+/**
+ * Get the minimum controller ID allowed in a subsystem.
+ *
+ * \param subsystem Subsystem to query.
+ *
+ * \return Minimum controller ID allowed in the subsystem.
+ */
+uint16_t spdk_nvmf_subsystem_get_min_cntlid(const struct spdk_nvmf_subsystem *subsystem);
+
+/**
+ * Get the maximum controller ID allowed in a subsystem.
+ *
+ * \param subsystem Subsystem to query.
+ *
+ * \return Maximum controller ID allowed in the subsystem.
+ */
+uint16_t spdk_nvmf_subsystem_get_max_cntlid(const struct spdk_nvmf_subsystem *subsystem);
+
 /**
  * Get a namespace's NSID.
  *
diff --git a/lib/nvmf/Makefile b/lib/nvmf/Makefile
index e7eab45b9..3058f41f9 100644
--- a/lib/nvmf/Makefile
+++ b/lib/nvmf/Makefile
@@ -35,7 +35,7 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 SO_VER := 8
-SO_MINOR := 0
+SO_MINOR := 1
 
 C_SRCS = ctrlr.c ctrlr_discovery.c ctrlr_bdev.c \
 	 subsystem.c nvmf.c nvmf_rpc.c transport.c tcp.c
diff --git a/lib/nvmf/nvmf.c b/lib/nvmf/nvmf.c
index 05aaff048..acaf9ef74 100644
--- a/lib/nvmf/nvmf.c
+++ b/lib/nvmf/nvmf.c
@@ -450,6 +450,9 @@ nvmf_write_subsystem_config_json(struct spdk_json_write_ctx *w,
 		spdk_json_write_named_uint32(w, "max_namespaces", max_namespaces);
 	}
 
+	spdk_json_write_named_uint32(w, "min_cntlid", spdk_nvmf_subsystem_get_min_cntlid(subsystem));
+	spdk_json_write_named_uint32(w, "max_cntlid", spdk_nvmf_subsystem_get_max_cntlid(subsystem));
+
 	/*     } "params" */
 	spdk_json_write_object_end(w);
 
diff --git a/lib/nvmf/nvmf_internal.h b/lib/nvmf/nvmf_internal.h
index d76b742a3..9c6510305 100644
--- a/lib/nvmf/nvmf_internal.h
+++ b/lib/nvmf/nvmf_internal.h
@@ -49,6 +49,10 @@
 
 #define NVMF_MAX_ASYNC_EVENTS	(4)
 
+/* The spec reserves cntlid values in the range FFF0h to FFFFh. */
+#define NVMF_MIN_CNTLID 1
+#define NVMF_MAX_CNTLID 0xFFEF
+
 enum spdk_nvmf_subsystem_state {
 	SPDK_NVMF_SUBSYSTEM_INACTIVE = 0,
 	SPDK_NVMF_SUBSYSTEM_ACTIVATING,
@@ -286,6 +290,9 @@ struct spdk_nvmf_subsystem {
 	struct spdk_nvmf_ns				**ns;
 	uint32_t					max_nsid;
 
+	uint16_t					min_cntlid;
+	uint16_t					max_cntlid;
+
 	TAILQ_HEAD(, spdk_nvmf_ctrlr)			ctrlrs;
 
 	/* A mutex used to protect the hosts list and allow_any_host flag. Unlike the namespace
@@ -372,6 +379,21 @@ void nvmf_subsystem_set_ana_state(struct spdk_nvmf_subsystem *subsystem,
 				  enum spdk_nvme_ana_state ana_state,
 				  spdk_nvmf_tgt_subsystem_listen_done_fn cb_fn, void *cb_arg);
 
+/**
+ * Sets the controller ID range for a subsystem.
+ * Valid range is [1, 0xFFEF].
+ *
+ * May only be performed on subsystems in the INACTIVE state.
+ *
+ * \param subsystem Subsystem to modify.
+ * \param min_cntlid Minimum controller ID.
+ * \param max_cntlid Maximum controller ID.
+ *
+ * \return 0 on success, or negated errno value on failure.
+ */
+int nvmf_subsystem_set_cntlid_range(struct spdk_nvmf_subsystem *subsystem,
+				    uint16_t min_cntlid, uint16_t max_cntlid);
+
 int nvmf_ctrlr_async_event_ns_notice(struct spdk_nvmf_ctrlr *ctrlr);
 int nvmf_ctrlr_async_event_ana_change_notice(struct spdk_nvmf_ctrlr *ctrlr);
 int nvmf_ctrlr_async_event_discovery_log_change_notice(struct spdk_nvmf_ctrlr *ctrlr);
diff --git a/lib/nvmf/nvmf_rpc.c b/lib/nvmf/nvmf_rpc.c
index 0998b0fa2..8ba9974f0 100644
--- a/lib/nvmf/nvmf_rpc.c
+++ b/lib/nvmf/nvmf_rpc.c
@@ -259,6 +259,9 @@ dump_nvmf_subsystem(struct spdk_json_write_ctx *w, struct spdk_nvmf_subsystem *s
 			spdk_json_write_named_uint32(w, "max_namespaces", max_namespaces);
 		}
 
+		spdk_json_write_named_uint32(w, "min_cntlid", spdk_nvmf_subsystem_get_min_cntlid(subsystem));
+		spdk_json_write_named_uint32(w, "max_cntlid", spdk_nvmf_subsystem_get_max_cntlid(subsystem));
+
 		spdk_json_write_named_array_begin(w, "namespaces");
 		for (ns = spdk_nvmf_subsystem_get_first_ns(subsystem); ns != NULL;
 		     ns = spdk_nvmf_subsystem_get_next_ns(subsystem, ns)) {
@@ -344,6 +347,8 @@ struct rpc_subsystem_create {
 	uint32_t max_namespaces;
 	bool allow_any_host;
 	bool ana_reporting;
+	uint16_t min_cntlid;
+	uint16_t max_cntlid;
 };
 
 static const struct spdk_json_object_decoder rpc_subsystem_create_decoders[] = {
@@ -354,6 +359,8 @@ static const struct spdk_json_object_decoder rpc_subsystem_create_decoders[] = {
 	{"max_namespaces", offsetof(struct rpc_subsystem_create, max_namespaces), spdk_json_decode_uint32, true},
 	{"allow_any_host", offsetof(struct rpc_subsystem_create, allow_any_host), spdk_json_decode_bool, true},
 	{"ana_reporting", offsetof(struct rpc_subsystem_create, ana_reporting), spdk_json_decode_bool, true},
+	{"min_cntlid", offsetof(struct rpc_subsystem_create, min_cntlid), spdk_json_decode_uint16, true},
+	{"max_cntlid", offsetof(struct rpc_subsystem_create, max_cntlid), spdk_json_decode_uint16, true},
 };
 
 static void
@@ -388,6 +395,8 @@ rpc_nvmf_create_subsystem(struct spdk_jsonrpc_request *request,
 						 "Memory allocation failed");
 		return;
 	}
+	req->min_cntlid = NVMF_MIN_CNTLID;
+	req->max_cntlid = NVMF_MAX_CNTLID;
 
 	if (spdk_json_decode_object(params, rpc_subsystem_create_decoders,
 				    SPDK_COUNTOF(rpc_subsystem_create_decoders),
@@ -436,6 +445,14 @@ rpc_nvmf_create_subsystem(struct spdk_jsonrpc_request *request,
 
 	spdk_nvmf_subsystem_set_ana_reporting(subsystem, req->ana_reporting);
 
+	if (nvmf_subsystem_set_cntlid_range(subsystem, req->min_cntlid, req->max_cntlid)) {
+		SPDK_ERRLOG("Subsystem %s: invalid cntlid range [%u-%u]\n", req->nqn, req->min_cntlid,
+			    req->max_cntlid);
+		spdk_jsonrpc_send_error_response_fmt(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
+						     "Invalid cntlid range [%u-%u]", req->min_cntlid, req->max_cntlid);
+		goto cleanup;
+	}
+
 	rc = spdk_nvmf_subsystem_start(subsystem,
 				       rpc_nvmf_subsystem_started,
 				       request);
diff --git a/lib/nvmf/spdk_nvmf.map b/lib/nvmf/spdk_nvmf.map
index 0247249bc..c43a96343 100644
--- a/lib/nvmf/spdk_nvmf.map
+++ b/lib/nvmf/spdk_nvmf.map
@@ -53,6 +53,8 @@
 	spdk_nvmf_subsystem_get_first_ns;
 	spdk_nvmf_subsystem_get_next_ns;
 	spdk_nvmf_subsystem_get_ns;
+	spdk_nvmf_subsystem_get_min_cntlid;
+	spdk_nvmf_subsystem_get_max_cntlid;
 	spdk_nvmf_subsystem_get_max_namespaces;
 	spdk_nvmf_ns_get_id;
 	spdk_nvmf_ns_get_bdev;
diff --git a/lib/nvmf/subsystem.c b/lib/nvmf/subsystem.c
index be9c12342..ee312719d 100644
--- a/lib/nvmf/subsystem.c
+++ b/lib/nvmf/subsystem.c
@@ -285,6 +285,8 @@ spdk_nvmf_subsystem_create(struct spdk_nvmf_tgt *tgt,
 	subsystem->subtype = type;
 	subsystem->max_nsid = num_ns;
 	subsystem->next_cntlid = 0;
+	subsystem->min_cntlid = NVMF_MIN_CNTLID;
+	subsystem->max_cntlid = NVMF_MAX_CNTLID;
 	snprintf(subsystem->subnqn, sizeof(subsystem->subnqn), "%s", nqn);
 	pthread_mutex_init(&subsystem->mutex, NULL);
 	TAILQ_INIT(&subsystem->listeners);
@@ -1632,20 +1634,44 @@ spdk_nvmf_subsystem_get_max_nsid(struct spdk_nvmf_subsystem *subsystem)
 	return subsystem->max_nsid;
 }
 
+int
+nvmf_subsystem_set_cntlid_range(struct spdk_nvmf_subsystem *subsystem,
+				uint16_t min_cntlid, uint16_t max_cntlid)
+{
+	if (subsystem->state != SPDK_NVMF_SUBSYSTEM_INACTIVE) {
+		return -EAGAIN;
+	}
+
+	if (min_cntlid > max_cntlid) {
+		return -EINVAL;
+	}
+	/* The spec reserves cntlid values in the range FFF0h to FFFFh. */
+	if (min_cntlid < NVMF_MIN_CNTLID || min_cntlid > NVMF_MAX_CNTLID ||
+	    max_cntlid < NVMF_MIN_CNTLID || max_cntlid > NVMF_MAX_CNTLID) {
+		return -EINVAL;
+	}
+	subsystem->min_cntlid = min_cntlid;
+	subsystem->max_cntlid = max_cntlid;
+	if (subsystem->next_cntlid < min_cntlid || subsystem->next_cntlid > max_cntlid - 1) {
+		subsystem->next_cntlid = min_cntlid - 1;
+	}
+
+	return 0;
+}
+
 static uint16_t
 nvmf_subsystem_gen_cntlid(struct spdk_nvmf_subsystem *subsystem)
 {
 	int count;
 
 	/*
-	 * In the worst case, we might have to try all CNTLID values between 1 and 0xFFF0 - 1
+	 * In the worst case, we might have to try all CNTLID values between min_cntlid and max_cntlid
 	 * before we find one that is unused (or find that all values are in use).
 	 */
-	for (count = 0; count < 0xFFF0 - 1; count++) {
+	for (count = 0; count < subsystem->max_cntlid - subsystem->min_cntlid + 1; count++) {
 		subsystem->next_cntlid++;
-		if (subsystem->next_cntlid >= 0xFFF0) {
-			/* The spec reserves cntlid values in the range FFF0h to FFFFh. */
-			subsystem->next_cntlid = 1;
+		if (subsystem->next_cntlid > subsystem->max_cntlid) {
+			subsystem->next_cntlid = subsystem->min_cntlid;
 		}
 
 		/* Check if a controller with this cntlid currently exists. */
@@ -1702,6 +1728,18 @@ spdk_nvmf_subsystem_get_max_namespaces(const struct spdk_nvmf_subsystem *subsyst
 	return subsystem->max_nsid;
 }
 
+uint16_t
+spdk_nvmf_subsystem_get_min_cntlid(const struct spdk_nvmf_subsystem *subsystem)
+{
+	return subsystem->min_cntlid;
+}
+
+uint16_t
+spdk_nvmf_subsystem_get_max_cntlid(const struct spdk_nvmf_subsystem *subsystem)
+{
+	return subsystem->max_cntlid;
+}
+
 struct _nvmf_ns_registrant {
 	uint64_t		rkey;
 	char			*host_uuid;
diff --git a/scripts/rpc.py b/scripts/rpc.py
index 1e4f57bf3..ae6bcfafe 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -1917,7 +1917,9 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
                                        model_number=args.model_number,
                                        allow_any_host=args.allow_any_host,
                                        max_namespaces=args.max_namespaces,
-                                       ana_reporting=args.ana_reporting)
+                                       ana_reporting=args.ana_reporting,
+                                       min_cntlid=args.min_cntlid,
+                                       max_cntlid=args.max_cntlid)
 
     p = subparsers.add_parser('nvmf_create_subsystem', aliases=['nvmf_subsystem_create'],
                               help='Create an NVMe-oF subsystem')
@@ -1933,6 +1935,8 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
     p.add_argument("-m", "--max-namespaces", help="Maximum number of namespaces allowed",
                    type=int, default=0)
     p.add_argument("-r", "--ana-reporting", action='store_true', help="Enable ANA reporting feature")
+    p.add_argument("-i", "--min_cntlid", help="Minimum controller ID", type=int, default=1)
+    p.add_argument("-I", "--max_cntlid", help="Maximum controller ID", type=int, default=0xffef)
     p.set_defaults(func=nvmf_create_subsystem)
 
     def nvmf_delete_subsystem(args):
diff --git a/scripts/rpc/nvmf.py b/scripts/rpc/nvmf.py
index 3070e49e0..8848b430b 100644
--- a/scripts/rpc/nvmf.py
+++ b/scripts/rpc/nvmf.py
@@ -177,7 +177,9 @@ def nvmf_create_subsystem(client,
                           model_number='SPDK bdev Controller',
                           allow_any_host=False,
                           max_namespaces=0,
-                          ana_reporting=False):
+                          ana_reporting=False,
+                          min_cntlid=1,
+                          max_cntlid=0xffef):
     """Construct an NVMe over Fabrics target subsystem.
 
     Args:
@@ -188,6 +190,8 @@ def nvmf_create_subsystem(client,
         allow_any_host: Allow any host (True) or enforce allowed host list (False). Default: False.
         max_namespaces: Maximum number of namespaces that can be attached to the subsystem (optional). Default: 0 (Unlimited).
         ana_reporting: Enable ANA reporting feature. Default: False.
+        min_cntlid: Minimum controller ID. Default: 1
+        max_cntlid: Maximum controller ID. Default: 0xffef
 
 
     Returns:
@@ -215,6 +219,12 @@ def nvmf_create_subsystem(client,
     if ana_reporting:
         params['ana_reporting'] = ana_reporting
 
+    if min_cntlid is not None:
+        params['min_cntlid'] = min_cntlid
+
+    if max_cntlid is not None:
+        params['max_cntlid'] = max_cntlid
+
     return client.call('nvmf_create_subsystem', params)
 
 
diff --git a/test/nvmf/target/invalid.sh b/test/nvmf/target/invalid.sh
index dbd8cdf19..a15115766 100755
--- a/test/nvmf/target/invalid.sh
+++ b/test/nvmf/target/invalid.sh
@@ -66,6 +66,20 @@ fi
 out=$("$rpc" nvmf_subsystem_remove_listener "$nqn" -t "$TEST_TRANSPORT" -a "$IP" -s 4421 2>&1) && false
 [[ $out != *"Unable to stop listener."* ]]
 
+# Attempt to create subsystem with invalid controller ID range - outside [1, 0xffef]
+out=$("$rpc" nvmf_create_subsystem "$nqn$RANDOM" -i 0 2>&1) && false
+[[ $out == *"Invalid cntlid range"* ]]
+out=$("$rpc" nvmf_create_subsystem "$nqn$RANDOM" -i 65520 2>&1) && false
+[[ $out == *"Invalid cntlid range"* ]]
+out=$("$rpc" nvmf_create_subsystem "$nqn$RANDOM" -I 0 2>&1) && false
+[[ $out == *"Invalid cntlid range"* ]]
+out=$("$rpc" nvmf_create_subsystem "$nqn$RANDOM" -I 65520 2>&1) && false
+[[ $out == *"Invalid cntlid range"* ]]
+
+# Attempt to create subsystem with invalid controller ID range - [x, y] where x>y
+out=$("$rpc" nvmf_create_subsystem "$nqn$RANDOM" -i 6 -I 5 2>&1) && false
+[[ $out == *"Invalid cntlid range"* ]]
+
 # Attempt to delete non-existing target
 out=$("$multi_target_rpc" nvmf_delete_target --name "$target" 2>&1) && false
 [[ $out == *"The specified target doesn't exist, cannot delete it."* ]]
diff --git a/test/nvmf/target/nvme_cli.sh b/test/nvmf/target/nvme_cli.sh
index 24ecd6853..ab0b13b08 100755
--- a/test/nvmf/target/nvme_cli.sh
+++ b/test/nvmf/target/nvme_cli.sh
@@ -23,7 +23,7 @@ $rpc_py nvmf_create_transport $NVMF_TRANSPORT_OPTS -u 8192
 $rpc_py bdev_malloc_create $MALLOC_BDEV_SIZE $MALLOC_BLOCK_SIZE -b Malloc0
 $rpc_py bdev_malloc_create $MALLOC_BDEV_SIZE $MALLOC_BLOCK_SIZE -b Malloc1
 
-$rpc_py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s $NVMF_SERIAL -d SPDK_Controller1
+$rpc_py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s $NVMF_SERIAL -d SPDK_Controller1 -i 291
 $rpc_py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 Malloc0
 $rpc_py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 Malloc1
 $rpc_py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t $TEST_TRANSPORT -a $NVMF_FIRST_TARGET_IP -s $NVMF_PORT
@@ -46,6 +46,11 @@ for ctrl in "${nvmes[@]}"; do
 		echo "Wrong model number for controller" $nvme_model
 		exit 1
 	fi
+	nvme_cntlid=$(nvme id-ctrl $ctrl | grep -w cntlid | sed 's/^.*: //' | sed 's/ *$//')
+	if [ "$nvme_cntlid" != "0x123" ]; then
+		echo "Wrong controller ID for controller" $nvme_model
+		exit 1
+	fi
 done
 
 for ns in "${nvmes[@]}"; do
-- 
2.26.2


From d5b7f3c580c721669687357b4f079369287fa755 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 26 Apr 2021 12:08:59 +0900
Subject: [PATCH 104/342] thread: Add check if the correct thread called
 spdk_poller_pause/resume()

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ie2156a331bc2384a1cebe66fcddb90ef5aa1c380
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7661
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/thread/thread.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 4c4b5da5a..c42b77903 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1355,6 +1355,12 @@ spdk_poller_pause(struct spdk_poller *poller)
 		return;
 	}
 
+	if (poller->thread != thread) {
+		SPDK_ERRLOG("different from the thread that called spdk_poller_pause()\n");
+		assert(false);
+		return;
+	}
+
 	/* If a poller is paused from within itself, we can immediately move it
 	 * on the paused_pollers list.  Otherwise we just set its state to
 	 * SPDK_POLLER_STATE_PAUSING and let spdk_thread_poll() move it.  It
@@ -1391,6 +1397,12 @@ spdk_poller_resume(struct spdk_poller *poller)
 		return;
 	}
 
+	if (poller->thread != thread) {
+		SPDK_ERRLOG("different from the thread that called spdk_poller_resume()\n");
+		assert(false);
+		return;
+	}
+
 	/* If a poller is paused it has to be removed from the paused pollers
 	 * list and put on the active / timer list depending on its
 	 * period_ticks.  If a poller is still in the process of being paused,
-- 
2.26.2


From cd83ea4a6d7bd7c46d676213c65d119e0449241e Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Fri, 30 Apr 2021 23:25:15 +0900
Subject: [PATCH 105/342] thread: Add SPDK internal APIs
 spdk_thread_get_first/next_active/timed/paused_poller()

The following patches will introduce red black tree to manage
timed pollers efficiently but it will be based on macros available only
in lib/thread/thread.c. Hence then it will be difficult to expose the
internal of timed pollers tree outside the file. On the other hand,
we do not want to include JSON into the file.

Hence add a few SPDK internal APIs to iterate pollers list transparently.

For spdk_thread_get_next_active/timed/pause_poller(), we omit the parameter
thread and get it internally from poller->thread even if the names include
the term "thread". This will be slightly cleaner.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I000801a2e4dc42fa79801a2fd6f2b06e1b769c88
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7717
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 include/spdk_internal/thread.h |  7 +++++++
 lib/event/app_rpc.c            | 20 +++++++++++++------
 lib/thread/Makefile            |  2 +-
 lib/thread/spdk_thread.map     |  6 ++++++
 lib/thread/thread.c            | 36 ++++++++++++++++++++++++++++++++++
 5 files changed, 64 insertions(+), 7 deletions(-)

diff --git a/include/spdk_internal/thread.h b/include/spdk_internal/thread.h
index 6d9e830d4..a29d7bdad 100644
--- a/include/spdk_internal/thread.h
+++ b/include/spdk_internal/thread.h
@@ -142,4 +142,11 @@ const char *spdk_poller_state_str(enum spdk_poller_state state);
 
 const char *spdk_io_device_get_name(struct io_device *dev);
 
+struct spdk_poller *spdk_thread_get_first_active_poller(struct spdk_thread *thread);
+struct spdk_poller *spdk_thread_get_next_active_poller(struct spdk_poller *prev);
+struct spdk_poller *spdk_thread_get_first_timed_poller(struct spdk_thread *thread);
+struct spdk_poller *spdk_thread_get_next_timed_poller(struct spdk_poller *prev);
+struct spdk_poller *spdk_thread_get_first_paused_poller(struct spdk_thread *thread);
+struct spdk_poller *spdk_thread_get_next_paused_poller(struct spdk_poller *prev);
+
 #endif /* SPDK_THREAD_INTERNAL_H_ */
diff --git a/lib/event/app_rpc.c b/lib/event/app_rpc.c
index b07bda12f..c7dede5bc 100644
--- a/lib/event/app_rpc.c
+++ b/lib/event/app_rpc.c
@@ -202,13 +202,18 @@ _rpc_thread_get_stats(void *arg)
 	uint64_t timed_pollers_count = 0;
 	uint64_t paused_pollers_count = 0;
 
-	TAILQ_FOREACH(poller, &thread->active_pollers, tailq) {
+	for (poller = spdk_thread_get_first_active_poller(thread); poller != NULL;
+	     poller = spdk_thread_get_next_active_poller(poller)) {
 		active_pollers_count++;
 	}
-	TAILQ_FOREACH(poller, &thread->timed_pollers, tailq) {
+
+	for (poller = spdk_thread_get_first_timed_poller(thread); poller != NULL;
+	     poller = spdk_thread_get_next_timed_poller(poller)) {
 		timed_pollers_count++;
 	}
-	TAILQ_FOREACH(poller, &thread->paused_pollers, tailq) {
+
+	for (poller = spdk_thread_get_first_paused_poller(thread); poller != NULL;
+	     poller = spdk_thread_get_next_paused_poller(poller)) {
 		paused_pollers_count++;
 	}
 
@@ -268,19 +273,22 @@ _rpc_thread_get_pollers(void *arg)
 	spdk_json_write_named_uint64(ctx->w, "id", spdk_thread_get_id(thread));
 
 	spdk_json_write_named_array_begin(ctx->w, "active_pollers");
-	TAILQ_FOREACH(poller, &thread->active_pollers, tailq) {
+	for (poller = spdk_thread_get_first_active_poller(thread); poller != NULL;
+	     poller = spdk_thread_get_next_active_poller(poller)) {
 		rpc_get_poller(poller, ctx->w);
 	}
 	spdk_json_write_array_end(ctx->w);
 
 	spdk_json_write_named_array_begin(ctx->w, "timed_pollers");
-	TAILQ_FOREACH(poller, &thread->timed_pollers, tailq) {
+	for (poller = spdk_thread_get_first_timed_poller(thread); poller != NULL;
+	     poller = spdk_thread_get_next_timed_poller(poller)) {
 		rpc_get_poller(poller, ctx->w);
 	}
 	spdk_json_write_array_end(ctx->w);
 
 	spdk_json_write_named_array_begin(ctx->w, "paused_pollers");
-	TAILQ_FOREACH(poller, &thread->paused_pollers, tailq) {
+	for (poller = spdk_thread_get_first_paused_poller(thread); poller != NULL;
+	     poller = spdk_thread_get_next_paused_poller(poller)) {
 		rpc_get_poller(poller, ctx->w);
 	}
 	spdk_json_write_array_end(ctx->w);
diff --git a/lib/thread/Makefile b/lib/thread/Makefile
index de4a09d85..fdaebd081 100644
--- a/lib/thread/Makefile
+++ b/lib/thread/Makefile
@@ -35,7 +35,7 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 SO_VER := 5
-SO_MINOR := 0
+SO_MINOR := 1
 
 C_SRCS = thread.c
 LIBNAME = thread
diff --git a/lib/thread/spdk_thread.map b/lib/thread/spdk_thread.map
index 4f16fa7b8..0b0e3a952 100644
--- a/lib/thread/spdk_thread.map
+++ b/lib/thread/spdk_thread.map
@@ -59,6 +59,12 @@
 	# internal functions in spdk_internal/thread.h
 	spdk_poller_state_str;
 	spdk_io_device_get_name;
+	spdk_thread_get_first_active_poller;
+	spdk_thread_get_next_active_poller;
+	spdk_thread_get_first_timed_poller;
+	spdk_thread_get_next_timed_poller;
+	spdk_thread_get_first_paused_poller;
+	spdk_thread_get_next_paused_poller;
 
 	local: *;
 };
diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index c42b77903..aa0c31983 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1436,6 +1436,42 @@ spdk_poller_state_str(enum spdk_poller_state state)
 	}
 }
 
+struct spdk_poller *
+spdk_thread_get_first_active_poller(struct spdk_thread *thread)
+{
+	return TAILQ_FIRST(&thread->active_pollers);
+}
+
+struct spdk_poller *
+spdk_thread_get_next_active_poller(struct spdk_poller *prev)
+{
+	return TAILQ_NEXT(prev, tailq);
+}
+
+struct spdk_poller *
+spdk_thread_get_first_timed_poller(struct spdk_thread *thread)
+{
+	return TAILQ_FIRST(&thread->active_pollers);
+}
+
+struct spdk_poller *
+spdk_thread_get_next_timed_poller(struct spdk_poller *prev)
+{
+	return TAILQ_NEXT(prev, tailq);
+}
+
+struct spdk_poller *
+spdk_thread_get_first_paused_poller(struct spdk_thread *thread)
+{
+	return TAILQ_FIRST(&thread->active_pollers);
+}
+
+struct spdk_poller *
+spdk_thread_get_next_paused_poller(struct spdk_poller *prev)
+{
+	return TAILQ_NEXT(prev, tailq);
+}
+
 struct call_thread {
 	struct spdk_thread *cur_thread;
 	spdk_msg_fn fn;
-- 
2.26.2


From 84ec9989763f0f5367e6c12be3f23800e0d4e28a Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 26 Apr 2021 18:59:33 +0900
Subject: [PATCH 106/342] thread: Check if timed poller is expired first in
 iteration of thread_poll()

There will be no issue even if time poller is unregistered or paused
after it is expired. The iteration is stopped anyway after the head poller
is found not to be expired.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I2b394b8b517930a6630dd31f59fcaea12eb80572
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7662
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/thread/thread.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index aa0c31983..d91cffa84 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -669,6 +669,10 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 	TAILQ_FOREACH_SAFE(poller, &thread->timed_pollers, tailq, tmp) {
 		int timer_rc = 0;
 
+		if (now < poller->next_run_tick) {
+			break;
+		}
+
 		if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
 			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
 			free(poller);
@@ -680,10 +684,6 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 			continue;
 		}
 
-		if (now < poller->next_run_tick) {
-			break;
-		}
-
 		poller->state = SPDK_POLLER_STATE_RUNNING;
 		timer_rc = poller->fn(poller->arg);
 
-- 
2.26.2


From 54215a1e9bdf501616f8c9fea59f66744c26d337 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 26 Apr 2021 19:17:23 +0900
Subject: [PATCH 107/342] thread: Factor out executing poller or timed poller
 into helper functions

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I8792b698f5de85c24482d6781fc3d47afce0c414
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7663
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/thread/thread.c | 151 +++++++++++++++++++++++++-------------------
 1 file changed, 85 insertions(+), 66 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index d91cffa84..ea8fe9c60 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -603,6 +603,89 @@ thread_update_stats(struct spdk_thread *thread, uint64_t end,
 	thread->tsc_last = end;
 }
 
+static inline int
+thread_execute_poller(struct spdk_thread *thread, struct spdk_poller *poller)
+{
+	int rc;
+
+	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
+		free(poller);
+		return 0;
+	} else if (poller->state == SPDK_POLLER_STATE_PAUSING) {
+		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
+		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
+		poller->state = SPDK_POLLER_STATE_PAUSED;
+		return 0;
+	}
+
+	poller->state = SPDK_POLLER_STATE_RUNNING;
+	rc = poller->fn(poller->arg);
+
+	poller->run_count++;
+	if (rc > 0) {
+		poller->busy_count++;
+	}
+
+#ifdef DEBUG
+	if (rc == -1) {
+		SPDK_DEBUGLOG(thread, "Poller %s returned -1\n", poller->name);
+	}
+#endif
+
+	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
+		free(poller);
+	} else if (poller->state != SPDK_POLLER_STATE_PAUSED) {
+		poller->state = SPDK_POLLER_STATE_WAITING;
+	}
+
+	return rc;
+}
+
+static inline int
+thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poller,
+			    uint64_t now)
+{
+	int rc;
+
+	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		free(poller);
+		return 0;
+	} else if (poller->state == SPDK_POLLER_STATE_PAUSING) {
+		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
+		poller->state = SPDK_POLLER_STATE_PAUSED;
+		return 0;
+	}
+
+	poller->state = SPDK_POLLER_STATE_RUNNING;
+	rc = poller->fn(poller->arg);
+
+	poller->run_count++;
+	if (rc > 0) {
+		poller->busy_count++;
+	}
+
+#ifdef DEBUG
+	if (rc == -1) {
+		SPDK_DEBUGLOG(thread, "Timed poller %s returned -1\n", poller->name);
+	}
+#endif
+
+	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		free(poller);
+	} else if (poller->state != SPDK_POLLER_STATE_PAUSED) {
+		poller->state = SPDK_POLLER_STATE_WAITING;
+		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		poller_insert_timer(thread, poller, now);
+	}
+
+	return rc;
+}
+
 static int
 thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 {
@@ -629,38 +712,7 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 				   active_pollers_head, tailq, tmp) {
 		int poller_rc;
 
-		if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
-			TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
-			free(poller);
-			continue;
-		} else if (poller->state == SPDK_POLLER_STATE_PAUSING) {
-			TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
-			TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
-			poller->state = SPDK_POLLER_STATE_PAUSED;
-			continue;
-		}
-
-		poller->state = SPDK_POLLER_STATE_RUNNING;
-		poller_rc = poller->fn(poller->arg);
-
-		poller->run_count++;
-		if (poller_rc > 0) {
-			poller->busy_count++;
-		}
-
-#ifdef DEBUG
-		if (poller_rc == -1) {
-			SPDK_DEBUGLOG(thread, "Poller %s returned -1\n", poller->name);
-		}
-#endif
-
-		if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
-			TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
-			free(poller);
-		} else if (poller->state != SPDK_POLLER_STATE_PAUSED) {
-			poller->state = SPDK_POLLER_STATE_WAITING;
-		}
-
+		poller_rc = thread_execute_poller(thread, poller);
 		if (poller_rc > rc) {
 			rc = poller_rc;
 		}
@@ -673,40 +725,7 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 			break;
 		}
 
-		if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
-			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
-			free(poller);
-			continue;
-		} else if (poller->state == SPDK_POLLER_STATE_PAUSING) {
-			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
-			TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
-			poller->state = SPDK_POLLER_STATE_PAUSED;
-			continue;
-		}
-
-		poller->state = SPDK_POLLER_STATE_RUNNING;
-		timer_rc = poller->fn(poller->arg);
-
-		poller->run_count++;
-		if (timer_rc > 0) {
-			poller->busy_count++;
-		}
-
-#ifdef DEBUG
-		if (timer_rc == -1) {
-			SPDK_DEBUGLOG(thread, "Timed poller %s returned -1\n", poller->name);
-		}
-#endif
-
-		if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
-			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
-			free(poller);
-		} else if (poller->state != SPDK_POLLER_STATE_PAUSED) {
-			poller->state = SPDK_POLLER_STATE_WAITING;
-			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
-			poller_insert_timer(thread, poller, now);
-		}
-
+		timer_rc = thread_execute_timed_poller(thread, poller, now);
 		if (timer_rc > rc) {
 			rc = timer_rc;
 		}
-- 
2.26.2


From 3f45ed2467270fccd8f76729a23c19243502b8d7 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 27 Apr 2021 00:20:54 +0900
Subject: [PATCH 108/342] thread: Change if-else_if to switch-case blocks of
 thread_execute_poller()

Change if - else if - else blocks of thread_execute_poller() and
thread_execute_timed_poller() to switch - cases blocks and specify
possible states explicitly in these switch - cases blocks.

The code will be simpler and clarified, and then the following patches
will be easier.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I2e283894f5d69e1bd67466ae070c5b8bb9014616
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7664
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/thread/thread.c | 44 ++++++++++++++++++++++++++++++++++++--------
 1 file changed, 36 insertions(+), 8 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index ea8fe9c60..231a205d1 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -608,15 +608,21 @@ thread_execute_poller(struct spdk_thread *thread, struct spdk_poller *poller)
 {
 	int rc;
 
-	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+	switch (poller->state) {
+	case SPDK_POLLER_STATE_UNREGISTERED:
 		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
 		free(poller);
 		return 0;
-	} else if (poller->state == SPDK_POLLER_STATE_PAUSING) {
+	case SPDK_POLLER_STATE_PAUSING:
 		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
 		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
 		poller->state = SPDK_POLLER_STATE_PAUSED;
 		return 0;
+	case SPDK_POLLER_STATE_WAITING:
+		break;
+	default:
+		assert(false);
+		break;
 	}
 
 	poller->state = SPDK_POLLER_STATE_RUNNING;
@@ -633,11 +639,19 @@ thread_execute_poller(struct spdk_thread *thread, struct spdk_poller *poller)
 	}
 #endif
 
-	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+	switch (poller->state) {
+	case SPDK_POLLER_STATE_UNREGISTERED:
 		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
 		free(poller);
-	} else if (poller->state != SPDK_POLLER_STATE_PAUSED) {
+		break;
+	case SPDK_POLLER_STATE_PAUSED:
+		break;
+	case SPDK_POLLER_STATE_RUNNING:
 		poller->state = SPDK_POLLER_STATE_WAITING;
+		break;
+	default:
+		assert(false);
+		break;
 	}
 
 	return rc;
@@ -649,15 +663,21 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 {
 	int rc;
 
-	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+	switch (poller->state) {
+	case SPDK_POLLER_STATE_UNREGISTERED:
 		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
 		free(poller);
 		return 0;
-	} else if (poller->state == SPDK_POLLER_STATE_PAUSING) {
+	case SPDK_POLLER_STATE_PAUSING:
 		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
 		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
 		poller->state = SPDK_POLLER_STATE_PAUSED;
 		return 0;
+	case SPDK_POLLER_STATE_WAITING:
+		break;
+	default:
+		assert(false);
+		break;
 	}
 
 	poller->state = SPDK_POLLER_STATE_RUNNING;
@@ -674,13 +694,21 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 	}
 #endif
 
-	if (poller->state == SPDK_POLLER_STATE_UNREGISTERED) {
+	switch (poller->state) {
+	case SPDK_POLLER_STATE_UNREGISTERED:
 		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
 		free(poller);
-	} else if (poller->state != SPDK_POLLER_STATE_PAUSED) {
+		break;
+	case SPDK_POLLER_STATE_PAUSED:
+		break;
+	case SPDK_POLLER_STATE_RUNNING:
 		poller->state = SPDK_POLLER_STATE_WAITING;
 		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
 		poller_insert_timer(thread, poller, now);
+		break;
+	default:
+		assert(false);
+		break;
 	}
 
 	return rc;
-- 
2.26.2


From 42ad32da6008401e21f77f952c5d1d2f9d43166c Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 27 Apr 2021 07:51:52 +0900
Subject: [PATCH 109/342] thread: Change if-else_if to switch-case blocks of
 spdk_poller_pause/resume()

It will be sufficiently reasonable to check if the caller thread is valid
even if spdk_poller_pause() or spdk_poller_resume() does nothing.
Besides, let's write all possibles states explicitly in switch - cases.

This refactoring clarifies the logic and makes the following patches easier.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I1163eff388fe741d6b6924f474a82b1aa7d18acb
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7665
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/thread/thread.c | 40 ++++++++++++++++++++++++----------------
 1 file changed, 24 insertions(+), 16 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 231a205d1..41e8541a0 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1391,11 +1391,6 @@ spdk_poller_pause(struct spdk_poller *poller)
 {
 	struct spdk_thread *thread;
 
-	if (poller->state == SPDK_POLLER_STATE_PAUSED ||
-	    poller->state == SPDK_POLLER_STATE_PAUSING) {
-		return;
-	}
-
 	thread = spdk_get_thread();
 	if (!thread) {
 		assert(false);
@@ -1414,9 +1409,11 @@ spdk_poller_pause(struct spdk_poller *poller)
 	 * allows a poller to be paused from another one's context without
 	 * breaking the TAILQ_FOREACH_REVERSE_SAFE iteration.
 	 */
-	if (poller->state != SPDK_POLLER_STATE_RUNNING) {
-		poller->state = SPDK_POLLER_STATE_PAUSING;
-	} else {
+	switch (poller->state) {
+	case SPDK_POLLER_STATE_PAUSED:
+	case SPDK_POLLER_STATE_PAUSING:
+		break;
+	case SPDK_POLLER_STATE_RUNNING:
 		if (poller->period_ticks > 0) {
 			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
 		} else {
@@ -1425,6 +1422,13 @@ spdk_poller_pause(struct spdk_poller *poller)
 
 		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
 		poller->state = SPDK_POLLER_STATE_PAUSED;
+		break;
+	case SPDK_POLLER_STATE_WAITING:
+		poller->state = SPDK_POLLER_STATE_PAUSING;
+		break;
+	default:
+		assert(false);
+		break;
 	}
 }
 
@@ -1433,11 +1437,6 @@ spdk_poller_resume(struct spdk_poller *poller)
 {
 	struct spdk_thread *thread;
 
-	if (poller->state != SPDK_POLLER_STATE_PAUSED &&
-	    poller->state != SPDK_POLLER_STATE_PAUSING) {
-		return;
-	}
-
 	thread = spdk_get_thread();
 	if (!thread) {
 		assert(false);
@@ -1456,12 +1455,21 @@ spdk_poller_resume(struct spdk_poller *poller)
 	 * we just need to flip its state back to waiting, as it's already on
 	 * the appropriate list.
 	 */
-	if (poller->state == SPDK_POLLER_STATE_PAUSED) {
+	switch (poller->state) {
+	case SPDK_POLLER_STATE_PAUSED:
 		TAILQ_REMOVE(&thread->paused_pollers, poller, tailq);
 		thread_insert_poller(thread, poller);
+	/* fallthrough */
+	case SPDK_POLLER_STATE_PAUSING:
+		poller->state = SPDK_POLLER_STATE_WAITING;
+		break;
+	case SPDK_POLLER_STATE_RUNNING:
+	case SPDK_POLLER_STATE_WAITING:
+		break;
+	default:
+		assert(false);
+		break;
 	}
-
-	poller->state = SPDK_POLLER_STATE_WAITING;
 }
 
 const char *
-- 
2.26.2


From aca41b43a34a066d8ac8f76bbbd98e233f54cfa4 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 27 Apr 2021 06:18:56 +0900
Subject: [PATCH 110/342] thread: Factor out convert period from usec to ticks
 into a helper function

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I1dc0a202aab61a42511d3afac6b6533cfe6d1ade
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7666
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/thread/thread.c | 27 +++++++++++++++++----------
 1 file changed, 17 insertions(+), 10 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 41e8541a0..f6d1c6a35 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1244,6 +1244,22 @@ spdk_poller_register_interrupt(struct spdk_poller *poller,
 	}
 }
 
+static uint64_t
+convert_us_to_ticks(uint64_t us)
+{
+	uint64_t quotient, remainder, ticks;
+
+	if (us) {
+		quotient = us / SPDK_SEC_TO_USEC;
+		remainder = us % SPDK_SEC_TO_USEC;
+		ticks = spdk_get_ticks_hz();
+
+		return ticks * quotient + (ticks * remainder) / SPDK_SEC_TO_USEC;
+	} else {
+		return 0;
+	}
+}
+
 static struct spdk_poller *
 poller_register(spdk_poller_fn fn,
 		void *arg,
@@ -1252,7 +1268,6 @@ poller_register(spdk_poller_fn fn,
 {
 	struct spdk_thread *thread;
 	struct spdk_poller *poller;
-	uint64_t quotient, remainder, ticks;
 
 	thread = spdk_get_thread();
 	if (!thread) {
@@ -1283,15 +1298,7 @@ poller_register(spdk_poller_fn fn,
 	poller->thread = thread;
 	poller->interruptfd = -1;
 
-	if (period_microseconds) {
-		quotient = period_microseconds / SPDK_SEC_TO_USEC;
-		remainder = period_microseconds % SPDK_SEC_TO_USEC;
-		ticks = spdk_get_ticks_hz();
-
-		poller->period_ticks = ticks * quotient + (ticks * remainder) / SPDK_SEC_TO_USEC;
-	} else {
-		poller->period_ticks = 0;
-	}
+	poller->period_ticks = convert_us_to_ticks(period_microseconds);
 
 	if (spdk_interrupt_mode_is_enabled()) {
 		int rc;
-- 
2.26.2


From c204c3d7862f575d710e64694debd020e46be99a Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 3 May 2021 09:30:50 +0900
Subject: [PATCH 111/342] thread: Change TAILQ_FOREACH_SAFE to TAILQ_FIRST()
 and _NEXT() for timed poller

When we introduce red black tree for timed pollers, we will not use
RB_FOREACH_SAFE() but cache the leftmost (smallest) node and iterate
from it via RB_NEXT() instead.

As another preparation, separate TAILQ_FOREACH_SAFE() into TAILQ_FIRST()
and TAILQ_NEXT().

The next patch will cache the first element to thread and refer it
first.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ie03c387b5b3a055c668e7b439a5eb05ed77eaa81
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7718
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/thread/thread.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index f6d1c6a35..b1cfe4835 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -746,17 +746,22 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 		}
 	}
 
-	TAILQ_FOREACH_SAFE(poller, &thread->timed_pollers, tailq, tmp) {
+	poller = TAILQ_FIRST(&thread->timed_pollers);
+	while (poller != NULL) {
 		int timer_rc = 0;
 
 		if (now < poller->next_run_tick) {
 			break;
 		}
 
+		tmp = TAILQ_NEXT(poller, tailq);
+
 		timer_rc = thread_execute_timed_poller(thread, poller, now);
 		if (timer_rc > rc) {
 			rc = timer_rc;
 		}
+
+		poller = tmp;
 	}
 
 	return rc;
-- 
2.26.2


From f5313b55018bdb05da468efb49b6dee4ff60a699 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 3 May 2021 10:12:58 +0900
Subject: [PATCH 112/342] thread: Factor out removing timed poller from list
 into a helper function

The following patches will update the cache to the closest timed
poller when removing it from the list. To do it easier, factor out
the operation to remove a timed poller from timed_pollers list into
a helper function.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I25016d86117b240a2651d1f06e23bea0342211f1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7719
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/thread/thread.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index b1cfe4835..75a908198 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -578,6 +578,12 @@ poller_insert_timer(struct spdk_thread *thread, struct spdk_poller *poller, uint
 	TAILQ_INSERT_HEAD(&thread->timed_pollers, poller, tailq);
 }
 
+static inline void
+poller_remove_timer(struct spdk_thread *thread, struct spdk_poller *poller)
+{
+	TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+}
+
 static void
 thread_insert_poller(struct spdk_thread *thread, struct spdk_poller *poller)
 {
@@ -665,11 +671,11 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 
 	switch (poller->state) {
 	case SPDK_POLLER_STATE_UNREGISTERED:
-		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		poller_remove_timer(thread, poller);
 		free(poller);
 		return 0;
 	case SPDK_POLLER_STATE_PAUSING:
-		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		poller_remove_timer(thread, poller);
 		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
 		poller->state = SPDK_POLLER_STATE_PAUSED;
 		return 0;
@@ -696,14 +702,14 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 
 	switch (poller->state) {
 	case SPDK_POLLER_STATE_UNREGISTERED:
-		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		poller_remove_timer(thread, poller);
 		free(poller);
 		break;
 	case SPDK_POLLER_STATE_PAUSED:
 		break;
 	case SPDK_POLLER_STATE_RUNNING:
 		poller->state = SPDK_POLLER_STATE_WAITING;
-		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		poller_remove_timer(thread, poller);
 		poller_insert_timer(thread, poller, now);
 		break;
 	default:
@@ -1128,7 +1134,7 @@ period_poller_set_interrupt_mode(struct spdk_poller *poller, void *cb_arg, bool
 		 */
 		now_tick = now_tick - poller->period_ticks + ticks * old_tv.it_value.tv_sec + \
 			   (ticks * old_tv.it_value.tv_nsec) / SPDK_SEC_TO_NSEC;
-		TAILQ_REMOVE(&poller->thread->timed_pollers, poller, tailq);
+		poller_remove_timer(poller->thread, poller);
 		poller_insert_timer(poller->thread, poller, now_tick);
 	}
 }
@@ -1427,7 +1433,7 @@ spdk_poller_pause(struct spdk_poller *poller)
 		break;
 	case SPDK_POLLER_STATE_RUNNING:
 		if (poller->period_ticks > 0) {
-			TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+			poller_remove_timer(thread, poller);
 		} else {
 			TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
 		}
-- 
2.26.2


From 9ff6238b88bd1f0dab5983ab2a7c5ac4ee52d5ed Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Thu, 6 May 2021 23:33:09 +0900
Subject: [PATCH 113/342] event/scheduler: Include not spdk_internal/thread.h
 but spdk/thread.h

It is better if the internal of poller or thread is not accessed
outside lib/thread.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I80d488a111fd9a67a0da32d1e63695ce5a6bcb4c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7776
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/event/gscheduler.c        | 2 +-
 lib/event/scheduler_dynamic.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/event/gscheduler.c b/lib/event/gscheduler.c
index 4f46d304c..ef96f8f4a 100644
--- a/lib/event/gscheduler.c
+++ b/lib/event/gscheduler.c
@@ -35,7 +35,7 @@
 #include "spdk/likely.h"
 
 #include "spdk_internal/event.h"
-#include "spdk_internal/thread.h"
+#include "spdk/thread.h"
 
 #include "spdk/log.h"
 #include "spdk/env.h"
diff --git a/lib/event/scheduler_dynamic.c b/lib/event/scheduler_dynamic.c
index ab685b410..03003a0ab 100644
--- a/lib/event/scheduler_dynamic.c
+++ b/lib/event/scheduler_dynamic.c
@@ -37,7 +37,7 @@
 #include "spdk/log.h"
 #include "spdk/env.h"
 
-#include "spdk_internal/thread.h"
+#include "spdk/thread.h"
 #include "spdk_internal/event.h"
 
 static uint32_t g_next_lcore = SPDK_ENV_LCORE_ID_ANY;
-- 
2.26.2


From 1aec9334d9d560d41c500889324d72898c6879d4 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Fri, 7 May 2021 08:02:30 +0900
Subject: [PATCH 114/342] thread: Change direct accesses to poller outside
 lib/thread to helper functions

Most accesses to the struct spdk_poller outside lib/thread have been
done via functions but a few direct accesses remain.

Change these to indirect accesses by addinng a few helper functions
as SPDK internal APIs.

Add spdk_poller_get_name() to get the name of the poller.

Remove spdk_poller_state_str() and add spdk_poller_get_state_str().
Exposing enum spdk_poller_state outside lib/thread is not really
necessary.

This removal requires us to update major SO version.

Add spdk_poller_get_period_ticks() to get the period ticks of the
poller.

Add struct spdk_poller_stats and spdk_poller_get_stats() to get
the stats of the poller.

The next patch will move the definition of struct spdk_poller and
enum spdk_poller_state from include/spdk_internal/thread.h to
lib/thread/thread.c.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Id597dae074a15fcd8af09fd9d416a22ce2f403c3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7798
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 include/spdk_internal/thread.h | 10 +++++++++-
 lib/event/app_rpc.c            | 18 ++++++++++++------
 lib/thread/Makefile            |  4 ++--
 lib/thread/spdk_thread.map     |  5 ++++-
 lib/thread/thread.c            | 23 +++++++++++++++++++++--
 5 files changed, 48 insertions(+), 12 deletions(-)

diff --git a/include/spdk_internal/thread.h b/include/spdk_internal/thread.h
index a29d7bdad..f1ff849d7 100644
--- a/include/spdk_internal/thread.h
+++ b/include/spdk_internal/thread.h
@@ -81,6 +81,11 @@ struct spdk_poller {
 	char				name[SPDK_MAX_POLLER_NAME_LEN + 1];
 };
 
+struct spdk_poller_stats {
+	uint64_t	run_count;
+	uint64_t	busy_count;
+};
+
 enum spdk_thread_state {
 	/* The thread is pocessing poller and message by spdk_thread_poll(). */
 	SPDK_THREAD_STATE_RUNNING,
@@ -138,7 +143,10 @@ struct spdk_thread {
 	uint8_t				ctx[0];
 };
 
-const char *spdk_poller_state_str(enum spdk_poller_state state);
+const char *spdk_poller_get_name(struct spdk_poller *poller);
+const char *spdk_poller_get_state_str(struct spdk_poller *poller);
+uint64_t spdk_poller_get_period_ticks(struct spdk_poller *poller);
+void spdk_poller_get_stats(struct spdk_poller *poller, struct spdk_poller_stats *stats);
 
 const char *spdk_io_device_get_name(struct io_device *dev);
 
diff --git a/lib/event/app_rpc.c b/lib/event/app_rpc.c
index c7dede5bc..a5cd18464 100644
--- a/lib/event/app_rpc.c
+++ b/lib/event/app_rpc.c
@@ -250,13 +250,19 @@ SPDK_RPC_REGISTER("thread_get_stats", rpc_thread_get_stats, SPDK_RPC_RUNTIME)
 static void
 rpc_get_poller(struct spdk_poller *poller, struct spdk_json_write_ctx *w)
 {
+	struct spdk_poller_stats stats;
+	uint64_t period_ticks;
+
+	period_ticks = spdk_poller_get_period_ticks(poller);
+	spdk_poller_get_stats(poller, &stats);
+
 	spdk_json_write_object_begin(w);
-	spdk_json_write_named_string(w, "name", poller->name);
-	spdk_json_write_named_string(w, "state", spdk_poller_state_str(poller->state));
-	spdk_json_write_named_uint64(w, "run_count", poller->run_count);
-	spdk_json_write_named_uint64(w, "busy_count", poller->busy_count);
-	if (poller->period_ticks) {
-		spdk_json_write_named_uint64(w, "period_ticks", poller->period_ticks);
+	spdk_json_write_named_string(w, "name", spdk_poller_get_name(poller));
+	spdk_json_write_named_string(w, "state", spdk_poller_get_state_str(poller));
+	spdk_json_write_named_uint64(w, "run_count", stats.run_count);
+	spdk_json_write_named_uint64(w, "busy_count", stats.busy_count);
+	if (period_ticks) {
+		spdk_json_write_named_uint64(w, "period_ticks", period_ticks);
 	}
 	spdk_json_write_object_end(w);
 }
diff --git a/lib/thread/Makefile b/lib/thread/Makefile
index fdaebd081..846b32f52 100644
--- a/lib/thread/Makefile
+++ b/lib/thread/Makefile
@@ -34,8 +34,8 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-SO_VER := 5
-SO_MINOR := 1
+SO_VER := 6
+SO_MINOR := 0
 
 C_SRCS = thread.c
 LIBNAME = thread
diff --git a/lib/thread/spdk_thread.map b/lib/thread/spdk_thread.map
index 0b0e3a952..501f5a8be 100644
--- a/lib/thread/spdk_thread.map
+++ b/lib/thread/spdk_thread.map
@@ -57,7 +57,10 @@
 	spdk_interrupt_mode_is_enabled;
 
 	# internal functions in spdk_internal/thread.h
-	spdk_poller_state_str;
+	spdk_poller_get_name;
+	spdk_poller_get_state_str;
+	spdk_poller_get_period_ticks;
+	spdk_poller_get_stats;
 	spdk_io_device_get_name;
 	spdk_thread_get_first_active_poller;
 	spdk_thread_get_next_active_poller;
diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 75a908198..d9e39b065 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1491,9 +1491,15 @@ spdk_poller_resume(struct spdk_poller *poller)
 }
 
 const char *
-spdk_poller_state_str(enum spdk_poller_state state)
+spdk_poller_get_name(struct spdk_poller *poller)
 {
-	switch (state) {
+	return poller->name;
+}
+
+const char *
+spdk_poller_get_state_str(struct spdk_poller *poller)
+{
+	switch (poller->state) {
 	case SPDK_POLLER_STATE_WAITING:
 		return "waiting";
 	case SPDK_POLLER_STATE_RUNNING:
@@ -1509,6 +1515,19 @@ spdk_poller_state_str(enum spdk_poller_state state)
 	}
 }
 
+uint64_t
+spdk_poller_get_period_ticks(struct spdk_poller *poller)
+{
+	return poller->period_ticks;
+}
+
+void
+spdk_poller_get_stats(struct spdk_poller *poller, struct spdk_poller_stats *stats)
+{
+	stats->run_count = poller->run_count;
+	stats->busy_count = poller->busy_count;
+}
+
 struct spdk_poller *
 spdk_thread_get_first_active_poller(struct spdk_thread *thread)
 {
-- 
2.26.2


From 5fdb2b761b88ea7672f7f80bfa7aaebb4255334d Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 12 May 2021 06:49:20 +0900
Subject: [PATCH 115/342] thread: Make struct spdk_poller and enum
 spdk_poller_state private in thread.c

Move the definition of struct spdk_poller and enum spdk_poller_state
from include/spdk_internal/thread.h to lib/thread/thread.c.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I4480a0b7a2a94ef97ff3185e458221e8c473665d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7799
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 include/spdk_internal/thread.h | 42 +---------------------------------
 lib/thread/thread.c            | 42 ++++++++++++++++++++++++++++++++++
 2 files changed, 43 insertions(+), 41 deletions(-)

diff --git a/include/spdk_internal/thread.h b/include/spdk_internal/thread.h
index f1ff849d7..ae3b99757 100644
--- a/include/spdk_internal/thread.h
+++ b/include/spdk_internal/thread.h
@@ -37,49 +37,9 @@
 #include "spdk/stdinc.h"
 #include "spdk/thread.h"
 
-#define SPDK_MAX_POLLER_NAME_LEN	256
 #define SPDK_MAX_THREAD_NAME_LEN	256
 
-enum spdk_poller_state {
-	/* The poller is registered with a thread but not currently executing its fn. */
-	SPDK_POLLER_STATE_WAITING,
-
-	/* The poller is currently running its fn. */
-	SPDK_POLLER_STATE_RUNNING,
-
-	/* The poller was unregistered during the execution of its fn. */
-	SPDK_POLLER_STATE_UNREGISTERED,
-
-	/* The poller is in the process of being paused.  It will be paused
-	 * during the next time it's supposed to be executed.
-	 */
-	SPDK_POLLER_STATE_PAUSING,
-
-	/* The poller is registered but currently paused.  It's on the
-	 * paused_pollers list.
-	 */
-	SPDK_POLLER_STATE_PAUSED,
-};
-
-struct spdk_poller {
-	TAILQ_ENTRY(spdk_poller)	tailq;
-
-	/* Current state of the poller; should only be accessed from the poller's thread. */
-	enum spdk_poller_state		state;
-
-	uint64_t			period_ticks;
-	uint64_t			next_run_tick;
-	uint64_t			run_count;
-	uint64_t			busy_count;
-	spdk_poller_fn			fn;
-	void				*arg;
-	struct spdk_thread		*thread;
-	int				interruptfd;
-	spdk_poller_set_interrupt_mode_cb set_intr_cb_fn;
-	void				*set_intr_cb_arg;
-
-	char				name[SPDK_MAX_POLLER_NAME_LEN + 1];
-};
+struct spdk_poller;
 
 struct spdk_poller_stats {
 	uint64_t	run_count;
diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index d9e39b065..bed569ac3 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -52,6 +52,48 @@
 #define SPDK_MSG_BATCH_SIZE		8
 #define SPDK_MAX_DEVICE_NAME_LEN	256
 #define SPDK_THREAD_EXIT_TIMEOUT_SEC	5
+#define SPDK_MAX_POLLER_NAME_LEN	256
+
+enum spdk_poller_state {
+	/* The poller is registered with a thread but not currently executing its fn. */
+	SPDK_POLLER_STATE_WAITING,
+
+	/* The poller is currently running its fn. */
+	SPDK_POLLER_STATE_RUNNING,
+
+	/* The poller was unregistered during the execution of its fn. */
+	SPDK_POLLER_STATE_UNREGISTERED,
+
+	/* The poller is in the process of being paused.  It will be paused
+	 * during the next time it's supposed to be executed.
+	 */
+	SPDK_POLLER_STATE_PAUSING,
+
+	/* The poller is registered but currently paused.  It's on the
+	 * paused_pollers list.
+	 */
+	SPDK_POLLER_STATE_PAUSED,
+};
+
+struct spdk_poller {
+	TAILQ_ENTRY(spdk_poller)	tailq;
+
+	/* Current state of the poller; should only be accessed from the poller's thread. */
+	enum spdk_poller_state		state;
+
+	uint64_t			period_ticks;
+	uint64_t			next_run_tick;
+	uint64_t			run_count;
+	uint64_t			busy_count;
+	spdk_poller_fn			fn;
+	void				*arg;
+	struct spdk_thread		*thread;
+	int				interruptfd;
+	spdk_poller_set_interrupt_mode_cb set_intr_cb_fn;
+	void				*set_intr_cb_arg;
+
+	char				name[SPDK_MAX_POLLER_NAME_LEN + 1];
+};
 
 static pthread_mutex_t g_devlist_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-- 
2.26.2


From bd2fae2f0e4cf878ec2bc65f3c2925caa78e13bf Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Fri, 7 May 2021 09:25:33 +0900
Subject: [PATCH 116/342] thread: Change remaining direct accesses to
 io_channel outside lib/thread to helper functions

This is the same effort as spdk_poller.

The following patches will move the definition of struct spdk_thread and
enum spdk_thread_state from include/spdk_internal/thread.h to
lib/thread/thread.c.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I7f7bdfdd7a7b1b834d16d79638a4fd2d63e9daf6
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7800
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 include/spdk_internal/thread.h |  5 +++++
 lib/event/app_rpc.c            |  5 +++--
 lib/thread/spdk_thread.map     |  3 +++
 lib/thread/thread.c            | 18 ++++++++++++++++++
 4 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/include/spdk_internal/thread.h b/include/spdk_internal/thread.h
index ae3b99757..98fe1ee2a 100644
--- a/include/spdk_internal/thread.h
+++ b/include/spdk_internal/thread.h
@@ -108,6 +108,8 @@ const char *spdk_poller_get_state_str(struct spdk_poller *poller);
 uint64_t spdk_poller_get_period_ticks(struct spdk_poller *poller);
 void spdk_poller_get_stats(struct spdk_poller *poller, struct spdk_poller_stats *stats);
 
+int spdk_io_channel_get_ref_count(struct spdk_io_channel *ch);
+
 const char *spdk_io_device_get_name(struct io_device *dev);
 
 struct spdk_poller *spdk_thread_get_first_active_poller(struct spdk_thread *thread);
@@ -117,4 +119,7 @@ struct spdk_poller *spdk_thread_get_next_timed_poller(struct spdk_poller *prev);
 struct spdk_poller *spdk_thread_get_first_paused_poller(struct spdk_thread *thread);
 struct spdk_poller *spdk_thread_get_next_paused_poller(struct spdk_poller *prev);
 
+struct spdk_io_channel *spdk_thread_get_first_io_channel(struct spdk_thread *thread);
+struct spdk_io_channel *spdk_thread_get_next_io_channel(struct spdk_io_channel *prev);
+
 #endif /* SPDK_THREAD_INTERNAL_H_ */
diff --git a/lib/event/app_rpc.c b/lib/event/app_rpc.c
index a5cd18464..dba215898 100644
--- a/lib/event/app_rpc.c
+++ b/lib/event/app_rpc.c
@@ -322,7 +322,7 @@ rpc_get_io_channel(struct spdk_io_channel *ch, struct spdk_json_write_ctx *w)
 {
 	spdk_json_write_object_begin(w);
 	spdk_json_write_named_string(w, "name", spdk_io_device_get_name(ch->dev));
-	spdk_json_write_named_uint32(w, "ref", ch->ref);
+	spdk_json_write_named_uint32(w, "ref", spdk_io_channel_get_ref_count(ch));
 	spdk_json_write_object_end(w);
 }
 
@@ -337,7 +337,8 @@ _rpc_thread_get_io_channels(void *arg)
 	spdk_json_write_named_string(ctx->w, "name", spdk_thread_get_name(thread));
 
 	spdk_json_write_named_array_begin(ctx->w, "io_channels");
-	TAILQ_FOREACH(ch, &thread->io_channels, tailq) {
+	for (ch = spdk_thread_get_first_io_channel(thread); ch != NULL;
+	     ch = spdk_thread_get_next_io_channel(ch)) {
 		rpc_get_io_channel(ch, ctx->w);
 	}
 	spdk_json_write_array_end(ctx->w);
diff --git a/lib/thread/spdk_thread.map b/lib/thread/spdk_thread.map
index 501f5a8be..ff8488ea9 100644
--- a/lib/thread/spdk_thread.map
+++ b/lib/thread/spdk_thread.map
@@ -61,6 +61,7 @@
 	spdk_poller_get_state_str;
 	spdk_poller_get_period_ticks;
 	spdk_poller_get_stats;
+	spdk_io_channel_get_ref_count;
 	spdk_io_device_get_name;
 	spdk_thread_get_first_active_poller;
 	spdk_thread_get_next_active_poller;
@@ -68,6 +69,8 @@
 	spdk_thread_get_next_timed_poller;
 	spdk_thread_get_first_paused_poller;
 	spdk_thread_get_next_paused_poller;
+	spdk_thread_get_first_io_channel;
+	spdk_thread_get_next_io_channel;
 
 	local: *;
 };
diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index bed569ac3..48950bac1 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1606,6 +1606,18 @@ spdk_thread_get_next_paused_poller(struct spdk_poller *prev)
 	return TAILQ_NEXT(prev, tailq);
 }
 
+struct spdk_io_channel *
+spdk_thread_get_first_io_channel(struct spdk_thread *thread)
+{
+	return TAILQ_FIRST(&thread->io_channels);
+}
+
+struct spdk_io_channel *
+spdk_thread_get_next_io_channel(struct spdk_io_channel *prev)
+{
+	return TAILQ_NEXT(prev, tailq);
+}
+
 struct call_thread {
 	struct spdk_thread *cur_thread;
 	spdk_msg_fn fn;
@@ -2068,6 +2080,12 @@ spdk_io_channel_get_io_device(struct spdk_io_channel *ch)
 	return ch->dev->io_device;
 }
 
+int
+spdk_io_channel_get_ref_count(struct spdk_io_channel *ch)
+{
+	return ch->ref;
+}
+
 struct spdk_io_channel_iter {
 	void *io_device;
 	struct io_device *dev;
-- 
2.26.2


From 6edc4abe4bc85ffca2ee160d356185656ab05a5f Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Fri, 7 May 2021 10:13:10 +0900
Subject: [PATCH 117/342] thread: Change remaining direct accesses outside
 lib/thread to spdk_thread to helper functions

Use spdk_thread_get_last_tsc() and spdk_thread_get_stats() in
unit tests for reactor. As a result, we can change one inclusion
from spdk_internal/thread.h to spdk/thread.h.

This is the same effort as spdk_poller.

The following patches will move the definition of struct spdk_thread and
enum spdk_thread_state from include/spdk_internal/thread.h to
lib/thread/thread.c.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I24d4a52ecf885b6e7db749616ee1f95b82574dc5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7801
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 test/unit/lib/event/reactor.c/reactor_ut.c | 35 ++++++++++++++--------
 1 file changed, 22 insertions(+), 13 deletions(-)

diff --git a/test/unit/lib/event/reactor.c/reactor_ut.c b/test/unit/lib/event/reactor.c/reactor_ut.c
index 3d5acbb37..347b0af29 100644
--- a/test/unit/lib/event/reactor.c/reactor_ut.c
+++ b/test/unit/lib/event/reactor.c/reactor_ut.c
@@ -36,7 +36,7 @@
 #include "spdk_cunit.h"
 #include "common/lib/test_env.c"
 #include "event/reactor.c"
-#include "spdk_internal/thread.h"
+#include "spdk/thread.h"
 #include "event/scheduler_static.c"
 #include "event/scheduler_dynamic.c"
 
@@ -359,6 +359,7 @@ test_reactor_stats(void)
 	struct spdk_thread *thread1, *thread2;
 	struct spdk_reactor *reactor;
 	struct spdk_poller *busy1, *idle1, *busy2, *idle2;
+	struct spdk_thread_stats stats;
 	int rc __attribute__((unused));
 
 	/* Test case is the following:
@@ -406,12 +407,16 @@ test_reactor_stats(void)
 
 	_reactor_run(reactor);
 
-	CU_ASSERT(thread1->tsc_last == 200);
-	CU_ASSERT(thread1->stats.busy_tsc == 100);
-	CU_ASSERT(thread1->stats.idle_tsc == 0);
-	CU_ASSERT(thread2->tsc_last == 500);
-	CU_ASSERT(thread2->stats.busy_tsc == 0);
-	CU_ASSERT(thread2->stats.idle_tsc == 300);
+	spdk_set_thread(thread1);
+	CU_ASSERT(spdk_thread_get_last_tsc(thread1) == 200);
+	CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+	CU_ASSERT(stats.busy_tsc == 100);
+	CU_ASSERT(stats.idle_tsc == 0);
+	spdk_set_thread(thread2);
+	CU_ASSERT(spdk_thread_get_last_tsc(thread2) == 500);
+	CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+	CU_ASSERT(stats.busy_tsc == 0);
+	CU_ASSERT(stats.idle_tsc == 300);
 
 	CU_ASSERT(reactor->busy_tsc == 100);
 	CU_ASSERT(reactor->idle_tsc == 300);
@@ -428,12 +433,16 @@ test_reactor_stats(void)
 
 	_reactor_run(reactor);
 
-	CU_ASSERT(thread1->tsc_last == 700);
-	CU_ASSERT(thread1->stats.busy_tsc == 100);
-	CU_ASSERT(thread1->stats.idle_tsc == 200);
-	CU_ASSERT(thread2->tsc_last == 1100);
-	CU_ASSERT(thread2->stats.busy_tsc == 400);
-	CU_ASSERT(thread2->stats.idle_tsc == 300);
+	spdk_set_thread(thread1);
+	CU_ASSERT(spdk_thread_get_last_tsc(thread1) == 700);
+	CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+	CU_ASSERT(stats.busy_tsc == 100);
+	CU_ASSERT(stats.idle_tsc == 200);
+	spdk_set_thread(thread2);
+	CU_ASSERT(spdk_thread_get_last_tsc(thread2) == 1100);
+	CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+	CU_ASSERT(stats.busy_tsc == 400);
+	CU_ASSERT(stats.idle_tsc == 300);
 
 	CU_ASSERT(reactor->busy_tsc == 500);
 	CU_ASSERT(reactor->idle_tsc == 500);
-- 
2.26.2


From 54bc83dcc7abf940817f96badf5c6177dc9812f1 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 12 May 2021 13:40:47 +0900
Subject: [PATCH 118/342] thread: Make struct spdk_thread and enum
 spdk_thread_state private in thread.c

Move the definition of struct spdk_thread and enum spdk_thread_state
from include/spdk_internal/thread.h to lib/thread/thread.c.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Iab8cec9776e76668ebfb3c75064c316d10607421
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7802
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk_internal/thread.h | 59 +---------------------------------
 lib/thread/thread.c            | 58 +++++++++++++++++++++++++++++++++
 2 files changed, 59 insertions(+), 58 deletions(-)

diff --git a/include/spdk_internal/thread.h b/include/spdk_internal/thread.h
index 98fe1ee2a..1fd654800 100644
--- a/include/spdk_internal/thread.h
+++ b/include/spdk_internal/thread.h
@@ -37,8 +37,6 @@
 #include "spdk/stdinc.h"
 #include "spdk/thread.h"
 
-#define SPDK_MAX_THREAD_NAME_LEN	256
-
 struct spdk_poller;
 
 struct spdk_poller_stats {
@@ -46,62 +44,7 @@ struct spdk_poller_stats {
 	uint64_t	busy_count;
 };
 
-enum spdk_thread_state {
-	/* The thread is pocessing poller and message by spdk_thread_poll(). */
-	SPDK_THREAD_STATE_RUNNING,
-
-	/* The thread is in the process of termination. It reaps unregistering
-	 * poller are releasing I/O channel.
-	 */
-	SPDK_THREAD_STATE_EXITING,
-
-	/* The thread is exited. It is ready to call spdk_thread_destroy(). */
-	SPDK_THREAD_STATE_EXITED,
-};
-
-struct spdk_thread {
-	uint64_t			tsc_last;
-	struct spdk_thread_stats	stats;
-	/*
-	 * Contains pollers actively running on this thread.  Pollers
-	 *  are run round-robin. The thread takes one poller from the head
-	 *  of the ring, executes it, then puts it back at the tail of
-	 *  the ring.
-	 */
-	TAILQ_HEAD(active_pollers_head, spdk_poller)	active_pollers;
-	/**
-	 * Contains pollers running on this thread with a periodic timer.
-	 */
-	TAILQ_HEAD(timed_pollers_head, spdk_poller)	timed_pollers;
-	/*
-	 * Contains paused pollers.  Pollers on this queue are waiting until
-	 * they are resumed (in which case they're put onto the active/timer
-	 * queues) or unregistered.
-	 */
-	TAILQ_HEAD(paused_pollers_head, spdk_poller)	paused_pollers;
-	struct spdk_ring		*messages;
-	int				msg_fd;
-	SLIST_HEAD(, spdk_msg)		msg_cache;
-	size_t				msg_cache_count;
-	spdk_msg_fn			critical_msg;
-	uint64_t			id;
-	enum spdk_thread_state		state;
-	int				pending_unregister_count;
-
-	TAILQ_HEAD(, spdk_io_channel)	io_channels;
-	TAILQ_ENTRY(spdk_thread)	tailq;
-
-	char				name[SPDK_MAX_THREAD_NAME_LEN + 1];
-	struct spdk_cpuset		cpumask;
-	uint64_t			exit_timeout_tsc;
-
-	/* Indicates whether this spdk_thread currently runs in interrupt. */
-	bool				in_interrupt;
-	struct spdk_fd_group		*fgrp;
-
-	/* User context allocated at the end */
-	uint8_t				ctx[0];
-};
+struct spdk_thread;
 
 const char *spdk_poller_get_name(struct spdk_poller *poller);
 const char *spdk_poller_get_state_str(struct spdk_poller *poller);
diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 48950bac1..8184cc2f4 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -53,6 +53,7 @@
 #define SPDK_MAX_DEVICE_NAME_LEN	256
 #define SPDK_THREAD_EXIT_TIMEOUT_SEC	5
 #define SPDK_MAX_POLLER_NAME_LEN	256
+#define SPDK_MAX_THREAD_NAME_LEN	256
 
 enum spdk_poller_state {
 	/* The poller is registered with a thread but not currently executing its fn. */
@@ -95,6 +96,63 @@ struct spdk_poller {
 	char				name[SPDK_MAX_POLLER_NAME_LEN + 1];
 };
 
+enum spdk_thread_state {
+	/* The thread is pocessing poller and message by spdk_thread_poll(). */
+	SPDK_THREAD_STATE_RUNNING,
+
+	/* The thread is in the process of termination. It reaps unregistering
+	 * poller are releasing I/O channel.
+	 */
+	SPDK_THREAD_STATE_EXITING,
+
+	/* The thread is exited. It is ready to call spdk_thread_destroy(). */
+	SPDK_THREAD_STATE_EXITED,
+};
+
+struct spdk_thread {
+	uint64_t			tsc_last;
+	struct spdk_thread_stats	stats;
+	/*
+	 * Contains pollers actively running on this thread.  Pollers
+	 *  are run round-robin. The thread takes one poller from the head
+	 *  of the ring, executes it, then puts it back at the tail of
+	 *  the ring.
+	 */
+	TAILQ_HEAD(active_pollers_head, spdk_poller)	active_pollers;
+	/**
+	 * Contains pollers running on this thread with a periodic timer.
+	 */
+	TAILQ_HEAD(timed_pollers_head, spdk_poller)	timed_pollers;
+	/*
+	 * Contains paused pollers.  Pollers on this queue are waiting until
+	 * they are resumed (in which case they're put onto the active/timer
+	 * queues) or unregistered.
+	 */
+	TAILQ_HEAD(paused_pollers_head, spdk_poller)	paused_pollers;
+	struct spdk_ring		*messages;
+	int				msg_fd;
+	SLIST_HEAD(, spdk_msg)		msg_cache;
+	size_t				msg_cache_count;
+	spdk_msg_fn			critical_msg;
+	uint64_t			id;
+	enum spdk_thread_state		state;
+	int				pending_unregister_count;
+
+	TAILQ_HEAD(, spdk_io_channel)	io_channels;
+	TAILQ_ENTRY(spdk_thread)	tailq;
+
+	char				name[SPDK_MAX_THREAD_NAME_LEN + 1];
+	struct spdk_cpuset		cpumask;
+	uint64_t			exit_timeout_tsc;
+
+	/* Indicates whether this spdk_thread currently runs in interrupt. */
+	bool				in_interrupt;
+	struct spdk_fd_group		*fgrp;
+
+	/* User context allocated at the end */
+	uint8_t				ctx[0];
+};
+
 static pthread_mutex_t g_devlist_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static spdk_new_thread_fn g_new_thread_fn = NULL;
-- 
2.26.2


From 64c6ddbf9574f8b8441e786c57b6ca3688c1f26e Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 8 Dec 2020 08:05:33 -0500
Subject: [PATCH 119/342] bdev/nvme: respond to attach RPC after bdev is
 examined

This makes use of newly added spdk_bdev_wait_for_examine(),
to only respond to RPC when bdev was fully examined.

Fixes #1760

Issue above was triggered in DD tests where application
finished before the examine had a chance to fully finish.
This patch addresses it by making sure that nvme attach
RPC waits for completion of the examine.
Later patch in series adds the bdev_wait_for_examine RPC
to multiple static configuration files. Making sure similar
issues do no occur for bdev modules which do not have changes
in their RPC as here.
The issue does not occur for JSON configs generated from apps,
see patch:
(e57bb1af)lib/bdev: build bdev_wait_for_examine into subsystem

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: Ie3ca2933af97a40ae01ecc3eefe2161d2d34c602
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/5483
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/bdev/nvme/bdev_nvme_rpc.c | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme_rpc.c b/module/bdev/nvme/bdev_nvme_rpc.c
index 27cd39901..6000ab146 100644
--- a/module/bdev/nvme/bdev_nvme_rpc.c
+++ b/module/bdev/nvme/bdev_nvme_rpc.c
@@ -218,36 +218,48 @@ static const struct spdk_json_object_decoder rpc_bdev_nvme_attach_controller_dec
 struct rpc_bdev_nvme_attach_controller_ctx {
 	struct rpc_bdev_nvme_attach_controller req;
 	uint32_t count;
+	size_t bdev_count;
 	const char *names[NVME_MAX_BDEVS_PER_RPC];
 	struct spdk_jsonrpc_request *request;
 };
 
 static void
-rpc_bdev_nvme_attach_controller_done(void *cb_ctx, size_t bdev_count, int rc)
+rpc_bdev_nvme_attach_controller_examined(void *cb_ctx)
 {
 	struct rpc_bdev_nvme_attach_controller_ctx *ctx = cb_ctx;
 	struct spdk_jsonrpc_request *request = ctx->request;
 	struct spdk_json_write_ctx *w;
 	size_t i;
 
-	if (rc < 0) {
-		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS, "Invalid parameters");
-		goto exit;
-	}
-
 	w = spdk_jsonrpc_begin_result(request);
 	spdk_json_write_array_begin(w);
-	for (i = 0; i < bdev_count; i++) {
+	for (i = 0; i < ctx->bdev_count; i++) {
 		spdk_json_write_string(w, ctx->names[i]);
 	}
 	spdk_json_write_array_end(w);
 	spdk_jsonrpc_end_result(request, w);
 
-exit:
 	free_rpc_bdev_nvme_attach_controller(&ctx->req);
 	free(ctx);
 }
 
+static void
+rpc_bdev_nvme_attach_controller_done(void *cb_ctx, size_t bdev_count, int rc)
+{
+	struct rpc_bdev_nvme_attach_controller_ctx *ctx = cb_ctx;
+	struct spdk_jsonrpc_request *request = ctx->request;
+
+	if (rc < 0) {
+		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS, "Invalid parameters");
+		free_rpc_bdev_nvme_attach_controller(&ctx->req);
+		free(ctx);
+		return;
+	}
+
+	ctx->bdev_count = bdev_count;
+	spdk_bdev_wait_for_examine(rpc_bdev_nvme_attach_controller_examined, ctx);
+}
+
 static void
 rpc_bdev_nvme_attach_controller(struct spdk_jsonrpc_request *request,
 				const struct spdk_json_val *params)
-- 
2.26.2


From d69b16dac8fdee4c451325410d39473dcca1dabc Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Wed, 12 May 2021 09:11:27 -0400
Subject: [PATCH 120/342] test/iscsi: remove comma from initiator_json_config

Function initiator_json_config is never called with
additional arguments that would fill up the subsystem
JSON.

Handling for the comma is removed.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I6ce5648a0eac29cb0f45d210696edf7977dfe89d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7860
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 test/iscsi_tgt/common.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/iscsi_tgt/common.sh b/test/iscsi_tgt/common.sh
index 7233b099d..d17a934f3 100644
--- a/test/iscsi_tgt/common.sh
+++ b/test/iscsi_tgt/common.sh
@@ -143,7 +143,7 @@ function initiator_json_config() {
 		            "url": "iscsi://$TARGET_IP/iqn.2016-06.io.spdk:disk1/0",
 		            "initiator_iqn": "iqn.2016-06.io.spdk:disk1/0"
 		          }
-		        }${*:+,$*}
+		        }
 		      ]
 		    }
 		  ]
-- 
2.26.2


From 1c9125e78e9eb66cc45cb9890209065f16fb1760 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Wed, 12 May 2021 07:49:53 -0400
Subject: [PATCH 121/342] test: add bdev_wait_for_examine to static JSON
 configs

Runtime RPCs such as bdev creation has no chance to wait for
bdev examination to finish. To handle this case commit below
introduced bdev_wait_for_examine RPC, and built it into all newly
saved JSON configurations:
(e57bb1af)lib/bdev: build bdev_wait_for_examine into subsystem

Some tests generate the configuration by hand, rather than
saving it from an existing application.
This patch embeds this RPC into the test configs.

Fixes #1760

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I79f998d722a2d19aa98b78333c64dbd2c1151444
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7861
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 test/blobfs/blobfs.sh                      |  5 ++++-
 test/dd/common.sh                          |  5 ++++-
 test/iscsi_tgt/common.sh                   |  3 +++
 test/nvme/perf/common.sh                   |  5 ++++-
 test/nvmf/common.sh                        |  5 ++++-
 test/ocf/integrity/fio-modes.sh            | 10 ++++++++++
 test/ocf/integrity/mallocs.conf            |  5 ++++-
 test/ocf/management/persistent-metadata.sh | 10 ++++++++++
 test/ocf/management/remove.sh              |  3 +++
 test/vhost/shared/bdev.json                |  3 +++
 10 files changed, 49 insertions(+), 5 deletions(-)

diff --git a/test/blobfs/blobfs.sh b/test/blobfs/blobfs.sh
index a741eca37..46975b01b 100755
--- a/test/blobfs/blobfs.sh
+++ b/test/blobfs/blobfs.sh
@@ -142,7 +142,10 @@ jq . <<- JSON > ${conf_file}
 	            "block_size": 512,
 	            "filename": "${tmp_file}"
 	          }
-	        }
+	        },
+	        {
+	          "method": "bdev_wait_for_examine"
+		}
 	      ]
 	    }
 	  ]
diff --git a/test/dd/common.sh b/test/dd/common.sh
index d2f7defa3..1475274ec 100644
--- a/test/dd/common.sh
+++ b/test/dd/common.sh
@@ -77,7 +77,10 @@ gen_conf() {
 		    {
 		      "subsystem": "bdev",
 		      "config": [
-		        ${config[*]}
+		        ${config[*]},
+			{
+			  "method": "bdev_wait_for_examine"
+			}
 		      ]
 		    }
 		    ${extra_subsystems[*]:+,${extra_subsystems[*]}}
diff --git a/test/iscsi_tgt/common.sh b/test/iscsi_tgt/common.sh
index d17a934f3..ca8d05f7c 100644
--- a/test/iscsi_tgt/common.sh
+++ b/test/iscsi_tgt/common.sh
@@ -143,6 +143,9 @@ function initiator_json_config() {
 		            "url": "iscsi://$TARGET_IP/iqn.2016-06.io.spdk:disk1/0",
 		            "initiator_iqn": "iqn.2016-06.io.spdk:disk1/0"
 		          }
+		        },
+		        {
+		          "method": "bdev_wait_for_examine"
 		        }
 		      ]
 		    }
diff --git a/test/nvme/perf/common.sh b/test/nvme/perf/common.sh
index f06e5141c..97951a059 100755
--- a/test/nvme/perf/common.sh
+++ b/test/nvme/perf/common.sh
@@ -85,7 +85,10 @@ function create_spdk_bdev_conf() {
 				{
 					"subsystem": "bdev",
 					"config": [
-						${bdev_json_cfg[*]}
+						${bdev_json_cfg[*]},
+					        {
+					                "method": "bdev_wait_for_examine"
+					        }
 					]
 				}
 			]
diff --git a/test/nvmf/common.sh b/test/nvmf/common.sh
index bf3dc2746..8c18d17f6 100644
--- a/test/nvmf/common.sh
+++ b/test/nvmf/common.sh
@@ -573,7 +573,10 @@ function gen_nvmf_target_json() {
 		        $(
 		IFS=","
 		printf '%s\n' "${config[*]}"
-		)
+		),
+			{
+			  "method": "bdev_wait_for_examine"
+			}
 		      ]
 		    }
 		  ]
diff --git a/test/ocf/integrity/fio-modes.sh b/test/ocf/integrity/fio-modes.sh
index b3801d33c..b8a28501d 100755
--- a/test/ocf/integrity/fio-modes.sh
+++ b/test/ocf/integrity/fio-modes.sh
@@ -68,6 +68,16 @@ for ((d = 0, c = 1; d <= ${#ocf_names[@]} + 2; d += 2, c++)); do
 	)
 done
 
+config+=(
+	"$(
+		cat <<- JSON
+			{
+			  "method": "bdev_wait_for_examine"
+			}
+		JSON
+	)"
+)
+
 # First ']}' closes our config and bdev subsystem blocks
 cat <<- CONFIG > "$curdir/modes.conf"
 	{"subsystems":[
diff --git a/test/ocf/integrity/mallocs.conf b/test/ocf/integrity/mallocs.conf
index 245dd23cf..0e9b7993e 100644
--- a/test/ocf/integrity/mallocs.conf
+++ b/test/ocf/integrity/mallocs.conf
@@ -50,7 +50,10 @@ gen_malloc_ocf_json () {
 		    {
 		      "subsystem": "bdev",
 		      "config": [
-		        $(IFS=","; printf '%s\n' "${config[*]}")
+		        $(IFS=","; printf '%s\n' "${config[*]}"),
+		        {
+		          "method": "bdev_wait_for_examine"
+		        }
 		      ]
 		    }
 		  ]
diff --git a/test/ocf/management/persistent-metadata.sh b/test/ocf/management/persistent-metadata.sh
index 6cecc9739..918e8e3bf 100755
--- a/test/ocf/management/persistent-metadata.sh
+++ b/test/ocf/management/persistent-metadata.sh
@@ -32,6 +32,16 @@ config+=(
 	)"
 )
 
+config+=(
+	"$(
+		cat <<- JSON
+			{
+			  "method": "bdev_wait_for_examine"
+			}
+		JSON
+	)"
+)
+
 # First ']}' closes our config and bdev subsystem blocks
 jq . <<- CONFIG > "$curdir/config"
 	{"subsystems":[
diff --git a/test/ocf/management/remove.sh b/test/ocf/management/remove.sh
index 1302f16cd..c06234080 100755
--- a/test/ocf/management/remove.sh
+++ b/test/ocf/management/remove.sh
@@ -31,6 +31,9 @@ jq . <<- JSON > "$curdir/config"
 	            "block_size": 512,
 	            "filename": "./aio1"
 	          }
+	        },
+	        {
+	          "method": "bdev_wait_for_examine"
 	        }
 	      ]
 	    }
diff --git a/test/vhost/shared/bdev.json b/test/vhost/shared/bdev.json
index ad28314a5..25945fdcf 100644
--- a/test/vhost/shared/bdev.json
+++ b/test/vhost/shared/bdev.json
@@ -13,6 +13,9 @@
             "name": "VirtioBlk0",
             "trtype": "user"
           }
+        },
+        {
+          "method": "bdev_wait_for_examine"
         }
       ]
     }
-- 
2.26.2


From 42c82595c39057f6c66495a4d26931ece3f0049c Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 8 Dec 2020 07:00:07 -0500
Subject: [PATCH 122/342] bdev/aio: respond to create RPC after bdev is
 examined

This makes use of newly added spdk_bdev_wait_for_examine(),
to only respond to RPC when bdev was fully examined.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: If82cd913ab6653e8cc0da38c639b384b6c0303ba
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/5482
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/bdev/aio/bdev_aio_rpc.c | 55 +++++++++++++++++++++++-----------
 1 file changed, 38 insertions(+), 17 deletions(-)

diff --git a/module/bdev/aio/bdev_aio_rpc.c b/module/bdev/aio/bdev_aio_rpc.c
index 035cded1c..da625c8fe 100644
--- a/module/bdev/aio/bdev_aio_rpc.c
+++ b/module/bdev/aio/bdev_aio_rpc.c
@@ -43,11 +43,17 @@ struct rpc_construct_aio {
 	uint32_t block_size;
 };
 
+struct rpc_construct_aio_ctx {
+	struct rpc_construct_aio req;
+	struct spdk_jsonrpc_request *request;
+};
+
 static void
-free_rpc_construct_aio(struct rpc_construct_aio *req)
+free_rpc_construct_aio(struct rpc_construct_aio_ctx *ctx)
 {
-	free(req->name);
-	free(req->filename);
+	free(ctx->req.name);
+	free(ctx->req.filename);
+	free(ctx);
 }
 
 static const struct spdk_json_object_decoder rpc_construct_aio_decoders[] = {
@@ -56,36 +62,51 @@ static const struct spdk_json_object_decoder rpc_construct_aio_decoders[] = {
 	{"block_size", offsetof(struct rpc_construct_aio, block_size), spdk_json_decode_uint32, true},
 };
 
+static void
+rpc_bdev_aio_create_cb(void *cb_arg)
+{
+	struct rpc_construct_aio_ctx *ctx = cb_arg;
+	struct spdk_jsonrpc_request *request = ctx->request;
+	struct spdk_json_write_ctx *w;
+
+	w = spdk_jsonrpc_begin_result(request);
+	spdk_json_write_string(w, ctx->req.name);
+	spdk_jsonrpc_end_result(request, w);
+	free_rpc_construct_aio(ctx);
+}
+
 static void
 rpc_bdev_aio_create(struct spdk_jsonrpc_request *request,
 		    const struct spdk_json_val *params)
 {
-	struct rpc_construct_aio req = {};
-	struct spdk_json_write_ctx *w;
-	int rc = 0;
+	struct rpc_construct_aio_ctx *ctx;
+	int rc;
+
+	ctx = calloc(1, sizeof(*ctx));
+	if (!ctx) {
+		spdk_jsonrpc_send_error_response(request, -ENOMEM, spdk_strerror(ENOMEM));
+		return;
+	}
 
 	if (spdk_json_decode_object(params, rpc_construct_aio_decoders,
 				    SPDK_COUNTOF(rpc_construct_aio_decoders),
-				    &req)) {
+				    &ctx->req)) {
 		SPDK_ERRLOG("spdk_json_decode_object failed\n");
 		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
 						 "spdk_json_decode_object failed");
-		goto cleanup;
+		free_rpc_construct_aio(ctx);
+		return;
 	}
 
-	rc = create_aio_bdev(req.name, req.filename, req.block_size);
+	ctx->request = request;
+	rc = create_aio_bdev(ctx->req.name, ctx->req.filename, ctx->req.block_size);
 	if (rc) {
 		spdk_jsonrpc_send_error_response(request, rc, spdk_strerror(-rc));
-		goto cleanup;
+		free_rpc_construct_aio(ctx);
+		return;
 	}
 
-
-	w = spdk_jsonrpc_begin_result(request);
-	spdk_json_write_string(w, req.name);
-	spdk_jsonrpc_end_result(request, w);
-
-cleanup:
-	free_rpc_construct_aio(&req);
+	spdk_bdev_wait_for_examine(rpc_bdev_aio_create_cb, ctx);
 }
 SPDK_RPC_REGISTER("bdev_aio_create", rpc_bdev_aio_create, SPDK_RPC_RUNTIME)
 SPDK_RPC_REGISTER_ALIAS_DEPRECATED(bdev_aio_create, construct_aio_bdev)
-- 
2.26.2


From 3c578739e96ed633ed728c19a0f1a65ce8c57310 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 12 May 2021 20:31:04 +0200
Subject: [PATCH 123/342] scripts/fio-wrapper: Make sure all nvme block devices
 exist

This is needed before we can start looking up attributes
of the block subsystem under sysfs. In some occasions they
may simply not exist yet at a given time.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I4261d17e92e02acec31b8affaccd0aa11c2b851e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7863
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/fio-wrapper | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/scripts/fio-wrapper b/scripts/fio-wrapper
index 34030c195..7eaafdb59 100755
--- a/scripts/fio-wrapper
+++ b/scripts/fio-wrapper
@@ -59,7 +59,11 @@ get_nvme() {
 			blocks+=("$nvme_sub/${nvme##*/}"n*)
 		done
 	done
-	printf '%s\n' "${blocks[@]##*/}"
+	blocks=("${blocks[@]##*/}")
+	if [[ -e $rootdir/scripts/sync_dev_uevents.sh ]]; then
+		"$rootdir/scripts/sync_dev_uevents.sh" block/disk "${blocks[@]}"
+	fi > /dev/null
+	printf '%s\n' "${blocks[@]}"
 }
 
 get_devices() {
-- 
2.26.2


From 3ebf25e020d30540c53559004f3bd01dfeb75763 Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Sat, 8 May 2021 14:04:32 +0300
Subject: [PATCH 124/342] test/unit/nvme: Use page size in
 nvme_pcie_qpair_construct_destroy

Some systems may have page size other than 4096 bytes

Change-Id: Id56bb1566fff480edbe1a293121fc7a68c74252a
Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7820
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 .../nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c    | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
index f1f4823fa..16ffdf996 100644
--- a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
@@ -106,6 +106,8 @@ test_nvme_pcie_qpair_construct_destroy(void)
 	struct nvme_pcie_ctrlr pctrlr = {};
 	struct spdk_nvme_cpl cpl[2] = {};
 	struct nvme_pcie_qpair *pqpair = NULL;
+	size_t page_align = sysconf(_SC_PAGESIZE);
+	uint64_t cmb_offset;
 	int rc;
 
 	opts.sq.paddr = 0xDEADBEEF;
@@ -119,7 +121,9 @@ test_nvme_pcie_qpair_construct_destroy(void)
 	pctrlr.cmb.bar_va = (void *)0xF9000000;
 	pctrlr.cmb.bar_pa = 0xF8000000;
 	pctrlr.cmb.current_offset = 0x10;
-	pctrlr.cmb.size = 1 << 16;
+	cmb_offset = pctrlr.cmb.current_offset;
+	/* Make sure that CMB size is big enough and includes page alignment */
+	pctrlr.cmb.size = (1 << 16) + page_align;
 	pctrlr.doorbell_base = (void *)0xF7000000;
 	pctrlr.doorbell_stride_u32 = 1;
 
@@ -143,12 +147,16 @@ test_nvme_pcie_qpair_construct_destroy(void)
 	CU_ASSERT(pqpair->max_completions_cap == 1);
 	CU_ASSERT(pqpair->sq_in_cmb == true);
 	CU_ASSERT(pqpair->cmd != NULL && pqpair->cmd != (void *)0xDCADBEEF);
-	CU_ASSERT(pqpair->cmd_bus_addr ==  0xF8001000);
+	CU_ASSERT(pqpair->cmd_bus_addr == (((pctrlr.cmb.bar_pa + cmb_offset) + page_align - 1) & ~
+					   (page_align - 1)));
 	CU_ASSERT(pqpair->sq_tdbl == (void *)0xF7000008);
 	CU_ASSERT(pqpair->cq_hdbl == (void *)0xF700000C);
 	CU_ASSERT(pqpair->flags.phase = 1);
 	CU_ASSERT(pqpair->tr != NULL);
 	CU_ASSERT(pqpair->tr == TAILQ_FIRST(&pqpair->free_tr));
+	CU_ASSERT(pctrlr.cmb.current_offset == (uintptr_t)pqpair->cmd + (pqpair->num_entries * sizeof(
+				struct spdk_nvme_cmd)) - (uintptr_t)pctrlr.cmb.bar_va);
+	cmb_offset = pctrlr.cmb.current_offset;
 	nvme_pcie_qpair_destroy(&pqpair->qpair);
 
 	/* Disable submission queue in controller memory buffer. */
-- 
2.26.2


From 6b372f419d0810ded0d3b863925714051a116838 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Mon, 10 May 2021 17:58:35 +0800
Subject: [PATCH 125/342] nvmf: fix heap corruption of Reservation Report
 command

We should use `ns->registrants` to count the number of registered
controllers(REGCTL) for Reservation Report command, as `subsystem->ctrlrs`
only list current active sessions(controllers).

Also use the output data buffer directly so that we don't need to calloc/free
during the process of Reservation Report command.

Fix #1928

Change-Id: I650224b751a08416208b8a504b82debff31e92fd
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7822
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: wanghailiang <hailiangx.e.wang@intel.com>
---
 lib/nvmf/subsystem.c | 36 ++++++++++++++----------------------
 1 file changed, 14 insertions(+), 22 deletions(-)

diff --git a/lib/nvmf/subsystem.c b/lib/nvmf/subsystem.c
index ee312719d..6f3b1f483 100644
--- a/lib/nvmf/subsystem.c
+++ b/lib/nvmf/subsystem.c
@@ -2677,13 +2677,11 @@ nvmf_ns_reservation_report(struct spdk_nvmf_ns *ns,
 			   struct spdk_nvmf_request *req)
 {
 	struct spdk_nvme_cmd *cmd = &req->cmd->nvme_cmd;
-	struct spdk_nvmf_subsystem *subsystem = ctrlr->subsys;
-	struct spdk_nvmf_ctrlr *ctrlr_tmp;
 	struct spdk_nvmf_registrant *reg, *tmp;
 	struct spdk_nvme_reservation_status_extended_data *status_data;
 	struct spdk_nvme_registered_ctrlr_extended_data *ctrlr_data;
 	uint8_t *payload;
-	uint32_t len, count = 0;
+	uint32_t transfer_len, payload_len = 0;
 	uint32_t regctl = 0;
 	uint8_t status = SPDK_NVME_SC_SUCCESS;
 
@@ -2701,19 +2699,11 @@ nvmf_ns_reservation_report(struct spdk_nvmf_ns *ns,
 		goto exit;
 	}
 
-	/* Get number of registerd controllers, one Host may have more than
-	 * one controller based on different ports.
-	 */
-	TAILQ_FOREACH(ctrlr_tmp, &subsystem->ctrlrs, link) {
-		reg = nvmf_ns_reservation_get_registrant(ns, &ctrlr_tmp->hostid);
-		if (reg) {
-			regctl++;
-		}
-	}
+	/* Number of Dwords of the Reservation Status data structure to transfer */
+	transfer_len = (cmd->cdw10 + 1) * sizeof(uint32_t);
+	payload = req->data;
 
-	len = sizeof(*status_data) + sizeof(*ctrlr_data) * regctl;
-	payload = calloc(1, len);
-	if (!payload) {
+	if (transfer_len < sizeof(struct spdk_nvme_reservation_status_extended_data)) {
 		status = SPDK_NVME_SC_INTERNAL_DEVICE_ERROR;
 		goto exit;
 	}
@@ -2721,23 +2711,25 @@ nvmf_ns_reservation_report(struct spdk_nvmf_ns *ns,
 	status_data = (struct spdk_nvme_reservation_status_extended_data *)payload;
 	status_data->data.gen = ns->gen;
 	status_data->data.rtype = ns->rtype;
-	status_data->data.regctl = regctl;
 	status_data->data.ptpls = ns->ptpl_activated;
+	payload_len += sizeof(struct spdk_nvme_reservation_status_extended_data);
 
 	TAILQ_FOREACH_SAFE(reg, &ns->registrants, link, tmp) {
-		assert(count <= regctl);
+		payload_len += sizeof(struct spdk_nvme_registered_ctrlr_extended_data);
+		if (payload_len > transfer_len) {
+			break;
+		}
+
 		ctrlr_data = (struct spdk_nvme_registered_ctrlr_extended_data *)
-			     (payload + sizeof(*status_data) + sizeof(*ctrlr_data) * count);
+			     (payload + sizeof(*status_data) + sizeof(*ctrlr_data) * regctl);
 		/* Set to 0xffffh for dynamic controller */
 		ctrlr_data->cntlid = 0xffff;
 		ctrlr_data->rcsts.status = (ns->holder == reg) ? true : false;
 		ctrlr_data->rkey = reg->rkey;
 		spdk_uuid_copy((struct spdk_uuid *)ctrlr_data->hostid, &reg->hostid);
-		count++;
+		regctl++;
 	}
-
-	memcpy(req->data, payload, spdk_min(len, (cmd->cdw10 + 1) * sizeof(uint32_t)));
-	free(payload);
+	status_data->data.regctl = regctl;
 
 exit:
 	req->rsp->nvme_cpl.status.sct = SPDK_NVME_SCT_GENERIC;
-- 
2.26.2


From 9442881ab9ef0e6386ab2a423656d01fbf076291 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 11 May 2021 19:33:22 +0800
Subject: [PATCH 126/342] accel_engine: Fix the coredump issue if no idxd
 engine is found.

The coredump info can be viewed in
https://github.com/spdk/spdk/issues/1935

We face this issue because no idxd device is attached, but we
still register the hw engine by spdk_accel_hw_engine_register
in accel_engine_idxd_init.

Fixes #1935

Change-Id: I537f06e2b2923faac7f2cd6a28903e77f1f6aaa5
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7832
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 module/accel/idxd/accel_engine_idxd.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/module/accel/idxd/accel_engine_idxd.c b/module/accel/idxd/accel_engine_idxd.c
index 64e7133c4..8df76eada 100644
--- a/module/accel/idxd/accel_engine_idxd.c
+++ b/module/accel/idxd/accel_engine_idxd.c
@@ -434,6 +434,11 @@ accel_engine_idxd_init(void)
 		return -EINVAL;
 	}
 
+	if (TAILQ_EMPTY(&g_idxd_devices)) {
+		SPDK_NOTICELOG("no available idxd devices\n");
+		return -EINVAL;
+	}
+
 	g_idxd_initialized = true;
 	g_batch_max = spdk_idxd_batch_get_max();
 	SPDK_NOTICELOG("Accel engine updated to use IDXD DSA engine.\n");
-- 
2.26.2


From 00c9dd58797ef2bdc3c86e6d809ad4811d878d7b Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 11 May 2021 21:14:33 +0800
Subject: [PATCH 127/342] accel_engine/ioat: If no ioat devices found, we
 should return.

If no ioat devices are registered, we should return.

Change-Id: I03435946716ef653b230515da32e8ccbdf5a188a
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7834
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 module/accel/ioat/accel_engine_ioat.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/module/accel/ioat/accel_engine_ioat.c b/module/accel/ioat/accel_engine_ioat.c
index 8d46dde27..2e50159c0 100644
--- a/module/accel/ioat/accel_engine_ioat.c
+++ b/module/accel/ioat/accel_engine_ioat.c
@@ -280,6 +280,11 @@ accel_engine_ioat_init(void)
 		return -1;
 	}
 
+	if (TAILQ_EMPTY(&g_devices)) {
+		SPDK_NOTICELOG("No available ioat devices\n");
+		return -1;
+	}
+
 	g_ioat_initialized = true;
 	SPDK_NOTICELOG("Accel engine updated to use IOAT engine.\n");
 	spdk_accel_hw_engine_register(&ioat_accel_engine);
-- 
2.26.2


From 8651ef29abbc81ab43e1b5668c26a05bf7234321 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Mon, 22 Mar 2021 11:59:30 +0100
Subject: [PATCH 128/342] autotest: Make sure entire EXIT trap is executed

process_core() indicates error where any core files are found. If
that happens to be the case when the trap is called, the remaining
pieces won't be executed due to errexit being enabled. With that
in mind, simply ignore process_core's exit status.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I83527468bd1b41bf92b9ee8189a4c425be914552
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6990
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autotest.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/autotest.sh b/autotest.sh
index 1b2f2f6cb..fccbfcb97 100755
--- a/autotest.sh
+++ b/autotest.sh
@@ -50,7 +50,7 @@ if [ $(uname -s) = Linux ]; then
 	fi
 fi
 
-trap "process_core; autotest_cleanup; exit 1" SIGINT SIGTERM EXIT
+trap "process_core || :; autotest_cleanup; exit 1" SIGINT SIGTERM EXIT
 
 timing_enter autotest
 
-- 
2.26.2


From 5f179d8bd121969a988d1b5a9f6f6104e11e3679 Mon Sep 17 00:00:00 2001
From: Jaylyn Ren <jaylyn.ren@arm.com>
Date: Fri, 16 Apr 2021 14:15:17 +0800
Subject: [PATCH 129/342] perf: Fix an error about perf cores usage

There is an error when collecting the cpu usage data in perf.c.

The cpu busy data exceeds 100% when running perf tool with mutli-cores.

Signed-off-by: Jaylyn Ren <jaylyn.ren@arm.com>
Change-Id: I9a00f86a51fb52e115c37199aee6f849b235d868
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7431
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 examples/nvme/perf/perf.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/examples/nvme/perf/perf.c b/examples/nvme/perf/perf.c
index 844d6908f..e38ee8f06 100644
--- a/examples/nvme/perf/perf.c
+++ b/examples/nvme/perf/perf.c
@@ -1527,13 +1527,13 @@ print_periodic_performance(bool warmup)
 		if (g_monitor_perf_cores) {
 			core_busy_tsc += busy_tsc;
 			core_idle_tsc += idle_tsc;
-			core_busy_perc += (double)core_busy_tsc / (core_idle_tsc + core_busy_tsc) * 100;
 		}
 	}
 	mb_this_second = (double)io_this_second * g_io_size_bytes / (1024 * 1024);
 
 	printf("%s%9ju IOPS, %8.2f MiB/s", warmup ? "[warmup] " : "", io_this_second, mb_this_second);
 	if (g_monitor_perf_cores) {
+		core_busy_perc = (double)core_busy_tsc / (core_idle_tsc + core_busy_tsc) * 100;
 		printf("%3d Core(s): %6.2f%% Busy", g_num_workers, core_busy_perc);
 	}
 	printf("\r");
-- 
2.26.2


From 7a12f4812d9a922e5c331b61d19708402fba33b2 Mon Sep 17 00:00:00 2001
From: Krishna Kanth Reddy <krish.reddy@samsung.com>
Date: Fri, 30 Apr 2021 14:29:32 +0530
Subject: [PATCH 130/342] lib/nvme: Add support for Simple Copy Command

Signed-off-by: Krishna Kanth Reddy <krish.reddy@samsung.com>
Change-Id: I7aae5abca6ba5621e99fd604d146d84401eb45cd
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7694
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 CHANGELOG.md           |  4 ++++
 include/spdk/nvme.h    | 34 ++++++++++++++++++++++++++++++++++
 lib/nvme/Makefile      |  2 +-
 lib/nvme/nvme_ns_cmd.c | 34 ++++++++++++++++++++++++++++++++++
 lib/nvme/spdk_nvme.map |  1 +
 5 files changed, 74 insertions(+), 1 deletion(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 13aa1d56a..57c6b8a85 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,6 +11,10 @@ of spdk_idxd_probe_cb function pointer. It should be implemented in idxd_user.c.
 
 Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the controller ID range.
 
+### nvme
+
+Added a new function `spdk_nvme_ns_cmd_copy` to submit a Simple Copy Command to a Namespace.
+
 ## v21.04:
 
 ### accel
diff --git a/include/spdk/nvme.h b/include/spdk/nvme.h
index f5a8f73c9..372352986 100644
--- a/include/spdk/nvme.h
+++ b/include/spdk/nvme.h
@@ -3062,6 +3062,40 @@ int spdk_nvme_ns_cmd_dataset_management(struct spdk_nvme_ns *ns, struct spdk_nvm
 					spdk_nvme_cmd_cb cb_fn,
 					void *cb_arg);
 
+/**
+ * Submit a simple copy command request to the specified NVMe namespace.
+ *
+ * The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
+ * The user must ensure that only one thread submits I/O on a given qpair at any
+ * given time.
+ *
+ * This is a convenience wrapper that will automatically allocate and construct
+ * the correct data buffers. Therefore, ranges does not need to be allocated from
+ * pinned memory and can be placed on the stack. If a higher performance, zero-copy
+ * version of SCC is required, simply build and submit a raw command using
+ * spdk_nvme_ctrlr_cmd_io_raw().
+ *
+ * \param ns NVMe namespace to submit the SCC request
+ * \param qpair I/O queue pair to submit the request
+ * \param ranges An array of \ref spdk_nvme_scc_source_range elements describing the LBAs
+ * to operate on.
+ * \param num_ranges The number of elements in the ranges array.
+ * \param dest_lba Destination LBA to copy the data.
+ * \param cb_fn Callback function to invoke when the I/O is completed
+ * \param cb_arg Argument to pass to the callback function
+ *
+ * \return 0 if successfully submitted, negated errnos on the following error conditions:
+ * -ENOMEM: The request cannot be allocated.
+ * -EINVAL: Invalid ranges.
+ * -ENXIO: The qpair is failed at the transport level.
+ */
+int spdk_nvme_ns_cmd_copy(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
+			  const struct spdk_nvme_scc_source_range *ranges,
+			  uint16_t num_ranges,
+			  uint64_t dest_lba,
+			  spdk_nvme_cmd_cb cb_fn,
+			  void *cb_arg);
+
 /**
  * Submit a flush request to the specified NVMe namespace.
  *
diff --git a/lib/nvme/Makefile b/lib/nvme/Makefile
index 65a494b34..f722ea56d 100644
--- a/lib/nvme/Makefile
+++ b/lib/nvme/Makefile
@@ -35,7 +35,7 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 SO_VER := 5
-SO_MINOR := 0
+SO_MINOR := 1
 
 C_SRCS = nvme_ctrlr_cmd.c nvme_ctrlr.c nvme_fabric.c nvme_ns_cmd.c nvme_ns.c nvme_pcie_common.c nvme_pcie.c nvme_qpair.c nvme.c nvme_quirks.c nvme_transport.c \
 	nvme_ctrlr_ocssd_cmd.c nvme_ns_ocssd_cmd.c nvme_tcp.c nvme_opal.c nvme_io_msg.c nvme_poll_group.c nvme_zns.c
diff --git a/lib/nvme/nvme_ns_cmd.c b/lib/nvme/nvme_ns_cmd.c
index 1f03d761a..7904f6d12 100644
--- a/lib/nvme/nvme_ns_cmd.c
+++ b/lib/nvme/nvme_ns_cmd.c
@@ -1091,6 +1091,40 @@ spdk_nvme_ns_cmd_dataset_management(struct spdk_nvme_ns *ns, struct spdk_nvme_qp
 	return nvme_qpair_submit_request(qpair, req);
 }
 
+int
+spdk_nvme_ns_cmd_copy(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
+		      const struct spdk_nvme_scc_source_range *ranges,
+		      uint16_t num_ranges, uint64_t dest_lba,
+		      spdk_nvme_cmd_cb cb_fn, void *cb_arg)
+{
+	struct nvme_request	*req;
+	struct spdk_nvme_cmd	*cmd;
+
+	if (num_ranges == 0) {
+		return -EINVAL;
+	}
+
+	if (ranges == NULL) {
+		return -EINVAL;
+	}
+
+	req = nvme_allocate_request_user_copy(qpair, (void *)ranges,
+					      num_ranges * sizeof(struct spdk_nvme_scc_source_range),
+					      cb_fn, cb_arg, true);
+	if (req == NULL) {
+		return -ENOMEM;
+	}
+
+	cmd = &req->cmd;
+	cmd->opc = SPDK_NVME_OPC_COPY;
+	cmd->nsid = ns->id;
+
+	*(uint64_t *)&cmd->cdw10 = dest_lba;
+	cmd->cdw12 = num_ranges - 1;
+
+	return nvme_qpair_submit_request(qpair, req);
+}
+
 int
 spdk_nvme_ns_cmd_flush(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		       spdk_nvme_cmd_cb cb_fn, void *cb_arg)
diff --git a/lib/nvme/spdk_nvme.map b/lib/nvme/spdk_nvme.map
index f9d95dba2..d54dd091b 100644
--- a/lib/nvme/spdk_nvme.map
+++ b/lib/nvme/spdk_nvme.map
@@ -139,6 +139,7 @@
 	spdk_nvme_ns_cmd_readv_with_md;
 	spdk_nvme_ns_cmd_read_with_md;
 	spdk_nvme_ns_cmd_dataset_management;
+	spdk_nvme_ns_cmd_copy;
 	spdk_nvme_ns_cmd_flush;
 	spdk_nvme_ns_cmd_reservation_register;
 	spdk_nvme_ns_cmd_reservation_release;
-- 
2.26.2


From f795dd6e6601b98b5ce4788a89150d1fc20dad32 Mon Sep 17 00:00:00 2001
From: Krishna Kanth Reddy <krish.reddy@samsung.com>
Date: Fri, 30 Apr 2021 14:55:13 +0530
Subject: [PATCH 131/342] test/unit: Add unit test for Simple Copy Command

Signed-off-by: Krishna Kanth Reddy <krish.reddy@samsung.com>
Change-Id: Ia43f5d0588133027e80dc5707fd5940c44605c68
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7695
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 .../lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c   | 54 +++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c b/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c
index 0b40d3779..7c85e4438 100644
--- a/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c
+++ b/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c
@@ -694,6 +694,59 @@ test_nvme_ns_cmd_dataset_management(void)
 	cleanup_after_test(&qpair);
 }
 
+static void
+test_nvme_ns_cmd_copy(void)
+{
+	struct spdk_nvme_ns	ns;
+	struct spdk_nvme_ctrlr	ctrlr;
+	struct spdk_nvme_qpair	qpair;
+	spdk_nvme_cmd_cb	cb_fn = NULL;
+	void			*cb_arg = NULL;
+	uint16_t		i;
+	int			rc = 0;
+	uint64_t		cmd_dest_lba;
+	uint32_t		cmd_range_count;
+	struct spdk_nvme_scc_source_range	ranges[64];
+
+	prepare_for_test(&ns, &ctrlr, &qpair, 512, 0, 128 * 1024, 0, false);
+
+	for (i = 0; i < 64; i++) {
+		ranges[i].slba = i;
+		ranges[i].nlb = 1;
+	}
+
+	/* COPY one LBA */
+	rc = spdk_nvme_ns_cmd_copy(&ns, &qpair, ranges,
+				   1, 64, cb_fn, cb_arg);
+	CU_ASSERT(rc == 0);
+	SPDK_CU_ASSERT_FATAL(g_request != NULL);
+	CU_ASSERT(g_request->cmd.opc == SPDK_NVME_OPC_COPY);
+	CU_ASSERT(g_request->cmd.nsid == ns.id);
+	nvme_cmd_interpret_rw(&g_request->cmd, &cmd_dest_lba, &cmd_range_count);
+	CU_ASSERT_EQUAL(cmd_dest_lba, 64);
+	CU_ASSERT_EQUAL(cmd_range_count, 1);
+	spdk_free(g_request->payload.contig_or_cb_arg);
+	nvme_free_request(g_request);
+
+	/* COPY 64 LBAs */
+	rc = spdk_nvme_ns_cmd_copy(&ns, &qpair, ranges,
+				   64, 64, cb_fn, cb_arg);
+	CU_ASSERT(rc == 0);
+	SPDK_CU_ASSERT_FATAL(g_request != NULL);
+	CU_ASSERT(g_request->cmd.opc == SPDK_NVME_OPC_COPY);
+	CU_ASSERT(g_request->cmd.nsid == ns.id);
+	nvme_cmd_interpret_rw(&g_request->cmd, &cmd_dest_lba, &cmd_range_count);
+	CU_ASSERT_EQUAL(cmd_dest_lba, 64);
+	CU_ASSERT_EQUAL(cmd_range_count, 64);
+	spdk_free(g_request->payload.contig_or_cb_arg);
+	nvme_free_request(g_request);
+
+	rc = spdk_nvme_ns_cmd_copy(&ns, &qpair, ranges,
+				   0, 64, cb_fn, cb_arg);
+	CU_ASSERT(rc != 0);
+	cleanup_after_test(&qpair);
+}
+
 static void
 test_nvme_ns_cmd_readv(void)
 {
@@ -1988,6 +2041,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, split_test4);
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_flush);
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_dataset_management);
+	CU_ADD_TEST(suite, test_nvme_ns_cmd_copy);
 	CU_ADD_TEST(suite, test_io_flags);
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_write_zeroes);
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_write_uncorrectable);
-- 
2.26.2


From 938cc7d959f8815a8f0730a13188db96b60a50bd Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Fri, 23 Apr 2021 20:34:21 +0800
Subject: [PATCH 132/342] bdev/iscsi: use req data structure as the input
 parameter

Change-Id: I70bf01fdb812044e172c4e022819bebd1e865e54
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7572
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 module/bdev/iscsi/bdev_iscsi.c | 23 ++++++++++-------------
 1 file changed, 10 insertions(+), 13 deletions(-)

diff --git a/module/bdev/iscsi/bdev_iscsi.c b/module/bdev/iscsi/bdev_iscsi.c
index edb537345..f5e47da05 100644
--- a/module/bdev/iscsi/bdev_iscsi.c
+++ b/module/bdev/iscsi/bdev_iscsi.c
@@ -621,10 +621,8 @@ static const struct spdk_bdev_fn_table iscsi_fn_table = {
 };
 
 static int
-create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *initiator_iqn,
-		 char *name,
-		 uint64_t num_blocks, uint32_t block_size, struct spdk_bdev **bdev, bool unmap_supported,
-		 uint8_t lbppbe)
+create_iscsi_lun(struct bdev_iscsi_conn_req *req, uint64_t num_blocks,
+		 uint32_t block_size, struct spdk_bdev **bdev, uint8_t lbppbe)
 {
 	struct bdev_iscsi_lun *lun;
 	int rc;
@@ -635,27 +633,27 @@ create_iscsi_lun(struct iscsi_context *context, int lun_id, char *url, char *ini
 		return -ENOMEM;
 	}
 
-	lun->context = context;
-	lun->lun_id = lun_id;
-	lun->url = url;
-	lun->initiator_iqn = initiator_iqn;
+	lun->context = req->context;
+	lun->lun_id = req->lun;
+	lun->url = req->url;
+	lun->initiator_iqn = req->initiator_iqn;
 
 	pthread_mutex_init(&lun->mutex, NULL);
 
-	lun->bdev.name = name;
+	lun->bdev.name = req->bdev_name;
 	lun->bdev.product_name = "iSCSI LUN";
 	lun->bdev.module = &g_iscsi_bdev_module;
 	lun->bdev.blocklen = block_size;
 	lun->bdev.phys_blocklen = block_size * (1 << lbppbe);
 	lun->bdev.blockcnt = num_blocks;
 	lun->bdev.ctxt = lun;
-	lun->unmap_supported = unmap_supported;
+	lun->unmap_supported = req->unmap_supported;
 
 	lun->bdev.fn_table = &iscsi_fn_table;
 
 	spdk_io_device_register(lun, bdev_iscsi_create_cb, bdev_iscsi_destroy_cb,
 				sizeof(struct bdev_iscsi_io_channel),
-				name);
+				req->bdev_name);
 	rc = spdk_bdev_register(&lun->bdev);
 	if (rc) {
 		spdk_io_device_unregister(lun, NULL);
@@ -692,8 +690,7 @@ iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,
 		goto ret;
 	}
 
-	status = create_iscsi_lun(req->context, req->lun, req->url, req->initiator_iqn, req->bdev_name,
-				  readcap16->returned_lba + 1, readcap16->block_length, &bdev, req->unmap_supported,
+	status = create_iscsi_lun(req, readcap16->returned_lba + 1, readcap16->block_length, &bdev,
 				  readcap16->lbppbe);
 	if (status) {
 		SPDK_ERRLOG("Unable to create iscsi bdev: %s (%d)\n", spdk_strerror(-status), status);
-- 
2.26.2


From 2594e757e5eb661b7bd33cb50fd2ecc97d4ef95c Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 20 Apr 2021 20:22:04 +0800
Subject: [PATCH 133/342] bdev/iscsi: save Block limits VPD unmap settings

Also free scsi_task data structure for the asynchronous
libiscsi APIs.

Change-Id: I0bff706bfb795e51a4b10c357913ae66493dca5d
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7513
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 module/bdev/iscsi/bdev_iscsi.c | 51 ++++++++++++++++++++++++++++++++--
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/module/bdev/iscsi/bdev_iscsi.c b/module/bdev/iscsi/bdev_iscsi.c
index f5e47da05..e12095d7b 100644
--- a/module/bdev/iscsi/bdev_iscsi.c
+++ b/module/bdev/iscsi/bdev_iscsi.c
@@ -58,6 +58,12 @@ struct bdev_iscsi_lun;
 
 #define DEFAULT_INITIATOR_NAME "iqn.2016-06.io.spdk:init"
 
+/* MAXIMUM UNMAP LBA COUNT:
+ * indicates the maximum  number of LBAs that may be unmapped
+ * by an UNMAP command.
+ */
+#define BDEV_ISCSI_DEFAULT_MAX_UNMAP_LBA_COUNT (32768)
+
 static int bdev_iscsi_initialize(void);
 static TAILQ_HEAD(, bdev_iscsi_conn_req) g_iscsi_conn_req = TAILQ_HEAD_INITIALIZER(
 			g_iscsi_conn_req);
@@ -99,6 +105,7 @@ struct bdev_iscsi_conn_req {
 	spdk_bdev_iscsi_create_cb		create_cb;
 	void					*create_cb_arg;
 	bool					unmap_supported;
+	uint32_t				max_unmap;
 	int					lun;
 	int					status;
 	TAILQ_ENTRY(bdev_iscsi_conn_req)	link;
@@ -702,7 +709,37 @@ ret:
 }
 
 static void
-bdev_iscsi_inquiry_cb(struct iscsi_context *context, int status, void *_task, void *private_data)
+bdev_iscsi_inquiry_bl_cb(struct iscsi_context *context, int status, void *_task, void *private_data)
+{
+	struct scsi_task *task = _task;
+	struct scsi_inquiry_block_limits *bl_inq = NULL;
+	struct bdev_iscsi_conn_req *req = private_data;
+
+	if (status == SPDK_SCSI_STATUS_GOOD) {
+		bl_inq = scsi_datain_unmarshall(task);
+		if (bl_inq != NULL) {
+			if (!bl_inq->max_unmap) {
+				SPDK_ERRLOG("Invalid max_unmap, use the default\n");
+				req->max_unmap = BDEV_ISCSI_DEFAULT_MAX_UNMAP_LBA_COUNT;
+			} else {
+				req->max_unmap = bl_inq->max_unmap;
+			}
+		}
+	}
+
+	scsi_free_scsi_task(task);
+	task = iscsi_readcapacity16_task(context, req->lun, iscsi_readcapacity16_cb, req);
+	if (task) {
+		return;
+	}
+
+	SPDK_ERRLOG("iSCSI error: %s\n", iscsi_get_error(req->context));
+	complete_conn_req(req, NULL, status);
+}
+
+static void
+bdev_iscsi_inquiry_lbp_cb(struct iscsi_context *context, int status, void *_task,
+			  void *private_data)
 {
 	struct scsi_task *task = _task;
 	struct scsi_inquiry_logical_block_provisioning *lbp_inq = NULL;
@@ -712,7 +749,17 @@ bdev_iscsi_inquiry_cb(struct iscsi_context *context, int status, void *_task, vo
 		lbp_inq = scsi_datain_unmarshall(task);
 		if (lbp_inq != NULL && lbp_inq->lbpu) {
 			req->unmap_supported = true;
+			scsi_free_scsi_task(task);
+
+			task = iscsi_inquiry_task(context, req->lun, 1,
+						  SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS,
+						  255, bdev_iscsi_inquiry_bl_cb, req);
+			if (task) {
+				return;
+			}
 		}
+	} else {
+		scsi_free_scsi_task(task);
 	}
 
 	task = iscsi_readcapacity16_task(context, req->lun, iscsi_readcapacity16_cb, req);
@@ -737,7 +784,7 @@ iscsi_connect_cb(struct iscsi_context *iscsi, int status,
 
 	task = iscsi_inquiry_task(iscsi, req->lun, 1,
 				  SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING,
-				  255, bdev_iscsi_inquiry_cb, req);
+				  255, bdev_iscsi_inquiry_lbp_cb, req);
 	if (task) {
 		return;
 	}
-- 
2.26.2


From b885e23b951e939cc0c805c34771f97e9db64ef0 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Wed, 21 Apr 2021 17:59:33 +0800
Subject: [PATCH 134/342] bdev/iscsi: apply max_unmap and max_unmap_segments to
 bdev layer

The bdev layer can do the unmap split now based on the backend
device.  For now we only use 1 unmap descriptor, the bdev layer
can help us to do the split.

Fix issue #1888

Change-Id: Iaf740bafd4f2bb4b108133fee2aafd2f53da9b2b
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7519
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 module/bdev/iscsi/bdev_iscsi.c | 53 +++++++++++++++++++++++++++++-----
 1 file changed, 45 insertions(+), 8 deletions(-)

diff --git a/module/bdev/iscsi/bdev_iscsi.c b/module/bdev/iscsi/bdev_iscsi.c
index e12095d7b..c811d65b6 100644
--- a/module/bdev/iscsi/bdev_iscsi.c
+++ b/module/bdev/iscsi/bdev_iscsi.c
@@ -64,6 +64,13 @@ struct bdev_iscsi_lun;
  */
 #define BDEV_ISCSI_DEFAULT_MAX_UNMAP_LBA_COUNT (32768)
 
+/* MAXIMUM UNMAP BLOCK DESCRIPTOR COUNT:
+ * indicates the maximum number of UNMAP block descriptors that
+ * shall be contained in the parameter data transferred to the
+ * device server for an UNMAP command.
+ */
+#define BDEV_ISCSI_MAX_UNMAP_BLOCK_DESCS_COUNT (1)
+
 static int bdev_iscsi_initialize(void);
 static TAILQ_HEAD(, bdev_iscsi_conn_req) g_iscsi_conn_req = TAILQ_HEAD_INITIALIZER(
 			g_iscsi_conn_req);
@@ -90,6 +97,7 @@ struct bdev_iscsi_lun {
 	struct spdk_poller		*no_main_ch_poller;
 	struct spdk_thread		*no_main_ch_poller_td;
 	bool				unmap_supported;
+	uint32_t			max_unmap;
 	struct spdk_poller		*poller;
 };
 
@@ -319,17 +327,41 @@ bdev_iscsi_unmap(struct bdev_iscsi_lun *lun, struct bdev_iscsi_io *iscsi_io,
 		 uint64_t lba, uint64_t num_blocks)
 {
 	struct scsi_task *task;
-	struct unmap_list list[1];
-
-	list[0].lba = lba;
-	list[0].num = num_blocks;
-	task = iscsi_unmap_task(lun->context, 0, 0, 0, list, 1,
+	struct unmap_list list[BDEV_ISCSI_MAX_UNMAP_BLOCK_DESCS_COUNT] = {};
+	struct unmap_list *entry;
+	uint32_t num_unmap_list;
+	uint64_t offset, remaining, unmap_blocks;
+
+	num_unmap_list = spdk_divide_round_up(num_blocks, lun->max_unmap);
+	if (num_unmap_list > BDEV_ISCSI_MAX_UNMAP_BLOCK_DESCS_COUNT) {
+		SPDK_ERRLOG("Too many unmap entries\n");
+		goto failed;
+	}
+
+	remaining = num_blocks;
+	offset = lba;
+	num_unmap_list = 0;
+	entry = &list[0];
+
+	do {
+		unmap_blocks = spdk_min(remaining, lun->max_unmap);
+		entry->lba = offset;
+		entry->num = unmap_blocks;
+		num_unmap_list++;
+		remaining -= unmap_blocks;
+		offset += unmap_blocks;
+		entry++;
+	} while (remaining > 0);
+
+	task = iscsi_unmap_task(lun->context, 0, 0, 0, list, num_unmap_list,
 				bdev_iscsi_command_cb, iscsi_io);
-	if (task == NULL) {
-		SPDK_ERRLOG("failed to get unmap_task\n");
-		bdev_iscsi_io_complete(iscsi_io, SPDK_BDEV_IO_STATUS_FAILED);
+	if (task != NULL) {
 		return;
 	}
+	SPDK_ERRLOG("failed to get unmap_task\n");
+
+failed:
+	bdev_iscsi_io_complete(iscsi_io, SPDK_BDEV_IO_STATUS_FAILED);
 }
 
 static void
@@ -655,6 +687,11 @@ create_iscsi_lun(struct bdev_iscsi_conn_req *req, uint64_t num_blocks,
 	lun->bdev.blockcnt = num_blocks;
 	lun->bdev.ctxt = lun;
 	lun->unmap_supported = req->unmap_supported;
+	if (lun->unmap_supported) {
+		lun->max_unmap = req->max_unmap;
+		lun->bdev.max_unmap = req->max_unmap;
+		lun->bdev.max_unmap_segments = BDEV_ISCSI_MAX_UNMAP_BLOCK_DESCS_COUNT;
+	}
 
 	lun->bdev.fn_table = &iscsi_fn_table;
 
-- 
2.26.2


From 64a9432c00cad41f038239990e6a8ef74a9dd156 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Wed, 5 May 2021 21:03:45 -0700
Subject: [PATCH 135/342] nvmf/tcp: Don't attempt to offload header digest
 calculations

The header is small enough that it likely won't ever make sense
to offload the digest computation.

Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Change-Id: Ib6baa201a76d769d978f498f5c65985d5ab06ffd
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7766
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/nvmf/tcp.c | 25 +++++--------------------
 1 file changed, 5 insertions(+), 20 deletions(-)

diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index 506c7de29..8409f38b3 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -885,22 +885,6 @@ pdu_data_crc32_compute(struct nvme_tcp_pdu *pdu)
 	_tcp_write_pdu(pdu);
 }
 
-static void
-header_crc32_accel_done(void *cb_arg, int status)
-{
-	struct nvme_tcp_pdu *pdu = cb_arg;
-
-	pdu->header_digest_crc32 ^= SPDK_CRC32C_XOR;
-	MAKE_DIGEST_WORD((uint8_t *)pdu->hdr.raw + pdu->hdr.common.hlen, pdu->header_digest_crc32);
-	if (spdk_unlikely(status)) {
-		SPDK_ERRLOG("Failed to compute header digest on pdu=%p\n", pdu);
-		_pdu_write_done(pdu, status);
-		return;
-	}
-
-	pdu_data_crc32_compute(pdu);
-}
-
 static void
 nvmf_tcp_qpair_write_pdu(struct spdk_nvmf_tcp_qpair *tqpair,
 			 struct nvme_tcp_pdu *pdu,
@@ -908,6 +892,7 @@ nvmf_tcp_qpair_write_pdu(struct spdk_nvmf_tcp_qpair *tqpair,
 			 void *cb_arg)
 {
 	int hlen;
+	uint32_t crc32c;
 
 	assert(tqpair->pdu_in_progress != pdu);
 
@@ -919,12 +904,12 @@ nvmf_tcp_qpair_write_pdu(struct spdk_nvmf_tcp_qpair *tqpair,
 	pdu->iov[0].iov_len = hlen;
 
 	/* Header Digest */
-	if (g_nvme_tcp_hdgst[pdu->hdr.common.pdu_type] && tqpair->host_hdgst_enable && tqpair->group) {
-		spdk_accel_submit_crc32cv(tqpair->group->accel_channel, &pdu->header_digest_crc32,
-					  pdu->iov, 1, 0, header_crc32_accel_done, pdu);
-		return;
+	if (g_nvme_tcp_hdgst[pdu->hdr.common.pdu_type] && tqpair->host_hdgst_enable) {
+		crc32c = nvme_tcp_pdu_calc_header_digest(pdu);
+		MAKE_DIGEST_WORD((uint8_t *)pdu->hdr.raw + hlen, crc32c);
 	}
 
+	/* Data Digest */
 	pdu_data_crc32_compute(pdu);
 }
 
-- 
2.26.2


From 4642d7b264c0debf72fbbfdacce4f8eca81f348b Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Tue, 6 Apr 2021 19:40:30 +0300
Subject: [PATCH 136/342] nvmf/rdma: Embed fill_wr_sge into fill_wr_sgl

This patch reduces admount of changes in the next patch,
no functional changes added.
The next patch will add usage of contig IO buffers for
multi SGL payload. To support it we need to pass an
offset to fill_wr_sgl function. Also in the current
version we assume that for 1 iteration we fill 1 IO
buffer, the next patch will change it and we'll need
to swtich to the next IO buffer in special case. That
can't be done easily if we use fill_wr_sge function

Change-Id: Iee8209634637697f700f8fa9fe61ead156b6d622
Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7258
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvmf/rdma.c | 147 ++++++++++++++++++++++--------------------------
 1 file changed, 66 insertions(+), 81 deletions(-)

diff --git a/lib/nvmf/rdma.c b/lib/nvmf/rdma.c
index 199db50cd..25bd02c0a 100644
--- a/lib/nvmf/rdma.c
+++ b/lib/nvmf/rdma.c
@@ -1432,91 +1432,22 @@ nvmf_rdma_update_remote_addr(struct spdk_nvmf_rdma_request *rdma_req, uint32_t n
 	}
 }
 
-static bool
-nvmf_rdma_fill_wr_sge(struct spdk_nvmf_rdma_device *device,
-		      struct iovec *iov, struct ibv_send_wr **_wr,
-		      uint32_t *_remaining_data_block, uint32_t *_offset,
-		      uint32_t *_num_extra_wrs,
-		      const struct spdk_dif_ctx *dif_ctx)
-{
-	struct ibv_send_wr *wr = *_wr;
-	struct ibv_sge	*sg_ele = &wr->sg_list[wr->num_sge];
-	struct spdk_rdma_memory_translation mem_translation;
-	int		rc;
-	uint32_t	lkey = 0;
-	uint32_t	remaining, data_block_size, md_size, sge_len;
-
-	rc = spdk_rdma_get_translation(device->map, iov->iov_base, iov->iov_len, &mem_translation);
-	if (spdk_unlikely(rc)) {
-		return false;
-	}
-
-	lkey = spdk_rdma_memory_translation_get_lkey(&mem_translation);
-
-	if (spdk_likely(!dif_ctx)) {
-		sg_ele->lkey = lkey;
-		sg_ele->addr = (uintptr_t)(iov->iov_base);
-		sg_ele->length = iov->iov_len;
-		wr->num_sge++;
-	} else {
-		remaining = iov->iov_len - *_offset;
-		data_block_size = dif_ctx->block_size - dif_ctx->md_size;
-		md_size = dif_ctx->md_size;
-
-		while (remaining) {
-			if (wr->num_sge >= SPDK_NVMF_MAX_SGL_ENTRIES) {
-				if (*_num_extra_wrs > 0 && wr->next) {
-					*_wr = wr->next;
-					wr = *_wr;
-					wr->num_sge = 0;
-					sg_ele = &wr->sg_list[wr->num_sge];
-					(*_num_extra_wrs)--;
-				} else {
-					break;
-				}
-			}
-			sg_ele->lkey = lkey;
-			sg_ele->addr = (uintptr_t)((char *)iov->iov_base + *_offset);
-			sge_len = spdk_min(remaining, *_remaining_data_block);
-			sg_ele->length = sge_len;
-			remaining -= sge_len;
-			*_remaining_data_block -= sge_len;
-			*_offset += sge_len;
-
-			sg_ele++;
-			wr->num_sge++;
-
-			if (*_remaining_data_block == 0) {
-				/* skip metadata */
-				*_offset += md_size;
-				/* Metadata that do not fit this IO buffer will be included in the next IO buffer */
-				remaining -= spdk_min(remaining, md_size);
-				*_remaining_data_block = data_block_size;
-			}
-
-			if (remaining == 0) {
-				/* By subtracting the size of the last IOV from the offset, we ensure that we skip
-				   the remaining metadata bits at the beginning of the next buffer */
-				*_offset -= iov->iov_len;
-			}
-		}
-	}
-
-	return true;
-}
-
 static int
 nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 		      struct spdk_nvmf_rdma_device *device,
 		      struct spdk_nvmf_rdma_request *rdma_req,
 		      struct ibv_send_wr *wr,
-		      uint32_t length,
+		      uint32_t total_length,
 		      uint32_t num_extra_wrs)
 {
 	struct spdk_nvmf_request *req = &rdma_req->req;
+	struct spdk_rdma_memory_translation mem_translation;
 	struct spdk_dif_ctx *dif_ctx = NULL;
+	struct ibv_sge	*sg_ele;
+	struct iovec *iov;
 	uint32_t remaining_data_block = 0;
-	uint32_t offset = 0;
+	uint32_t offset = 0, lkey, remaining;
+	int rc;
 
 	if (spdk_unlikely(rdma_req->req.dif.dif_insert_or_strip)) {
 		dif_ctx = &rdma_req->req.dif.dif_ctx;
@@ -1525,17 +1456,71 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 
 	wr->num_sge = 0;
 
-	while (length && (num_extra_wrs || wr->num_sge < SPDK_NVMF_MAX_SGL_ENTRIES)) {
-		if (spdk_unlikely(!nvmf_rdma_fill_wr_sge(device, &req->iov[rdma_req->iovpos], &wr,
-				  &remaining_data_block, &offset, &num_extra_wrs, dif_ctx))) {
-			return -EINVAL;
+	while (total_length && (num_extra_wrs || wr->num_sge < SPDK_NVMF_MAX_SGL_ENTRIES)) {
+		iov = &req->iov[rdma_req->iovpos];
+		rc = spdk_rdma_get_translation(device->map, iov->iov_base, iov->iov_len, &mem_translation);
+		if (spdk_unlikely(rc)) {
+			return false;
+		}
+
+		lkey = spdk_rdma_memory_translation_get_lkey(&mem_translation);
+		sg_ele = &wr->sg_list[wr->num_sge];
+
+		if (spdk_likely(!dif_ctx)) {
+			sg_ele->lkey = lkey;
+			sg_ele->addr = (uintptr_t)(iov->iov_base);
+			sg_ele->length = (uint32_t)iov->iov_len;
+			wr->num_sge++;
+		} else {
+			uint32_t data_block_size = dif_ctx->block_size - dif_ctx->md_size;
+			uint32_t md_size = dif_ctx->md_size;
+			uint32_t sge_len;
+
+			remaining = (uint32_t)iov->iov_len - offset;
+
+			while (remaining) {
+				if (wr->num_sge >= SPDK_NVMF_MAX_SGL_ENTRIES) {
+					if (num_extra_wrs > 0 && wr->next) {
+						wr = wr->next;
+						wr->num_sge = 0;
+						sg_ele = &wr->sg_list[wr->num_sge];
+						num_extra_wrs--;
+					} else {
+						break;
+					}
+				}
+				sg_ele->lkey = lkey;
+				sg_ele->addr = (uintptr_t)((char *)iov->iov_base + offset);
+				sge_len = spdk_min(remaining, remaining_data_block);
+				sg_ele->length = sge_len;
+				remaining -= sge_len;
+				remaining_data_block -= sge_len;
+				offset += sge_len;
+
+				sg_ele++;
+				wr->num_sge++;
+
+				if (remaining_data_block == 0) {
+					/* skip metadata */
+					offset += md_size;
+					/* Metadata that do not fit this IO buffer will be included in the next IO buffer */
+					remaining -= spdk_min(remaining, md_size);
+					remaining_data_block = data_block_size;
+				}
+
+				if (remaining == 0) {
+					/* By subtracting the size of the last IOV from the offset, we ensure that we skip
+					   the remaining metadata bits at the beginning of the next buffer */
+					offset -= iov->iov_len;
+				}
+			}
 		}
 
-		length -= req->iov[rdma_req->iovpos].iov_len;
+		total_length -= req->iov[rdma_req->iovpos].iov_len;
 		rdma_req->iovpos++;
 	}
 
-	if (length) {
+	if (total_length) {
 		SPDK_ERRLOG("Not enough SG entries to hold data buffer\n");
 		return -EINVAL;
 	}
-- 
2.26.2


From 180d281c7fc2167eeca2a3a8b0b5d5e1868e6382 Mon Sep 17 00:00:00 2001
From: Wojciech Malikowski <wojciech.malikowski@intel.com>
Date: Thu, 23 Apr 2020 08:53:20 +0200
Subject: [PATCH 137/342] lib/ftl: Drain retry queue before shutdown

Requests that still reside on retry queue should be
submitted to disk before shutdown.

Signed-off-by: Wojciech Malikowski <wojciech.malikowski@intel.com>
Change-Id: Id2d020fcaef6443d01cfd8628686e9b0f34a1cfa
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6771
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/ftl/ftl_core.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/lib/ftl/ftl_core.c b/lib/ftl/ftl_core.c
index 18cd7b4a3..bb13c6dd1 100644
--- a/lib/ftl/ftl_core.c
+++ b/lib/ftl/ftl_core.c
@@ -966,11 +966,18 @@ ftl_wptr_pad_band(struct ftl_wptr *wptr)
 	struct spdk_ftl_dev *dev = wptr->dev;
 	struct ftl_batch *batch = dev->current_batch;
 	struct ftl_io_channel *ioch;
+	struct ftl_io *io;
 	size_t size, pad_size, blocks_left;
 
 	size = batch != NULL ? batch->num_entries : 0;
 	TAILQ_FOREACH(ioch, &dev->ioch_queue, tailq) {
 		size += spdk_ring_count(ioch->submit_queue);
+
+		TAILQ_FOREACH(io, &ioch->retry_queue, ioch_entry) {
+			if (io->type == FTL_IO_WRITE) {
+				size += io->num_blocks - io->pos;
+			}
+		}
 	}
 
 	ioch = ftl_io_channel_get_ctx(ftl_get_io_channel(dev));
@@ -989,11 +996,18 @@ ftl_wptr_process_shutdown(struct ftl_wptr *wptr)
 	struct spdk_ftl_dev *dev = wptr->dev;
 	struct ftl_batch *batch = dev->current_batch;
 	struct ftl_io_channel *ioch;
+	struct ftl_io *io;
 	size_t size;
 
 	size = batch != NULL ? batch->num_entries : 0;
 	TAILQ_FOREACH(ioch, &dev->ioch_queue, tailq) {
 		size += spdk_ring_count(ioch->submit_queue);
+
+		TAILQ_FOREACH(io, &ioch->retry_queue, ioch_entry) {
+			if (io->type == FTL_IO_WRITE) {
+				size += io->num_blocks - io->pos;
+			}
+		}
 	}
 
 	if (size >= dev->xfer_size) {
-- 
2.26.2


From 4f11fa5b6c046732054c1636c40435043d9578fb Mon Sep 17 00:00:00 2001
From: Konrad Sztyber <konrad.sztyber@intel.com>
Date: Wed, 31 Mar 2021 17:35:36 +0200
Subject: [PATCH 138/342] scripts/setup: use `test -e` to test for msr presence

Current `test -f` never succeeds, because `/dev/cpu/0/msr` is a
character device file.

Signed-off-by: Konrad Sztyber <konrad.sztyber@intel.com>
Change-Id: Iaa28f04866ab24140668ad43351a37f0ccccef65
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7166
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/setup.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/scripts/setup.sh b/scripts/setup.sh
index a2319ec71..4d2346424 100755
--- a/scripts/setup.sh
+++ b/scripts/setup.sh
@@ -509,7 +509,7 @@ function configure_linux() {
 		fi
 	fi
 
-	if [ ! -f /dev/cpu/0/msr ]; then
+	if [ ! -e /dev/cpu/0/msr ]; then
 		# Some distros build msr as a module.  Make sure it's loaded to ensure
 		#  DPDK can easily figure out the TSC rate rather than relying on 100ms
 		#  sleeps.
-- 
2.26.2


From 4748ebef40f3e06f793eaf7362f034b25b99e8f5 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 11 May 2021 15:16:05 +0900
Subject: [PATCH 139/342] thread: Cache the closest timed poller into thread

When we introduce RB tree, getting the closest timed poller is not
O(1) but O(log N). To mitigate such delay, cache the closest timed
poller into thread, and update the cache when its content is changed.

Add unit test cases for this change. They will also clarify the current
behavior of spdk_poller_unregister() and spdk_poller_pause() for
timed pollers.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ibb98a54c261859a3210034038d3953e5c93ef8aa
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7720
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
---
 lib/thread/thread.c                       |  11 ++-
 test/unit/lib/thread/thread.c/thread_ut.c | 101 ++++++++++++++++++++++
 2 files changed, 110 insertions(+), 2 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 8184cc2f4..3ba3c09c9 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -123,6 +123,7 @@ struct spdk_thread {
 	 * Contains pollers running on this thread with a periodic timer.
 	 */
 	TAILQ_HEAD(timed_pollers_head, spdk_poller)	timed_pollers;
+	struct spdk_poller				*first_timed_poller;
 	/*
 	 * Contains paused pollers.  Pollers on this queue are waiting until
 	 * they are resumed (in which case they're put onto the active/timer
@@ -676,12 +677,18 @@ poller_insert_timer(struct spdk_thread *thread, struct spdk_poller *poller, uint
 
 	/* No earlier pollers were found, so this poller must be the new head */
 	TAILQ_INSERT_HEAD(&thread->timed_pollers, poller, tailq);
+
+	thread->first_timed_poller = poller;
 }
 
 static inline void
 poller_remove_timer(struct spdk_thread *thread, struct spdk_poller *poller)
 {
 	TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+
+	if (thread->first_timed_poller == poller) {
+		thread->first_timed_poller = TAILQ_FIRST(&thread->timed_pollers);
+	}
 }
 
 static void
@@ -852,7 +859,7 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 		}
 	}
 
-	poller = TAILQ_FIRST(&thread->timed_pollers);
+	poller = thread->first_timed_poller;
 	while (poller != NULL) {
 		int timer_rc = 0;
 
@@ -927,7 +934,7 @@ spdk_thread_next_poller_expiration(struct spdk_thread *thread)
 {
 	struct spdk_poller *poller;
 
-	poller = TAILQ_FIRST(&thread->timed_pollers);
+	poller = thread->first_timed_poller;
 	if (poller) {
 		return poller->next_run_tick;
 	}
diff --git a/test/unit/lib/thread/thread.c/thread_ut.c b/test/unit/lib/thread/thread.c/thread_ut.c
index 11e3bf3c9..8cc6a6207 100644
--- a/test/unit/lib/thread/thread.c/thread_ut.c
+++ b/test/unit/lib/thread/thread.c/thread_ut.c
@@ -1332,6 +1332,106 @@ device_unregister_and_thread_exit_race(void)
 	free_threads();
 }
 
+static int
+dummy_poller(void *arg)
+{
+	return SPDK_POLLER_IDLE;
+}
+
+static void
+cache_closest_timed_poller(void)
+{
+	struct spdk_thread *thread;
+	struct spdk_poller *poller1, *poller2, *poller3, *tmp;
+
+	allocate_threads(1);
+	set_thread(0);
+
+	thread = spdk_get_thread();
+	SPDK_CU_ASSERT_FATAL(thread != NULL);
+
+	poller1 = spdk_poller_register(dummy_poller, NULL, 1000);
+	SPDK_CU_ASSERT_FATAL(poller1 != NULL);
+
+	poller2 = spdk_poller_register(dummy_poller, NULL, 1500);
+	SPDK_CU_ASSERT_FATAL(poller2 != NULL);
+
+	poller3 = spdk_poller_register(dummy_poller, NULL, 1800);
+	SPDK_CU_ASSERT_FATAL(poller3 != NULL);
+
+	poll_threads();
+
+	/* When multiple timed pollers are inserted, the cache should
+	 * have the closest timed poller.
+	 */
+	CU_ASSERT(thread->first_timed_poller == poller1);
+	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller1);
+
+	spdk_delay_us(1000);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == poller2);
+	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller2);
+
+	/* If we unregister a timed poller by spdk_poller_unregister()
+	 * when it is waiting, it is marked as being unregistereed and
+	 * is actually unregistered when it is expired.
+	 *
+	 * Hence if we unregister the closest timed poller when it is waiting,
+	 * the cache is not updated to the next timed poller until it is expired.
+	 */
+	tmp = poller2;
+
+	spdk_poller_unregister(&poller2);
+	CU_ASSERT(poller2 == NULL);
+
+	spdk_delay_us(499);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == tmp);
+	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == tmp);
+
+	spdk_delay_us(1);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == poller3);
+	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller3);
+
+	/* If we pause a timed poller by spdk_poller_pause() when it is waiting,
+	 * it is marked as being paused and is actually paused when it is expired.
+	 *
+	 * Hence if we pause the closest timed poller when it is waiting, the cache
+	 * is not updated to the next timed poller until it is expired.
+	 */
+	spdk_poller_pause(poller3);
+
+	spdk_delay_us(299);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == poller3);
+	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller3);
+
+	spdk_delay_us(1);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == poller1);
+	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller1);
+
+	/* After unregistering all timed pollers, the cache should
+	 * be NULL.
+	 */
+	spdk_poller_unregister(&poller1);
+	spdk_poller_unregister(&poller3);
+
+	spdk_delay_us(200);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == NULL);
+	CU_ASSERT(TAILQ_EMPTY(&thread->timed_pollers));
+
+	free_threads();
+}
+
 int
 main(int argc, char **argv)
 {
@@ -1357,6 +1457,7 @@ main(int argc, char **argv)
 	CU_ADD_TEST(suite, thread_update_stats_test);
 	CU_ADD_TEST(suite, nested_channel);
 	CU_ADD_TEST(suite, device_unregister_and_thread_exit_race);
+	CU_ADD_TEST(suite, cache_closest_timed_poller);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From fb68d4e9ac01f6ca48e81d3fc9acf6e8a5d631e1 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 3 May 2021 11:36:07 +0900
Subject: [PATCH 140/342] util: Add Free BSD Red-Black tree macros

Copy Free BSD's sys/sys/tree.h to SPDK's include/spdk/tree.h by
changing as little as possible.

A few changes are as follows:
- Remove a few lines located at the head of the file.
- Change the name of ifdef from _SYS_TREE_H_ to SPDK_TREE_H.
- Change the type __uintptr_t to uintptr_t.
- Change the attribute __unused to __attribute__((unused))
- Insert a space to the front and the end of CONSTCOND.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I26488d8fd61f80508cf7d96fbeb6007f12080a01
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7721
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Monica Kenguva <monica.kenguva@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 include/spdk/tree.h | 829 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 829 insertions(+)
 create mode 100644 include/spdk/tree.h

diff --git a/include/spdk/tree.h b/include/spdk/tree.h
new file mode 100644
index 000000000..958185cee
--- /dev/null
+++ b/include/spdk/tree.h
@@ -0,0 +1,829 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright 2002 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	SPDK_TREE_H
+#define SPDK_TREE_H
+
+#include <sys/cdefs.h>
+
+/*
+ * This file defines data structures for different types of trees:
+ * splay trees and rank-balanced trees.
+ *
+ * A splay tree is a self-organizing data structure.  Every operation
+ * on the tree causes a splay to happen.  The splay moves the requested
+ * node to the root of the tree and partly rebalances it.
+ *
+ * This has the benefit that request locality causes faster lookups as
+ * the requested nodes move to the top of the tree.  On the other hand,
+ * every lookup causes memory writes.
+ *
+ * The Balance Theorem bounds the total access time for m operations
+ * and n inserts on an initially empty tree as O((m + n)lg n).  The
+ * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
+ *
+ * A rank-balanced tree is a binary search tree with an integer
+ * rank-difference as an attribute of each pointer from parent to child.
+ * The sum of the rank-differences on any path from a node down to null is
+ * the same, and defines the rank of that node. The rank of the null node
+ * is -1.
+ *
+ * Different additional conditions define different sorts of balanced
+ * trees, including "red-black" and "AVL" trees.  The set of conditions
+ * applied here are the "weak-AVL" conditions of Haeupler, Sen and Tarjan:
+ *	- every rank-difference is 1 or 2.
+ *	- the rank of any leaf is 1.
+ *
+ * For historical reasons, rank differences that are even are associated
+ * with the color red (Rank-Even-Difference), and the child that a red edge
+ * points to is called a red child.
+ *
+ * Every operation on a rank-balanced tree is bounded as O(lg n).
+ * The maximum height of a rank-balanced tree is 2lg (n+1).
+ */
+
+#define SPLAY_HEAD(name, type)						\
+struct name {								\
+	struct type *sph_root; /* root of the tree */			\
+}
+
+#define SPLAY_INITIALIZER(root)						\
+	{ NULL }
+
+#define SPLAY_INIT(root) do {						\
+	(root)->sph_root = NULL;					\
+} while (/* CONSTCOND */ 0)
+
+#define SPLAY_ENTRY(type)						\
+struct {								\
+	struct type *spe_left; /* left element */			\
+	struct type *spe_right; /* right element */			\
+}
+
+#define SPLAY_LEFT(elm, field)		(elm)->field.spe_left
+#define SPLAY_RIGHT(elm, field)		(elm)->field.spe_right
+#define SPLAY_ROOT(head)		(head)->sph_root
+#define SPLAY_EMPTY(head)		(SPLAY_ROOT(head) == NULL)
+
+/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
+#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {			\
+	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);	\
+	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
+	(head)->sph_root = tmp;						\
+} while (/* CONSTCOND */ 0)
+
+#define SPLAY_ROTATE_LEFT(head, tmp, field) do {			\
+	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);	\
+	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
+	(head)->sph_root = tmp;						\
+} while (/* CONSTCOND */ 0)
+
+#define SPLAY_LINKLEFT(head, tmp, field) do {				\
+	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
+	tmp = (head)->sph_root;						\
+	(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);		\
+} while (/* CONSTCOND */ 0)
+
+#define SPLAY_LINKRIGHT(head, tmp, field) do {				\
+	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
+	tmp = (head)->sph_root;						\
+	(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);	\
+} while (/* CONSTCOND */ 0)
+
+#define SPLAY_ASSEMBLE(head, node, left, right, field) do {		\
+	SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);	\
+	SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);\
+	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);	\
+	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);	\
+} while (/* CONSTCOND */ 0)
+
+/* Generates prototypes and inline functions */
+
+#define SPLAY_PROTOTYPE(name, type, field, cmp)				\
+void name##_SPLAY(struct name *, struct type *);			\
+void name##_SPLAY_MINMAX(struct name *, int);				\
+struct type *name##_SPLAY_INSERT(struct name *, struct type *);		\
+struct type *name##_SPLAY_REMOVE(struct name *, struct type *);		\
+									\
+/* Finds the node with the same key as elm */				\
+static __attribute__((unused)) __inline struct type *					\
+name##_SPLAY_FIND(struct name *head, struct type *elm)			\
+{									\
+	if (SPLAY_EMPTY(head))						\
+		return(NULL);						\
+	name##_SPLAY(head, elm);					\
+	if ((cmp)(elm, (head)->sph_root) == 0)				\
+		return (head->sph_root);				\
+	return (NULL);							\
+}									\
+									\
+static __attribute__((unused)) __inline struct type *					\
+name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
+{									\
+	name##_SPLAY(head, elm);					\
+	if (SPLAY_RIGHT(elm, field) != NULL) {				\
+		elm = SPLAY_RIGHT(elm, field);				\
+		while (SPLAY_LEFT(elm, field) != NULL) {		\
+			elm = SPLAY_LEFT(elm, field);			\
+		}							\
+	} else								\
+		elm = NULL;						\
+	return (elm);							\
+}									\
+									\
+static __attribute__((unused)) __inline struct type *					\
+name##_SPLAY_MIN_MAX(struct name *head, int val)			\
+{									\
+	name##_SPLAY_MINMAX(head, val);					\
+        return (SPLAY_ROOT(head));					\
+}
+
+/* Main splay operation.
+ * Moves node close to the key of elm to top
+ */
+#define SPLAY_GENERATE(name, type, field, cmp)				\
+struct type *								\
+name##_SPLAY_INSERT(struct name *head, struct type *elm)		\
+{									\
+    if (SPLAY_EMPTY(head)) {						\
+	    SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;	\
+    } else {								\
+	    int __comp;							\
+	    name##_SPLAY(head, elm);					\
+	    __comp = (cmp)(elm, (head)->sph_root);			\
+	    if (__comp < 0) {						\
+		    SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);\
+		    SPLAY_RIGHT(elm, field) = (head)->sph_root;		\
+		    SPLAY_LEFT((head)->sph_root, field) = NULL;		\
+	    } else if (__comp > 0) {					\
+		    SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);\
+		    SPLAY_LEFT(elm, field) = (head)->sph_root;		\
+		    SPLAY_RIGHT((head)->sph_root, field) = NULL;	\
+	    } else							\
+		    return ((head)->sph_root);				\
+    }									\
+    (head)->sph_root = (elm);						\
+    return (NULL);							\
+}									\
+									\
+struct type *								\
+name##_SPLAY_REMOVE(struct name *head, struct type *elm)		\
+{									\
+	struct type *__tmp;						\
+	if (SPLAY_EMPTY(head))						\
+		return (NULL);						\
+	name##_SPLAY(head, elm);					\
+	if ((cmp)(elm, (head)->sph_root) == 0) {			\
+		if (SPLAY_LEFT((head)->sph_root, field) == NULL) {	\
+			(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\
+		} else {						\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\
+			name##_SPLAY(head, elm);			\
+			SPLAY_RIGHT((head)->sph_root, field) = __tmp;	\
+		}							\
+		return (elm);						\
+	}								\
+	return (NULL);							\
+}									\
+									\
+void									\
+name##_SPLAY(struct name *head, struct type *elm)			\
+{									\
+	struct type __node, *__left, *__right, *__tmp;			\
+	int __comp;							\
+\
+	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
+	__left = __right = &__node;					\
+\
+	while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {		\
+		if (__comp < 0) {					\
+			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if ((cmp)(elm, __tmp) < 0){			\
+				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
+				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKLEFT(head, __right, field);		\
+		} else if (__comp > 0) {				\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if ((cmp)(elm, __tmp) > 0){			\
+				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
+				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKRIGHT(head, __left, field);		\
+		}							\
+	}								\
+	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
+}									\
+									\
+/* Splay with either the minimum or the maximum element			\
+ * Used to find minimum or maximum element in tree.			\
+ */									\
+void name##_SPLAY_MINMAX(struct name *head, int __comp) \
+{									\
+	struct type __node, *__left, *__right, *__tmp;			\
+\
+	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
+	__left = __right = &__node;					\
+\
+	while (1) {							\
+		if (__comp < 0) {					\
+			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if (__comp < 0){				\
+				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
+				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKLEFT(head, __right, field);		\
+		} else if (__comp > 0) {				\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if (__comp > 0) {				\
+				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
+				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKRIGHT(head, __left, field);		\
+		}							\
+	}								\
+	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
+}
+
+#define SPLAY_NEGINF	-1
+#define SPLAY_INF	1
+
+#define SPLAY_INSERT(name, x, y)	name##_SPLAY_INSERT(x, y)
+#define SPLAY_REMOVE(name, x, y)	name##_SPLAY_REMOVE(x, y)
+#define SPLAY_FIND(name, x, y)		name##_SPLAY_FIND(x, y)
+#define SPLAY_NEXT(name, x, y)		name##_SPLAY_NEXT(x, y)
+#define SPLAY_MIN(name, x)		(SPLAY_EMPTY(x) ? NULL	\
+					: name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
+#define SPLAY_MAX(name, x)		(SPLAY_EMPTY(x) ? NULL	\
+					: name##_SPLAY_MIN_MAX(x, SPLAY_INF))
+
+#define SPLAY_FOREACH(x, name, head)					\
+	for ((x) = SPLAY_MIN(name, head);				\
+	     (x) != NULL;						\
+	     (x) = SPLAY_NEXT(name, head, x))
+
+/* Macros that define a rank-balanced tree */
+#define RB_HEAD(name, type)						\
+struct name {								\
+	struct type *rbh_root; /* root of the tree */			\
+}
+
+#define RB_INITIALIZER(root)						\
+	{ NULL }
+
+#define RB_INIT(root) do {						\
+	(root)->rbh_root = NULL;					\
+} while (/* CONSTCOND */ 0)
+
+#define RB_ENTRY(type)							\
+struct {								\
+	struct type *rbe_left;		/* left element */		\
+	struct type *rbe_right;		/* right element */		\
+	struct type *rbe_parent;	/* parent element */		\
+}
+
+#define RB_LEFT(elm, field)		(elm)->field.rbe_left
+#define RB_RIGHT(elm, field)		(elm)->field.rbe_right
+
+/*
+ * With the expectation that any object of struct type has an
+ * address that is a multiple of 4, and that therefore the
+ * 2 least significant bits of a pointer to struct type are
+ * always zero, this implementation sets those bits to indicate
+ * that the left or right child of the tree node is "red".
+ */
+#define RB_UP(elm, field)		(elm)->field.rbe_parent
+#define RB_BITS(elm, field)		(*(uintptr_t *)&RB_UP(elm, field))
+#define RB_RED_L			((uintptr_t)1)
+#define RB_RED_R			((uintptr_t)2)
+#define RB_RED_MASK			((uintptr_t)3)
+#define RB_FLIP_LEFT(elm, field)	(RB_BITS(elm, field) ^= RB_RED_L)
+#define RB_FLIP_RIGHT(elm, field)	(RB_BITS(elm, field) ^= RB_RED_R)
+#define RB_RED_LEFT(elm, field)		((RB_BITS(elm, field) & RB_RED_L) != 0)
+#define RB_RED_RIGHT(elm, field)	((RB_BITS(elm, field) & RB_RED_R) != 0)
+#define RB_PARENT(elm, field)		((__typeof(RB_UP(elm, field)))	\
+					 (RB_BITS(elm, field) & ~RB_RED_MASK))
+#define RB_ROOT(head)			(head)->rbh_root
+#define RB_EMPTY(head)			(RB_ROOT(head) == NULL)
+
+#define RB_SET_PARENT(dst, src, field) do {				\
+	RB_BITS(dst, field) &= RB_RED_MASK;				\
+	RB_BITS(dst, field) |= (uintptr_t)src;			\
+} while (/* CONSTCOND */ 0)
+
+#define RB_SET(elm, parent, field) do {					\
+	RB_UP(elm, field) = parent;					\
+	RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;		\
+} while (/* CONSTCOND */ 0)
+
+#define RB_COLOR(elm, field)	(RB_PARENT(elm, field) == NULL ? 0 :	\
+				RB_LEFT(RB_PARENT(elm, field), field) == elm ? \
+				RB_RED_LEFT(RB_PARENT(elm, field), field) : \
+				RB_RED_RIGHT(RB_PARENT(elm, field), field))
+
+/*
+ * Something to be invoked in a loop at the root of every modified subtree,
+ * from the bottom up to the root, to update augmented node data.
+ */
+#ifndef RB_AUGMENT
+#define RB_AUGMENT(x)	break
+#endif
+
+#define RB_SWAP_CHILD(head, out, in, field) do {			\
+	if (RB_PARENT(out, field) == NULL)				\
+		RB_ROOT(head) = (in);					\
+	else if ((out) == RB_LEFT(RB_PARENT(out, field), field))	\
+		RB_LEFT(RB_PARENT(out, field), field) = (in);		\
+	else								\
+		RB_RIGHT(RB_PARENT(out, field), field) = (in);		\
+} while (/* CONSTCOND */ 0)
+
+#define RB_ROTATE_LEFT(head, elm, tmp, field) do {			\
+	(tmp) = RB_RIGHT(elm, field);					\
+	if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field)) != NULL) {	\
+		RB_SET_PARENT(RB_RIGHT(elm, field), elm, field);	\
+	}								\
+	RB_SET_PARENT(tmp, RB_PARENT(elm, field), field);		\
+	RB_SWAP_CHILD(head, elm, tmp, field);				\
+	RB_LEFT(tmp, field) = (elm);					\
+	RB_SET_PARENT(elm, tmp, field);					\
+	RB_AUGMENT(elm);						\
+} while (/* CONSTCOND */ 0)
+
+#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {			\
+	(tmp) = RB_LEFT(elm, field);					\
+	if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field)) != NULL) {	\
+		RB_SET_PARENT(RB_LEFT(elm, field), elm, field);		\
+	}								\
+	RB_SET_PARENT(tmp, RB_PARENT(elm, field), field);		\
+	RB_SWAP_CHILD(head, elm, tmp, field);				\
+	RB_RIGHT(tmp, field) = (elm);					\
+	RB_SET_PARENT(elm, tmp, field);					\
+	RB_AUGMENT(elm);						\
+} while (/* CONSTCOND */ 0)
+
+/* Generates prototypes and inline functions */
+#define	RB_PROTOTYPE(name, type, field, cmp)				\
+	RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)
+#define	RB_PROTOTYPE_STATIC(name, type, field, cmp)			\
+	RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __attribute__((unused)) static)
+#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)		\
+	RB_PROTOTYPE_INSERT_COLOR(name, type, attr);			\
+	RB_PROTOTYPE_REMOVE_COLOR(name, type, attr);			\
+	RB_PROTOTYPE_INSERT(name, type, attr);				\
+	RB_PROTOTYPE_REMOVE(name, type, attr);				\
+	RB_PROTOTYPE_FIND(name, type, attr);				\
+	RB_PROTOTYPE_NFIND(name, type, attr);				\
+	RB_PROTOTYPE_NEXT(name, type, attr);				\
+	RB_PROTOTYPE_PREV(name, type, attr);				\
+	RB_PROTOTYPE_MINMAX(name, type, attr);				\
+	RB_PROTOTYPE_REINSERT(name, type, attr);
+#define RB_PROTOTYPE_INSERT_COLOR(name, type, attr)			\
+	attr void name##_RB_INSERT_COLOR(struct name *, struct type *)
+#define RB_PROTOTYPE_REMOVE_COLOR(name, type, attr)			\
+	attr void name##_RB_REMOVE_COLOR(struct name *,			\
+	    struct type *, struct type *)
+#define RB_PROTOTYPE_REMOVE(name, type, attr)				\
+	attr struct type *name##_RB_REMOVE(struct name *, struct type *)
+#define RB_PROTOTYPE_INSERT(name, type, attr)				\
+	attr struct type *name##_RB_INSERT(struct name *, struct type *)
+#define RB_PROTOTYPE_FIND(name, type, attr)				\
+	attr struct type *name##_RB_FIND(struct name *, struct type *)
+#define RB_PROTOTYPE_NFIND(name, type, attr)				\
+	attr struct type *name##_RB_NFIND(struct name *, struct type *)
+#define RB_PROTOTYPE_NEXT(name, type, attr)				\
+	attr struct type *name##_RB_NEXT(struct type *)
+#define RB_PROTOTYPE_PREV(name, type, attr)				\
+	attr struct type *name##_RB_PREV(struct type *)
+#define RB_PROTOTYPE_MINMAX(name, type, attr)				\
+	attr struct type *name##_RB_MINMAX(struct name *, int)
+#define RB_PROTOTYPE_REINSERT(name, type, attr)			\
+	attr struct type *name##_RB_REINSERT(struct name *, struct type *)
+
+/* Main rb operation.
+ * Moves node close to the key of elm to top
+ */
+#define	RB_GENERATE(name, type, field, cmp)				\
+	RB_GENERATE_INTERNAL(name, type, field, cmp,)
+#define	RB_GENERATE_STATIC(name, type, field, cmp)			\
+	RB_GENERATE_INTERNAL(name, type, field, cmp, __attribute__((unused)) static)
+#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)		\
+	RB_GENERATE_INSERT_COLOR(name, type, field, attr)		\
+	RB_GENERATE_REMOVE_COLOR(name, type, field, attr)		\
+	RB_GENERATE_INSERT(name, type, field, cmp, attr)		\
+	RB_GENERATE_REMOVE(name, type, field, attr)			\
+	RB_GENERATE_FIND(name, type, field, cmp, attr)			\
+	RB_GENERATE_NFIND(name, type, field, cmp, attr)			\
+	RB_GENERATE_NEXT(name, type, field, attr)			\
+	RB_GENERATE_PREV(name, type, field, attr)			\
+	RB_GENERATE_MINMAX(name, type, field, attr)			\
+	RB_GENERATE_REINSERT(name, type, field, cmp, attr)
+
+#define RB_GENERATE_INSERT_COLOR(name, type, field, attr)		\
+attr void								\
+name##_RB_INSERT_COLOR(struct name *head, struct type *elm)		\
+{									\
+	struct type *child, *parent;					\
+	while ((parent = RB_PARENT(elm, field)) != NULL) {		\
+		if (RB_LEFT(parent, field) == elm) {			\
+			if (RB_RED_LEFT(parent, field)) {		\
+				RB_FLIP_LEFT(parent, field);		\
+				return;					\
+			}						\
+			RB_FLIP_RIGHT(parent, field);			\
+			if (RB_RED_RIGHT(parent, field)) {		\
+				elm = parent;				\
+				continue;				\
+			}						\
+			if (!RB_RED_RIGHT(elm, field)) {		\
+				RB_FLIP_LEFT(elm, field);		\
+				RB_ROTATE_LEFT(head, elm, child, field);\
+				if (RB_RED_LEFT(child, field))		\
+					RB_FLIP_RIGHT(elm, field);	\
+				else if (RB_RED_RIGHT(child, field))	\
+					RB_FLIP_LEFT(parent, field);	\
+				elm = child;				\
+			}						\
+			RB_ROTATE_RIGHT(head, parent, elm, field);	\
+		} else {						\
+			if (RB_RED_RIGHT(parent, field)) {		\
+				RB_FLIP_RIGHT(parent, field);		\
+				return;					\
+			}						\
+			RB_FLIP_LEFT(parent, field);			\
+			if (RB_RED_LEFT(parent, field)) {		\
+				elm = parent;				\
+				continue;				\
+			}						\
+			if (!RB_RED_LEFT(elm, field)) {			\
+				RB_FLIP_RIGHT(elm, field);		\
+				RB_ROTATE_RIGHT(head, elm, child, field);\
+				if (RB_RED_RIGHT(child, field))		\
+					RB_FLIP_LEFT(elm, field);	\
+				else if (RB_RED_LEFT(child, field))	\
+					RB_FLIP_RIGHT(parent, field);	\
+				elm = child;				\
+			}						\
+			RB_ROTATE_LEFT(head, parent, elm, field);	\
+		}							\
+		RB_BITS(elm, field) &= ~RB_RED_MASK;			\
+		break;							\
+	}								\
+}
+
+#define RB_GENERATE_REMOVE_COLOR(name, type, field, attr)		\
+attr void								\
+name##_RB_REMOVE_COLOR(struct name *head,				\
+    struct type *parent, struct type *elm)				\
+{									\
+	struct type *sib;						\
+	if (RB_LEFT(parent, field) == elm &&				\
+	    RB_RIGHT(parent, field) == elm) {				\
+		RB_BITS(parent, field) &= ~RB_RED_MASK;			\
+		elm = parent;						\
+		parent = RB_PARENT(elm, field);				\
+		if (parent == NULL)					\
+			return;						\
+	}								\
+	do  {								\
+		if (RB_LEFT(parent, field) == elm) {			\
+			if (!RB_RED_LEFT(parent, field)) {		\
+				RB_FLIP_LEFT(parent, field);		\
+				return;					\
+			}						\
+			if (RB_RED_RIGHT(parent, field)) {		\
+				RB_FLIP_RIGHT(parent, field);		\
+				elm = parent;				\
+				continue;				\
+			}						\
+			sib = RB_RIGHT(parent, field);			\
+			if ((~RB_BITS(sib, field) & RB_RED_MASK) == 0) {\
+				RB_BITS(sib, field) &= ~RB_RED_MASK;	\
+				elm = parent;				\
+				continue;				\
+			}						\
+			RB_FLIP_RIGHT(sib, field);			\
+			if (RB_RED_LEFT(sib, field))			\
+				RB_FLIP_LEFT(parent, field);		\
+			else if (!RB_RED_RIGHT(sib, field)) {		\
+				RB_FLIP_LEFT(parent, field);		\
+				RB_ROTATE_RIGHT(head, sib, elm, field);	\
+				if (RB_RED_RIGHT(elm, field))		\
+					RB_FLIP_LEFT(sib, field);	\
+				if (RB_RED_LEFT(elm, field))		\
+					RB_FLIP_RIGHT(parent, field);	\
+				RB_BITS(elm, field) |= RB_RED_MASK;	\
+				sib = elm;				\
+			}						\
+			RB_ROTATE_LEFT(head, parent, sib, field);	\
+		} else {						\
+			if (!RB_RED_RIGHT(parent, field)) {		\
+				RB_FLIP_RIGHT(parent, field);		\
+				return;					\
+			}						\
+			if (RB_RED_LEFT(parent, field)) {		\
+				RB_FLIP_LEFT(parent, field);		\
+				elm = parent;				\
+				continue;				\
+			}						\
+			sib = RB_LEFT(parent, field);			\
+			if ((~RB_BITS(sib, field) & RB_RED_MASK) == 0) {\
+				RB_BITS(sib, field) &= ~RB_RED_MASK;	\
+				elm = parent;				\
+				continue;				\
+			}						\
+			RB_FLIP_LEFT(sib, field);			\
+			if (RB_RED_RIGHT(sib, field))			\
+				RB_FLIP_RIGHT(parent, field);		\
+			else if (!RB_RED_LEFT(sib, field)) {		\
+				RB_FLIP_RIGHT(parent, field);		\
+				RB_ROTATE_LEFT(head, sib, elm, field);	\
+				if (RB_RED_LEFT(elm, field))		\
+					RB_FLIP_RIGHT(sib, field);	\
+				if (RB_RED_RIGHT(elm, field))		\
+					RB_FLIP_LEFT(parent, field);	\
+				RB_BITS(elm, field) |= RB_RED_MASK;	\
+				sib = elm;				\
+			}						\
+			RB_ROTATE_RIGHT(head, parent, sib, field);	\
+		}							\
+		break;							\
+	} while ((parent = RB_PARENT(elm, field)) != NULL);		\
+}
+
+#define RB_GENERATE_REMOVE(name, type, field, attr)			\
+attr struct type *							\
+name##_RB_REMOVE(struct name *head, struct type *elm)			\
+{									\
+	struct type *child, *old, *parent, *right;			\
+									\
+	old = elm;							\
+	parent = RB_PARENT(elm, field);					\
+	right = RB_RIGHT(elm, field);					\
+	if (RB_LEFT(elm, field) == NULL)				\
+		elm = child = right;					\
+	else if (right == NULL)						\
+		elm = child = RB_LEFT(elm, field);			\
+	else {								\
+		if ((child = RB_LEFT(right, field)) == NULL) {		\
+			child = RB_RIGHT(right, field);			\
+			RB_RIGHT(old, field) = child;			\
+			parent = elm = right;				\
+		} else {						\
+			do						\
+				elm = child;				\
+			while ((child = RB_LEFT(elm, field)) != NULL);	\
+			child = RB_RIGHT(elm, field);			\
+			parent = RB_PARENT(elm, field);			\
+			RB_LEFT(parent, field) = child;			\
+			RB_SET_PARENT(RB_RIGHT(old, field), elm, field);\
+		}							\
+		RB_SET_PARENT(RB_LEFT(old, field), elm, field);		\
+		elm->field = old->field;				\
+	}								\
+	RB_SWAP_CHILD(head, old, elm, field);				\
+	if (child != NULL)						\
+		RB_SET_PARENT(child, parent, field);			\
+	if (parent != NULL)						\
+		name##_RB_REMOVE_COLOR(head, parent, child);		\
+	while (parent != NULL) {					\
+		RB_AUGMENT(parent);					\
+		parent = RB_PARENT(parent, field);			\
+	}								\
+	return (old);							\
+}
+
+#define RB_GENERATE_INSERT(name, type, field, cmp, attr)		\
+/* Inserts a node into the RB tree */					\
+attr struct type *							\
+name##_RB_INSERT(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp;						\
+	struct type *parent = NULL;					\
+	int comp = 0;							\
+	tmp = RB_ROOT(head);						\
+	while (tmp) {							\
+		parent = tmp;						\
+		comp = (cmp)(elm, parent);				\
+		if (comp < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	RB_SET(elm, parent, field);					\
+	if (parent == NULL)						\
+		RB_ROOT(head) = elm;					\
+	else if (comp < 0)						\
+		RB_LEFT(parent, field) = elm;				\
+	else								\
+		RB_RIGHT(parent, field) = elm;				\
+	name##_RB_INSERT_COLOR(head, elm);				\
+	while (elm != NULL) {						\
+		RB_AUGMENT(elm);					\
+		elm = RB_PARENT(elm, field);				\
+	}								\
+	return (NULL);							\
+}
+
+#define RB_GENERATE_FIND(name, type, field, cmp, attr)			\
+/* Finds the node with the same key as elm */				\
+attr struct type *							\
+name##_RB_FIND(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	int comp;							\
+	while (tmp) {							\
+		comp = cmp(elm, tmp);					\
+		if (comp < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	return (NULL);							\
+}
+
+#define RB_GENERATE_NFIND(name, type, field, cmp, attr)			\
+/* Finds the first node greater than or equal to the search key */	\
+attr struct type *							\
+name##_RB_NFIND(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	struct type *res = NULL;					\
+	int comp;							\
+	while (tmp) {							\
+		comp = cmp(elm, tmp);					\
+		if (comp < 0) {						\
+			res = tmp;					\
+			tmp = RB_LEFT(tmp, field);			\
+		}							\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	return (res);							\
+}
+
+#define RB_GENERATE_NEXT(name, type, field, attr)			\
+/* ARGSUSED */								\
+attr struct type *							\
+name##_RB_NEXT(struct type *elm)					\
+{									\
+	if (RB_RIGHT(elm, field)) {					\
+		elm = RB_RIGHT(elm, field);				\
+		while (RB_LEFT(elm, field))				\
+			elm = RB_LEFT(elm, field);			\
+	} else {							\
+		if (RB_PARENT(elm, field) &&				\
+		    (elm == RB_LEFT(RB_PARENT(elm, field), field)))	\
+			elm = RB_PARENT(elm, field);			\
+		else {							\
+			while (RB_PARENT(elm, field) &&			\
+			    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\
+				elm = RB_PARENT(elm, field);		\
+			elm = RB_PARENT(elm, field);			\
+		}							\
+	}								\
+	return (elm);							\
+}
+
+#define RB_GENERATE_PREV(name, type, field, attr)			\
+/* ARGSUSED */								\
+attr struct type *							\
+name##_RB_PREV(struct type *elm)					\
+{									\
+	if (RB_LEFT(elm, field)) {					\
+		elm = RB_LEFT(elm, field);				\
+		while (RB_RIGHT(elm, field))				\
+			elm = RB_RIGHT(elm, field);			\
+	} else {							\
+		if (RB_PARENT(elm, field) &&				\
+		    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))	\
+			elm = RB_PARENT(elm, field);			\
+		else {							\
+			while (RB_PARENT(elm, field) &&			\
+			    (elm == RB_LEFT(RB_PARENT(elm, field), field)))\
+				elm = RB_PARENT(elm, field);		\
+			elm = RB_PARENT(elm, field);			\
+		}							\
+	}								\
+	return (elm);							\
+}
+
+#define RB_GENERATE_MINMAX(name, type, field, attr)			\
+attr struct type *							\
+name##_RB_MINMAX(struct name *head, int val)				\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	struct type *parent = NULL;					\
+	while (tmp) {							\
+		parent = tmp;						\
+		if (val < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else							\
+			tmp = RB_RIGHT(tmp, field);			\
+	}								\
+	return (parent);						\
+}
+
+#define	RB_GENERATE_REINSERT(name, type, field, cmp, attr)		\
+attr struct type *							\
+name##_RB_REINSERT(struct name *head, struct type *elm)			\
+{									\
+	struct type *cmpelm;						\
+	if (((cmpelm = RB_PREV(name, head, elm)) != NULL &&		\
+	    cmp(cmpelm, elm) >= 0) ||					\
+	    ((cmpelm = RB_NEXT(name, head, elm)) != NULL &&		\
+	    cmp(elm, cmpelm) >= 0)) {					\
+		/* XXXLAS: Remove/insert is heavy handed. */		\
+		RB_REMOVE(name, head, elm);				\
+		return (RB_INSERT(name, head, elm));			\
+	}								\
+	return (NULL);							\
+}									\
+
+#define RB_NEGINF	-1
+#define RB_INF	1
+
+#define RB_INSERT(name, x, y)	name##_RB_INSERT(x, y)
+#define RB_REMOVE(name, x, y)	name##_RB_REMOVE(x, y)
+#define RB_FIND(name, x, y)	name##_RB_FIND(x, y)
+#define RB_NFIND(name, x, y)	name##_RB_NFIND(x, y)
+#define RB_NEXT(name, x, y)	name##_RB_NEXT(y)
+#define RB_PREV(name, x, y)	name##_RB_PREV(y)
+#define RB_MIN(name, x)		name##_RB_MINMAX(x, RB_NEGINF)
+#define RB_MAX(name, x)		name##_RB_MINMAX(x, RB_INF)
+#define RB_REINSERT(name, x, y)	name##_RB_REINSERT(x, y)
+
+#define RB_FOREACH(x, name, head)					\
+	for ((x) = RB_MIN(name, head);					\
+	     (x) != NULL;						\
+	     (x) = name##_RB_NEXT(x))
+
+#define RB_FOREACH_FROM(x, name, y)					\
+	for ((x) = (y);							\
+	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);	\
+	     (x) = (y))
+
+#define RB_FOREACH_SAFE(x, name, head, y)				\
+	for ((x) = RB_MIN(name, head);					\
+	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);	\
+	     (x) = (y))
+
+#define RB_FOREACH_REVERSE(x, name, head)				\
+	for ((x) = RB_MAX(name, head);					\
+	     (x) != NULL;						\
+	     (x) = name##_RB_PREV(x))
+
+#define RB_FOREACH_REVERSE_FROM(x, name, y)				\
+	for ((x) = (y);							\
+	    ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);	\
+	     (x) = (y))
+
+#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)			\
+	for ((x) = RB_MAX(name, head);					\
+	    ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);	\
+	     (x) = (y))
+
+#endif	/* SPDK_TREE_H */
-- 
2.26.2


From e18eaee2afc973897aa3fb13ee72c39080e821c9 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Wed, 21 Apr 2021 20:58:01 +0800
Subject: [PATCH 141/342] bdev/rbd: Add cluster register/unregister RPC support

This patch is used to add two rpc calls:
bdev_rbd_register_cluster
bdev_rbd_unregister_cluster

Then in the next patch, rbd bdev constructed on the same cluster object
can share the common Rados_t structure in order to remove the thread creation
overhead and improve the scalability.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: I898cc4ffabb8e6721ba5bef099cbf948c64d2c98
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7551
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 CHANGELOG.md                   |   6 ++
 doc/jsonrpc.md                 | 102 ++++++++++++++++++
 module/bdev/rbd/bdev_rbd.c     | 187 +++++++++++++++++++++++++++++++++
 module/bdev/rbd/bdev_rbd.h     |  21 ++++
 module/bdev/rbd/bdev_rbd_rpc.c |  89 ++++++++++++++++
 scripts/rpc.py                 |  32 ++++++
 scripts/rpc/bdev.py            |  34 ++++++
 7 files changed, 471 insertions(+)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 57c6b8a85..b1d6ee979 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -15,6 +15,12 @@ Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the cont
 
 Added a new function `spdk_nvme_ns_cmd_copy` to submit a Simple Copy Command to a Namespace.
 
+### rpc
+
+New RPC `bdev_rbd_register_cluster` and `bdev_rbd_unregister_cluster` was added, it allows to create
+and delete the rados object cluster, then users can choose the cluster to create related rbd
+device.
+
 ## v21.04:
 
 ### accel
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 370d0efe4..6c0e88514 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -3303,6 +3303,108 @@ Example response:
 }
 ~~~
 
+## bdev_rbd_register_cluster {#rpc_bdev_rbd_register_cluster}
+
+This method is available only if SPDK was build with Ceph RBD support.
+
+### Parameters
+
+Name                    | Optional | Type        | Description
+----------------------- | -------- | ----------- | -----------
+name                    | Required | string      | Registerd Rados cluster object name
+user_id                 | Optional | string      | Ceph ID (i.e. admin, not client.admin)
+config_param            | Optional | string map  | Explicit librados configuration
+config_file             | Optional | string      | File path of libraodos configuration file
+
+This RPC registers a Rados Cluster object handle which is only known
+to rbd module, it uses user_id + config_param or user_id + config_file to
+identify a Rados cluster object.
+
+If no config_param is specified, Ceph configuration files must exist with
+all relevant settings for accessing the Ceph cluster. If a config map is
+passed, the configuration files are ignored and instead all key/value
+pairs are passed to rados_conf_set to configure cluster access. In
+practice, "mon_host" (= list of monitor address+port) and "key" (= the
+secret key stored in Ceph keyrings) are enough.
+
+When accessing the Ceph cluster as some user other than "admin" (the
+default), the "user_id" has to be set.
+
+### Result
+
+Name of newly created Rados cluster object.
+
+### Example
+
+Example request with `key` from `/etc/ceph/ceph.client.admin.keyring`:
+
+~~
+{
+  "params": {
+    "name": "rbd_cluster",
+    "config_param": {
+      "mon_host": "192.168.7.1:6789,192.168.7.2:6789",
+      "key": "AQDwf8db7zR1GRAA5k7NKXjS5S5V4mntwUDnGQ==",
+    }
+  },
+  "jsonrpc": "2.0",
+  "method": "bdev_rbd_register_cluster",
+  "id": 1
+}
+~~
+
+Example response:
+
+~~
+response:
+{
+  "jsonrpc": "2.0",
+  "id": 1,
+  "result": "rbd_cluster"
+}
+~~
+
+## bdev_rbd_unregister_cluster {#rpc_bdev_rbd_unregister_cluster}
+
+This method is available only if SPDK was build with Ceph RBD support.
+If there is still rbd bdev using this cluster, the unregisteration operation
+will fail.
+
+### Result
+
+`true` if Rados cluster object with provided name was deleted or `false` otherwise.
+
+### Parameters
+
+Name                    | Optional | Type        | Description
+----------------------- | -------- | ----------- | -------------------------
+name                    | Required | string      | Rados cluster object name
+
+### Example
+
+Example request:
+
+~~
+{
+  "params": {
+    "name": "rbd_cluster"
+  },
+  "jsonrpc": "2.0",
+  "method": "bdev_rbd_unregister_cluster",
+  "id": 1
+}
+~~
+
+Example response:
+
+~~
+{
+  "jsonrpc": "2.0",
+  "id": 1,
+  "result": true
+}
+~~
+
 ## bdev_rbd_create {#rpc_bdev_rbd_create}
 
 Create @ref bdev_config_rbd bdev
diff --git a/module/bdev/rbd/bdev_rbd.c b/module/bdev/rbd/bdev_rbd.c
index 5a334b255..76373b626 100644
--- a/module/bdev/rbd/bdev_rbd.c
+++ b/module/bdev/rbd/bdev_rbd.c
@@ -86,6 +86,32 @@ struct bdev_rbd_io {
 	size_t	total_len;
 };
 
+struct bdev_rbd_cluster {
+	char *name;
+	char *user_id;
+	char **config_param;
+	char *config_file;
+	rados_t cluster;
+	uint32_t ref;
+	STAILQ_ENTRY(bdev_rbd_cluster) link;
+};
+
+static STAILQ_HEAD(, bdev_rbd_cluster) g_map_bdev_rbd_cluster = STAILQ_HEAD_INITIALIZER(
+			g_map_bdev_rbd_cluster);
+static pthread_mutex_t g_map_bdev_rbd_cluster_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void
+bdev_rbd_cluster_free(struct bdev_rbd_cluster *entry)
+{
+	assert(entry != NULL);
+
+	bdev_rbd_free_config(entry->config_param);
+	free(entry->config_file);
+	free(entry->user_id);
+	free(entry->name);
+	free(entry);
+}
+
 static void
 bdev_rbd_free(struct bdev_rbd *rbd)
 {
@@ -650,6 +676,167 @@ static const struct spdk_bdev_fn_table rbd_fn_table = {
 	.write_config_json	= bdev_rbd_write_config_json,
 };
 
+static int
+rbd_register_cluster(const char *name, const char *user_id, const char *const *config_param,
+		     const char *config_file)
+{
+	struct bdev_rbd_cluster *entry;
+	int rc;
+
+	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
+	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+		if (strncmp(name, entry->name, strlen(entry->name)) == 0) {
+			SPDK_ERRLOG("Cluster name=%s already exists\n", name);
+			pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+			return -1;
+		}
+	}
+
+	entry = calloc(1, sizeof(*entry));
+	if (!entry) {
+		SPDK_ERRLOG("Cannot allocate an entry for name=%s\n", name);
+		pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+		return -1;
+	}
+
+	entry->name = strdup(name);
+	if (entry->name == NULL) {
+		SPDK_ERRLOG("Failed to save the name =%s on entry =%p\n", name, entry);
+		goto err_handle;
+	}
+
+	if (user_id) {
+		entry->user_id = strdup(user_id);
+		if (entry->user_id == NULL) {
+			SPDK_ERRLOG("Failed to save the str =%s on entry =%p\n", user_id, entry);
+			goto err_handle;
+		}
+	}
+
+	/* The first priority is the config_param, then we use the config_file */
+	if (config_param) {
+		entry->config_param = bdev_rbd_dup_config(config_param);
+		if (entry->config_param == NULL) {
+			SPDK_ERRLOG("Failed to save the config_param=%p on entry = %p\n", config_param, entry);
+			goto err_handle;
+		}
+	} else if (config_file) {
+		entry->config_file = strdup(config_file);
+		if (entry->config_file == NULL) {
+			SPDK_ERRLOG("Failed to save the config_file=%s on entry = %p\n", config_file, entry);
+			goto err_handle;
+		}
+	}
+
+	rc = rados_create(&entry->cluster, user_id);
+	if (rc < 0) {
+		SPDK_ERRLOG("Failed to create rados_t struct\n");
+		goto err_handle;
+	}
+
+	if (config_param) {
+		const char *const *config_entry = config_param;
+		while (*config_entry) {
+			rc = rados_conf_set(entry->cluster, config_entry[0], config_entry[1]);
+			if (rc < 0) {
+				SPDK_ERRLOG("Failed to set %s = %s\n", config_entry[0], config_entry[1]);
+				rados_shutdown(entry->cluster);
+				goto err_handle;
+			}
+			config_entry += 2;
+		}
+	} else {
+		rc = rados_conf_read_file(entry->cluster, entry->config_file);
+		if (rc < 0) {
+			SPDK_ERRLOG("Failed to read conf file\n");
+			rados_shutdown(entry->cluster);
+			goto err_handle;
+		}
+	}
+
+	rc = rados_connect(entry->cluster);
+	if (rc < 0) {
+		SPDK_ERRLOG("Failed to connect to rbd_pool on cluster=%p\n", entry->cluster);
+		rados_shutdown(entry->cluster);
+		goto err_handle;
+	}
+
+	STAILQ_INSERT_TAIL(&g_map_bdev_rbd_cluster, entry, link);
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+
+	return 0;
+
+err_handle:
+	bdev_rbd_cluster_free(entry);
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+	return -1;
+}
+
+int
+bdev_rbd_unregister_cluster(const char *name)
+{
+	struct bdev_rbd_cluster *entry;
+	int rc = 0;
+
+	if (name == NULL) {
+		return -1;
+	}
+
+	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
+	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+		if (strncmp(name, entry->name, strlen(entry->name)) == 0) {
+			if (entry->ref == 0) {
+				STAILQ_REMOVE(&g_map_bdev_rbd_cluster, entry, bdev_rbd_cluster, link);
+				rados_shutdown(entry->cluster);
+				bdev_rbd_cluster_free(entry);
+			} else {
+				SPDK_ERRLOG("Cluster with name=%p is still used and we cannot delete it\n",
+					    entry->name);
+				rc = -1;
+			}
+
+			pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+			return rc;
+		}
+	}
+
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+
+	SPDK_ERRLOG("Could not find the cluster name =%p\n", name);
+
+	return -1;
+}
+
+static void *
+_bdev_rbd_register_cluster(void *arg)
+{
+	struct cluster_register_info *info = arg;
+	void *ret = arg;
+	int rc;
+
+	rc = rbd_register_cluster((const char *)info->name, (const char *)info->user_id,
+				  (const char *const *)info->config_param, (const char *)info->config_file);
+	if (rc) {
+		ret = NULL;
+	}
+
+	return ret;
+}
+
+int
+bdev_rbd_register_cluster(struct cluster_register_info *info)
+{
+	assert(info != NULL);
+
+	/* Rados cluster info need to be created in non SPDK-thread to avoid CPU
+	 * resource contention */
+	if (spdk_call_unaffinitized(_bdev_rbd_register_cluster, info) == NULL) {
+		return -1;
+	}
+
+	return 0;
+}
+
 int
 bdev_rbd_create(struct spdk_bdev **bdev, const char *name, const char *user_id,
 		const char *pool_name,
diff --git a/module/bdev/rbd/bdev_rbd.h b/module/bdev/rbd/bdev_rbd.h
index 1d16a02db..44c88d436 100644
--- a/module/bdev/rbd/bdev_rbd.h
+++ b/module/bdev/rbd/bdev_rbd.h
@@ -38,6 +38,13 @@
 
 #include "spdk/bdev.h"
 
+struct cluster_register_info {
+	char *name;
+	char *user_id;
+	char **config_param;
+	char *config_file;
+};
+
 void bdev_rbd_free_config(char **config);
 char **bdev_rbd_dup_config(const char *const *config);
 
@@ -65,4 +72,18 @@ void bdev_rbd_delete(struct spdk_bdev *bdev, spdk_delete_rbd_complete cb_fn,
  */
 int bdev_rbd_resize(struct spdk_bdev *bdev, const uint64_t new_size_in_mb);
 
+/**
+ * Create a Rados cluster.
+ *
+ * \param info the info to register the Rados cluster object
+ */
+int bdev_rbd_register_cluster(struct cluster_register_info *info);
+
+/**
+ * Delete a registered cluster.
+ *
+ * \param name the name of the cluster to be deleted.
+ */
+int bdev_rbd_unregister_cluster(const char *name);
+
 #endif /* SPDK_BDEV_RBD_H */
diff --git a/module/bdev/rbd/bdev_rbd_rpc.c b/module/bdev/rbd/bdev_rbd_rpc.c
index ea2a7f463..24e5042c8 100644
--- a/module/bdev/rbd/bdev_rbd_rpc.c
+++ b/module/bdev/rbd/bdev_rbd_rpc.c
@@ -244,3 +244,92 @@ cleanup:
 	free_rpc_bdev_rbd_resize(&req);
 }
 SPDK_RPC_REGISTER("bdev_rbd_resize", rpc_bdev_rbd_resize, SPDK_RPC_RUNTIME)
+
+static void
+free_rpc_register_cluster(struct cluster_register_info *req)
+{
+	free(req->name);
+	free(req->user_id);
+	bdev_rbd_free_config(req->config_param);
+	free(req->config_file);
+}
+
+static const struct spdk_json_object_decoder rpc_register_cluster_decoders[] = {
+	{"name", offsetof(struct cluster_register_info, name), spdk_json_decode_string, true},
+	{"user_id", offsetof(struct cluster_register_info, user_id), spdk_json_decode_string, true},
+	{"config_param", offsetof(struct cluster_register_info, config_param), bdev_rbd_decode_config, true},
+	{"config_file", offsetof(struct cluster_register_info, config_file), bdev_rbd_decode_config, true}
+};
+
+static void
+rpc_bdev_rbd_register_cluster(struct spdk_jsonrpc_request *request,
+			      const struct spdk_json_val *params)
+{
+	struct cluster_register_info req = {};
+	int rc = 0;
+	struct spdk_json_write_ctx *w;
+
+	if (spdk_json_decode_object(params, rpc_register_cluster_decoders,
+				    SPDK_COUNTOF(rpc_register_cluster_decoders),
+				    &req)) {
+		SPDK_DEBUGLOG(bdev_rbd, "spdk_json_decode_object failed\n");
+		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
+						 "spdk_json_decode_object failed");
+		goto cleanup;
+	}
+
+	rc = bdev_rbd_register_cluster(&req);
+	if (rc) {
+		spdk_jsonrpc_send_error_response(request, rc, spdk_strerror(-rc));
+		goto cleanup;
+	}
+
+	w = spdk_jsonrpc_begin_result(request);
+	spdk_json_write_string(w, req.name);
+	spdk_jsonrpc_end_result(request, w);
+cleanup:
+	free_rpc_register_cluster(&req);
+}
+SPDK_RPC_REGISTER("bdev_rbd_register_cluster", rpc_bdev_rbd_register_cluster, SPDK_RPC_RUNTIME)
+
+struct rpc_bdev_rbd_unregister_cluster {
+	char *name;
+};
+
+static void
+free_rpc_bdev_cluster_unregister(struct rpc_bdev_rbd_unregister_cluster *req)
+{
+	free(req->name);
+}
+
+static const struct spdk_json_object_decoder rpc_bdev_rbd_unregister_cluster_decoders[] = {
+	{"name", offsetof(struct rpc_bdev_rbd_unregister_cluster, name), spdk_json_decode_string},
+};
+
+static void
+rpc_bdev_rbd_unregister_cluster(struct spdk_jsonrpc_request *request,
+				const struct spdk_json_val *params)
+{
+	struct rpc_bdev_rbd_unregister_cluster req = {NULL};
+	int rc;
+
+	if (spdk_json_decode_object(params, rpc_bdev_rbd_unregister_cluster_decoders,
+				    SPDK_COUNTOF(rpc_bdev_rbd_unregister_cluster_decoders),
+				    &req)) {
+		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
+						 "spdk_json_decode_object failed");
+		goto cleanup;
+	}
+
+	rc = bdev_rbd_unregister_cluster(req.name);
+	if (rc) {
+		spdk_jsonrpc_send_error_response(request, rc, spdk_strerror(-rc));
+		goto cleanup;
+	}
+
+	spdk_jsonrpc_send_bool_response(request, true);
+
+cleanup:
+	free_rpc_bdev_cluster_unregister(&req);
+}
+SPDK_RPC_REGISTER("bdev_rbd_unregister_cluster", rpc_bdev_rbd_unregister_cluster, SPDK_RPC_RUNTIME)
diff --git a/scripts/rpc.py b/scripts/rpc.py
index ae6bcfafe..28824ab9f 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -629,6 +629,38 @@ if __name__ == "__main__":
     p.add_argument('name', help='Virtual zone bdev name')
     p.set_defaults(func=bdev_zone_block_delete)
 
+    def bdev_rbd_register_cluster(args):
+        config_param = None
+        if args.config_param:
+            config_param = {}
+            for entry in args.config:
+                parts = entry.split('=', 1)
+                if len(parts) != 2:
+                    raise Exception('--config %s not in key=value form' % entry)
+                config_param[parts[0]] = parts[1]
+        print_json(rpc.bdev.bdev_rbd_register_cluster(args.client,
+                                                      name=args.name,
+                                                      user=args.user,
+                                                      config_param=config_param,
+                                                      config_file=args.config_file))
+
+    p = subparsers.add_parser('bdev_rbd_register_cluster',
+                              help='Add a Rados cluster with ceph rbd backend')
+    p.add_argument('name', help="Name of the Rados cluster only known to rbd bdev")
+    p.add_argument('--user', help="Ceph user name (i.e. admin, not client.admin)", required=False)
+    p.add_argument('--config_param', action='append', metavar='key=value',
+                   help="adds a key=value configuration option for rados_conf_set (default: rely on config file)")
+    p.add_argument('--config_file', help="The file path of the Rados configuration file", required=False)
+    p.set_defaults(func=bdev_rbd_register_cluster)
+
+    def bdev_rbd_unregister_cluster(args):
+        rpc.bdev.bdev_rbd_unregister_cluster(args.client, name=args.name)
+
+    p = subparsers.add_parser('bdev_rbd_unregister_cluster',
+                              help='Unregister a Rados cluster object')
+    p.add_argument('name', help='Name of the Rados Cluster only known to rbd bdev')
+    p.set_defaults(func=bdev_rbd_unregister_cluster)
+
     def bdev_rbd_create(args):
         config = None
         if args.config:
diff --git a/scripts/rpc/bdev.py b/scripts/rpc/bdev.py
index 83cb1eb60..b30b5c32a 100644
--- a/scripts/rpc/bdev.py
+++ b/scripts/rpc/bdev.py
@@ -659,6 +659,40 @@ def bdev_zone_block_delete(client, name):
     return client.call('bdev_zone_block_delete', params)
 
 
+def bdev_rbd_register_cluster(client, name, user=None, config_param=None, config_file=None):
+    """Create a Rados Cluster object of the Ceph RBD backend.
+
+    Args:
+        name: name of Rados Cluster
+        user: Ceph user name (optional)
+        config_param: map of config keys to values (optional)
+        config_file: file path of Ceph configuration file (optional)
+
+    Returns:
+        Name of registered Rados Cluster object.
+    """
+    params = {'name': name}
+
+    if user is not None:
+        params['user_id'] = user
+    if config_param is not None:
+        params['config_param'] = config_param
+    if config_file is not None:
+        params['config_file'] = config_file
+
+    return client.call('bdev_rbd_register_cluster', params)
+
+
+def bdev_rbd_unregister_cluster(client, name):
+    """Remove Rados cluster object from the system.
+
+    Args:
+        name: name of Rados cluster object to unregister
+    """
+    params = {'name': name}
+    return client.call('bdev_rbd_unregister_cluster', params)
+
+
 @deprecated_alias('construct_rbd_bdev')
 def bdev_rbd_create(client, pool_name, rbd_name, block_size, name=None, user=None, config=None):
     """Create a Ceph RBD block device.
-- 
2.26.2


From d92a67be47404c4fa5e50993e587e19317530b61 Mon Sep 17 00:00:00 2001
From: Richael Zhuang <richael.zhuang@arm.com>
Date: Tue, 11 May 2021 14:01:42 +0800
Subject: [PATCH 142/342] spdk_top: fix display of core_freq

When running scheduler/interrupt.sh, the core_freq displayed from
refresh_cores_tab() and show_core() mismatch for lcore 1. We should
get core_freq from cores[] array which has been qsort.

Change-Id: I4eba9b023cfa00700ab82c679d42fff22b85be46
Signed-off-by: Richael Zhuang <richael.zhuang@arm.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7854
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 app/spdk_top/spdk_top.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index 84a2e20a3..fca9da36c 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -137,6 +137,7 @@ struct core_info {
 	uint64_t last_idle;
 	uint64_t busy;
 	uint64_t last_busy;
+	uint32_t core_freq;
 };
 
 uint8_t g_sleep_time = 1;
@@ -1389,6 +1390,7 @@ refresh_cores_tab(uint8_t current_page)
 		cores[core_num].core = core_num;
 		cores[core_num].busy = g_cores_stats.cores.core[i].busy;
 		cores[core_num].idle = g_cores_stats.cores.core[i].idle;
+		cores[core_num].core_freq = g_cores_stats.cores.core[i].core_freq;
 		if (last_page != current_page) {
 			store_core_last_stats(cores[core_num].core, cores[core_num].idle, cores[core_num].busy);
 		}
@@ -1459,11 +1461,11 @@ refresh_cores_tab(uint8_t current_page)
 		}
 
 		if (!col_desc[5].disabled) {
-			if (!g_cores_stats.cores.core[core_num].core_freq) {
+			if (!cores[core_num].core_freq) {
 				snprintf(core_freq,  MAX_CORE_FREQ_STR_LEN, "%s", "N/A");
 			} else {
 				snprintf(core_freq, MAX_CORE_FREQ_STR_LEN, "%" PRIu32,
-					 g_cores_stats.cores.core[core_num].core_freq);
+					 cores[core_num].core_freq);
 			}
 			print_max_len(g_tabs[CORES_TAB], TABS_DATA_START_ROW + item_index, offset,
 				      col_desc[5].max_data_string, ALIGN_RIGHT, core_freq);
-- 
2.26.2


From da9766336eff2c855fab067e282180d236176034 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 13 May 2021 15:31:54 +0000
Subject: [PATCH 143/342] nvmf: delay remove subsystem cb until no qpairs
 remain

We cannot solely rely on the qpair_ctx->count reaching
0, because qpairs that are in process of being
disconnected will immediately invoke the qpair
disconnect cb.

Instead, we need to wait until the poll group
no longer has any qpairs remaining on the subsystem.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I977747d367d14a4bf60f66a1147b3d75679e5179
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7870
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/nvmf/nvmf.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/lib/nvmf/nvmf.c b/lib/nvmf/nvmf.c
index acaf9ef74..a04beee78 100644
--- a/lib/nvmf/nvmf.c
+++ b/lib/nvmf/nvmf.c
@@ -1364,6 +1364,8 @@ fini:
 	}
 }
 
+static void nvmf_poll_group_remove_subsystem_msg(void *ctx);
+
 static void
 remove_subsystem_qpair_cb(void *ctx)
 {
@@ -1372,7 +1374,12 @@ remove_subsystem_qpair_cb(void *ctx)
 	assert(qpair_ctx->count > 0);
 	qpair_ctx->count--;
 	if (qpair_ctx->count == 0) {
-		_nvmf_poll_group_remove_subsystem_cb(ctx, 0);
+		/* All of the asynchronous callbacks for this context have been
+		 * completed.  Call nvmf_poll_group_remove_subsystem_msg() again
+		 * to check if all associated qpairs for this subsystem have
+		 * been removed from the poll group.
+		 */
+		nvmf_poll_group_remove_subsystem_msg(ctx);
 	}
 }
 
@@ -1383,6 +1390,7 @@ nvmf_poll_group_remove_subsystem_msg(void *ctx)
 	struct spdk_nvmf_subsystem *subsystem;
 	struct spdk_nvmf_poll_group *group;
 	struct nvmf_qpair_disconnect_many_ctx *qpair_ctx = ctx;
+	bool qpairs_found = false;
 	int rc = 0;
 
 	group = qpair_ctx->group;
@@ -1390,12 +1398,13 @@ nvmf_poll_group_remove_subsystem_msg(void *ctx)
 
 	/* Initialize count to 1.  This acts like a ref count, to ensure that if spdk_nvmf_qpair_disconnect
 	 * immediately invokes the callback (i.e. the qpairs is already in process of being disconnected)
-	 * that we don't prematurely call _nvmf_poll_group_remove_subsystem_cb() before we've
-	 * iterated the full list of qpairs.
+	 * that we don't recursively call nvmf_poll_group_remove_subsystem_msg before we've iterated the
+	 * full list of qpairs.
 	 */
 	qpair_ctx->count = 1;
 	TAILQ_FOREACH_SAFE(qpair, &group->qpairs, link, qpair_tmp) {
 		if ((qpair->ctrlr != NULL) && (qpair->ctrlr->subsys == subsystem)) {
+			qpairs_found = true;
 			qpair_ctx->count++;
 			rc = spdk_nvmf_qpair_disconnect(qpair, remove_subsystem_qpair_cb, ctx);
 			if (rc) {
@@ -1405,8 +1414,19 @@ nvmf_poll_group_remove_subsystem_msg(void *ctx)
 	}
 	qpair_ctx->count--;
 
+	if (!qpairs_found) {
+		_nvmf_poll_group_remove_subsystem_cb(ctx, 0);
+		return;
+	}
+
 	if (qpair_ctx->count == 0 || rc) {
-		_nvmf_poll_group_remove_subsystem_cb(ctx, rc);
+		/* If count == 0, it means there were some qpairs in the poll group but they
+		 * were already in process of being disconnected.  So we send a message to this
+		 * same thread so that this function executes again later.  We won't actually
+		 * invoke the remove_subsystem_cb until all of the qpairs are actually removed
+		 * from the poll group.
+		 */
+		spdk_thread_send_msg(spdk_get_thread(), nvmf_poll_group_remove_subsystem_msg, ctx);
 	}
 }
 
-- 
2.26.2


From 199fa6015d774e265ccec87ae99d9e36e62f9045 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 6 May 2021 21:20:45 +0000
Subject: [PATCH 144/342] util: add zipf random number generator

zipf is a power law probability distribution. When
applied to performance testing of block devices, it
will select blocks over the full range of LBAs, but
will more frequently select lower-numbered LBAs.
The theta parameter governs the distribution - higher
values of theta will concentrate the distribution on
a smaller number of LBAs.

Note that fio supports zipf, so adding it to SPDK
will enable our perf tools (bdevperf, nvme-perf) to
provide similar functionality.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I7df129c9d61996a2070188c6cd9f1fde631ac208
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7779
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 include/spdk/stdinc.h  |   1 +
 include/spdk/zipf.h    |  83 ++++++++++++++++++++++++
 lib/util/Makefile      |   4 +-
 lib/util/spdk_util.map |   5 ++
 lib/util/zipf.c        | 139 +++++++++++++++++++++++++++++++++++++++++
 mk/spdk.common.mk      |   1 +
 6 files changed, 231 insertions(+), 2 deletions(-)
 create mode 100644 include/spdk/zipf.h
 create mode 100644 lib/util/zipf.c

diff --git a/include/spdk/stdinc.h b/include/spdk/stdinc.h
index 65820d58e..f7501f820 100644
--- a/include/spdk/stdinc.h
+++ b/include/spdk/stdinc.h
@@ -50,6 +50,7 @@ extern "C" {
 #include <errno.h>
 #include <inttypes.h>
 #include <limits.h>
+#include <math.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stddef.h>
diff --git a/include/spdk/zipf.h b/include/spdk/zipf.h
new file mode 100644
index 000000000..d68c417b7
--- /dev/null
+++ b/include/spdk/zipf.h
@@ -0,0 +1,83 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file
+ * Zipf random number distribution
+ */
+
+#ifndef SPDK_ZIPF_H
+#define SPDK_ZIPF_H
+
+#include "spdk/stdinc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct spdk_zipf;
+
+/**
+ * Create a zipf random number generator.
+ *
+ * Numbers from [0, range) will be returned by the generator when
+ * calling \ref spdk_zipf_generate.
+ *
+ * \param range Range of values for the zipf distribution.
+ * \param theta Theta distribution parameter.
+ * \param seed Seed value for the random number generator.
+ *
+ * \return a pointer to the new zipf generator.
+ */
+struct spdk_zipf *spdk_zipf_create(uint64_t range, double theta, uint32_t seed);
+
+/**
+ * Free a zipf generator and set the pointer to NULL.
+ *
+ * \param zipfp Zipf generator to free.
+ */
+void spdk_zipf_free(struct spdk_zipf **zipfp);
+
+/**
+ * Generate a value from the zipf generator.
+ *
+ * \param zipf Zipf generator to generate the value from.
+ *
+ * \return value in the range [0, range)
+ */
+uint64_t spdk_zipf_generate(struct spdk_zipf *zipf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/lib/util/Makefile b/lib/util/Makefile
index f4eb147c2..f08543de6 100644
--- a/lib/util/Makefile
+++ b/lib/util/Makefile
@@ -35,11 +35,11 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 SO_VER := 3
-SO_MINOR := 0
+SO_MINOR := 1
 
 C_SRCS = base64.c bit_array.c cpuset.c crc16.c crc32.c crc32c.c crc32_ieee.c \
 	 dif.c fd.c file.c iov.c math.c pipe.c strerror_tls.c string.c uuid.c \
-	 fd_group.c
+	 fd_group.c zipf.c
 LIBNAME = util
 LOCAL_SYS_LIBS = -luuid
 
diff --git a/lib/util/spdk_util.map b/lib/util/spdk_util.map
index 31b191af0..f182f423f 100644
--- a/lib/util/spdk_util.map
+++ b/lib/util/spdk_util.map
@@ -144,5 +144,10 @@
 	spdk_fd_group_event_modify;
 	spdk_fd_group_get_fd;
 
+	# public functions in zipf.h
+	spdk_zipf_create;
+	spdk_zipf_free;
+	spdk_zipf_generate;
+
 	local: *;
 };
diff --git a/lib/util/zipf.c b/lib/util/zipf.c
new file mode 100644
index 000000000..e7a1106bd
--- /dev/null
+++ b/lib/util/zipf.c
@@ -0,0 +1,139 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright(c) Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "spdk/stdinc.h"
+#include "spdk/util.h"
+#include "spdk/zipf.h"
+
+struct spdk_zipf {
+	uint64_t	range;
+	double		alpha;
+	double		eta;
+	double		theta;
+	double		zetan;
+	double		val1_limit;
+	uint32_t	seed;
+};
+
+static double
+zeta_increment(uint64_t n, double theta)
+{
+	return pow((double) 1.0 / (n + 1), theta);
+}
+
+static double
+zeta(uint64_t range, double theta)
+{
+	double zetan = 0;
+	double inc1, inc2;
+	uint64_t i, calc, count;
+	const uint32_t ZIPF_MAX_ZETA_CALC = 10 * 1000 * 1000;
+	const uint32_t ZIPF_ZETA_ESTIMATE = 1 * 1000 * 1000;
+
+	/* Cumulate zeta discretely for the first ZIPF_MAX_ZETA_CALC
+	 * entries in the range.
+	 */
+	calc = spdk_min(ZIPF_MAX_ZETA_CALC, range);
+	for (i = 0; i < calc; i++) {
+		zetan += zeta_increment(i, theta);
+	}
+
+	/* For the remaining values in the range, increment zetan
+	 * with an approximation for every ZIPF_ZETA_ESTIMATE
+	 * entries.  We will take an average of the increment
+	 * for (i) and (i + ZIPF_ZETA_ESTIMATE), and then multiply
+	 * that by ZIPF_ZETA_ESTIMATE.
+	 *
+	 * Of course, we'll cap ZIPF_ZETA_ESTIMATE to something
+	 * smaller if necessary at the end of the range.
+	 */
+	while (i < range) {
+		count = spdk_min(ZIPF_ZETA_ESTIMATE, range - i);
+		inc1 = zeta_increment(i, theta);
+		inc2 = zeta_increment(i + count, theta);
+		zetan += (inc1 + inc2) * count / 2;
+		i += count;
+	}
+
+	return zetan;
+}
+
+struct spdk_zipf *
+spdk_zipf_create(uint64_t range, double theta, uint32_t seed)
+{
+	struct spdk_zipf *zipf;
+
+	zipf = calloc(1, sizeof(*zipf));
+	if (zipf == NULL) {
+		return NULL;
+	}
+
+	zipf->range = range;
+	zipf->seed = seed;
+
+	zipf->theta = theta;
+	zipf->alpha = 1.0 / (1.0 - zipf->theta);
+	zipf->zetan = zeta(range, theta);
+	zipf->eta = (1.0 - pow(2.0 / zipf->range, 1.0 - zipf->theta)) /
+		    (1.0 - zeta(2, theta) / zipf->zetan);
+	zipf->val1_limit = 1.0 + pow(0.5, zipf->theta);
+
+	return zipf;
+}
+
+void
+spdk_zipf_free(struct spdk_zipf **zipfp)
+{
+	assert(zipfp != NULL);
+	free(*zipfp);
+	*zipfp = NULL;
+}
+
+uint64_t
+spdk_zipf_generate(struct spdk_zipf *zipf)
+{
+	double randu, randz;
+	uint64_t val;
+
+	randu = (double)rand_r(&zipf->seed) / RAND_MAX;
+	randz = randu * zipf->zetan;
+
+	if (randz < 1.0) {
+		return 0;
+	} else if (randz < zipf->val1_limit) {
+		return 1;
+	} else {
+		val = zipf->range * pow(zipf->eta * (randu - 1.0) + 1.0, zipf->alpha);
+		return val % zipf->range;
+	}
+}
diff --git a/mk/spdk.common.mk b/mk/spdk.common.mk
index e3f7b3a75..d3bf5689b 100644
--- a/mk/spdk.common.mk
+++ b/mk/spdk.common.mk
@@ -295,6 +295,7 @@ CXXFLAGS += $(COMMON_CFLAGS)
 SYS_LIBS += -lrt
 SYS_LIBS += -luuid
 SYS_LIBS += -lcrypto
+SYS_LIBS += -lm
 
 ifneq ($(CONFIG_NVME_CUSE)$(CONFIG_FUSE),nn)
 SYS_LIBS += -lfuse3
-- 
2.26.2


From afc432ba9635eabb2352688a3e06c89e2356e8c4 Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Mon, 17 May 2021 08:55:21 +0000
Subject: [PATCH 145/342] bdev/fio_plugin: implement support for fio
 .get_max_open_zones callback

Implement support for the recently added fio .get_max_open_zones callback.

If our ioengine does not implement this callback, fio will always result
in an error when using --zonemode=zbd, on platforms which does not have a
fio oslib implementation for this callback, e.g. FreeBSD.

On Linux, fio will by default try to parse sysfs, which will of course not
work on SPDK.

Implement this callback so that our ioengine will be able to provide fio
with the proper max open zones limit.

This will ensure that fio will be able to fetch the proper max open zones
limit, regardless of OS.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: Ia9c281290e11e4204d270ba4090edb73212ce20f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7896
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 examples/bdev/fio_plugin/README.md    |  3 +++
 examples/bdev/fio_plugin/fio_plugin.c | 21 +++++++++++++++++++++
 2 files changed, 24 insertions(+)

diff --git a/examples/bdev/fio_plugin/README.md b/examples/bdev/fio_plugin/README.md
index ee9519926..7794cd539 100644
--- a/examples/bdev/fio_plugin/README.md
+++ b/examples/bdev/fio_plugin/README.md
@@ -94,6 +94,9 @@ state at any point in time. It is very important to not exceed this limit.
 You can control how many zones fio will keep in an open state by using the
 ``--max_open_zones`` option.
 
+If you use a fio version newer than 3.26, fio will automatically detect and set the proper value.
+If you use an old version of fio, make sure to provide the proper --max_open_zones value yourself.
+
 ## Maximum Active Zones
 
 Zoned block devices may also have a resource constraint on the number of zones that can be active at
diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index fba1ea2dd..2ce5c8104 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -1067,6 +1067,24 @@ spdk_fio_reset_wp(struct thread_data *td, struct fio_file *f, uint64_t offset, u
 }
 #endif
 
+#if FIO_IOOPS_VERSION >= 30
+static int spdk_fio_get_max_open_zones(struct thread_data *td, struct fio_file *f,
+				       unsigned int *max_open_zones)
+{
+	struct spdk_bdev *bdev;
+
+	bdev = spdk_bdev_get_by_name(f->file_name);
+	if (!bdev) {
+		SPDK_ERRLOG("Cannot get max open zones, no bdev with name: %s\n", f->file_name);
+		return -ENODEV;
+	}
+
+	*max_open_zones = spdk_bdev_get_max_open_zones(bdev);
+
+	return 0;
+}
+#endif
+
 static int
 spdk_fio_handle_options(struct thread_data *td, struct fio_file *f, struct spdk_bdev *bdev)
 {
@@ -1203,6 +1221,9 @@ struct ioengine_ops ioengine = {
 	.get_zoned_model	= spdk_fio_get_zoned_model,
 	.report_zones		= spdk_fio_report_zones,
 	.reset_wp		= spdk_fio_reset_wp,
+#endif
+#if FIO_IOOPS_VERSION >= 30
+	.get_max_open_zones	= spdk_fio_get_max_open_zones,
 #endif
 	.option_struct_size	= sizeof(struct spdk_fio_options),
 	.options		= options,
-- 
2.26.2


From ddf27c3d15141f0ed793ddb3460fb67aa1369ba7 Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Mon, 17 May 2021 10:23:34 +0000
Subject: [PATCH 146/342] nvme/fio_plugin: move get_fio_qpair() out of ifdef
 and reuse it

Move get_fio_qpair() out of ifdef and reuse it in spdk_fio_queue(),
since the code is next to identical.
The only difference is that get_fio_qpair() returns NULL if qpair->ns
is not set.

Since we know that get_fio_qpair() returns NULL if qpair>ns is not set,
we can also remove the equivalent check in spdk_fio_queue().

Also use ns pointer instead of qpair->ns pointer in two other places
in spdk_fio_queue().

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: Ie647a814ff0b7a6f2bb81cbc9d7e95537fbe5256
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7897
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 examples/nvme/fio_plugin/fio_plugin.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/examples/nvme/fio_plugin/fio_plugin.c b/examples/nvme/fio_plugin/fio_plugin.c
index c09b8993f..6e9c16a71 100644
--- a/examples/nvme/fio_plugin/fio_plugin.c
+++ b/examples/nvme/fio_plugin/fio_plugin.c
@@ -241,7 +241,6 @@ get_fio_ctrlr(const struct spdk_nvme_transport_id *trid)
 	return NULL;
 }
 
-#if FIO_HAS_ZBD
 /**
  * Returns the fio_qpair matching the given fio_file and has an associated ns
  */
@@ -259,6 +258,7 @@ get_fio_qpair(struct spdk_fio_thread *fio_thread, struct fio_file *f)
 	return NULL;
 }
 
+#if FIO_HAS_ZBD
 /**
  * Callback function to use while processing completions until completion-indicator turns non-zero
  */
@@ -988,16 +988,12 @@ spdk_fio_queue(struct thread_data *td, struct io_u *io_u)
 	uint64_t		lba;
 	uint32_t		lba_count;
 
-	/* Find the namespace that corresponds to the file in the io_u */
-	TAILQ_FOREACH(fio_qpair, &fio_thread->fio_qpair, link) {
-		if (fio_qpair->f == io_u->file) {
-			ns = fio_qpair->ns;
-			break;
-		}
-	}
-	if (fio_qpair == NULL || ns == NULL) {
+	fio_qpair = get_fio_qpair(fio_thread, io_u->file);
+	if (fio_qpair == NULL) {
 		return -ENXIO;
 	}
+	ns = fio_qpair->ns;
+
 	if (fio_qpair->nvme_pi_enabled && !fio_qpair->extended_lba) {
 		md_buf = fio_req->md_buf;
 	}
@@ -1041,7 +1037,7 @@ spdk_fio_queue(struct thread_data *td, struct io_u *io_u)
 								    spdk_fio_completion_cb, fio_req,
 								    fio_qpair->io_flags, dif_ctx->apptag_mask, dif_ctx->app_tag);
 			} else {
-				uint64_t zslba = fio_offset_to_zslba(io_u->offset, fio_qpair->ns);
+				uint64_t zslba = fio_offset_to_zslba(io_u->offset, ns);
 				rc = spdk_nvme_zns_zone_append_with_md(ns, fio_qpair->qpair, io_u->buf, md_buf, zslba,
 								       lba_count,
 								       spdk_fio_completion_cb, fio_req,
@@ -1054,7 +1050,7 @@ spdk_fio_queue(struct thread_data *td, struct io_u *io_u)
 								     spdk_nvme_io_reset_sgl, spdk_nvme_io_next_sge, md_buf,
 								     dif_ctx->apptag_mask, dif_ctx->app_tag);
 			} else {
-				uint64_t zslba = fio_offset_to_zslba(io_u->offset, fio_qpair->ns);
+				uint64_t zslba = fio_offset_to_zslba(io_u->offset, ns);
 				rc = spdk_nvme_zns_zone_appendv_with_md(ns, fio_qpair->qpair, zslba,
 									lba_count, spdk_fio_completion_cb, fio_req, fio_qpair->io_flags,
 									spdk_nvme_io_reset_sgl, spdk_nvme_io_next_sge, md_buf,
-- 
2.26.2


From 6e57273783c9785b75808f7fbbed68606a3c71fa Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Mon, 17 May 2021 10:42:54 +0000
Subject: [PATCH 147/342] nvme/fio_plugin: implement support for fio
 .get_max_open_zones callback

Implement support for the recently added fio .get_max_open_zones callback.

If our ioengine does not implement this callback, fio will always result
in an error when using --zonemode=zbd, on platforms which does not have a
fio oslib implementation for this callback, e.g. FreeBSD.

On Linux, fio will by default try to parse sysfs, which will of course not
work on SPDK.

Implement this callback so that our ioengine will be able to provide fio
with the proper max open zones limit.

This will ensure that fio will be able to fetch the proper max open zones
limit, regardless of OS.

While our SPDK nvme ioengine did overwrite the max_open_zones option if it
was set to zero, this is a bit of a hack. The new fio callback is the
proper way to inform fio about the max open zones limit, so that fio itself
can have access to the actual device limit.
(Just overwriting the requested max_open_zones option will not allow fio
to know if the requested max_open_zones option exceeds the device limit.)
Remove the SPDK specific hack and update our README.md accordingly.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: I532a0fa065b9e215ee6229b9100135e5403f198e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7898
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 examples/nvme/fio_plugin/README.md    |  3 +-
 examples/nvme/fio_plugin/fio_plugin.c | 45 +++++++++++++--------------
 2 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/examples/nvme/fio_plugin/README.md b/examples/nvme/fio_plugin/README.md
index 445573ae2..4242c7404 100644
--- a/examples/nvme/fio_plugin/README.md
+++ b/examples/nvme/fio_plugin/README.md
@@ -125,7 +125,8 @@ Zoned Namespaces has a resource constraint on the amount of zones which can be i
 any point in time. You can control how many zones fio will keep in an open state by using the
 ``--max_open_zones`` option.
 
-The SPDK/NVMe fio io-engine will set a default value if you do not provide one.
+If you use a fio version newer than 3.26, fio will automatically detect and set the proper value.
+If you use an old version of fio, make sure to provide the proper --max_open_zones value yourself.
 
 ## Maximum Active Zones
 
diff --git a/examples/nvme/fio_plugin/fio_plugin.c b/examples/nvme/fio_plugin/fio_plugin.c
index 6e9c16a71..c169e6e72 100644
--- a/examples/nvme/fio_plugin/fio_plugin.c
+++ b/examples/nvme/fio_plugin/fio_plugin.c
@@ -1186,29 +1186,6 @@ spdk_fio_get_zoned_model(struct thread_data *td, struct fio_file *f, enum zbd_zo
 
 		*model = ZBD_HOST_MANAGED;
 
-		/** Unlimited open resources, skip checking 'max_open_zones' */
-		if (0xFFFFFFFF == zns_data->mor) {
-			return 0;
-		}
-
-		if (!td->o.max_open_zones) {
-			td->o.max_open_zones = spdk_min(ZBD_MAX_OPEN_ZONES, zns_data->mor + 1);
-			log_info("spdk/nvme: parameter 'max_open_zones' was unset; assigned: %d.\n",
-				 td->o.max_open_zones);
-		} else if (td->o.max_open_zones < 0) {
-			log_err("spdk/nvme: invalid parameter 'max_open_zones': %d\n",
-				td->o.max_open_zones);
-			return -EINVAL;
-		} else if (td->o.max_open_zones > ZBD_MAX_OPEN_ZONES) {
-			log_err("spdk/nvme: parameter 'max_open_zones': %d exceeds fio-limit: %d\n",
-				td->o.max_open_zones, ZBD_MAX_OPEN_ZONES);
-			return -EINVAL;
-		} else if ((uint32_t)td->o.max_open_zones > (zns_data->mor + 1)) {
-			log_err("spdk/nvme: parameter 'max_open_zones': %d exceeds dev-limit: %u\n",
-				td->o.max_open_zones, zns_data->mor + 1);
-			return -EINVAL;
-		}
-
 		return 0;
 	}
 
@@ -1378,6 +1355,25 @@ spdk_fio_reset_wp(struct thread_data *td, struct fio_file *f, uint64_t offset, u
 }
 #endif
 
+#if FIO_IOOPS_VERSION >= 30
+static int spdk_fio_get_max_open_zones(struct thread_data *td, struct fio_file *f,
+				       unsigned int *max_open_zones)
+{
+	struct spdk_fio_thread *fio_thread = td->io_ops_data;
+	struct spdk_fio_qpair *fio_qpair = NULL;
+
+	fio_qpair = get_fio_qpair(fio_thread, f);
+	if (!fio_qpair) {
+		log_err("spdk/nvme: no ns/qpair or file_name: '%s'\n", f->file_name);
+		return -ENODEV;
+	}
+
+	*max_open_zones = spdk_nvme_zns_ns_get_max_open_zones(fio_qpair->ns);
+
+	return 0;
+}
+#endif
+
 static void spdk_fio_cleanup(struct thread_data *td)
 {
 	struct spdk_fio_thread	*fio_thread = td->io_ops_data;
@@ -1669,6 +1665,9 @@ struct ioengine_ops ioengine = {
 	.get_zoned_model	= spdk_fio_get_zoned_model,
 	.report_zones		= spdk_fio_report_zones,
 	.reset_wp		= spdk_fio_reset_wp,
+#endif
+#if FIO_IOOPS_VERSION >= 30
+	.get_max_open_zones	= spdk_fio_get_max_open_zones,
 #endif
 	.flags			= FIO_RAWIO | FIO_NOEXTEND | FIO_NODISKUTIL | FIO_MEMALIGN,
 	.options		= options,
-- 
2.26.2


From 99550a756d38c33c730d7b2c3a93d1287869b47c Mon Sep 17 00:00:00 2001
From: Niklas Cassel <niklas.cassel@wdc.com>
Date: Tue, 18 May 2021 07:35:01 +0000
Subject: [PATCH 148/342] bdev/fio_plugin: fix typo in README.md

The definition is that:
max active zones >= max open zones.

The REAME.md incorrectly writes max active twice.
Fix this typo in the README.md.

Signed-off-by: Niklas Cassel <niklas.cassel@wdc.com>
Change-Id: I4b7d24d7bd1efcbe1608d3ee04d8900f83857f5e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7912
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 examples/bdev/fio_plugin/README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/examples/bdev/fio_plugin/README.md b/examples/bdev/fio_plugin/README.md
index 7794cd539..aaa65e64e 100644
--- a/examples/bdev/fio_plugin/README.md
+++ b/examples/bdev/fio_plugin/README.md
@@ -103,7 +103,7 @@ Zoned block devices may also have a resource constraint on the number of zones t
 any point in time. Unlike ``max_open_zones``, fio currently does not manage this constraint, and
 there is thus no option to limit it either.
 
-Since the max active zones limit (by definition) has to be greater than or equal to the max active
+Since the max active zones limit (by definition) has to be greater than or equal to the max open
 zones limit, the easiest way to work around that fio does not manage this constraint, is to start
 with a clean state each run (except for read-only workloads), by resetting all zones before fio
 starts running its jobs by using the engine option:
-- 
2.26.2


From 75f9a150a6408478911bb82cd19d75f1e9cb827e Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Sat, 8 May 2021 13:45:20 +0800
Subject: [PATCH 149/342] test/nvme_pcie_common: cases for creating and
 deleting IO queue

Change-Id: I79237a63b0f3b414cb3300bf41ee6193ce35e60f
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7632
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 .../nvme_pcie_common.c/nvme_pcie_common_ut.c  | 76 +++++++++++++++++++
 1 file changed, 76 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
index 16ffdf996..7c5f8152b 100644
--- a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
@@ -212,6 +212,81 @@ test_nvme_pcie_qpair_construct_destroy(void)
 	MOCK_CLEAR(spdk_vtophys);
 }
 
+static void
+test_nvme_pcie_ctrlr_cmd_create_delete_io_queue(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct nvme_pcie_qpair pqpair = {};
+	struct spdk_nvme_qpair adminq = {};
+	struct nvme_request req = {};
+	int rc;
+
+	ctrlr.adminq = &adminq;
+	STAILQ_INIT(&ctrlr.adminq->free_req);
+	STAILQ_INSERT_HEAD(&ctrlr.adminq->free_req, &req, stailq);
+	pqpair.qpair.id = 1;
+	pqpair.num_entries = 1;
+	pqpair.cpl_bus_addr = 0xDEADBEEF;
+	pqpair.cmd_bus_addr = 0xDDADBEEF;
+	pqpair.qpair.qprio = SPDK_NVME_QPRIO_HIGH;
+
+	rc = nvme_pcie_ctrlr_cmd_create_io_cq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_CREATE_IO_CQ);
+	CU_ASSERT(req.cmd.cdw10_bits.create_io_q.qid == 1);
+	CU_ASSERT(req.cmd.cdw10_bits.create_io_q.qsize == 0);
+	CU_ASSERT(req.cmd.cdw11_bits.create_io_cq.pc == 1);
+	CU_ASSERT(req.cmd.dptr.prp.prp1 == 0xDEADBEEF);
+	CU_ASSERT(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+
+	memset(&req, 0, sizeof(req));
+	STAILQ_INSERT_HEAD(&ctrlr.adminq->free_req, &req, stailq);
+
+	rc = nvme_pcie_ctrlr_cmd_create_io_sq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_CREATE_IO_SQ);
+	CU_ASSERT(req.cmd.cdw10_bits.create_io_q.qid == 1);
+	CU_ASSERT(req.cmd.cdw10_bits.create_io_q.qsize == 0);
+	CU_ASSERT(req.cmd.cdw11_bits.create_io_sq.pc == 1);
+	CU_ASSERT(req.cmd.cdw11_bits.create_io_sq.qprio == SPDK_NVME_QPRIO_HIGH);
+	CU_ASSERT(req.cmd.cdw11_bits.create_io_sq.cqid = 1);
+	CU_ASSERT(req.cmd.dptr.prp.prp1 == 0xDDADBEEF);
+	CU_ASSERT(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+
+	/* No free request available */
+	rc = nvme_pcie_ctrlr_cmd_create_io_cq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == -ENOMEM);
+
+	rc = nvme_pcie_ctrlr_cmd_create_io_sq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == -ENOMEM);
+
+	/* Delete cq or sq */
+	memset(&req, 0, sizeof(req));
+	STAILQ_INSERT_HEAD(&ctrlr.adminq->free_req, &req, stailq);
+
+	rc = nvme_pcie_ctrlr_cmd_delete_io_cq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_DELETE_IO_CQ);
+	CU_ASSERT(req.cmd.cdw10_bits.delete_io_q.qid == 1);
+	CU_ASSERT(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+
+	memset(&req, 0, sizeof(req));
+	STAILQ_INSERT_HEAD(&ctrlr.adminq->free_req, &req, stailq);
+
+	rc = nvme_pcie_ctrlr_cmd_delete_io_sq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_DELETE_IO_SQ);
+	CU_ASSERT(req.cmd.cdw10_bits.delete_io_q.qid == 1);
+	CU_ASSERT(STAILQ_EMPTY(&ctrlr.adminq->free_req));
+
+	/* No free request available */
+	rc = nvme_pcie_ctrlr_cmd_delete_io_cq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == -ENOMEM);
+
+	rc = nvme_pcie_ctrlr_cmd_delete_io_sq(&ctrlr, &pqpair.qpair, NULL, NULL);
+	CU_ASSERT(rc == -ENOMEM);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -223,6 +298,7 @@ int main(int argc, char **argv)
 	suite = CU_add_suite("nvme_pcie_common", NULL, NULL);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_alloc_cmb);
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_construct_destroy);
+	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_cmd_create_delete_io_queue);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 861bf2d1c3695533b794c917a960376c5db4650b Mon Sep 17 00:00:00 2001
From: Krishna Kanth Reddy <krish.reddy@samsung.com>
Date: Fri, 30 Apr 2021 14:56:21 +0530
Subject: [PATCH 150/342] test/nvme: Add test application to verify Simple Copy
 Command support

Signed-off-by: Krishna Kanth Reddy <krish.reddy@samsung.com>
Change-Id: I7bf61d98c444b473ec73f6afaf31ac408af6e409
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7696
Community-CI: Broadcom CI
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 autotest.sh                         |   3 +
 test/common/autotest_common.sh      |   2 +
 test/common/config/pkgdep/git       |   1 +
 test/common/config/vm_setup.sh      |   1 +
 test/common/skipped_tests.txt       |   4 +
 test/nvme/Makefile                  |   2 +-
 test/nvme/nvme_scc.sh               |  12 +
 test/nvme/simple_copy/.gitignore    |   1 +
 test/nvme/simple_copy/Makefile      |  38 +++
 test/nvme/simple_copy/simple_copy.c | 444 ++++++++++++++++++++++++++++
 10 files changed, 507 insertions(+), 1 deletion(-)
 create mode 100755 test/nvme/nvme_scc.sh
 create mode 100644 test/nvme/simple_copy/.gitignore
 create mode 100644 test/nvme/simple_copy/Makefile
 create mode 100644 test/nvme/simple_copy/simple_copy.c

diff --git a/autotest.sh b/autotest.sh
index fccbfcb97..a5f63c164 100755
--- a/autotest.sh
+++ b/autotest.sh
@@ -210,6 +210,9 @@ if [ $SPDK_RUN_FUNCTIONAL_TEST -eq 1 ]; then
 		if [[ $SPDK_TEST_NVME_PMR -eq 1 ]]; then
 			run_test "nvme_pmr" test/nvme/nvme_pmr.sh
 		fi
+		if [[ $SPDK_TEST_NVME_SCC -eq 1 ]]; then
+			run_test "nvme_scc" test/nvme/nvme_scc.sh
+		fi
 		if [[ $SPDK_TEST_NVME_CUSE -eq 1 ]]; then
 			run_test "nvme_cuse" test/nvme/cuse/nvme_cuse.sh
 		fi
diff --git a/test/common/autotest_common.sh b/test/common/autotest_common.sh
index cec9a9504..ca247c60c 100755
--- a/test/common/autotest_common.sh
+++ b/test/common/autotest_common.sh
@@ -77,6 +77,8 @@ export SPDK_TEST_ISCSI_INITIATOR
 export SPDK_TEST_NVME
 : ${SPDK_TEST_NVME_PMR=0}
 export SPDK_TEST_NVME_PMR
+: ${SPDK_TEST_NVME_SCC=0}
+export SPDK_TEST_NVME_SCC
 : ${SPDK_TEST_NVME_CLI=0}
 export SPDK_TEST_NVME_CLI
 : ${SPDK_TEST_NVME_CUSE=0}
diff --git a/test/common/config/pkgdep/git b/test/common/config/pkgdep/git
index 618856251..c1ebea43a 100644
--- a/test/common/config/pkgdep/git
+++ b/test/common/config/pkgdep/git
@@ -82,6 +82,7 @@ function install_refspdk() {
 		SPDK_RUN_ASAN=1
 		SPDK_RUN_UBSAN=1
 		SPDK_TEST_NVME_PMR=1
+		SPDK_TEST_NVME_SCC=1
 		SPDK_TEST_NVME_CUSE=1
 		SPDK_TEST_BLOBFS=1
 		SPDK_TEST_URING=1
diff --git a/test/common/config/vm_setup.sh b/test/common/config/vm_setup.sh
index bf9ae59d1..6ee58e788 100755
--- a/test/common/config/vm_setup.sh
+++ b/test/common/config/vm_setup.sh
@@ -185,6 +185,7 @@ SPDK_TEST_ISCSI=1
 SPDK_TEST_ISCSI_INITIATOR=1
 SPDK_TEST_NVME=1
 SPDK_TEST_NVME_PMR=1
+SPDK_TEST_NVME_SCC=1
 SPDK_TEST_NVME_CLI=1
 SPDK_TEST_NVMF=1
 SPDK_TEST_VFIOUSER=1
diff --git a/test/common/skipped_tests.txt b/test/common/skipped_tests.txt
index 294a0aa09..949ac26e3 100644
--- a/test/common/skipped_tests.txt
+++ b/test/common/skipped_tests.txt
@@ -13,6 +13,10 @@ iscsi_tgt_fio_remote_nvme
 nvme_pmr
 nvme_pmr_persistence
 
+# Waiting on SCC support in CI
+nvme_scc
+nvme_simple_copy
+
 # Waiting on significant test rewrite
 nvme_opal
 nvme_opal_bdevio
diff --git a/test/nvme/Makefile b/test/nvme/Makefile
index b2ed73a09..0edfb3478 100644
--- a/test/nvme/Makefile
+++ b/test/nvme/Makefile
@@ -35,7 +35,7 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 DIRS-y = aer reset sgl e2edp overhead deallocated_value err_injection \
-	startup reserve
+	startup reserve simple_copy
 DIRS-$(CONFIG_NVME_CUSE) += cuse
 
 .PHONY: all clean $(DIRS-y)
diff --git a/test/nvme/nvme_scc.sh b/test/nvme/nvme_scc.sh
new file mode 100755
index 000000000..ce16f6e8a
--- /dev/null
+++ b/test/nvme/nvme_scc.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+testdir=$(readlink -f $(dirname $0))
+rootdir=$(readlink -f $testdir/../..)
+source $rootdir/scripts/common.sh
+source $rootdir/test/common/autotest_common.sh
+
+if [ $(uname) = Linux ]; then
+	$rootdir/scripts/setup.sh
+fi
+
+run_test "nvme_simple_copy" $testdir/simple_copy/simple_copy
diff --git a/test/nvme/simple_copy/.gitignore b/test/nvme/simple_copy/.gitignore
new file mode 100644
index 000000000..e14dcbf9c
--- /dev/null
+++ b/test/nvme/simple_copy/.gitignore
@@ -0,0 +1 @@
+simple_copy
diff --git a/test/nvme/simple_copy/Makefile b/test/nvme/simple_copy/Makefile
new file mode 100644
index 000000000..021861b84
--- /dev/null
+++ b/test/nvme/simple_copy/Makefile
@@ -0,0 +1,38 @@
+#
+#  BSD LICENSE
+#
+#  Copyright (c) Samsung Electronics Co., Ltd.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Samsung Electronics Co., Ltd. nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../..)
+
+APP = simple_copy
+
+include $(SPDK_ROOT_DIR)/mk/nvme.libtest.mk
diff --git a/test/nvme/simple_copy/simple_copy.c b/test/nvme/simple_copy/simple_copy.c
new file mode 100644
index 000000000..0f96c65c0
--- /dev/null
+++ b/test/nvme/simple_copy/simple_copy.c
@@ -0,0 +1,444 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Samsung Electronics Co., Ltd.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "spdk/stdinc.h"
+#include "spdk/nvme.h"
+#include "spdk/env.h"
+
+#define NUM_LBAS 64
+#define DEST_LBA 256
+
+struct ns_entry {
+	struct spdk_nvme_ctrlr	*ctrlr;
+	struct spdk_nvme_ns	*ns;
+	struct ns_entry		*next;
+	struct spdk_nvme_qpair	*qpair;
+};
+
+struct simple_copy_context {
+	struct ns_entry	*ns_entry;
+	char		**write_bufs;
+	char		**read_bufs;
+	int		writes_completed;
+	int		reads_completed;
+	int		simple_copy_completed;
+	int		matches_written_data;
+	int		error;
+};
+
+static struct ns_entry *g_namespaces = NULL;
+
+static void cleanup(struct simple_copy_context *context);
+
+static void
+fill_random(char *buf, size_t num_bytes)
+{
+	size_t	i;
+
+	srand((unsigned) time(NULL));
+	for (i = 0; i < num_bytes; i++) {
+		buf[i] = rand() % 0x100;
+	}
+}
+
+static void
+register_ns(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
+{
+	struct ns_entry				*entry;
+	const struct spdk_nvme_ctrlr_data	*cdata;
+
+	cdata = spdk_nvme_ctrlr_get_data(ctrlr);
+
+	if (!spdk_nvme_ns_is_active(ns)) {
+		printf("Controller %-20.20s (%-20.20s): Skipping inactive NS %u\n",
+		       cdata->mn, cdata->sn,
+		       spdk_nvme_ns_get_id(ns));
+		return;
+	}
+
+	entry = malloc(sizeof(struct ns_entry));
+	if (entry == NULL) {
+		perror("ns_entry malloc");
+		exit(1);
+	}
+
+	entry->ctrlr = ctrlr;
+	entry->ns = ns;
+	entry->next = g_namespaces;
+	g_namespaces = entry;
+
+	printf("  Namespace ID: %d size: %juGB\n", spdk_nvme_ns_get_id(ns),
+	       spdk_nvme_ns_get_size(ns) / 1000000000);
+}
+
+static uint32_t
+get_max_block_size(void)
+{
+	struct ns_entry	*ns;
+	uint32_t	max_block_size, temp_block_size;
+
+	ns = g_namespaces;
+	max_block_size = 0;
+
+	while (ns != NULL) {
+		temp_block_size = spdk_nvme_ns_get_sector_size(ns->ns);
+		max_block_size = temp_block_size > max_block_size ? temp_block_size : max_block_size;
+		ns = ns->next;
+	}
+
+	return max_block_size;
+}
+
+static void
+write_complete(void *arg, const struct spdk_nvme_cpl *cpl)
+{
+	struct simple_copy_context	*context = arg;
+
+	context->writes_completed++;
+
+	if (spdk_nvme_cpl_is_error(cpl)) {
+		printf("write cpl error. SC 0x%x SCT 0x%x\n", cpl->status.sc, cpl->status.sct);
+		context->error++;
+		return;
+	}
+}
+
+static void
+read_complete(void *arg, const struct spdk_nvme_cpl *cpl)
+{
+	struct simple_copy_context	*context = arg;
+	struct ns_entry			*ns_entry = context->ns_entry;
+	int				rc;
+
+	if (spdk_nvme_cpl_is_error(cpl)) {
+		printf("read cpl error. SC 0x%x SCT 0x%x\n", cpl->status.sc, cpl->status.sct);
+		context->reads_completed++;
+		context->error++;
+		return;
+	}
+
+	rc = memcmp(context->write_bufs[context->reads_completed],
+		    context->read_bufs[context->reads_completed], spdk_nvme_ns_get_sector_size(ns_entry->ns));
+	if (rc == 0) {
+		context->matches_written_data++;
+	}
+
+	context->reads_completed++;
+}
+
+static void
+simple_copy_complete(void *arg, const struct spdk_nvme_cpl *cpl)
+{
+	struct simple_copy_context	*context = arg;
+
+	context->simple_copy_completed = 1;
+
+	if (spdk_nvme_cpl_is_error(cpl)) {
+		printf("scc cpl error. SC 0x%x SCT 0x%x\n", cpl->status.sc, cpl->status.sct);
+		context->error++;
+		return;
+	}
+
+	printf("Copied LBAs from 0 - %d to the Destination LBA %d\n", NUM_LBAS - 1, DEST_LBA);
+	context->reads_completed = 0;
+	context->matches_written_data = 0;
+}
+
+static void
+simple_copy_test(void)
+{
+	struct ns_entry				*ns_entry;
+	struct spdk_nvme_ctrlr			*ctrlr;
+	const struct spdk_nvme_ctrlr_data	*data;
+	struct simple_copy_context		context;
+	struct spdk_nvme_scc_source_range	range;
+	uint32_t				max_block_size;
+	int					rc, i;
+
+	memset(&context, 0, sizeof(struct simple_copy_context));
+	max_block_size = get_max_block_size();
+	ns_entry = g_namespaces;
+
+	context.write_bufs = calloc(NUM_LBAS, sizeof(char *));
+	if (context.write_bufs == NULL) {
+		printf("could not allocate write buffer pointers for test\n");
+		cleanup(&context);
+		return;
+	}
+
+	context.read_bufs = calloc(NUM_LBAS, sizeof(char *));
+	if (context.read_bufs == NULL) {
+		printf("could not allocate read buffer pointers for test\n");
+		cleanup(&context);
+		return;
+	}
+
+	for (i = 0; i < NUM_LBAS; i++) {
+		context.write_bufs[i] = spdk_zmalloc(0x1000, max_block_size, NULL, SPDK_ENV_LCORE_ID_ANY,
+						     SPDK_MALLOC_DMA);
+		if (context.write_bufs[i] == NULL) {
+			printf("could not allocate write buffer %d for test\n", i);
+			cleanup(&context);
+			return;
+		}
+
+		fill_random(context.write_bufs[i], 0x1000);
+		context.read_bufs[i] = spdk_zmalloc(0x1000, max_block_size, NULL, SPDK_ENV_LCORE_ID_ANY,
+						    SPDK_MALLOC_DMA);
+		if (context.read_bufs[i] == NULL) {
+			printf("could not allocate read buffer %d for test\n", i);
+			cleanup(&context);
+			return;
+		}
+	}
+
+	while (ns_entry != NULL) {
+
+		ns_entry->qpair = spdk_nvme_ctrlr_alloc_io_qpair(ns_entry->ctrlr, NULL, 0);
+		if (ns_entry->qpair == NULL) {
+			printf("ERROR: spdk_nvme_ctrlr_alloc_io_qpair() failed\n");
+			cleanup(&context);
+			return;
+		}
+
+		ctrlr = spdk_nvme_ns_get_ctrlr(ns_entry->ns);
+		data = spdk_nvme_ctrlr_get_data(ctrlr);
+
+		printf("\nController %-20.20s (%-20.20s)\n", data->mn, data->sn);
+		printf("Controller PCI vendor:%u PCI subsystem vendor:%u\n", data->vid, data->ssvid);
+		printf("Namespace Block Size:%u\n", spdk_nvme_ns_get_sector_size(ns_entry->ns));
+		printf("Writing LBAs 0 to %d with Random Data\n", NUM_LBAS - 1);
+
+		context.ns_entry = ns_entry;
+
+		for (i = 0; i < NUM_LBAS; i++) {
+			rc = spdk_nvme_ns_cmd_write(ns_entry->ns, ns_entry->qpair, context.write_bufs[i],
+						    i,
+						    1,
+						    write_complete, &context, 0);
+			if (rc) {
+				printf("submission of write I/O failed\n");
+			}
+		}
+		while (context.writes_completed < NUM_LBAS) {
+			rc = spdk_nvme_qpair_process_completions(ns_entry->qpair, 0);
+			if (rc < 0) {
+				printf("Error processing write completions, rc: %d\n", rc);
+				break;
+			}
+		}
+
+		if (context.error) {
+			printf("Error : %d Write completions failed\n",
+			       context.error);
+			spdk_nvme_ctrlr_free_io_qpair(ns_entry->qpair);
+			cleanup(&context);
+			exit(1);
+		}
+
+		range.nlb = NUM_LBAS;
+		range.slba = 0;
+
+		rc = spdk_nvme_ns_cmd_copy(ns_entry->ns, ns_entry->qpair,
+					   &range, 1, DEST_LBA, simple_copy_complete, &context);
+
+		if (rc) {
+			printf("submission of copy I/O failed\n");
+		}
+
+		while (!context.simple_copy_completed) {
+			rc = spdk_nvme_qpair_process_completions(ns_entry->qpair, 0);
+			if (rc < 0) {
+				printf("Error processing copy completions, rc: %d\n", rc);
+				break;
+			}
+		}
+
+		if (context.error) {
+			printf("Error : Copy completion failed\n");
+			spdk_nvme_ctrlr_free_io_qpair(ns_entry->qpair);
+			cleanup(&context);
+			exit(1);
+		}
+
+		for (i = 0; i < NUM_LBAS; i++) {
+			rc = spdk_nvme_ns_cmd_read(ns_entry->ns, ns_entry->qpair, context.read_bufs[i],
+						   DEST_LBA + i, /* LBA start */
+						   1, /* number of LBAs */
+						   read_complete, &context, 0);
+			if (rc) {
+				printf("submission of read I/O failed\n");
+			}
+			/* block after each read command so that we can match the block to the write buffer. */
+			while (context.reads_completed <= i) {
+				rc = spdk_nvme_qpair_process_completions(ns_entry->qpair, 0);
+				if (rc < 0) {
+					printf("Error processing read completions, rc: %d\n", rc);
+					break;
+				}
+			}
+		}
+
+		if (context.error) {
+			printf("Error : %d Read completions failed\n",
+			       context.error);
+			spdk_nvme_ctrlr_free_io_qpair(ns_entry->qpair);
+			cleanup(&context);
+			exit(1);
+		}
+
+		printf("LBAs matching Written Data: %d\n", context.matches_written_data);
+
+		if (context.matches_written_data != NUM_LBAS) {
+			printf("Error : %d LBAs are copied correctly out of %d LBAs\n",
+			       context.matches_written_data, NUM_LBAS);
+			spdk_nvme_ctrlr_free_io_qpair(ns_entry->qpair);
+			cleanup(&context);
+			exit(1);
+		}
+
+		/* reset counters in between each namespace. */
+		context.matches_written_data = 0;
+		context.writes_completed = 0;
+		context.reads_completed = 0;
+		context.simple_copy_completed = 0;
+
+		spdk_nvme_ctrlr_free_io_qpair(ns_entry->qpair);
+		ns_entry = ns_entry->next;
+	}
+	cleanup(&context);
+}
+
+static bool
+probe_cb(void *cb_ctx, const struct spdk_nvme_transport_id *trid,
+	 struct spdk_nvme_ctrlr_opts *opts)
+{
+	printf("Attaching to %s\n", trid->traddr);
+
+	return true;
+}
+
+static void
+attach_cb(void *cb_ctx, const struct spdk_nvme_transport_id *trid,
+	  struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_ctrlr_opts *opts)
+{
+	int			num_ns;
+	struct spdk_nvme_ns	*ns;
+	const struct spdk_nvme_ctrlr_data	*cdata;
+
+	cdata = spdk_nvme_ctrlr_get_data(ctrlr);
+
+	if (cdata->oncs.copy) {
+		printf("Controller supports SCC. Attached to %s\n", trid->traddr);
+		/*
+		 * Use only the first namespace from each controller since we are testing controller level functionality.
+		 */
+		num_ns = spdk_nvme_ctrlr_get_num_ns(ctrlr);
+		if (num_ns < 1) {
+			printf("No valid namespaces in controller\n");
+		} else {
+			ns = spdk_nvme_ctrlr_get_ns(ctrlr, 1);
+			register_ns(ctrlr, ns);
+		}
+	} else {
+		printf("Controller doesn't support SCC. Not Attached to %s\n", trid->traddr);
+	}
+}
+
+static void
+cleanup(struct simple_copy_context *context)
+{
+	struct ns_entry	*ns_entry = g_namespaces;
+	struct spdk_nvme_detach_ctx *detach_ctx = NULL;
+	int		i;
+
+	while (ns_entry) {
+		struct ns_entry *next = ns_entry->next;
+
+		detach_ctx = NULL;
+		spdk_nvme_detach_async(ns_entry->ctrlr, &detach_ctx);
+
+		while (detach_ctx && spdk_nvme_detach_poll_async(detach_ctx) == -EAGAIN) {
+			;
+		}
+
+		free(ns_entry);
+		ns_entry = next;
+	}
+	for (i = 0; i < NUM_LBAS; i++) {
+		if (context->write_bufs && context->write_bufs[i]) {
+			spdk_free(context->write_bufs[i]);
+		} else {
+			break;
+		}
+		if (context->read_bufs && context->read_bufs[i]) {
+			spdk_free(context->read_bufs[i]);
+		} else {
+			break;
+		}
+	}
+
+	free(context->write_bufs);
+	free(context->read_bufs);
+}
+
+int main(int argc, char **argv)
+{
+	int			rc;
+	struct spdk_env_opts	opts;
+
+	spdk_env_opts_init(&opts);
+	opts.name = "simple_copy";
+	opts.shm_id = 0;
+	if (spdk_env_init(&opts) < 0) {
+		fprintf(stderr, "Unable to initialize SPDK env\n");
+		return 1;
+	}
+
+	printf("Initializing NVMe Controllers\n");
+
+	rc = spdk_nvme_probe(NULL, NULL, probe_cb, attach_cb, NULL);
+	if (rc != 0) {
+		fprintf(stderr, "spdk_nvme_probe() failed\n");
+		return 1;
+	}
+
+	if (g_namespaces == NULL) {
+		fprintf(stderr, "no NVMe controllers found\n");
+		return 1;
+	}
+
+	printf("Initialization complete.\n");
+	simple_copy_test();
+	return 0;
+}
-- 
2.26.2


From c07a6a949b958fc1319813f6ec474c3fa56bcec2 Mon Sep 17 00:00:00 2001
From: Richael Zhuang <richael.zhuang@arm.com>
Date: Wed, 12 May 2021 15:01:45 +0800
Subject: [PATCH 151/342] event/reactor: fix bug when showing core state

It should print "intr" when target->in_interrupt==1.

Change-Id: I74479da1dc66d937899fdf5c619cdf1a09951918
Signed-off-by: Richael Zhuang <richael.zhuang@arm.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7857
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/event/reactor.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index 4b058ab32..fd886c353 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -394,7 +394,7 @@ _reactor_set_interrupt_mode(void *arg1, void *arg2)
 	assert(target != NULL);
 	assert(target->in_interrupt != target->new_in_interrupt);
 	SPDK_DEBUGLOG(reactor, "Do reactor set on core %u from %s to state %s\n",
-		      target->lcore, !target->in_interrupt ? "intr" : "poll", target->new_in_interrupt ? "intr" : "poll");
+		      target->lcore, target->in_interrupt ? "intr" : "poll", target->new_in_interrupt ? "intr" : "poll");
 
 	target->in_interrupt = target->new_in_interrupt;
 
-- 
2.26.2


From 019a5361a5060ab9943eb07417404ce4a7575eb3 Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Fri, 2 Apr 2021 08:46:40 +0300
Subject: [PATCH 152/342] nvmf/rdma: Use contig buffers for multi SGL payload

Currently we allocate buffers perf each SGL descriptor.
That can lead to a problem when we use NVME bdev with
PRP controller and length of the 1st SGL descriptor is
not multiple of block size, i.e. the initiator may send
PRP1 (which is SGL[0]) which end address is page aligned
while start address is not aligned. This is allowed by
the spec. But when we read such a data to a local buffer,
start of the buffer is page aligned when its end is not.
That violates PRP requirements and we can't handle such
request. However if we use contig buffer to write both
PRP1 and PRP2 (SGL[0] and SGL[1]) then we won't meet
this problem.

Some existing unit tests were updated, 1 new was added.

Fixes github issue #1853

Change-Id: Ib2d56112b7b25e235d17bbc6df8dce4dc556e12d
Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7259
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvmf/rdma.c                     | 64 ++++++++++++++++++-----------
 test/unit/lib/nvmf/rdma.c/rdma_ut.c | 54 +++++++++++++++++++++++-
 2 files changed, 94 insertions(+), 24 deletions(-)

diff --git a/lib/nvmf/rdma.c b/lib/nvmf/rdma.c
index 25bd02c0a..9d45fc89a 100644
--- a/lib/nvmf/rdma.c
+++ b/lib/nvmf/rdma.c
@@ -267,6 +267,9 @@ struct spdk_nvmf_rdma_request {
 
 	enum spdk_nvmf_rdma_request_state	state;
 
+	/* Data offset in req.iov */
+	uint32_t				offset;
+
 	struct spdk_nvmf_rdma_recv		*recv;
 
 	struct {
@@ -1440,13 +1443,12 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 		      uint32_t total_length,
 		      uint32_t num_extra_wrs)
 {
-	struct spdk_nvmf_request *req = &rdma_req->req;
 	struct spdk_rdma_memory_translation mem_translation;
 	struct spdk_dif_ctx *dif_ctx = NULL;
 	struct ibv_sge	*sg_ele;
 	struct iovec *iov;
 	uint32_t remaining_data_block = 0;
-	uint32_t offset = 0, lkey, remaining;
+	uint32_t lkey, remaining;
 	int rc;
 
 	if (spdk_unlikely(rdma_req->req.dif.dif_insert_or_strip)) {
@@ -1457,7 +1459,7 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 	wr->num_sge = 0;
 
 	while (total_length && (num_extra_wrs || wr->num_sge < SPDK_NVMF_MAX_SGL_ENTRIES)) {
-		iov = &req->iov[rdma_req->iovpos];
+		iov = &rdma_req->req.iov[rdma_req->iovpos];
 		rc = spdk_rdma_get_translation(device->map, iov->iov_base, iov->iov_len, &mem_translation);
 		if (spdk_unlikely(rc)) {
 			return false;
@@ -1465,19 +1467,27 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 
 		lkey = spdk_rdma_memory_translation_get_lkey(&mem_translation);
 		sg_ele = &wr->sg_list[wr->num_sge];
+		remaining = spdk_min((uint32_t)iov->iov_len - rdma_req->offset, total_length);
 
 		if (spdk_likely(!dif_ctx)) {
 			sg_ele->lkey = lkey;
-			sg_ele->addr = (uintptr_t)(iov->iov_base);
-			sg_ele->length = (uint32_t)iov->iov_len;
+			sg_ele->addr = (uintptr_t)iov->iov_base + rdma_req->offset;
+			sg_ele->length = remaining;
+			SPDK_DEBUGLOG(rdma, "sge[%d] %p addr 0x%"PRIx64", len %u\n", wr->num_sge, sg_ele, sg_ele->addr,
+				      sg_ele->length);
+			rdma_req->offset += sg_ele->length;
+			total_length -= sg_ele->length;
 			wr->num_sge++;
+
+			if (rdma_req->offset == iov->iov_len) {
+				rdma_req->offset = 0;
+				rdma_req->iovpos++;
+			}
 		} else {
 			uint32_t data_block_size = dif_ctx->block_size - dif_ctx->md_size;
 			uint32_t md_size = dif_ctx->md_size;
 			uint32_t sge_len;
 
-			remaining = (uint32_t)iov->iov_len - offset;
-
 			while (remaining) {
 				if (wr->num_sge >= SPDK_NVMF_MAX_SGL_ENTRIES) {
 					if (num_extra_wrs > 0 && wr->next) {
@@ -1490,19 +1500,23 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 					}
 				}
 				sg_ele->lkey = lkey;
-				sg_ele->addr = (uintptr_t)((char *)iov->iov_base + offset);
+				sg_ele->addr = (uintptr_t)((char *)iov->iov_base + rdma_req->offset);
 				sge_len = spdk_min(remaining, remaining_data_block);
 				sg_ele->length = sge_len;
+				SPDK_DEBUGLOG(rdma, "sge[%d] %p addr 0x%"PRIx64", len %u\n", wr->num_sge, sg_ele, sg_ele->addr,
+					      sg_ele->length);
 				remaining -= sge_len;
 				remaining_data_block -= sge_len;
-				offset += sge_len;
+				rdma_req->offset += sge_len;
+				total_length -= sge_len;
 
 				sg_ele++;
 				wr->num_sge++;
 
 				if (remaining_data_block == 0) {
 					/* skip metadata */
-					offset += md_size;
+					rdma_req->offset += md_size;
+					total_length -= md_size;
 					/* Metadata that do not fit this IO buffer will be included in the next IO buffer */
 					remaining -= spdk_min(remaining, md_size);
 					remaining_data_block = data_block_size;
@@ -1511,13 +1525,11 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 				if (remaining == 0) {
 					/* By subtracting the size of the last IOV from the offset, we ensure that we skip
 					   the remaining metadata bits at the beginning of the next buffer */
-					offset -= iov->iov_len;
+					rdma_req->offset -= spdk_min(iov->iov_len, rdma_req->offset);
+					rdma_req->iovpos++;
 				}
 			}
 		}
-
-		total_length -= req->iov[rdma_req->iovpos].iov_len;
-		rdma_req->iovpos++;
 	}
 
 	if (total_length) {
@@ -1621,7 +1633,7 @@ nvmf_rdma_request_fill_iovs_multi_sgl(struct spdk_nvmf_rdma_transport *rtranspor
 	struct spdk_nvmf_request		*req = &rdma_req->req;
 	struct spdk_nvme_sgl_descriptor		*inline_segment, *desc;
 	uint32_t				num_sgl_descriptors;
-	uint32_t				lengths[SPDK_NVMF_MAX_SGL_ENTRIES];
+	uint32_t				lengths[SPDK_NVMF_MAX_SGL_ENTRIES], total_length = 0;
 	uint32_t				i;
 	int					rc;
 
@@ -1635,10 +1647,6 @@ nvmf_rdma_request_fill_iovs_multi_sgl(struct spdk_nvmf_rdma_transport *rtranspor
 	num_sgl_descriptors = inline_segment->unkeyed.length / sizeof(struct spdk_nvme_sgl_descriptor);
 	assert(num_sgl_descriptors <= SPDK_NVMF_MAX_SGL_ENTRIES);
 
-	if (nvmf_request_alloc_wrs(rtransport, rdma_req, num_sgl_descriptors - 1) != 0) {
-		return -ENOMEM;
-	}
-
 	desc = (struct spdk_nvme_sgl_descriptor *)rdma_req->recv->buf + inline_segment->address;
 	for (i = 0; i < num_sgl_descriptors; i++) {
 		if (spdk_likely(!req->dif.dif_insert_or_strip)) {
@@ -1648,11 +1656,22 @@ nvmf_rdma_request_fill_iovs_multi_sgl(struct spdk_nvmf_rdma_transport *rtranspor
 			lengths[i] = spdk_dif_get_length_with_md(desc->keyed.length, &req->dif.dif_ctx);
 			req->dif.elba_length += lengths[i];
 		}
+		total_length += lengths[i];
 		desc++;
 	}
 
-	rc = spdk_nvmf_request_get_buffers_multi(req, &rgroup->group, &rtransport->transport,
-			lengths, num_sgl_descriptors);
+	if (total_length > rtransport->transport.opts.max_io_size) {
+		SPDK_ERRLOG("Multi SGL length 0x%x exceeds max io size 0x%x\n",
+			    total_length, rtransport->transport.opts.max_io_size);
+		req->rsp->nvme_cpl.status.sc = SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID;
+		return -EINVAL;
+	}
+
+	if (nvmf_request_alloc_wrs(rtransport, rdma_req, num_sgl_descriptors - 1) != 0) {
+		return -ENOMEM;
+	}
+
+	rc = spdk_nvmf_request_get_buffers(req, &rgroup->group, &rtransport->transport, total_length);
 	if (rc != 0) {
 		nvmf_rdma_request_free_data(rdma_req, rtransport);
 		return rc;
@@ -1673,8 +1692,6 @@ nvmf_rdma_request_fill_iovs_multi_sgl(struct spdk_nvmf_rdma_transport *rtranspor
 			goto err_exit;
 		}
 
-		current_wr->num_sge = 0;
-
 		rc = nvmf_rdma_fill_wr_sgl(rgroup, device, rdma_req, current_wr, lengths[i], 0);
 		if (rc != 0) {
 			rc = -ENOMEM;
@@ -1851,6 +1868,7 @@ _nvmf_rdma_request_free(struct spdk_nvmf_rdma_request *rdma_req,
 	rdma_req->req.data = NULL;
 	rdma_req->rsp.wr.next = NULL;
 	rdma_req->data.wr.next = NULL;
+	rdma_req->offset = 0;
 	memset(&rdma_req->req.dif, 0, sizeof(rdma_req->req.dif));
 	rqpair->qd--;
 
diff --git a/test/unit/lib/nvmf/rdma.c/rdma_ut.c b/test/unit/lib/nvmf/rdma.c/rdma_ut.c
index 007f34421..f1e6ff6cd 100644
--- a/test/unit/lib/nvmf/rdma.c/rdma_ut.c
+++ b/test/unit/lib/nvmf/rdma.c/rdma_ut.c
@@ -132,6 +132,7 @@ static void reset_nvmf_rdma_request(struct spdk_nvmf_rdma_request *rdma_req)
 	rdma_req->data.wr.num_sge = 0;
 	rdma_req->data.wr.wr.rdma.remote_addr = 0;
 	rdma_req->data.wr.wr.rdma.rkey = 0;
+	rdma_req->offset = 0;
 	memset(&rdma_req->req.dif, 0, sizeof(rdma_req->req.dif));
 
 	for (i = 0; i < SPDK_NVMF_MAX_SGL_ENTRIES; i++) {
@@ -162,6 +163,8 @@ test_spdk_nvmf_rdma_request_parse_sgl(void)
 	struct spdk_nvme_sgl_descriptor sgl_desc[SPDK_NVMF_MAX_SGL_ENTRIES] = {{0}};
 	struct spdk_nvmf_rdma_request_data data;
 	int rc, i;
+	uint32_t sgl_length;
+	uintptr_t aligned_buffer_address;
 
 	data.wr.sg_list = data.sgl;
 	STAILQ_INIT(&group.group.buf_cache);
@@ -362,7 +365,7 @@ test_spdk_nvmf_rdma_request_parse_sgl(void)
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(rdma_req.req.data_from_pool == true);
 	CU_ASSERT(rdma_req.req.length == rtransport.transport.opts.io_unit_size * 16);
-	CU_ASSERT(rdma_req.req.iovcnt == 17);
+	CU_ASSERT(rdma_req.req.iovcnt == 16);
 	CU_ASSERT(rdma_req.data.wr.num_sge == 16);
 	for (i = 0; i < 15; i++) {
 		CU_ASSERT(rdma_req.data.sgl[i].length == rtransport.transport.opts.io_unit_size);
@@ -378,6 +381,39 @@ test_spdk_nvmf_rdma_request_parse_sgl(void)
 	CU_ASSERT(data.wr.num_sge == 1);
 	CU_ASSERT(data.wr.next == &rdma_req.rsp.wr);
 
+	/* part 4: 2 SGL descriptors, each length is transport buffer / 2
+	 * 1 transport buffers should be allocated */
+	reset_nvmf_rdma_request(&rdma_req);
+	aligned_buffer_address = ((uintptr_t)(&data) + NVMF_DATA_BUFFER_MASK) & ~NVMF_DATA_BUFFER_MASK;
+	sgl->unkeyed.length = 2 * sizeof(struct spdk_nvme_sgl_descriptor);
+	sgl_length = rtransport.transport.opts.io_unit_size / 2;
+	for (i = 0; i < 2; i++) {
+		sgl_desc[i].keyed.length = sgl_length;
+		sgl_desc[i].address = 0x4000 + i * sgl_length;
+	}
+
+	rc = nvmf_rdma_request_parse_sgl(&rtransport, &device, &rdma_req);
+
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(rdma_req.req.data_from_pool == true);
+	CU_ASSERT(rdma_req.req.length == rtransport.transport.opts.io_unit_size);
+	CU_ASSERT(rdma_req.req.iovcnt == 1);
+
+	CU_ASSERT(rdma_req.data.sgl[0].length == sgl_length);
+	/* We mocked mempool_get to return address of data variable. Mempool is used
+	 * to get both additional WRs and data buffers, so data points to &data */
+	CU_ASSERT(rdma_req.data.sgl[0].addr == aligned_buffer_address);
+	CU_ASSERT(rdma_req.data.wr.wr.rdma.rkey == 0x44);
+	CU_ASSERT(rdma_req.data.wr.wr.rdma.remote_addr == 0x4000);
+	CU_ASSERT(rdma_req.data.wr.num_sge == 1);
+	CU_ASSERT(rdma_req.data.wr.next == &data.wr);
+
+	CU_ASSERT(data.wr.wr.rdma.rkey == 0x44);
+	CU_ASSERT(data.wr.wr.rdma.remote_addr == 0x4000 + sgl_length);
+	CU_ASSERT(data.sgl[0].length == sgl_length);
+	CU_ASSERT(data.sgl[0].addr == aligned_buffer_address + sgl_length);
+	CU_ASSERT(data.wr.num_sge == 1);
+
 	/* Test 4: use PG buffer cache */
 	sgl->generic.type = SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK;
 	sgl->keyed.subtype = SPDK_NVME_SGL_SUBTYPE_ADDRESS;
@@ -1106,10 +1142,26 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	CU_ASSERT(rdma_req.data.wr.num_sge == 16);
 	CU_ASSERT(rdma_req.data.wr.wr.rdma.rkey == 0xEEEE);
 	CU_ASSERT(rdma_req.data.wr.wr.rdma.remote_addr == 0xFFFF);
+
+	for (i = 0; i < 15; ++i) {
+		CU_ASSERT(rdma_req.data.wr.sg_list[i].addr == (uintptr_t)aligned_buffer + i * (data_bs + md_size));
+		CU_ASSERT(rdma_req.data.wr.sg_list[i].length == data_bs);
+		CU_ASSERT(rdma_req.data.wr.sg_list[i].lkey == RDMA_UT_LKEY);
+	}
+
+	/* 8192 - (512 + 8) * 15 = 392 */
+	CU_ASSERT(rdma_req.data.wr.sg_list[i].addr == (uintptr_t)aligned_buffer + i * (data_bs + md_size));
+	CU_ASSERT(rdma_req.data.wr.sg_list[i].length == 392);
+	CU_ASSERT(rdma_req.data.wr.sg_list[i].lkey == RDMA_UT_LKEY);
+
 	/* additional wr from pool */
 	CU_ASSERT(rdma_req.data.wr.next == (void *)&data2->wr);
 	CU_ASSERT(rdma_req.data.wr.next->num_sge == 1);
 	CU_ASSERT(rdma_req.data.wr.next->next == &rdma_req.rsp.wr);
+	/* 2nd IO buffer */
+	CU_ASSERT(data2->wr.sg_list[0].addr == (uintptr_t)aligned_buffer);
+	CU_ASSERT(data2->wr.sg_list[0].length == 120);
+	CU_ASSERT(data2->wr.sg_list[0].lkey == RDMA_UT_LKEY);
 
 	/* Part 8: simple I/O, data with metadata do not fit to 1 io_buffer */
 	MOCK_SET(spdk_mempool_get, (void *)0x2000);
-- 
2.26.2


From 6263457ca3ccc5b43542d7e45ad625473db5a19f Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Fri, 14 May 2021 15:54:02 +0300
Subject: [PATCH 153/342] nvmf: Remove spdk_nvmf_request_get_buffers_multi API

It is not used.

Change-Id: I238c5e2b2d557063f8443ca703551e02b35ba2c7
Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7882
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 CHANGELOG.md                  |  2 ++
 include/spdk/nvmf_transport.h |  6 +-----
 lib/nvmf/Makefile             |  4 ++--
 lib/nvmf/spdk_nvmf.map        |  1 -
 lib/nvmf/transport.c          | 27 +--------------------------
 5 files changed, 6 insertions(+), 34 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index b1d6ee979..4c91c9c02 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,6 +11,8 @@ of spdk_idxd_probe_cb function pointer. It should be implemented in idxd_user.c.
 
 Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the controller ID range.
 
+`spdk_nvmf_request_get_buffers_multi` API is removed.
+
 ### nvme
 
 Added a new function `spdk_nvme_ns_cmd_copy` to submit a Simple Copy Command to a Namespace.
diff --git a/include/spdk/nvmf_transport.h b/include/spdk/nvmf_transport.h
index f3af783fd..b09eb04b2 100644
--- a/include/spdk/nvmf_transport.h
+++ b/include/spdk/nvmf_transport.h
@@ -2,7 +2,7 @@
  *   BSD LICENSE
  *
  *   Copyright (c) Intel Corporation. All rights reserved.
- *   Copyright (c) 2019 Mellanox Technologies LTD. All rights reserved.
+ *   Copyright (c) 2019, 2021 Mellanox Technologies LTD. All rights reserved.
  *
  *   Redistribution and use in source and binary forms, with or without
  *   modification, are permitted provided that the following conditions
@@ -429,10 +429,6 @@ int spdk_nvmf_request_get_buffers(struct spdk_nvmf_request *req,
 				  struct spdk_nvmf_transport_poll_group *group,
 				  struct spdk_nvmf_transport *transport,
 				  uint32_t length);
-int spdk_nvmf_request_get_buffers_multi(struct spdk_nvmf_request *req,
-					struct spdk_nvmf_transport_poll_group *group,
-					struct spdk_nvmf_transport *transport,
-					uint32_t *lengths, uint32_t num_lengths);
 
 bool spdk_nvmf_request_get_dif_ctx(struct spdk_nvmf_request *req, struct spdk_dif_ctx *dif_ctx);
 
diff --git a/lib/nvmf/Makefile b/lib/nvmf/Makefile
index 3058f41f9..22cab3985 100644
--- a/lib/nvmf/Makefile
+++ b/lib/nvmf/Makefile
@@ -34,8 +34,8 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-SO_VER := 8
-SO_MINOR := 1
+SO_VER := 9
+SO_MINOR := 0
 
 C_SRCS = ctrlr.c ctrlr_discovery.c ctrlr_bdev.c \
 	 subsystem.c nvmf.c nvmf_rpc.c transport.c tcp.c
diff --git a/lib/nvmf/spdk_nvmf.map b/lib/nvmf/spdk_nvmf.map
index c43a96343..fc6ec9cfd 100644
--- a/lib/nvmf/spdk_nvmf.map
+++ b/lib/nvmf/spdk_nvmf.map
@@ -108,7 +108,6 @@
 	spdk_nvmf_ctrlr_get_regs;
 	spdk_nvmf_request_free_buffers;
 	spdk_nvmf_request_get_buffers;
-	spdk_nvmf_request_get_buffers_multi;
 	spdk_nvmf_request_get_dif_ctx;
 	spdk_nvmf_request_exec_fabrics;
 	spdk_nvmf_request_exec;
diff --git a/lib/nvmf/transport.c b/lib/nvmf/transport.c
index 563b82ae3..4ff3dde43 100644
--- a/lib/nvmf/transport.c
+++ b/lib/nvmf/transport.c
@@ -2,7 +2,7 @@
  *   BSD LICENSE
  *
  *   Copyright (c) Intel Corporation. All rights reserved.
- *   Copyright (c) 2018-2019 Mellanox Technologies LTD. All rights reserved.
+ *   Copyright (c) 2018-2019, 2021 Mellanox Technologies LTD. All rights reserved.
  *
  *   Redistribution and use in source and binary forms, with or without
  *   modification, are permitted provided that the following conditions
@@ -721,28 +721,3 @@ spdk_nvmf_request_get_buffers(struct spdk_nvmf_request *req,
 
 	return rc;
 }
-
-int
-spdk_nvmf_request_get_buffers_multi(struct spdk_nvmf_request *req,
-				    struct spdk_nvmf_transport_poll_group *group,
-				    struct spdk_nvmf_transport *transport,
-				    uint32_t *lengths, uint32_t num_lengths)
-{
-	int rc = 0;
-	uint32_t i;
-
-	req->iovcnt = 0;
-
-	for (i = 0; i < num_lengths; i++) {
-		rc = nvmf_request_get_buffers(req, group, transport, lengths[i]);
-		if (rc != 0) {
-			goto err_exit;
-		}
-	}
-
-	return 0;
-
-err_exit:
-	spdk_nvmf_request_free_buffers(req, group, transport);
-	return rc;
-}
-- 
2.26.2


From d424e2449a9d8cdd9057c21afd71cf14c2d28563 Mon Sep 17 00:00:00 2001
From: Rui Chang <rui.chang@arm.com>
Date: Tue, 11 May 2021 17:27:23 +0800
Subject: [PATCH 154/342] test/json_config: Fix json_config test fail for
 multiple nvme disk config

In json_config test, when there are multiple nvme disks, we see errors like:

ERROR: expected event 'bdev_register:Nvme0n1p1' but got 'bdev_register:Nvme1n1' (whole event line: bdev_register:Nvme1n1:1)

The reason is when there are multiple nvme disks in the system, when
start nvmf_tgt, it will register all the disks in bdev, so there would
be multiple bdev_register events for these disks before we run
create_bdev_subsystem_config. So in create_bdev_subsystem_config we need
add these events to expected events list first.

Signed-off-by: Rui Chang <rui.chang@arm.com>
Change-Id: Ice8f5464975e68ae63fec891ef18dbc7590a9ab5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7858
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 test/json_config/json_config.sh | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/test/json_config/json_config.sh b/test/json_config/json_config.sh
index 5dd95e0c6..396213469 100755
--- a/test/json_config/json_config.sh
+++ b/test/json_config/json_config.sh
@@ -150,6 +150,20 @@ function create_bdev_subsystem_config() {
 
 	local expected_notifications=()
 
+	local event_line event ev_type ev_ctx
+	local rc=""
+
+	# Before testing notifications generated by the operations in this function, we
+	# need add existing notification to the expected list first. Otherwise it would fail.
+	while read -r event_line; do
+		# remove ID
+		event="${event_line%:*}"
+		ev_type=${event%:*}
+		ev_ctx=${event#*:}
+
+		expected_notifications+=(${ev_type}:${ev_ctx})
+	done < <(tgt_rpc notify_get_notifications -i ${last_event_id} | jq -r '.[] | "\(.type):\(.ctx):\(.id)"')
+
 	if [[ $SPDK_TEST_BLOCKDEV -eq 1 ]]; then
 		local lvol_store_base_bdev=Nvme0n1
 		if ! tgt_rpc get_bdevs --name ${lvol_store_base_bdev} > /dev/null; then
@@ -174,7 +188,6 @@ function create_bdev_subsystem_config() {
 		tgt_rpc bdev_malloc_create 16 4096 --name Malloc1
 
 		expected_notifications+=(
-			bdev_register:${lvol_store_base_bdev}
 			bdev_register:${lvol_store_base_bdev}p1
 			bdev_register:${lvol_store_base_bdev}p0
 			bdev_register:Malloc3
-- 
2.26.2


From 7e9d5ae123affadb4ac1b6282fdc04bc7a83aee0 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Wed, 12 May 2021 21:10:54 +0800
Subject: [PATCH 155/342] doc/vhost: update example parameter when starting VM

Some Linux distributions reports kernel panic using the same
command line as we suggested in this document, that's because
number of IO queues is bigger than number of CPUs, so here
just fix it and added a comment on the number of IO queues
parameter.

See issues #1295 and #1737.

Change-Id: Ie1e18d5e83a80523f71d98b8761d13a8d57cc9ab
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7852
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 doc/vhost.md | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/doc/vhost.md b/doc/vhost.md
index a44454fd3..6282bbc2d 100644
--- a/doc/vhost.md
+++ b/doc/vhost.md
@@ -280,9 +280,9 @@ host:~# taskset -c 2,3 qemu-system-x86_64 \
   -drive file=guest_os_image.qcow2,if=none,id=disk \
   -device ide-hd,drive=disk,bootindex=0 \
   -chardev socket,id=spdk_vhost_scsi0,path=/var/tmp/vhost.0 \
-  -device vhost-user-scsi-pci,id=scsi0,chardev=spdk_vhost_scsi0,num_queues=4 \
+  -device vhost-user-scsi-pci,id=scsi0,chardev=spdk_vhost_scsi0,num_queues=2 \
   -chardev socket,id=spdk_vhost_blk0,path=/var/tmp/vhost.1 \
-  -device vhost-user-blk-pci,chardev=spdk_vhost_blk0,num-queues=4
+  -device vhost-user-blk-pci,chardev=spdk_vhost_blk0,num-queues=2
 ~~~
 
 Please note the following two commands are run on the guest VM.
@@ -331,6 +331,10 @@ to set `num_queues=4` to saturate physical device. Adding too many queues might
 vhost performance degradation if many vhost devices are used because each device will require
 additional `num_queues` to be polled.
 
+Some Linux distributions report a kernel panic when starting the VM if the number of I/O queues
+specified via the `num-queues` parameter is greater than number of vCPUs. If you need to use
+more I/O queues than vCPUs, check that your OS image supports that configuration.
+
 ## Hot-attach/hot-detach {#vhost_hotattach}
 
 Hotplug/hotremove within a vhost controller is called hot-attach/detach. This is to
-- 
2.26.2


From 0346e733e12292fd5437615de7974269664565f9 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Tue, 18 May 2021 16:16:22 +0000
Subject: [PATCH 156/342] histogram: add handling for datapoint == 0

__builtin_clzll(0) is technically undefined, but
returns 64 on all currently tested architectures,
which is the desired value.  So remove the
assert(datapoint != 0) and instead just set clz=64
for that case so that we aren't depending on
undefined behavior.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ibb05f756e07f20a250d24f0c5adecc4dfbc5a056
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7939
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk/histogram_data.h | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/include/spdk/histogram_data.h b/include/spdk/histogram_data.h
index 5f114fe69..de9ef08e7 100644
--- a/include/spdk/histogram_data.h
+++ b/include/spdk/histogram_data.h
@@ -123,9 +123,7 @@ __spdk_histogram_data_get_bucket_range(struct spdk_histogram_data *h, uint64_t d
 {
 	uint32_t clz, range;
 
-	assert(datapoint != 0);
-
-	clz = __builtin_clzll(datapoint);
+	clz = datapoint > 0 ? __builtin_clzll(datapoint) : 64;
 
 	if (clz <= SPDK_HISTOGRAM_BUCKET_LSB(h)) {
 		range = SPDK_HISTOGRAM_BUCKET_LSB(h) - clz;
-- 
2.26.2


From e6b7e585746259fc86b98d97fabe2016186d61d7 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 6 May 2021 21:43:05 +0000
Subject: [PATCH 157/342] examples: add zipf example app

This app shows how to use the SPDK zipf functionality,
and uses spdk_histogram to show the cumulative
distributions.

Usage:

build/examples/zipf 1.2 100000000 10000

This will generate 10000 random numbers from a range
[0, 100000000) using zipf theta parameter = 1.2.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I36486399b54f57e771cbc5530ae4905afca60b64
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7780
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 examples/Makefile           |  2 +-
 examples/util/Makefile      | 47 ++++++++++++++++++
 examples/util/zipf/Makefile | 42 ++++++++++++++++
 examples/util/zipf/zipf.c   | 96 +++++++++++++++++++++++++++++++++++++
 4 files changed, 186 insertions(+), 1 deletion(-)
 create mode 100644 examples/util/Makefile
 create mode 100644 examples/util/zipf/Makefile
 create mode 100644 examples/util/zipf/zipf.c

diff --git a/examples/Makefile b/examples/Makefile
index fa7c0d9b5..098814b1b 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -34,7 +34,7 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-DIRS-y += accel bdev blob ioat nvme sock vmd nvmf
+DIRS-y += accel bdev blob ioat nvme sock vmd nvmf util
 
 ifeq ($(OS),Linux)
 DIRS-$(CONFIG_VHOST) += interrupt_tgt
diff --git a/examples/util/Makefile b/examples/util/Makefile
new file mode 100644
index 000000000..40ddb1e2c
--- /dev/null
+++ b/examples/util/Makefile
@@ -0,0 +1,47 @@
+#
+#  BSD LICENSE
+#
+#  Copyright (c) Intel Corporation.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Intel Corporation nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
+include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
+
+DIRS-y += zipf
+
+.PHONY: all clean $(DIRS-y)
+
+all: $(DIRS-y)
+	@:
+
+clean: $(DIRS-y)
+	@:
+
+include $(SPDK_ROOT_DIR)/mk/spdk.subdirs.mk
diff --git a/examples/util/zipf/Makefile b/examples/util/zipf/Makefile
new file mode 100644
index 000000000..66528d9a9
--- /dev/null
+++ b/examples/util/zipf/Makefile
@@ -0,0 +1,42 @@
+#
+#  Copyright (c) Intel Corporation.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Intel Corporation nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../..)
+include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
+include $(SPDK_ROOT_DIR)/mk/spdk.modules.mk
+
+APP = zipf
+
+C_SRCS := zipf.c
+
+SPDK_LIB_LIST = util
+
+include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/examples/util/zipf/zipf.c b/examples/util/zipf/zipf.c
new file mode 100644
index 000000000..795cd5054
--- /dev/null
+++ b/examples/util/zipf/zipf.c
@@ -0,0 +1,96 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "spdk/stdinc.h"
+#include "spdk/zipf.h"
+#include "spdk/histogram_data.h"
+#include "spdk/string.h"
+
+static void
+usage(const char *prog)
+{
+	printf("usage: %s <theta> <range> <count>\n", prog);
+}
+
+static void
+print_bucket(void *ctx, uint64_t start, uint64_t end, uint64_t count,
+	     uint64_t total, uint64_t so_far)
+{
+	double so_far_pct;
+	char range[64];
+
+	if (count == 0) {
+		return;
+	}
+
+	so_far_pct = (double)so_far * 100 / total;
+	snprintf(range, sizeof(range), "[%ju, %ju)", start, end);
+	printf("%24s: %9.4f%%  (%9ju)\n", range, so_far_pct, count);
+}
+
+int
+main(int argc, char **argv)
+{
+	struct spdk_zipf *zipf;
+	struct spdk_histogram_data *h;
+	float theta;
+	int range, count, i;
+
+	if (argc < 4) {
+		usage(argv[0]);
+		return 1;
+	}
+
+	theta = atof(argv[1]);
+	range = spdk_strtol(argv[2], 10);
+	count = spdk_strtol(argv[3], 10);
+
+	if (range <= 0 || count <= 0) {
+		printf("range and count must be positive integers\n");
+		usage(argv[0]);
+		return 1;
+	}
+
+	zipf = spdk_zipf_create(range, theta, time(NULL));
+	h = spdk_histogram_data_alloc();
+
+	for (i = 0; i < count; i++) {
+		spdk_histogram_data_tally(h, spdk_zipf_generate(zipf));
+	}
+
+	spdk_histogram_data_iterate(h, print_bucket, NULL);
+	spdk_histogram_data_free(h);
+	spdk_zipf_free(&zipf);
+
+	return 0;
+}
-- 
2.26.2


From 760452eefe9a9ad32aa826cb3e12dc2b6a146d40 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 6 May 2021 23:18:58 +0000
Subject: [PATCH 158/342] bdevperf: store the rand_r seed in the bdevperf_job

This eliminates the thread-local seed variable.  But
we're also adding zipf distributions in an upcoming
patch, and we'll want to store that context in the
job rather than making it thread local.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: If8079682e7d3da8f989ee6b880edc8d3fcb4fdd8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7789
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 test/bdev/bdevperf/bdevperf.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/test/bdev/bdevperf/bdevperf.c b/test/bdev/bdevperf/bdevperf.c
index 9515f2b7a..fcdeed5ea 100644
--- a/test/bdev/bdevperf/bdevperf.c
+++ b/test/bdev/bdevperf/bdevperf.c
@@ -118,6 +118,7 @@ struct bdevperf_job {
 	bool				flush;
 	bool				abort;
 	int				queue_depth;
+	unsigned int			seed;
 
 	uint64_t			io_completed;
 	uint64_t			io_failed;
@@ -826,15 +827,13 @@ bdevperf_job_get_task(struct bdevperf_job *job)
 	return task;
 }
 
-static __thread unsigned int seed = 0;
-
 static void
 bdevperf_submit_single(struct bdevperf_job *job, struct bdevperf_task *task)
 {
 	uint64_t offset_in_ios;
 
 	if (job->is_random) {
-		offset_in_ios = rand_r(&seed) % job->size_in_ios;
+		offset_in_ios = rand_r(&job->seed) % job->size_in_ios;
 	} else {
 		offset_in_ios = job->offset_in_ios++;
 		if (job->offset_in_ios == job->size_in_ios) {
@@ -884,7 +883,7 @@ bdevperf_submit_single(struct bdevperf_job *job, struct bdevperf_task *task)
 	} else if (job->write_zeroes) {
 		task->io_type = SPDK_BDEV_IO_TYPE_WRITE_ZEROES;
 	} else if ((job->rw_percentage == 100) ||
-		   (job->rw_percentage != 0 && ((rand_r(&seed) % 100) < job->rw_percentage))) {
+		   (job->rw_percentage != 0 && ((rand_r(&job->seed) % 100) < job->rw_percentage))) {
 		task->io_type = SPDK_BDEV_IO_TYPE_READ;
 	} else {
 		if (g_zcopy) {
-- 
2.26.2


From bef22f45e730677e7fa9643987234dcee862d544 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 6 May 2021 23:12:43 +0000
Subject: [PATCH 159/342] bdevperf: add -F option for zipf distribution

Currently this will only support a global setting
that must be set on the command line.  We can make
it per-job later, but will require adding float
support to the conf library.

Tested by running bdevperf with some malloc
bdevs.  Performance with low theta values (i.e. 0.2)
are almost identical to random w/o zipf.  But
higher zipf values start to show better performance,
because we get more hits on data that is already
in the CPU cache.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I55b1587cdec2919973b488786d361042ca210606
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7790
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 test/bdev/bdevperf/bdevperf.c | 25 ++++++++++++++++++++++---
 1 file changed, 22 insertions(+), 3 deletions(-)

diff --git a/test/bdev/bdevperf/bdevperf.c b/test/bdev/bdevperf/bdevperf.c
index fcdeed5ea..e7ee68b27 100644
--- a/test/bdev/bdevperf/bdevperf.c
+++ b/test/bdev/bdevperf/bdevperf.c
@@ -45,6 +45,7 @@
 #include "spdk/rpc.h"
 #include "spdk/bit_array.h"
 #include "spdk/conf.h"
+#include "spdk/zipf.h"
 
 #define BDEVPERF_CONFIG_MAX_FILENAME 1024
 #define BDEVPERF_CONFIG_UNDEFINED -1
@@ -91,6 +92,7 @@ static bool g_multithread_mode = false;
 static int g_timeout_in_sec;
 static struct spdk_conf *g_bdevperf_conf = NULL;
 static const char *g_bdevperf_conf_file = NULL;
+static double g_zipf_theta;
 
 static struct spdk_cpuset g_all_cpuset;
 static struct spdk_poller *g_perf_timer = NULL;
@@ -136,6 +138,7 @@ struct bdevperf_job {
 	struct spdk_poller		*run_timer;
 	struct spdk_poller		*reset_timer;
 	struct spdk_bit_array		*outstanding;
+	struct spdk_zipf		*zipf;
 	TAILQ_HEAD(, bdevperf_task)	task_list;
 };
 
@@ -406,7 +409,7 @@ bdevperf_test_done(void *ctx)
 		if (job->verify) {
 			spdk_bit_array_free(&job->outstanding);
 		}
-
+		spdk_zipf_free(&job->zipf);
 		free(job->name);
 		free(job);
 	}
@@ -832,7 +835,9 @@ bdevperf_submit_single(struct bdevperf_job *job, struct bdevperf_task *task)
 {
 	uint64_t offset_in_ios;
 
-	if (job->is_random) {
+	if (job->zipf) {
+		offset_in_ios = spdk_zipf_generate(job->zipf);
+	} else if (job->is_random) {
 		offset_in_ios = rand_r(&job->seed) % job->size_in_ios;
 	} else {
 		offset_in_ios = job->offset_in_ios++;
@@ -1298,6 +1303,10 @@ bdevperf_construct_job(struct spdk_bdev *bdev, struct job_config *config,
 		job->ios_base = 0;
 	}
 
+	if (job->is_random && g_zipf_theta > 0) {
+		job->zipf = spdk_zipf_create(job->size_in_ios, g_zipf_theta, 0);
+	}
+
 	if (job->verify) {
 		job->outstanding = spdk_bit_array_create(job->size_in_ios);
 		if (job->outstanding == NULL) {
@@ -1935,6 +1944,15 @@ bdevperf_parse_arg(int ch, char *arg)
 		g_continue_on_failure = true;
 	} else if (ch == 'j') {
 		g_bdevperf_conf_file = optarg;
+	} else if (ch == 'F') {
+		char *endptr;
+
+		errno = 0;
+		g_zipf_theta = strtod(optarg, &endptr);
+		if (errno || optarg == endptr || g_zipf_theta < 0) {
+			fprintf(stderr, "Illegal zipf theta value %s\n", optarg);
+			return -EINVAL;
+		}
 	} else {
 		tmp = spdk_strtoll(optarg, 10);
 		if (tmp < 0) {
@@ -1992,6 +2010,7 @@ bdevperf_usage(void)
 	printf(" -S <period>               show performance result in real time every <period> seconds\n");
 	printf(" -T <bdev>                 bdev to run against. Default: all available bdevs.\n");
 	printf(" -f                        continue processing I/O even after failures\n");
+	printf(" -F <zipf theta>           use zipf distribution for random I/O\n");
 	printf(" -Z                        enable using zcopy bdev API for read or write I/O\n");
 	printf(" -z                        start bdevperf, but wait for RPC to start tests\n");
 	printf(" -X                        abort timed out I/O\n");
@@ -2102,7 +2121,7 @@ main(int argc, char **argv)
 	opts.rpc_addr = NULL;
 	opts.shutdown_cb = spdk_bdevperf_shutdown_cb;
 
-	if ((rc = spdk_app_parse_args(argc, argv, &opts, "Zzfq:o:t:w:k:CM:P:S:T:Xj:", NULL,
+	if ((rc = spdk_app_parse_args(argc, argv, &opts, "Zzfq:o:t:w:k:CF:M:P:S:T:Xj:", NULL,
 				      bdevperf_parse_arg, bdevperf_usage)) !=
 	    SPDK_APP_PARSE_ARGS_SUCCESS) {
 		return rc;
-- 
2.26.2


From 6ee7dd5375a74b6ec99d0960e44fe09d14015eba Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 7 May 2021 00:02:40 +0000
Subject: [PATCH 160/342] nvme/perf: move rand_r seed to ns_entry_

This eliminates the thread-local seed variable.  But
we're also adding zipf distributions in an upcoming
patch, and we'll want to store that context in the
ns_entry rather than making it thread local.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Icc4a8b7bdbc9cd35525f2d35c9ada8e3ec0ba76c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7791
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 examples/nvme/perf/perf.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/examples/nvme/perf/perf.c b/examples/nvme/perf/perf.c
index e38ee8f06..530ea5120 100644
--- a/examples/nvme/perf/perf.c
+++ b/examples/nvme/perf/perf.c
@@ -105,6 +105,7 @@ struct ns_entry {
 	uint32_t		block_size;
 	uint32_t		md_size;
 	bool			md_interleave;
+	unsigned int		seed;
 	bool			pi_loc;
 	enum spdk_nvme_pi_type	pi_type;
 	uint32_t		io_flags;
@@ -1341,8 +1342,6 @@ register_ctrlr(struct spdk_nvme_ctrlr *ctrlr, struct trid_entry *trid_entry)
 	}
 }
 
-static __thread unsigned int seed = 0;
-
 static inline void
 submit_single_io(struct perf_task *task)
 {
@@ -1352,7 +1351,7 @@ submit_single_io(struct perf_task *task)
 	struct ns_entry		*entry = ns_ctx->entry;
 
 	if (g_is_random) {
-		offset_in_ios = rand_r(&seed) % entry->size_in_ios;
+		offset_in_ios = rand_r(&entry->seed) % entry->size_in_ios;
 	} else {
 		offset_in_ios = ns_ctx->offset_in_ios++;
 		if (ns_ctx->offset_in_ios == entry->size_in_ios) {
@@ -1363,7 +1362,7 @@ submit_single_io(struct perf_task *task)
 	task->submit_tsc = spdk_get_ticks();
 
 	if ((g_rw_percentage == 100) ||
-	    (g_rw_percentage != 0 && ((rand_r(&seed) % 100) < g_rw_percentage))) {
+	    (g_rw_percentage != 0 && ((rand_r(&entry->seed) % 100) < g_rw_percentage))) {
 		task->is_read = true;
 	} else {
 		task->is_read = false;
-- 
2.26.2


From 40a9b64352d6122d71db99f50626e607652d88ff Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 7 May 2021 00:01:23 +0000
Subject: [PATCH 161/342] nvme/perf: add -F option for zipf distribution

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I818c5671574f556176a6cc5a0e372735a9e8a51a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7792
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 examples/nvme/perf/perf.c | 30 ++++++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/examples/nvme/perf/perf.c b/examples/nvme/perf/perf.c
index 530ea5120..5e62e801c 100644
--- a/examples/nvme/perf/perf.c
+++ b/examples/nvme/perf/perf.c
@@ -49,6 +49,7 @@
 #include "spdk/log.h"
 #include "spdk/likely.h"
 #include "spdk/sock.h"
+#include "spdk/zipf.h"
 
 #ifdef SPDK_CONFIG_URING
 #include <liburing.h>
@@ -106,6 +107,7 @@ struct ns_entry {
 	uint32_t		md_size;
 	bool			md_interleave;
 	unsigned int		seed;
+	struct spdk_zipf	*zipf;
 	bool			pi_loc;
 	enum spdk_nvme_pi_type	pi_type;
 	uint32_t		io_flags;
@@ -268,6 +270,7 @@ static bool g_exit;
 /* Default to 10 seconds for the keep alive value. This value is arbitrary. */
 static uint32_t g_keep_alive_timeout_in_ms = 10000;
 static uint32_t g_quiet_count = 1;
+static double g_zipf_theta;
 
 /* When user specifies -Q, some error messages are rate limited.  When rate
  * limited, we only print the error message every g_quiet_count times the
@@ -727,6 +730,10 @@ register_file(const char *path)
 	entry->size_in_ios = size / g_io_size_bytes;
 	entry->io_size_blocks = g_io_size_bytes / blklen;
 
+	if (g_is_random && g_zipf_theta > 0) {
+		entry->zipf = spdk_zipf_create(entry->size_in_ios, g_zipf_theta, 0);
+	}
+
 	snprintf(entry->name, sizeof(entry->name), "%s", path);
 
 	g_num_namespaces++;
@@ -1214,6 +1221,10 @@ register_ns(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
 	entry->size_in_ios = ns_size / g_io_size_bytes;
 	entry->io_size_blocks = g_io_size_bytes / sector_size;
 
+	if (g_is_random && g_zipf_theta > 0) {
+		entry->zipf = spdk_zipf_create(entry->size_in_ios, g_zipf_theta, 0);
+	}
+
 	entry->block_size = spdk_nvme_ns_get_extended_sector_size(ns);
 	entry->md_size = spdk_nvme_ns_get_md_size(ns);
 	entry->md_interleave = spdk_nvme_ns_supports_extended_lba(ns);
@@ -1254,6 +1265,7 @@ unregister_namespaces(void)
 
 	TAILQ_FOREACH_SAFE(entry, &g_namespaces, link, tmp) {
 		TAILQ_REMOVE(&g_namespaces, entry, link);
+		spdk_zipf_free(&entry->zipf);
 		free(entry);
 	}
 }
@@ -1350,7 +1362,9 @@ submit_single_io(struct perf_task *task)
 	struct ns_worker_ctx	*ns_ctx = task->ns_ctx;
 	struct ns_entry		*entry = ns_ctx->entry;
 
-	if (g_is_random) {
+	if (entry->zipf) {
+		offset_in_ios = spdk_zipf_generate(entry->zipf);
+	} else if (g_is_random) {
 		offset_in_ios = rand_r(&entry->seed) % entry->size_in_ios;
 	} else {
 		offset_in_ios = ns_ctx->offset_in_ios++;
@@ -1698,6 +1712,7 @@ static void usage(char *program_name)
 	printf("\t[-w, --io-pattern <pattern> io pattern type, must be one of\n");
 	printf("\t\t(read, write, randread, randwrite, rw, randrw)]\n");
 	printf("\t[-M, --rwmixread <0-100> rwmixread (100 for reads, 0 for writes)]\n");
+	printf("\t[-F, --zipf <theta> use zipf distribution for random I/O\n");
 	printf("\t[-L, --enable-sw-latency-tracking enable latency tracking via sw, default: disabled]\n");
 	printf("\t\t-L for latency summary, -LL for detailed histogram\n");
 	printf("\t[-l, --enable-ssd-latency-tracking enable latency tracking via ssd (if supported), default: disabled]\n");
@@ -2170,7 +2185,7 @@ parse_metadata(const char *metacfg_str)
 	return 0;
 }
 
-#define PERF_GETOPT_SHORT "a:b:c:e:gi:lmo:q:r:k:s:t:w:z:A:C:DGHILM:NO:P:Q:RS:T:U:VZ:"
+#define PERF_GETOPT_SHORT "a:b:c:e:gi:lmo:q:r:k:s:t:w:z:A:C:DF:GHILM:NO:P:Q:RS:T:U:VZ:"
 
 static const struct option g_perf_cmdline_opts[] = {
 #define PERF_WARMUP_TIME	'a'
@@ -2211,6 +2226,8 @@ static const struct option g_perf_cmdline_opts[] = {
 	{"max-completion-per-poll",			required_argument,	NULL, PERF_MAX_COMPLETIONS_PER_POLL},
 #define PERF_DISABLE_SQ_CMB	'D'
 	{"disable-sq-cmb",			no_argument,	NULL, PERF_DISABLE_SQ_CMB},
+#define PERF_ZIPF		'F'
+	{"zipf",				required_argument,	NULL, PERF_ZIPF},
 #define PERF_ENABLE_DEBUG	'G'
 	{"enable-debug",			no_argument,	NULL, PERF_ENABLE_DEBUG},
 #define PERF_ENABLE_TCP_HDGST	'H'
@@ -2255,6 +2272,7 @@ parse_args(int argc, char **argv, struct spdk_env_opts *env_opts)
 	int op, long_idx;
 	long int val;
 	int rc;
+	char *endptr;
 
 	while ((op = getopt_long(argc, argv, PERF_GETOPT_SHORT, g_perf_cmdline_opts, &long_idx)) != -1) {
 		switch (op) {
@@ -2330,6 +2348,14 @@ parse_args(int argc, char **argv, struct spdk_env_opts *env_opts)
 				break;
 			}
 			break;
+		case PERF_ZIPF:
+			errno = 0;
+			g_zipf_theta = strtod(optarg, &endptr);
+			if (errno || optarg == endptr || g_zipf_theta < 0) {
+				fprintf(stderr, "Illegal zipf theta value %s\n", optarg);
+				return 1;
+			}
+			break;
 		case PERF_ALLOWED_PCI_ADDR:
 			if (add_allowed_pci_device(optarg, env_opts)) {
 				usage(argv[0]);
-- 
2.26.2


From 4e4d865fa000feca82f1bc0bbb67b4d02e40f7d7 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Mon, 17 May 2021 15:22:13 +0800
Subject: [PATCH 162/342] test/nvme_cuse: cases for getting cuse ns device

Change-Id: I117b81554b6cf0f6eb1af7bd1050ff06cc351af9
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7442
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c | 41 +++++++++++++++++--
 1 file changed, 38 insertions(+), 3 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
index 7a2cc9674..d1a10b767 100644
--- a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
+++ b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
@@ -49,9 +49,6 @@ DEFINE_STUB(spdk_nvme_ctrlr_cmd_io_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
 		struct spdk_nvme_qpair *qpair, struct spdk_nvme_cmd *cmd, void *buf, uint32_t len,
 		spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
 
-DEFINE_STUB(spdk_nvme_ctrlr_get_num_ns, uint32_t,
-	    (struct spdk_nvme_ctrlr *ctrlr), 128);
-
 DEFINE_STUB(spdk_nvme_ctrlr_reset, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
 
 DEFINE_STUB(spdk_nvme_ns_cmd_read, int,
@@ -90,6 +87,12 @@ DEFINE_STUB(fuse_reply_err, int, (fuse_req_t req, int err), 0);
 
 struct cuse_io_ctx *g_ut_ctx;
 
+uint32_t
+spdk_nvme_ctrlr_get_num_ns(struct spdk_nvme_ctrlr *ctrlr)
+{
+	return ctrlr->num_ns;
+}
+
 DEFINE_RETURN_MOCK(nvme_io_msg_send, int);
 int
 nvme_io_msg_send(struct spdk_nvme_ctrlr *ctrlr,
@@ -204,6 +207,37 @@ test_cuse_nvme_submit_passthru_cmd(void)
 	free(passthru_cmd);
 }
 
+static void
+test_nvme_cuse_get_cuse_ns_device(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct cuse_device ctrlr_device = {};
+	struct cuse_device ns_devices[3] = {};
+	struct cuse_device *cuse_dev = NULL;
+
+	ctrlr.num_ns = 3;
+	ctrlr_device.ctrlr = &ctrlr;
+	ctrlr_device.ns_devices = ns_devices;
+	ns_devices[0].is_started = true;
+	ns_devices[1].is_started = false;
+
+	SPDK_CU_ASSERT_FATAL(TAILQ_EMPTY(&g_ctrlr_ctx_head));
+	TAILQ_INSERT_TAIL(&g_ctrlr_ctx_head, &ctrlr_device, tailq);
+
+	cuse_dev = nvme_cuse_get_cuse_ns_device(&ctrlr, 1);
+	CU_ASSERT(cuse_dev == &ns_devices[0]);
+
+	/* nsid 2 was not started */
+	cuse_dev = nvme_cuse_get_cuse_ns_device(&ctrlr, 2);
+	CU_ASSERT(cuse_dev == NULL);
+
+	/* nsid invalid */
+	cuse_dev = nvme_cuse_get_cuse_ns_device(&ctrlr, 0);
+	CU_ASSERT(cuse_dev == NULL);
+
+	TAILQ_REMOVE(&g_ctrlr_ctx_head, &ctrlr_device, tailq);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -215,6 +249,7 @@ int main(int argc, char **argv)
 	suite = CU_add_suite("nvme_cuse", NULL, NULL);
 	CU_ADD_TEST(suite, test_cuse_nvme_submit_io_read_write);
 	CU_ADD_TEST(suite, test_cuse_nvme_submit_passthru_cmd);
+	CU_ADD_TEST(suite, test_nvme_cuse_get_cuse_ns_device);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 5c0160263cdc873e090d155d13af018ae283cbd5 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Thu, 22 Apr 2021 21:51:42 +0800
Subject: [PATCH 163/342] bdev/rbd: Revise bdev_rbd_create rpc function.

Revise bdev_rbd_create rpc call to add an optional
parameter "--cluster-name", e.g., "--cluster-name Rados".

Then users can create a rbd bdev with registered
Rados Cluster. This shared strategy can be used to
remove the thread creation overhead if multiple rbds
are connected to the same Ceph cluster.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: Ide5800f8fc6b2074805272a59731c666fe279b9a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7584
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 CHANGELOG.md                   |   3 +
 doc/jsonrpc.md                 |  32 +++++++
 module/bdev/rbd/bdev_rbd.c     | 159 ++++++++++++++++++++++++++++++---
 module/bdev/rbd/bdev_rbd.h     |   2 +-
 module/bdev/rbd/bdev_rbd_rpc.c |   7 +-
 scripts/rpc.py                 |   4 +-
 scripts/rpc/bdev.py            |   5 +-
 test/iscsi_tgt/rbd/rbd.sh      |   4 +-
 8 files changed, 196 insertions(+), 20 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4c91c9c02..e2a41fe9f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -23,6 +23,9 @@ New RPC `bdev_rbd_register_cluster` and `bdev_rbd_unregister_cluster` was added,
 and delete the rados object cluster, then users can choose the cluster to create related rbd
 device.
 
+Revised `bdev_rbd_create` parameter, it allows to use an optional parameter --cluster-name
+to create a rbd bdev with  an already registered Rados Cluster Object.
+
 ## v21.04:
 
 ### accel
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 6c0e88514..264b0f33f 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -3421,6 +3421,7 @@ pool_name               | Required | string      | Pool name
 rbd_name                | Required | string      | Image name
 block_size              | Required | number      | Block size
 config                  | Optional | string map  | Explicit librados configuration
+cluster_name            | Optional | string      | Rados cluster object name created in this module.
 
 If no config is specified, Ceph configuration files must exist with
 all relevant settings for accessing the pool. If a config map is
@@ -3432,6 +3433,10 @@ secret key stored in Ceph keyrings) are enough.
 When accessing the image as some user other than "admin" (the
 default), the "user_id" has to be set.
 
+If provided with cluster_name option, it will use the Rados cluster object
+referenced by the name (created by bdev_rbd_register_cluster RPC) and ignores
+"user_id + config" combination to create its own Rados cluster.
+
 ### Result
 
 Name of newly created bdev.
@@ -3468,6 +3473,33 @@ response:
 }
 ~~~
 
+Example request with `cluster_name`:
+
+~~
+{
+  "params": {
+    "pool_name": "rbd",
+    "rbd_name": "foo",
+    "block_size": 4096,
+    "cluster_name": "rbd_cluster"
+  },
+  "jsonrpc": "2.0",
+  "method": "bdev_rbd_create",
+  "id": 1
+}
+~~
+
+Example response:
+
+~~
+response:
+{
+  "jsonrpc": "2.0",
+  "id": 1,
+  "result": "Ceph0"
+}
+~~
+
 ## bdev_rbd_delete {#rpc_bdev_rbd_delete}
 
 Delete @ref bdev_config_rbd bdev
diff --git a/module/bdev/rbd/bdev_rbd.c b/module/bdev/rbd/bdev_rbd.c
index 76373b626..ff981cb4e 100644
--- a/module/bdev/rbd/bdev_rbd.c
+++ b/module/bdev/rbd/bdev_rbd.c
@@ -63,6 +63,8 @@ struct bdev_rbd {
 	char *pool_name;
 	char **config;
 	rados_t cluster;
+	rados_t *cluster_p;
+	char *cluster_name;
 	rbd_image_info_t info;
 	TAILQ_ENTRY(bdev_rbd) tailq;
 	struct spdk_poller *reset_timer;
@@ -113,14 +115,39 @@ bdev_rbd_cluster_free(struct bdev_rbd_cluster *entry)
 }
 
 static void
-bdev_rbd_free(struct bdev_rbd *rbd)
+bdev_rbd_put_cluster(rados_t **cluster)
 {
-	if (!rbd) {
+	struct bdev_rbd_cluster *entry;
+
+	assert(cluster != NULL);
+
+	/* No need go through the map if *cluster equals to NULL */
+	if (*cluster == NULL) {
 		return;
 	}
 
-	if (rbd->cluster) {
-		rados_shutdown(rbd->cluster);
+	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
+	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+		if (*cluster != &entry->cluster) {
+			continue;
+		}
+
+		assert(entry->ref > 0);
+		entry->ref--;
+		*cluster = NULL;
+		pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+		return;
+	}
+
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+	SPDK_ERRLOG("Cannot find the entry for cluster=%p\n", cluster);
+}
+
+static void
+bdev_rbd_free(struct bdev_rbd *rbd)
+{
+	if (!rbd) {
+		return;
 	}
 
 	free(rbd->disk.name);
@@ -128,6 +155,14 @@ bdev_rbd_free(struct bdev_rbd *rbd)
 	free(rbd->user_id);
 	free(rbd->pool_name);
 	bdev_rbd_free_config(rbd->config);
+
+	if (rbd->cluster_name) {
+		bdev_rbd_put_cluster(&rbd->cluster_p);
+		free(rbd->cluster_name);
+	} else if (rbd->cluster) {
+		rados_shutdown(rbd->cluster);
+	}
+
 	free(rbd);
 }
 
@@ -209,11 +244,49 @@ bdev_rados_cluster_init(const char *user_id, const char *const *config,
 	return 0;
 }
 
+static int
+bdev_rbd_get_cluster(const char *cluster_name, rados_t **cluster)
+{
+	struct bdev_rbd_cluster *entry;
+
+	if (cluster == NULL) {
+		SPDK_ERRLOG("cluster should not be NULL\n");
+		return -1;
+	}
+
+	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
+	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+		if (strncmp(cluster_name, entry->name, strlen(entry->name)) == 0) {
+			entry->ref++;
+			*cluster = &entry->cluster;
+			pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+			return 0;
+		}
+	}
+
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+	return -1;
+}
+
+static int
+bdev_rbd_shared_cluster_init(const char *cluster_name, rados_t **cluster)
+{
+	int ret;
+
+	ret = bdev_rbd_get_cluster(cluster_name, cluster);
+	if (ret < 0) {
+		SPDK_ERRLOG("Failed to create rados_t struct\n");
+		return -1;
+	}
+
+	return ret;
+}
+
 static void *
 bdev_rbd_cluster_handle(void *arg)
 {
-	struct bdev_rbd *rbd = arg;
 	void *ret = arg;
+	struct bdev_rbd *rbd = arg;
 	int rc;
 
 	rc = bdev_rados_cluster_init(rbd->user_id, (const char *const *)rbd->config,
@@ -234,14 +307,24 @@ bdev_rbd_init(struct bdev_rbd *rbd)
 	rados_ioctx_t io_ctx = NULL;
 	rbd_image_t image = NULL;
 
-	/* Cluster should be created in non-SPDK thread to avoid conflict between
-	 * Rados and SPDK thread */
-	if (spdk_call_unaffinitized(bdev_rbd_cluster_handle, rbd) == NULL) {
-		SPDK_ERRLOG("Cannot create the rados object on rbd=%p\n", rbd);
-		return -1;
+	if (!rbd->cluster_name) {
+		rbd->cluster_p = &rbd->cluster;
+		/* Cluster should be created in non-SPDK thread to avoid conflict between
+		 * Rados and SPDK thread */
+		if (spdk_call_unaffinitized(bdev_rbd_cluster_handle, rbd) == NULL) {
+			SPDK_ERRLOG("Cannot create the rados object on rbd=%p\n", rbd);
+			return -1;
+		}
+	} else {
+		ret = bdev_rbd_shared_cluster_init(rbd->cluster_name, &rbd->cluster_p);
+		if (ret < 0) {
+			SPDK_ERRLOG("Failed to create rados object for rbd =%p on cluster_name=%s\n",
+				    rbd, rbd->cluster_name);
+			return -1;
+		}
 	}
 
-	ret = rados_ioctx_create(rbd->cluster, rbd->pool_name, &io_ctx);
+	ret = rados_ioctx_create(*(rbd->cluster_p), rbd->pool_name, &io_ctx);
 	if (ret < 0) {
 		SPDK_ERRLOG("Failed to create ioctx\n");
 		return -1;
@@ -514,9 +597,9 @@ bdev_rbd_handle(void *arg)
 	struct bdev_rbd_io_channel *ch = arg;
 	void *ret = arg;
 
-	assert(ch->disk->cluster != NULL);
+	assert(ch->disk->cluster_p != NULL);
 
-	if (rados_ioctx_create(ch->disk->cluster, ch->disk->pool_name, &ch->io_ctx) < 0) {
+	if (rados_ioctx_create(*(ch->disk->cluster_p), ch->disk->pool_name, &ch->io_ctx) < 0) {
 		SPDK_ERRLOG("Failed to create ioctx\n");
 		ret = NULL;
 		return ret;
@@ -602,6 +685,40 @@ bdev_rbd_get_io_channel(void *ctx)
 	return spdk_get_io_channel(rbd_bdev);
 }
 
+static void
+bdev_rbd_cluster_dump_entry(const char *cluster_name, struct spdk_json_write_ctx *w)
+{
+	struct bdev_rbd_cluster *entry;
+
+	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
+	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+		if (strncmp(cluster_name, entry->name, strlen(entry->name))) {
+			continue;
+		}
+		if (entry->user_id) {
+			spdk_json_write_named_string(w, "user_id", entry->user_id);
+		}
+
+		if (entry->config_param) {
+			char **config_entry = entry->config_param;
+
+			spdk_json_write_named_object_begin(w, "config_param");
+			while (*config_entry) {
+				spdk_json_write_named_string(w, config_entry[0], config_entry[1]);
+				config_entry += 2;
+			}
+			spdk_json_write_object_end(w);
+		} else if (entry->config_file) {
+			spdk_json_write_named_string(w, "config_file", entry->config_file);
+		}
+
+		pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+		return;
+	}
+
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+}
+
 static int
 bdev_rbd_dump_info_json(void *ctx, struct spdk_json_write_ctx *w)
 {
@@ -613,6 +730,11 @@ bdev_rbd_dump_info_json(void *ctx, struct spdk_json_write_ctx *w)
 
 	spdk_json_write_named_string(w, "rbd_name", rbd_bdev->rbd_name);
 
+	if (rbd_bdev->cluster_name) {
+		bdev_rbd_cluster_dump_entry(rbd_bdev->cluster_name, w);
+		goto end;
+	}
+
 	if (rbd_bdev->user_id) {
 		spdk_json_write_named_string(w, "user_id", rbd_bdev->user_id);
 	}
@@ -628,6 +750,7 @@ bdev_rbd_dump_info_json(void *ctx, struct spdk_json_write_ctx *w)
 		spdk_json_write_object_end(w);
 	}
 
+end:
 	spdk_json_write_object_end(w);
 
 	return 0;
@@ -842,7 +965,8 @@ bdev_rbd_create(struct spdk_bdev **bdev, const char *name, const char *user_id,
 		const char *pool_name,
 		const char *const *config,
 		const char *rbd_name,
-		uint32_t block_size)
+		uint32_t block_size,
+		const char *cluster_name)
 {
 	struct bdev_rbd *rbd;
 	int ret;
@@ -871,6 +995,13 @@ bdev_rbd_create(struct spdk_bdev **bdev, const char *name, const char *user_id,
 		}
 	}
 
+	if (cluster_name) {
+		rbd->cluster_name = strdup(cluster_name);
+		if (!rbd->cluster_name) {
+			bdev_rbd_free(rbd);
+			return -ENOMEM;
+		}
+	}
 	rbd->pool_name = strdup(pool_name);
 	if (!rbd->pool_name) {
 		bdev_rbd_free(rbd);
diff --git a/module/bdev/rbd/bdev_rbd.h b/module/bdev/rbd/bdev_rbd.h
index 44c88d436..4f6f0bad3 100644
--- a/module/bdev/rbd/bdev_rbd.h
+++ b/module/bdev/rbd/bdev_rbd.h
@@ -53,7 +53,7 @@ typedef void (*spdk_delete_rbd_complete)(void *cb_arg, int bdeverrno);
 int bdev_rbd_create(struct spdk_bdev **bdev, const char *name, const char *user_id,
 		    const char *pool_name,
 		    const char *const *config,
-		    const char *rbd_name, uint32_t block_size);
+		    const char *rbd_name, uint32_t block_size, const char *cluster_name);
 /**
  * Delete rbd bdev.
  *
diff --git a/module/bdev/rbd/bdev_rbd_rpc.c b/module/bdev/rbd/bdev_rbd_rpc.c
index 24e5042c8..8eee4400f 100644
--- a/module/bdev/rbd/bdev_rbd_rpc.c
+++ b/module/bdev/rbd/bdev_rbd_rpc.c
@@ -44,6 +44,7 @@ struct rpc_create_rbd {
 	char *rbd_name;
 	uint32_t block_size;
 	char **config;
+	char *cluster_name;
 };
 
 static void
@@ -54,6 +55,7 @@ free_rpc_create_rbd(struct rpc_create_rbd *req)
 	free(req->pool_name);
 	free(req->rbd_name);
 	bdev_rbd_free_config(req->config);
+	free(req->cluster_name);
 }
 
 static int
@@ -104,7 +106,8 @@ static const struct spdk_json_object_decoder rpc_create_rbd_decoders[] = {
 	{"pool_name", offsetof(struct rpc_create_rbd, pool_name), spdk_json_decode_string},
 	{"rbd_name", offsetof(struct rpc_create_rbd, rbd_name), spdk_json_decode_string},
 	{"block_size", offsetof(struct rpc_create_rbd, block_size), spdk_json_decode_uint32},
-	{"config", offsetof(struct rpc_create_rbd, config), bdev_rbd_decode_config, true}
+	{"config", offsetof(struct rpc_create_rbd, config), bdev_rbd_decode_config, true},
+	{"cluster_name", offsetof(struct rpc_create_rbd, cluster_name), spdk_json_decode_string, true}
 };
 
 static void
@@ -128,7 +131,7 @@ rpc_bdev_rbd_create(struct spdk_jsonrpc_request *request,
 	rc = bdev_rbd_create(&bdev, req.name, req.user_id, req.pool_name,
 			     (const char *const *)req.config,
 			     req.rbd_name,
-			     req.block_size);
+			     req.block_size, req.cluster_name);
 	if (rc) {
 		spdk_jsonrpc_send_error_response(request, rc, spdk_strerror(-rc));
 		goto cleanup;
diff --git a/scripts/rpc.py b/scripts/rpc.py
index 28824ab9f..47cb5b087 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -676,7 +676,8 @@ if __name__ == "__main__":
                                             config=config,
                                             pool_name=args.pool_name,
                                             rbd_name=args.rbd_name,
-                                            block_size=args.block_size))
+                                            block_size=args.block_size,
+                                            cluster_name=args.cluster_name))
 
     p = subparsers.add_parser('bdev_rbd_create', aliases=['construct_rbd_bdev'],
                               help='Add a bdev with ceph rbd backend')
@@ -687,6 +688,7 @@ if __name__ == "__main__":
     p.add_argument('pool_name', help='rbd pool name')
     p.add_argument('rbd_name', help='rbd image name')
     p.add_argument('block_size', help='rbd block size', type=int)
+    p.add_argument('-c', '--cluster_name', help="cluster name to identify the Rados cluster", required=False)
     p.set_defaults(func=bdev_rbd_create)
 
     def bdev_rbd_delete(args):
diff --git a/scripts/rpc/bdev.py b/scripts/rpc/bdev.py
index b30b5c32a..4f75cb81a 100644
--- a/scripts/rpc/bdev.py
+++ b/scripts/rpc/bdev.py
@@ -694,7 +694,7 @@ def bdev_rbd_unregister_cluster(client, name):
 
 
 @deprecated_alias('construct_rbd_bdev')
-def bdev_rbd_create(client, pool_name, rbd_name, block_size, name=None, user=None, config=None):
+def bdev_rbd_create(client, pool_name, rbd_name, block_size, name=None, user=None, config=None, cluster_name=None):
     """Create a Ceph RBD block device.
 
     Args:
@@ -704,6 +704,7 @@ def bdev_rbd_create(client, pool_name, rbd_name, block_size, name=None, user=Non
         name: name of block device (optional)
         user: Ceph user name (optional)
         config: map of config keys to values (optional)
+        cluster_name: Name to identify Rados cluster (optional)
 
     Returns:
         Name of created block device.
@@ -720,6 +721,8 @@ def bdev_rbd_create(client, pool_name, rbd_name, block_size, name=None, user=Non
         params['user_id'] = user
     if config is not None:
         params['config'] = config
+    if cluster_name is not None:
+        params['cluster_name'] = cluster_name
 
     return client.call('bdev_rbd_create', params)
 
diff --git a/test/iscsi_tgt/rbd/rbd.sh b/test/iscsi_tgt/rbd/rbd.sh
index 8a2a9a702..607ef9561 100755
--- a/test/iscsi_tgt/rbd/rbd.sh
+++ b/test/iscsi_tgt/rbd/rbd.sh
@@ -31,7 +31,8 @@ timing_exit start_iscsi_tgt
 
 $rpc_py iscsi_create_portal_group $PORTAL_TAG $TARGET_IP:$ISCSI_PORT
 $rpc_py iscsi_create_initiator_group $INITIATOR_TAG $INITIATOR_NAME $NETMASK
-rbd_bdev="$($rpc_py bdev_rbd_create $RBD_POOL $RBD_NAME 4096)"
+rbd_cluster_name="$($rpc_py bdev_rbd_register_cluster iscsi_rbd_cluster)"
+rbd_bdev="$($rpc_py bdev_rbd_create $RBD_POOL $RBD_NAME 4096 -c $rbd_cluster_name)"
 $rpc_py bdev_get_bdevs
 
 $rpc_py bdev_rbd_resize $rbd_bdev 2000
@@ -64,6 +65,7 @@ trap - SIGINT SIGTERM EXIT
 
 iscsicleanup
 $rpc_py bdev_rbd_delete $rbd_bdev
+$rpc_py bdev_rbd_unregister_cluster $rbd_cluster_name
 killprocess $pid
 rbd_cleanup
 
-- 
2.26.2


From 706aa1ff08e3a19b39895df35a1a0336e3f6785c Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 2 Mar 2021 03:40:19 -0500
Subject: [PATCH 164/342] dpdk: update submodule to DPDK 21.02

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I794f2266e0de175fe85ceea3a01b8db118550ada
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6617
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 CHANGELOG.md | 4 ++++
 dpdk         | 2 +-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index e2a41fe9f..2554a7588 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,10 @@
 
 ## v21.07: (Upcoming Release)
 
+### dpdk
+
+Updated DPDK submodule to DPDK 21.02.
+
 ### idxd
 
 Remove the probe_cb parameter in spdk_idxd_probe function. And remove the definition
diff --git a/dpdk b/dpdk
index eb1678683..56963a26a 160000
--- a/dpdk
+++ b/dpdk
@@ -1 +1 @@
-Subproject commit eb16786836e3a8380bb86fde67efa2ee0d9d3852
+Subproject commit 56963a26a45cba28e9a613b4a8cfee75f792564e
-- 
2.26.2


From f4d2ba4371b841163927da634c34be7c14b05356 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Thu, 29 Apr 2021 22:37:55 +0800
Subject: [PATCH 165/342] test/nvmf: use recommended nvmf_create_subsystem rpc

There are logs like below in existing CI tests:
"nvmf_subsystem_create is deprecated, use nvmf_create_subsystem instead."

Change-Id: Id257ab13120a71ad3d0ae7ed22ed6e0a4f005cf0
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7670
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Monica Kenguva <monica.kenguva@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/compress/compress.sh           | 2 +-
 test/nvmf/host/target_disconnect.sh | 2 +-
 test/nvmf/target/dif.sh             | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/test/compress/compress.sh b/test/compress/compress.sh
index ae18778d6..7ee601227 100755
--- a/test/compress/compress.sh
+++ b/test/compress/compress.sh
@@ -99,7 +99,7 @@ if [ $RUN_NIGHTLY -eq 1 ]; then
 	# Create an NVMe-oF subsystem and add compress bdevs as namespaces
 	$rpc_py nvmf_create_transport -t $TEST_TRANSPORT -u 8192
 	create_vols
-	$rpc_py nvmf_subsystem_create nqn.2016-06.io.spdk:cnode0 -a -s SPDK0
+	$rpc_py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode0 -a -s SPDK0
 	$rpc_py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode0 COMP_lvs0/lv0
 	$rpc_py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode0 -t $TEST_TRANSPORT -a $NVMF_FIRST_TARGET_IP -s $NVMF_PORT
 
diff --git a/test/nvmf/host/target_disconnect.sh b/test/nvmf/host/target_disconnect.sh
index 22c077afb..27bb2a3bc 100755
--- a/test/nvmf/host/target_disconnect.sh
+++ b/test/nvmf/host/target_disconnect.sh
@@ -18,7 +18,7 @@ function disconnect_init() {
 	$rpc_py bdev_malloc_create $MALLOC_BDEV_SIZE $MALLOC_BLOCK_SIZE -b Malloc0
 
 	$rpc_py nvmf_create_transport $NVMF_TRANSPORT_OPTS
-	$rpc_py nvmf_subsystem_create nqn.2016-06.io.spdk:cnode1 -a -s SPDK00000000000001
+	$rpc_py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s SPDK00000000000001
 
 	$rpc_py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 Malloc0
 	$rpc_py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t $TEST_TRANSPORT -a $1 -s $NVMF_PORT
diff --git a/test/nvmf/target/dif.sh b/test/nvmf/target/dif.sh
index 7d82edb15..b08bace1e 100755
--- a/test/nvmf/target/dif.sh
+++ b/test/nvmf/target/dif.sh
@@ -15,7 +15,7 @@ create_subsystem() {
 
 	# Make sure NQN matches what's used in gen_nvmf_target_json()
 	rpc_cmd bdev_null_create "bdev_null$sub_id" "$NULL_SIZE" "$NULL_BLOCK_SIZE" --md-size "$NULL_META" --dif-type "$NULL_DIF"
-	rpc_cmd nvmf_subsystem_create "nqn.2016-06.io.spdk:cnode$sub_id" --serial-number "53313233-$sub_id" --allow-any-host
+	rpc_cmd nvmf_create_subsystem "nqn.2016-06.io.spdk:cnode$sub_id" --serial-number "53313233-$sub_id" --allow-any-host
 	rpc_cmd nvmf_subsystem_add_ns "nqn.2016-06.io.spdk:cnode$sub_id" "bdev_null$sub_id"
 	rpc_cmd nvmf_subsystem_add_listener "nqn.2016-06.io.spdk:cnode$sub_id" -t "$TEST_TRANSPORT" -a "$NVMF_FIRST_TARGET_IP" -s "$NVMF_PORT"
 }
-- 
2.26.2


From f651e22a98a49788a15efc3eefc312bc6fa7294a Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 19 May 2021 21:07:44 +0000
Subject: [PATCH 166/342] bdev: remove all references to spdk_bdev_open

This API was removed previously, so remove remaining
references in map file and unit tests.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Iba2f6a5f5ba590d3996dc133c8181083a33d7405
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7963
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/bdev/spdk_bdev.map            | 1 -
 test/unit/lib/nvmf/fc.c/fc_ut.c   | 3 ---
 test/unit/lib/scsi/lun.c/lun_ut.c | 5 -----
 3 files changed, 9 deletions(-)

diff --git a/lib/bdev/spdk_bdev.map b/lib/bdev/spdk_bdev.map
index 91d21d5db..2e3df5fd2 100644
--- a/lib/bdev/spdk_bdev.map
+++ b/lib/bdev/spdk_bdev.map
@@ -15,7 +15,6 @@
 	spdk_bdev_next;
 	spdk_bdev_first_leaf;
 	spdk_bdev_next_leaf;
-	spdk_bdev_open;
 	spdk_bdev_open_ext;
 	spdk_bdev_close;
 	spdk_bdev_desc_get_bdev;
diff --git a/test/unit/lib/nvmf/fc.c/fc_ut.c b/test/unit/lib/nvmf/fc.c/fc_ut.c
index 560505767..cad99e482 100644
--- a/test/unit/lib/nvmf/fc.c/fc_ut.c
+++ b/test/unit/lib/nvmf/fc.c/fc_ut.c
@@ -112,9 +112,6 @@ DEFINE_STUB(spdk_bdev_get_io_channel, struct spdk_io_channel *, (struct spdk_bde
 	    NULL);
 DEFINE_STUB_V(spdk_nvmf_request_exec, (struct spdk_nvmf_request *req));
 DEFINE_STUB_V(nvmf_ctrlr_ns_changed, (struct spdk_nvmf_ctrlr *ctrlr, uint32_t nsid));
-DEFINE_STUB(spdk_bdev_open, int, (struct spdk_bdev *bdev, bool write,
-				  spdk_bdev_remove_cb_t remove_cb,
-				  void *remove_ctx, struct spdk_bdev_desc **desc), 0);
 DEFINE_STUB_V(spdk_bdev_close, (struct spdk_bdev_desc *desc));
 DEFINE_STUB(spdk_bdev_module_claim_bdev, int,
 	    (struct spdk_bdev *bdev, struct spdk_bdev_desc *desc,
diff --git a/test/unit/lib/scsi/lun.c/lun_ut.c b/test/unit/lib/scsi/lun.c/lun_ut.c
index 5501537c0..532318fa5 100644
--- a/test/unit/lib/scsi/lun.c/lun_ut.c
+++ b/test/unit/lib/scsi/lun.c/lun_ut.c
@@ -94,11 +94,6 @@ spdk_bdev_free_io(struct spdk_bdev_io *bdev_io)
 	CU_ASSERT(0);
 }
 
-DEFINE_STUB(spdk_bdev_open, int,
-	    (struct spdk_bdev *bdev, bool write, spdk_bdev_remove_cb_t remove_cb,
-	     void *remove_ctx, struct spdk_bdev_desc **desc),
-	    0);
-
 DEFINE_STUB(spdk_bdev_open_ext, int,
 	    (const char *bdev_name, bool write, spdk_bdev_event_cb_t event_cb,
 	     void *event_ctx, struct spdk_bdev_desc **desc),
-- 
2.26.2


From 2975e0dbb52df20173048fad989dd31f5af9c89c Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@nutanix.com>
Date: Wed, 19 May 2021 13:11:02 +0100
Subject: [PATCH 167/342] vfio-user: support cmake3

libvfio-user now uses cmake3 if available, so check for that as well as cmake.

Signed-off-by: John Levon <john.levon@nutanix.com>
Change-Id: Idf7a496d0d3fec21140afeede56337e53ad475fd
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7954
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 configure | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure b/configure
index 3a785ce94..ce9fba177 100755
--- a/configure
+++ b/configure
@@ -472,7 +472,7 @@ BUILD_CMD+=(-I/usr/local/include -L/usr/local/lib)
 
 if [[ "${CONFIG[VFIO_USER]}" = "y" ]]; then
 
-	if ! hash cmake; then
+	if ! bash -c "command -v cmake3 cmake" > /dev/null; then
 		echo "ERROR: --with-vfio-user requires cmake"
 		echo "Please install then re-run this script"
 		exit 1
-- 
2.26.2


From 50487701b174a68d307f3706dc68b382c2dffa8a Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 18 May 2021 17:45:29 +0900
Subject: [PATCH 168/342] ut/thread: Test if multiple timed pollers are expired
 simultaneously

Add a little complex test cases to avoid regression by the following
patches.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I1c94edd913f0a582868e355be085a1faf9bd1a94
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7913
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 test/unit/lib/thread/thread.c/thread_ut.c | 164 ++++++++++++++++++++++
 1 file changed, 164 insertions(+)

diff --git a/test/unit/lib/thread/thread.c/thread_ut.c b/test/unit/lib/thread/thread.c/thread_ut.c
index 8cc6a6207..c64a5e249 100644
--- a/test/unit/lib/thread/thread.c/thread_ut.c
+++ b/test/unit/lib/thread/thread.c/thread_ut.c
@@ -1432,6 +1432,169 @@ cache_closest_timed_poller(void)
 	free_threads();
 }
 
+static void
+multi_timed_pollers_have_same_expiration(void)
+{
+	struct spdk_thread *thread;
+	struct spdk_poller *poller1, *poller2, *poller3, *poller4, *tmp;
+	uint64_t start_ticks;
+
+	allocate_threads(1);
+	set_thread(0);
+
+	thread = spdk_get_thread();
+	SPDK_CU_ASSERT_FATAL(thread != NULL);
+
+	/*
+	 * case 1: multiple timed pollers have the same next_run_tick.
+	 */
+	start_ticks = spdk_get_ticks();
+
+	poller1 = spdk_poller_register(dummy_poller, NULL, 500);
+	SPDK_CU_ASSERT_FATAL(poller1 != NULL);
+
+	poller2 = spdk_poller_register(dummy_poller, NULL, 500);
+	SPDK_CU_ASSERT_FATAL(poller2 != NULL);
+
+	poller3 = spdk_poller_register(dummy_poller, NULL, 1000);
+	SPDK_CU_ASSERT_FATAL(poller3 != NULL);
+
+	poller4 = spdk_poller_register(dummy_poller, NULL, 1500);
+	SPDK_CU_ASSERT_FATAL(poller4 != NULL);
+
+	/* poller1 and poller2 have the same next_run_tick but cache has poller1
+	 * because poller1 is registered earlier than poller2.
+	 */
+	CU_ASSERT(thread->first_timed_poller == poller1);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 500);
+	CU_ASSERT(poller2->next_run_tick == start_ticks + 500);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 1000);
+	CU_ASSERT(poller4->next_run_tick == start_ticks + 1500);
+
+	/* after 500 usec, poller1 and poller2 are expired. */
+	spdk_delay_us(500);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 500);
+	poll_threads();
+
+	/* poller1, poller2, and poller3 have the same next_run_tick but cache
+	 * has poller3 because poller3 is not expired yet.
+	 */
+	CU_ASSERT(thread->first_timed_poller == poller3);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 1000);
+	CU_ASSERT(poller2->next_run_tick == start_ticks + 1000);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 1000);
+	CU_ASSERT(poller4->next_run_tick == start_ticks + 1500);
+
+	/* after 500 usec, poller1, poller2, and poller3 are expired. */
+	spdk_delay_us(500);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 1000);
+	poll_threads();
+
+	/* poller1, poller2, and poller4 have the same next_run_tick but cache
+	 * has poller4 because poller4 is not expired yet.
+	 */
+	CU_ASSERT(thread->first_timed_poller == poller4);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 1500);
+	CU_ASSERT(poller2->next_run_tick == start_ticks + 1500);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 2000);
+	CU_ASSERT(poller4->next_run_tick == start_ticks + 1500);
+
+	/* after 500 usec, poller1, poller2, and poller4 are expired. */
+	spdk_delay_us(500);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 1500);
+	poll_threads();
+
+	/* poller1, poller2, and poller3 have the same next_run_tick but cache
+	 * has poller3 because poller3 is updated earlier than poller1 and poller2.
+	 */
+	CU_ASSERT(thread->first_timed_poller == poller3);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 2000);
+	CU_ASSERT(poller2->next_run_tick == start_ticks + 2000);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 2000);
+	CU_ASSERT(poller4->next_run_tick == start_ticks + 3000);
+
+	spdk_poller_unregister(&poller1);
+	spdk_poller_unregister(&poller2);
+	spdk_poller_unregister(&poller3);
+	spdk_poller_unregister(&poller4);
+
+	spdk_delay_us(1500);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 3000);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == NULL);
+	CU_ASSERT(TAILQ_EMPTY(&thread->timed_pollers));
+
+	/*
+	 * case 2: unregister timed pollers while multiple timed pollers are registered.
+	 */
+	start_ticks = spdk_get_ticks();
+
+	poller1 = spdk_poller_register(dummy_poller, NULL, 500);
+	SPDK_CU_ASSERT_FATAL(poller1 != NULL);
+
+	CU_ASSERT(thread->first_timed_poller == poller1);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 500);
+
+	/* after 250 usec, register poller2 and poller3. */
+	spdk_delay_us(250);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 250);
+
+	poller2 = spdk_poller_register(dummy_poller, NULL, 500);
+	SPDK_CU_ASSERT_FATAL(poller2 != NULL);
+
+	poller3 = spdk_poller_register(dummy_poller, NULL, 750);
+	SPDK_CU_ASSERT_FATAL(poller3 != NULL);
+
+	CU_ASSERT(thread->first_timed_poller == poller1);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 500);
+	CU_ASSERT(poller2->next_run_tick == start_ticks + 750);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 1000);
+
+	/* unregister poller2 which is not the closest. */
+	tmp = poller2;
+	spdk_poller_unregister(&poller2);
+
+	/* after 250 usec, poller1 is expired. */
+	spdk_delay_us(250);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 500);
+	poll_threads();
+
+	/* poller2 is not unregistered yet because it is not expired. */
+	CU_ASSERT(thread->first_timed_poller == tmp);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 1000);
+	CU_ASSERT(tmp->next_run_tick == start_ticks + 750);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 1000);
+
+	spdk_delay_us(250);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 750);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == poller3);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 1000);
+	CU_ASSERT(poller3->next_run_tick == start_ticks + 1000);
+
+	spdk_poller_unregister(&poller3);
+
+	spdk_delay_us(250);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 1000);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == poller1);
+	CU_ASSERT(poller1->next_run_tick == start_ticks + 1500);
+
+	spdk_poller_unregister(&poller1);
+
+	spdk_delay_us(500);
+	CU_ASSERT(spdk_get_ticks() == start_ticks + 1500);
+	poll_threads();
+
+	CU_ASSERT(thread->first_timed_poller == NULL);
+	CU_ASSERT(TAILQ_EMPTY(&thread->timed_pollers));
+
+	free_threads();
+}
+
 int
 main(int argc, char **argv)
 {
@@ -1458,6 +1621,7 @@ main(int argc, char **argv)
 	CU_ADD_TEST(suite, nested_channel);
 	CU_ADD_TEST(suite, device_unregister_and_thread_exit_race);
 	CU_ADD_TEST(suite, cache_closest_timed_poller);
+	CU_ADD_TEST(suite, multi_timed_pollers_have_same_expiration);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 3ca15e33e4917e82979e9309ed1d4dbb8bf767f2 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 18 May 2021 11:05:55 +0900
Subject: [PATCH 169/342] thread: Set poller to PAUSING even when it is in
 RUNNING

This change is a preparation to first dequeue the closest timed poller
always when it is expired. Previously the poller_remove_timer() calls
were not consistent and difficult to follow.

spdk_poller_pause() sets poller to PAUSING even when it in RUNNING
and move it to PAUSED after returning from its context.

If spdk_poller_pause() and spdk_poller_resume() are called while poller
runs, it is moved to WAITING. Hence thread_execute_poller() and
thread_execute_timed_poller() ignore such cases.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I29340613a2ec0c3529d0886f4d81c0a0fdf8745d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7908
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/thread/thread.c                       | 32 +++++----
 test/unit/lib/thread/thread.c/thread_ut.c | 81 +++++++++++++++++++++++
 2 files changed, 99 insertions(+), 14 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 3ba3c09c9..914af75cb 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -757,7 +757,13 @@ thread_execute_poller(struct spdk_thread *thread, struct spdk_poller *poller)
 		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
 		free(poller);
 		break;
+	case SPDK_POLLER_STATE_PAUSING:
+		TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
+		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
+		poller->state = SPDK_POLLER_STATE_PAUSED;
+		break;
 	case SPDK_POLLER_STATE_PAUSED:
+	case SPDK_POLLER_STATE_WAITING:
 		break;
 	case SPDK_POLLER_STATE_RUNNING:
 		poller->state = SPDK_POLLER_STATE_WAITING;
@@ -812,10 +818,17 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 		poller_remove_timer(thread, poller);
 		free(poller);
 		break;
+	case SPDK_POLLER_STATE_PAUSING:
+		poller_remove_timer(thread, poller);
+		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
+		poller->state = SPDK_POLLER_STATE_PAUSED;
+		break;
 	case SPDK_POLLER_STATE_PAUSED:
 		break;
 	case SPDK_POLLER_STATE_RUNNING:
 		poller->state = SPDK_POLLER_STATE_WAITING;
+	/* fallthrough */
+	case SPDK_POLLER_STATE_WAITING:
 		poller_remove_timer(thread, poller);
 		poller_insert_timer(thread, poller, now);
 		break;
@@ -1528,26 +1541,17 @@ spdk_poller_pause(struct spdk_poller *poller)
 		return;
 	}
 
-	/* If a poller is paused from within itself, we can immediately move it
-	 * on the paused_pollers list.  Otherwise we just set its state to
-	 * SPDK_POLLER_STATE_PAUSING and let spdk_thread_poll() move it.  It
-	 * allows a poller to be paused from another one's context without
-	 * breaking the TAILQ_FOREACH_REVERSE_SAFE iteration.
+	/* We just set its state to SPDK_POLLER_STATE_PAUSING and let
+	 * spdk_thread_poll() move it. It allows a poller to be paused from
+	 * another one's context without breaking the TAILQ_FOREACH_REVERSE_SAFE
+	 * iteration, or from within itself without breaking the logic to always
+	 * remove the closest timed poller in the TAILQ_FOREACH_SAFE iteration.
 	 */
 	switch (poller->state) {
 	case SPDK_POLLER_STATE_PAUSED:
 	case SPDK_POLLER_STATE_PAUSING:
 		break;
 	case SPDK_POLLER_STATE_RUNNING:
-		if (poller->period_ticks > 0) {
-			poller_remove_timer(thread, poller);
-		} else {
-			TAILQ_REMOVE(&thread->active_pollers, poller, tailq);
-		}
-
-		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
-		poller->state = SPDK_POLLER_STATE_PAUSED;
-		break;
 	case SPDK_POLLER_STATE_WAITING:
 		poller->state = SPDK_POLLER_STATE_PAUSING;
 		break;
diff --git a/test/unit/lib/thread/thread.c/thread_ut.c b/test/unit/lib/thread/thread.c/thread_ut.c
index c64a5e249..d292459cf 100644
--- a/test/unit/lib/thread/thread.c/thread_ut.c
+++ b/test/unit/lib/thread/thread.c/thread_ut.c
@@ -244,6 +244,23 @@ poller_run_pause(void *ctx)
 	return 0;
 }
 
+/* Verify the same poller can be switched multiple times between
+ * pause and resume while it runs.
+ */
+static int
+poller_run_pause_resume_pause(void *ctx)
+{
+	struct poller_ctx *poller_ctx = ctx;
+
+	poller_ctx->run = true;
+
+	spdk_poller_pause(poller_ctx->poller);
+	spdk_poller_resume(poller_ctx->poller);
+	spdk_poller_pause(poller_ctx->poller);
+
+	return 0;
+}
+
 static void
 poller_msg_pause_cb(void *ctx)
 {
@@ -285,6 +302,21 @@ poller_pause(void)
 	spdk_poller_unregister(&poller_ctx.poller);
 	CU_ASSERT_PTR_NULL(poller_ctx.poller);
 
+	/* Register a poller that switches between pause and resume itself */
+	poller_ctx.poller = spdk_poller_register(poller_run_pause_resume_pause, &poller_ctx, 0);
+	CU_ASSERT_PTR_NOT_NULL(poller_ctx.poller);
+
+	poller_ctx.run = false;
+	poll_threads();
+	CU_ASSERT_EQUAL(poller_ctx.run, true);
+
+	poller_ctx.run = false;
+	poll_threads();
+	CU_ASSERT_EQUAL(poller_ctx.run, false);
+
+	spdk_poller_unregister(&poller_ctx.poller);
+	CU_ASSERT_PTR_NULL(poller_ctx.poller);
+
 	/* Verify that resuming an unpaused poller doesn't do anything */
 	poller_ctx.poller = spdk_poller_register(poller_run_done, &poller_ctx.run, 0);
 	CU_ASSERT_PTR_NOT_NULL(poller_ctx.poller);
@@ -386,6 +418,55 @@ poller_pause(void)
 
 		spdk_poller_unregister(&poller_ctx.poller);
 		CU_ASSERT_PTR_NULL(poller_ctx.poller);
+
+		/* Register a timed poller that pauses itself */
+		poller_ctx.poller = spdk_poller_register(poller_run_pause, &poller_ctx, delay[i]);
+		CU_ASSERT_PTR_NOT_NULL(poller_ctx.poller);
+
+		spdk_delay_us(delay[i]);
+		poller_ctx.run = false;
+		poll_threads();
+		CU_ASSERT_EQUAL(poller_ctx.run, true);
+
+		poller_ctx.run = false;
+		spdk_delay_us(delay[i]);
+		poll_threads();
+		CU_ASSERT_EQUAL(poller_ctx.run, false);
+
+		spdk_poller_resume(poller_ctx.poller);
+
+		CU_ASSERT_EQUAL(poller_ctx.run, false);
+		spdk_delay_us(delay[i]);
+		poll_threads();
+		CU_ASSERT_EQUAL(poller_ctx.run, true);
+
+		spdk_poller_unregister(&poller_ctx.poller);
+		CU_ASSERT_PTR_NULL(poller_ctx.poller);
+
+		/* Register a timed poller that switches between pause and resume itself */
+		poller_ctx.poller = spdk_poller_register(poller_run_pause_resume_pause,
+				    &poller_ctx, delay[i]);
+		CU_ASSERT_PTR_NOT_NULL(poller_ctx.poller);
+
+		spdk_delay_us(delay[i]);
+		poller_ctx.run = false;
+		poll_threads();
+		CU_ASSERT_EQUAL(poller_ctx.run, true);
+
+		poller_ctx.run = false;
+		spdk_delay_us(delay[i]);
+		poll_threads();
+		CU_ASSERT_EQUAL(poller_ctx.run, false);
+
+		spdk_poller_resume(poller_ctx.poller);
+
+		CU_ASSERT_EQUAL(poller_ctx.run, false);
+		spdk_delay_us(delay[i]);
+		poll_threads();
+		CU_ASSERT_EQUAL(poller_ctx.run, true);
+
+		spdk_poller_unregister(&poller_ctx.poller);
+		CU_ASSERT_PTR_NULL(poller_ctx.poller);
 	}
 
 	free_threads();
-- 
2.26.2


From 83c197633f3a061417b5b72fa0db2139adc0e5c0 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 18 May 2021 11:53:41 +0900
Subject: [PATCH 170/342] thread: Consolidate poller_remove_timer() calls into
 a single place

This enable us to optimize the cache update when RB tree is supported.

Call poller_remove_timer() after getting the next element because
as TAILQ_FOREACH_SAFE() and RB_FOREACH_SAFE() do, TAILQ_NEXT() may
not be valid after the current element is removed.

Previously, the patch had called poller_remove_timer() before getting
the next element. However, thanks to the nice testing, this bug was
found.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I18afb4412115dc1696cc568610cbe3dc618c2357
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7909
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/thread/thread.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 914af75cb..90ab5a3be 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -784,11 +784,9 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 
 	switch (poller->state) {
 	case SPDK_POLLER_STATE_UNREGISTERED:
-		poller_remove_timer(thread, poller);
 		free(poller);
 		return 0;
 	case SPDK_POLLER_STATE_PAUSING:
-		poller_remove_timer(thread, poller);
 		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
 		poller->state = SPDK_POLLER_STATE_PAUSED;
 		return 0;
@@ -815,11 +813,9 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 
 	switch (poller->state) {
 	case SPDK_POLLER_STATE_UNREGISTERED:
-		poller_remove_timer(thread, poller);
 		free(poller);
 		break;
 	case SPDK_POLLER_STATE_PAUSING:
-		poller_remove_timer(thread, poller);
 		TAILQ_INSERT_TAIL(&thread->paused_pollers, poller, tailq);
 		poller->state = SPDK_POLLER_STATE_PAUSED;
 		break;
@@ -829,7 +825,6 @@ thread_execute_timed_poller(struct spdk_thread *thread, struct spdk_poller *poll
 		poller->state = SPDK_POLLER_STATE_WAITING;
 	/* fallthrough */
 	case SPDK_POLLER_STATE_WAITING:
-		poller_remove_timer(thread, poller);
 		poller_insert_timer(thread, poller, now);
 		break;
 	default:
@@ -881,6 +876,7 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 		}
 
 		tmp = TAILQ_NEXT(poller, tailq);
+		poller_remove_timer(thread, poller);
 
 		timer_rc = thread_execute_timed_poller(thread, poller, now);
 		if (timer_rc > rc) {
-- 
2.26.2


From 4eb96aeba0181c195a3fa5408db12d82663d99eb Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 19 May 2021 14:29:20 +0900
Subject: [PATCH 171/342] thread: Inline poller_remove_timer() into
 thread_poll()

We already hold thehe next closest timed poller in tmp. Inlining
poller_remove_timer() into thread_poll() makes the cache update
more efficient.

After this patch, poller_remove_timer() is called only in a single case
and the case is compiled only on Linux. So add it inside of a temporary
block is much clearner. However it will be used by spdk_poller_reschedule()
in the end of this patch series. So keep
the current position.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I2e6858223713eed84f5d70b160da6122edae6d03
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7910
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/thread/thread.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 90ab5a3be..815bf3cda 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -681,6 +681,7 @@ poller_insert_timer(struct spdk_thread *thread, struct spdk_poller *poller, uint
 	thread->first_timed_poller = poller;
 }
 
+#ifdef __linux__
 static inline void
 poller_remove_timer(struct spdk_thread *thread, struct spdk_poller *poller)
 {
@@ -690,6 +691,7 @@ poller_remove_timer(struct spdk_thread *thread, struct spdk_poller *poller)
 		thread->first_timed_poller = TAILQ_FIRST(&thread->timed_pollers);
 	}
 }
+#endif
 
 static void
 thread_insert_poller(struct spdk_thread *thread, struct spdk_poller *poller)
@@ -876,7 +878,15 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 		}
 
 		tmp = TAILQ_NEXT(poller, tailq);
-		poller_remove_timer(thread, poller);
+		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+
+		/* Update the cache to the next timed poller in the list
+		 * only if the current poller is still the closest, otherwise,
+		 * do nothing because the cache has been already updated.
+		 */
+		if (thread->first_timed_poller == poller) {
+			thread->first_timed_poller = tmp;
+		}
 
 		timer_rc = thread_execute_timed_poller(thread, poller, now);
 		if (timer_rc > rc) {
-- 
2.26.2


From 4e9adb3bf95b55a21149b981513e8d91e022be96 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 19 May 2021 14:35:32 +0900
Subject: [PATCH 172/342] thread: Replace TAILQ by Red Black tree for timed
 pollers

Use the macros for red black tree provided by Free BSD to manage
timed pollers efficiently.

Allow RB_INSERT() to insert elements with duplicated keys by changing
the compare function to return 1 if two keys are equal.

Check the return code of RB_INSERT() because this is the first use case
for RB tree macros in SPDK. We did the same for RB_REMOVE() by
adding another temporary variable but we remove it from this patch
because it is not so important compared with RB_INSERT().

When a timed poller is inserted, update the cache for the closest (leftmost)
timed poller only if the tree was empty before or the closest (leftmost)
timed poller was actually changed. We do not have to use RB_MIN()
because all duplicated entries are inserted on the right side.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ibe253ca8eecc10116548b5eedbcdba8fb961b88d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7722
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/thread/thread.c                       | 87 +++++++++++++++--------
 test/unit/lib/thread/thread.c/thread_ut.c | 18 ++---
 2 files changed, 68 insertions(+), 37 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 815bf3cda..c07fbe15d 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -38,6 +38,7 @@
 #include "spdk/queue.h"
 #include "spdk/string.h"
 #include "spdk/thread.h"
+#include "spdk/tree.h"
 #include "spdk/util.h"
 #include "spdk/fd_group.h"
 
@@ -78,6 +79,7 @@ enum spdk_poller_state {
 
 struct spdk_poller {
 	TAILQ_ENTRY(spdk_poller)	tailq;
+	RB_ENTRY(spdk_poller)		node;
 
 	/* Current state of the poller; should only be accessed from the poller's thread. */
 	enum spdk_poller_state		state;
@@ -122,7 +124,7 @@ struct spdk_thread {
 	/**
 	 * Contains pollers running on this thread with a periodic timer.
 	 */
-	TAILQ_HEAD(timed_pollers_head, spdk_poller)	timed_pollers;
+	RB_HEAD(timed_pollers_tree, spdk_poller)	timed_pollers;
 	struct spdk_poller				*first_timed_poller;
 	/*
 	 * Contains paused pollers.  Pollers on this queue are waiting until
@@ -199,6 +201,29 @@ static uint32_t g_thread_count = 0;
 
 static __thread struct spdk_thread *tls_thread = NULL;
 
+/*
+ * If this compare function returns zero when two next_run_ticks are equal,
+ * the macro RB_INSERT() returns a pointer to the element with the same
+ * next_run_tick.
+ *
+ * Fortunately, the macro RB_REMOVE() takes not a key but a pointer to the element
+ * to remove as a parameter.
+ *
+ * Hence we allow RB_INSERT() to insert elements with the same keys on the right
+ * side by returning 1 when two next_run_ticks are equal.
+ */
+static inline int
+timed_poller_compare(struct spdk_poller *poller1, struct spdk_poller *poller2)
+{
+	if (poller1->next_run_tick < poller2->next_run_tick) {
+		return -1;
+	} else {
+		return 1;
+	}
+}
+
+RB_GENERATE_STATIC(timed_pollers_tree, spdk_poller, node, timed_poller_compare);
+
 static inline struct spdk_thread *
 _get_thread(void)
 {
@@ -310,12 +335,12 @@ _free_thread(struct spdk_thread *thread)
 		free(poller);
 	}
 
-	TAILQ_FOREACH_SAFE(poller, &thread->timed_pollers, tailq, ptmp) {
+	RB_FOREACH_SAFE(poller, timed_pollers_tree, &thread->timed_pollers, ptmp) {
 		if (poller->state != SPDK_POLLER_STATE_UNREGISTERED) {
 			SPDK_WARNLOG("timed_poller %s still registered at thread exit\n",
 				     poller->name);
 		}
-		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		RB_REMOVE(timed_pollers_tree, &thread->timed_pollers, poller);
 		free(poller);
 	}
 
@@ -373,7 +398,7 @@ spdk_thread_create(const char *name, struct spdk_cpuset *cpumask)
 
 	TAILQ_INIT(&thread->io_channels);
 	TAILQ_INIT(&thread->active_pollers);
-	TAILQ_INIT(&thread->timed_pollers);
+	RB_INIT(&thread->timed_pollers);
 	TAILQ_INIT(&thread->paused_pollers);
 	SLIST_INIT(&thread->msg_cache);
 	thread->msg_cache_count = 0;
@@ -471,7 +496,7 @@ thread_exit(struct spdk_thread *thread, uint64_t now)
 		}
 	}
 
-	TAILQ_FOREACH(poller, &thread->timed_pollers, tailq) {
+	RB_FOREACH(poller, timed_pollers_tree, &thread->timed_pollers) {
 		if (poller->state != SPDK_POLLER_STATE_UNREGISTERED) {
 			SPDK_INFOLOG(thread,
 				     "thread %s still has active timed poller %s\n",
@@ -660,35 +685,41 @@ msg_queue_run_batch(struct spdk_thread *thread, uint32_t max_msgs)
 static void
 poller_insert_timer(struct spdk_thread *thread, struct spdk_poller *poller, uint64_t now)
 {
-	struct spdk_poller *iter;
+	struct spdk_poller *tmp __attribute__((unused));
 
 	poller->next_run_tick = now + poller->period_ticks;
 
 	/*
-	 * Insert poller in the thread's timed_pollers list in sorted order by next scheduled
-	 * run time.
+	 * Insert poller in the thread's timed_pollers tree by next scheduled run time
+	 * as its key.
 	 */
-	TAILQ_FOREACH_REVERSE(iter, &thread->timed_pollers, timed_pollers_head, tailq) {
-		if (iter->next_run_tick <= poller->next_run_tick) {
-			TAILQ_INSERT_AFTER(&thread->timed_pollers, iter, poller, tailq);
-			return;
-		}
-	}
+	tmp = RB_INSERT(timed_pollers_tree, &thread->timed_pollers, poller);
+	assert(tmp == NULL);
 
-	/* No earlier pollers were found, so this poller must be the new head */
-	TAILQ_INSERT_HEAD(&thread->timed_pollers, poller, tailq);
-
-	thread->first_timed_poller = poller;
+	/* Update the cache only if it is empty or the inserted poller is earlier than it.
+	 * RB_MIN() is not necessary here because all pollers, which has exactly the same
+	 * next_run_tick as the existing poller, are inserted on the right side.
+	 */
+	if (thread->first_timed_poller == NULL ||
+	    poller->next_run_tick < thread->first_timed_poller->next_run_tick) {
+		thread->first_timed_poller = poller;
+	}
 }
 
 #ifdef __linux__
 static inline void
 poller_remove_timer(struct spdk_thread *thread, struct spdk_poller *poller)
 {
-	TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+	struct spdk_poller *tmp __attribute__((unused));
+
+	tmp = RB_REMOVE(timed_pollers_tree, &thread->timed_pollers, poller);
+	assert(tmp != NULL);
 
+	/* This function is not used in any case that is performance critical.
+	 * Update the cache simply by RB_MIN() if it needs to be changed.
+	 */
 	if (thread->first_timed_poller == poller) {
-		thread->first_timed_poller = TAILQ_FIRST(&thread->timed_pollers);
+		thread->first_timed_poller = RB_MIN(timed_pollers_tree, &thread->timed_pollers);
 	}
 }
 #endif
@@ -877,8 +908,8 @@ thread_poll(struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)
 			break;
 		}
 
-		tmp = TAILQ_NEXT(poller, tailq);
-		TAILQ_REMOVE(&thread->timed_pollers, poller, tailq);
+		tmp = RB_NEXT(timed_pollers_tree, &thread->timed_pollers, poller);
+		RB_REMOVE(timed_pollers_tree, &thread->timed_pollers, poller);
 
 		/* Update the cache to the next timed poller in the list
 		 * only if the current poller is still the closest, otherwise,
@@ -971,7 +1002,7 @@ static bool
 thread_has_unpaused_pollers(struct spdk_thread *thread)
 {
 	if (TAILQ_EMPTY(&thread->active_pollers) &&
-	    TAILQ_EMPTY(&thread->timed_pollers)) {
+	    RB_EMPTY(&thread->timed_pollers)) {
 		return false;
 	}
 
@@ -1585,10 +1616,10 @@ spdk_poller_resume(struct spdk_poller *poller)
 	}
 
 	/* If a poller is paused it has to be removed from the paused pollers
-	 * list and put on the active / timer list depending on its
+	 * list and put on the active list or timer tree depending on its
 	 * period_ticks.  If a poller is still in the process of being paused,
 	 * we just need to flip its state back to waiting, as it's already on
-	 * the appropriate list.
+	 * the appropriate list or tree.
 	 */
 	switch (poller->state) {
 	case SPDK_POLLER_STATE_PAUSED:
@@ -1660,13 +1691,13 @@ spdk_thread_get_next_active_poller(struct spdk_poller *prev)
 struct spdk_poller *
 spdk_thread_get_first_timed_poller(struct spdk_thread *thread)
 {
-	return TAILQ_FIRST(&thread->active_pollers);
+	return RB_MIN(timed_pollers_tree, &thread->timed_pollers);
 }
 
 struct spdk_poller *
 spdk_thread_get_next_timed_poller(struct spdk_poller *prev)
 {
-	return TAILQ_NEXT(prev, tailq);
+	return RB_NEXT(timed_pollers_tree, &thread->timed_pollers, prev);
 }
 
 struct spdk_poller *
@@ -1796,7 +1827,7 @@ spdk_thread_set_interrupt_mode(bool enable_interrupt)
 	}
 
 	/* Set pollers to expected mode */
-	TAILQ_FOREACH_SAFE(poller, &thread->timed_pollers, tailq, tmp) {
+	RB_FOREACH_SAFE(poller, timed_pollers_tree, &thread->timed_pollers, tmp) {
 		poller_set_interrupt_mode(poller, enable_interrupt);
 	}
 	TAILQ_FOREACH_SAFE(poller, &thread->active_pollers, tailq, tmp) {
diff --git a/test/unit/lib/thread/thread.c/thread_ut.c b/test/unit/lib/thread/thread.c/thread_ut.c
index d292459cf..150aaed84 100644
--- a/test/unit/lib/thread/thread.c/thread_ut.c
+++ b/test/unit/lib/thread/thread.c/thread_ut.c
@@ -1446,13 +1446,13 @@ cache_closest_timed_poller(void)
 	 * have the closest timed poller.
 	 */
 	CU_ASSERT(thread->first_timed_poller == poller1);
-	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller1);
+	CU_ASSERT(RB_MIN(timed_pollers_tree, &thread->timed_pollers) == poller1);
 
 	spdk_delay_us(1000);
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == poller2);
-	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller2);
+	CU_ASSERT(RB_MIN(timed_pollers_tree, &thread->timed_pollers) == poller2);
 
 	/* If we unregister a timed poller by spdk_poller_unregister()
 	 * when it is waiting, it is marked as being unregistereed and
@@ -1470,13 +1470,13 @@ cache_closest_timed_poller(void)
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == tmp);
-	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == tmp);
+	CU_ASSERT(RB_MIN(timed_pollers_tree, &thread->timed_pollers) == tmp);
 
 	spdk_delay_us(1);
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == poller3);
-	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller3);
+	CU_ASSERT(RB_MIN(timed_pollers_tree, &thread->timed_pollers) == poller3);
 
 	/* If we pause a timed poller by spdk_poller_pause() when it is waiting,
 	 * it is marked as being paused and is actually paused when it is expired.
@@ -1490,13 +1490,13 @@ cache_closest_timed_poller(void)
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == poller3);
-	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller3);
+	CU_ASSERT(RB_MIN(timed_pollers_tree, &thread->timed_pollers) == poller3);
 
 	spdk_delay_us(1);
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == poller1);
-	CU_ASSERT(TAILQ_FIRST(&thread->timed_pollers) == poller1);
+	CU_ASSERT(RB_MIN(timed_pollers_tree, &thread->timed_pollers) == poller1);
 
 	/* After unregistering all timed pollers, the cache should
 	 * be NULL.
@@ -1508,7 +1508,7 @@ cache_closest_timed_poller(void)
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == NULL);
-	CU_ASSERT(TAILQ_EMPTY(&thread->timed_pollers));
+	CU_ASSERT(RB_EMPTY(&thread->timed_pollers));
 
 	free_threads();
 }
@@ -1604,7 +1604,7 @@ multi_timed_pollers_have_same_expiration(void)
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == NULL);
-	CU_ASSERT(TAILQ_EMPTY(&thread->timed_pollers));
+	CU_ASSERT(RB_EMPTY(&thread->timed_pollers));
 
 	/*
 	 * case 2: unregister timed pollers while multiple timed pollers are registered.
@@ -1671,7 +1671,7 @@ multi_timed_pollers_have_same_expiration(void)
 	poll_threads();
 
 	CU_ASSERT(thread->first_timed_poller == NULL);
-	CU_ASSERT(TAILQ_EMPTY(&thread->timed_pollers));
+	CU_ASSERT(RB_EMPTY(&thread->timed_pollers));
 
 	free_threads();
 }
-- 
2.26.2


From 1ae601b573b8cf2be93b87b4fbd7ef491cbb6d87 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Fri, 23 Apr 2021 14:13:28 -0700
Subject: [PATCH 173/342] sock/posix: Avoid extra readv calls after draining
 recv_pipe

Move from a single flag indicating that the socket is on the
pending_events list to two flags - pipe_has_data and socket_has_data. If
either flag is true, the socket is on the socks_with_data list.

This is necessary to track enough state to avoid doing extra recv()
system calls.

Change-Id: I65e5701dccb0a5bade19f266f164f26706b110d4
Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7595
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/sock/posix/posix.c | 150 +++++++++++++++++++++-----------------
 1 file changed, 84 insertions(+), 66 deletions(-)

diff --git a/module/sock/posix/posix.c b/module/sock/posix/posix.c
index 59125f823..a23751357 100644
--- a/module/sock/posix/posix.c
+++ b/module/sock/posix/posix.c
@@ -68,7 +68,8 @@ struct spdk_posix_sock {
 	struct spdk_pipe	*recv_pipe;
 	void			*recv_buf;
 	int			recv_buf_sz;
-	bool			pending_events;
+	bool			pipe_has_data;
+	bool			socket_has_data;
 	bool			zcopy;
 
 	int			placement_id;
@@ -76,12 +77,12 @@ struct spdk_posix_sock {
 	TAILQ_ENTRY(spdk_posix_sock)	link;
 };
 
-TAILQ_HEAD(spdk_pending_events_list, spdk_posix_sock);
+TAILQ_HEAD(spdk_has_data_list, spdk_posix_sock);
 
 struct spdk_posix_sock_group_impl {
 	struct spdk_sock_group_impl	base;
 	int				fd;
-	struct spdk_pending_events_list	pending_events;
+	struct spdk_has_data_list	socks_with_data;
 	int				placement_id;
 };
 
@@ -904,13 +905,16 @@ posix_sock_recv_from_pipe(struct spdk_posix_sock *sock, struct iovec *diov, int
 
 	spdk_pipe_reader_advance(sock->recv_pipe, bytes);
 
-	/* If we drained the pipe, take it off the pending_events list. The socket may still have data buffered
-	 * in the kernel to receive, but this will be handled on the next poll call when we get the same EPOLLIN
-	 * event again. */
-	if (sock->base.group_impl && spdk_pipe_reader_bytes_available(sock->recv_pipe) == 0) {
+	/* If we drained the pipe, mark it appropriately */
+	if (spdk_pipe_reader_bytes_available(sock->recv_pipe) == 0) {
+		assert(sock->pipe_has_data == true);
+
 		group = __posix_group_impl(sock->base.group_impl);
-		TAILQ_REMOVE(&group->pending_events, sock, link);
-		sock->pending_events = false;
+		if (group && !sock->socket_has_data) {
+			TAILQ_REMOVE(&group->socks_with_data, sock, link);
+		}
+
+		sock->pipe_has_data = false;
 	}
 
 	return bytes;
@@ -920,34 +924,46 @@ static inline ssize_t
 posix_sock_read(struct spdk_posix_sock *sock)
 {
 	struct iovec iov[2];
-	int bytes;
+	int bytes_avail, bytes_recvd;
 	struct spdk_posix_sock_group_impl *group;
 
-	bytes = spdk_pipe_writer_get_buffer(sock->recv_pipe, sock->recv_buf_sz, iov);
-
-	if (bytes > 0) {
-		bytes = readv(sock->fd, iov, 2);
-		if (bytes > 0) {
-			spdk_pipe_writer_advance(sock->recv_pipe, bytes);
-
-			/* For normal operation, this function is called in response to an EPOLLIN
-			 * event, which already placed the socket onto the pending_events list.
-			 * But between polls the user may repeatedly call posix_sock_read
-			 * and if they clear the pipe on one of those earlier calls, the
-			 * socket will be removed from the pending_events list. In that case,
-			 * if we now found more data, put it back on.
-			 * This essentially never happens in practice because the application
-			 * will stop trying to receive and wait for the next EPOLLIN event, but
-			 * for correctness let's handle it. */
-			if (!sock->pending_events && sock->base.group_impl) {
-				group = __posix_group_impl(sock->base.group_impl);
-				TAILQ_INSERT_TAIL(&group->pending_events, sock, link);
-				sock->pending_events = true;
-			}
+	bytes_avail = spdk_pipe_writer_get_buffer(sock->recv_pipe, sock->recv_buf_sz, iov);
+
+	if (bytes_avail <= 0) {
+		return bytes_avail;
+	}
+
+	bytes_recvd = readv(sock->fd, iov, 2);
+
+	assert(sock->pipe_has_data == false);
+
+	if (bytes_recvd <= 0) {
+		/* Errors count as draining the socket data */
+		if (sock->base.group_impl && sock->socket_has_data) {
+			group = __posix_group_impl(sock->base.group_impl);
+			TAILQ_REMOVE(&group->socks_with_data, sock, link);
 		}
+
+		sock->socket_has_data = false;
+
+		return bytes_recvd;
 	}
 
-	return bytes;
+	spdk_pipe_writer_advance(sock->recv_pipe, bytes_recvd);
+
+#if DEBUG
+	if (sock->base.group_impl) {
+		assert(sock->socket_has_data == true);
+	}
+#endif
+
+	sock->pipe_has_data = true;
+	if (bytes_recvd < bytes_avail) {
+		/* We drained the kernel socket entirely. */
+		sock->socket_has_data = false;
+	}
+
+	return bytes_recvd;
 }
 
 static ssize_t
@@ -959,26 +975,26 @@ posix_sock_readv(struct spdk_sock *_sock, struct iovec *iov, int iovcnt)
 	size_t len;
 
 	if (sock->recv_pipe == NULL) {
-		if (group && sock->pending_events) {
-			sock->pending_events = false;
-			TAILQ_REMOVE(&group->pending_events, sock, link);
+		assert(sock->pipe_has_data == false);
+		if (group && sock->socket_has_data) {
+			sock->socket_has_data = false;
+			TAILQ_REMOVE(&group->socks_with_data, sock, link);
 		}
 		return readv(sock->fd, iov, iovcnt);
 	}
 
-	len = 0;
-	for (i = 0; i < iovcnt; i++) {
-		len += iov[i].iov_len;
-	}
-
-	if (spdk_pipe_reader_bytes_available(sock->recv_pipe) == 0) {
+	/* If the socket is not in a group, we must assume it always has
+	 * data waiting for us because it is not epolled */
+	if (!sock->pipe_has_data && (group == NULL || sock->socket_has_data)) {
 		/* If the user is receiving a sufficiently large amount of data,
 		 * receive directly to their buffers. */
+		len = 0;
+		for (i = 0; i < iovcnt; i++) {
+			len += iov[i].iov_len;
+		}
+
 		if (len >= MIN_SOCK_PIPE_SIZE) {
-			if (group && sock->pending_events) {
-				sock->pending_events = false;
-				TAILQ_REMOVE(&group->pending_events, sock, link);
-			}
+			/* TODO: Should this detect if kernel socket is drained? */
 			return readv(sock->fd, iov, iovcnt);
 		}
 
@@ -1160,7 +1176,7 @@ posix_sock_group_impl_create(void)
 	}
 
 	group_impl->fd = fd;
-	TAILQ_INIT(&group_impl->pending_events);
+	TAILQ_INIT(&group_impl->socks_with_data);
 	group_impl->placement_id = -1;
 
 	if (g_spdk_posix_sock_impl_opts.enable_placement_id == PLACEMENT_CPU) {
@@ -1256,9 +1272,9 @@ posix_sock_group_impl_add_sock(struct spdk_sock_group_impl *_group, struct spdk_
 	/* switched from another polling group due to scheduling */
 	if (spdk_unlikely(sock->recv_pipe != NULL  &&
 			  (spdk_pipe_reader_bytes_available(sock->recv_pipe) > 0))) {
-		assert(sock->pending_events == false);
-		sock->pending_events = true;
-		TAILQ_INSERT_TAIL(&group->pending_events, sock, link);
+		sock->pipe_has_data = true;
+		sock->socket_has_data = false;
+		TAILQ_INSERT_TAIL(&group->socks_with_data, sock, link);
 	}
 
 	if (g_spdk_posix_sock_impl_opts.enable_placement_id == PLACEMENT_MARK) {
@@ -1281,9 +1297,10 @@ posix_sock_group_impl_remove_sock(struct spdk_sock_group_impl *_group, struct sp
 	struct spdk_posix_sock *sock = __posix_sock(_sock);
 	int rc;
 
-	if (sock->pending_events) {
-		TAILQ_REMOVE(&group->pending_events, sock, link);
-		sock->pending_events = false;
+	if (sock->pipe_has_data || sock->socket_has_data) {
+		TAILQ_REMOVE(&group->socks_with_data, sock, link);
+		sock->pipe_has_data = false;
+		sock->socket_has_data = false;
 	}
 
 	if (sock->placement_id != -1) {
@@ -1362,7 +1379,7 @@ posix_sock_group_impl_poll(struct spdk_sock_group_impl *_group, int max_events,
 	 */
 	int last_placement_id = -1;
 
-	TAILQ_FOREACH(psock, &group->pending_events, link) {
+	TAILQ_FOREACH(psock, &group->socks_with_data, link) {
 		if (psock->zcopy && psock->placement_id >= 0 &&
 		    psock->placement_id != last_placement_id) {
 			struct pollfd pfd = {psock->fd, POLLIN | POLLERR, 0};
@@ -1433,16 +1450,16 @@ posix_sock_group_impl_poll(struct spdk_sock_group_impl *_group, int max_events,
 		psock = __posix_sock(sock);
 #endif
 
-		/* If the socket does not already have recv pending, add it now */
-		if (!psock->pending_events) {
-			psock->pending_events = true;
-			TAILQ_INSERT_TAIL(&group->pending_events, psock, link);
+		/* If the socket is not already in the list, add it now */
+		if (!psock->socket_has_data && !psock->pipe_has_data) {
+			TAILQ_INSERT_TAIL(&group->socks_with_data, psock, link);
 		}
+		psock->socket_has_data = true;
 	}
 
 	num_events = 0;
 
-	TAILQ_FOREACH_SAFE(psock, &group->pending_events, link, ptmp) {
+	TAILQ_FOREACH_SAFE(psock, &group->socks_with_data, link, ptmp) {
 		if (num_events == max_events) {
 			break;
 		}
@@ -1450,15 +1467,16 @@ posix_sock_group_impl_poll(struct spdk_sock_group_impl *_group, int max_events,
 		/* If the socket's cb_fn is NULL, just remove it from the
 		 * list and do not add it to socks array */
 		if (spdk_unlikely(psock->base.cb_fn == NULL)) {
-			psock->pending_events = false;
-			TAILQ_REMOVE(&group->pending_events, psock, link);
+			psock->socket_has_data = false;
+			psock->pipe_has_data = false;
+			TAILQ_REMOVE(&group->socks_with_data, psock, link);
 			continue;
 		}
 
 		socks[num_events++] = &psock->base;
 	}
 
-	/* Cycle the pending_events list so that each time we poll things aren't
+	/* Cycle the has_data list so that each time we poll things aren't
 	 * in the same order. Say we have 6 sockets in the list, named as follows:
 	 * A B C D E F
 	 * And all 6 sockets had epoll events, but max_events is only 3. That means
@@ -1473,9 +1491,9 @@ posix_sock_group_impl_poll(struct spdk_sock_group_impl *_group, int max_events,
 
 		/* Capture pointers to the elements we need */
 		pd = psock;
-		pc = TAILQ_PREV(pd, spdk_pending_events_list, link);
-		pa = TAILQ_FIRST(&group->pending_events);
-		pf = TAILQ_LAST(&group->pending_events, spdk_pending_events_list);
+		pc = TAILQ_PREV(pd, spdk_has_data_list, link);
+		pa = TAILQ_FIRST(&group->socks_with_data);
+		pf = TAILQ_LAST(&group->socks_with_data, spdk_has_data_list);
 
 		/* Break the link between C and D */
 		pc->link.tqe_next = NULL;
@@ -1486,8 +1504,8 @@ posix_sock_group_impl_poll(struct spdk_sock_group_impl *_group, int max_events,
 		pa->link.tqe_prev = &pf->link.tqe_next;
 
 		/* Fix up the list first/last pointers */
-		group->pending_events.tqh_first = pd;
-		group->pending_events.tqh_last = &pc->link.tqe_next;
+		group->socks_with_data.tqh_first = pd;
+		group->socks_with_data.tqh_last = &pc->link.tqe_next;
 	}
 
 	return num_events;
-- 
2.26.2


From 1c71de70bd1babe0fa88a8225574e73d57146f5d Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 10 May 2021 08:56:00 -0400
Subject: [PATCH 174/342] perf/nvmf: add FIO I/O rate limit to the config

Added 'rate_iops' FIO option to the performance scripts.

This will be used during tests where limiting factor
has to be artifically imposed, rather than come from
the target/initiator system or enviroment.

One case for this are scheduler tests, to limit
each connection and balance the threads accordingly.

Signed-off-by: Maciej Szwed <maciej.szwed@intel.com>
Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I10bb09be9205a8b7ba90b36cd4e0bf922b0ecbc3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7840
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 scripts/perf/nvmf/README.md   | 5 +++++
 scripts/perf/nvmf/run_nvmf.py | 8 +++++---
 2 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/scripts/perf/nvmf/README.md b/scripts/perf/nvmf/README.md
index 3d0ff9c3e..a4f62a0cc 100644
--- a/scripts/perf/nvmf/README.md
+++ b/scripts/perf/nvmf/README.md
@@ -227,6 +227,7 @@ Optional, SPDK Initiator only:
   "qd": [32, 128],
   "rw": ["randwrite", "write"],
   "rwmixread": 100,
+  "rate_iops": 10000,
   "num_jobs": 2,
   "run_time": 30,
   "ramp_time": 30,
@@ -247,6 +248,10 @@ Required:
 - run_num - number of times each workload combination is run.
   If more than 1 then final result is the average of all runs.
 
+Optional:
+
+- rate_iops - limit IOPS to this number
+
 #### Test Combinations
 
 It is possible to specify more than one value for bs, qd and rw parameters.
diff --git a/scripts/perf/nvmf/run_nvmf.py b/scripts/perf/nvmf/run_nvmf.py
index df445e6d0..87867b56c 100755
--- a/scripts/perf/nvmf/run_nvmf.py
+++ b/scripts/perf/nvmf/run_nvmf.py
@@ -777,7 +777,7 @@ class Initiator(Server):
         # Logic implemented in SPDKInitiator and KernelInitiator classes
         pass
 
-    def gen_fio_config(self, rw, rwmixread, block_size, io_depth, subsys_no, num_jobs=None, ramp_time=0, run_time=10):
+    def gen_fio_config(self, rw, rwmixread, block_size, io_depth, subsys_no, num_jobs=None, ramp_time=0, run_time=10, rate_iops=0):
         fio_conf_template = """
 [global]
 ioengine={ioengine}
@@ -794,6 +794,7 @@ bs={block_size}
 time_based=1
 ramp_time={ramp_time}
 runtime={run_time}
+rate_iops={rate_iops}
 """
         if "spdk" in self.mode:
             bdev_conf = self.gen_spdk_bdev_conf(self.subsystem_info_list)
@@ -835,7 +836,7 @@ runtime={run_time}
 
         fio_config = fio_conf_template.format(ioengine=ioengine, spdk_conf=spdk_conf,
                                               rw=rw, rwmixread=rwmixread, block_size=block_size,
-                                              ramp_time=ramp_time, run_time=run_time)
+                                              ramp_time=ramp_time, run_time=run_time, rate_iops=rate_iops)
         if num_jobs:
             fio_config = fio_config + "numjobs=%s \n" % num_jobs
         if self.cpus_allowed is not None:
@@ -1342,6 +1343,7 @@ if __name__ == "__main__":
             fio_run_time = data[k]["run_time"]
             fio_ramp_time = data[k]["ramp_time"]
             fio_rw_mix_read = data[k]["rwmixread"]
+            fio_rate_iops = data[k]["rate_iops"]
             fio_run_num = data[k]["run_num"] if "run_num" in data[k].keys() else None
             fio_num_jobs = data[k]["num_jobs"] if "num_jobs" in data[k].keys() else None
         else:
@@ -1369,7 +1371,7 @@ if __name__ == "__main__":
                 i.kernel_init_connect(i.target_nic_ips, target_obj.subsys_no)
 
             cfg = i.gen_fio_config(rw, fio_rw_mix_read, block_size, io_depth, target_obj.subsys_no,
-                                   fio_num_jobs, fio_ramp_time, fio_run_time)
+                                   fio_num_jobs, fio_ramp_time, fio_run_time, fio_rate_iops)
             configs.append(cfg)
 
         for i, cfg in zip(initiators, configs):
-- 
2.26.2


From a3a0651569b60ff30c299c190def364fe67c95e9 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 28 Apr 2021 11:45:44 +0200
Subject: [PATCH 175/342] autotest: Run dd tests under SPDK_TEST_URING

As these tests were limited to SPDK_TEST_BLOCKBDEV the spdk_dd was
not being tested against liburing. Make sure it is the case now.
Also, fail the test if spdk_dd is not linked to liburing in case
where such tests were requested.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I5704577530048ed4775ea15a6cdacf23380b5072
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7653
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autotest.sh   | 7 ++++++-
 test/dd/dd.sh | 5 +++++
 2 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/autotest.sh b/autotest.sh
index a5f63c164..4020553ef 100755
--- a/autotest.sh
+++ b/autotest.sh
@@ -194,11 +194,16 @@ if [ $SPDK_RUN_FUNCTIONAL_TEST -eq 1 ]; then
 		run_test "bdev_raid" test/bdev/bdev_raid.sh
 		run_test "bdevperf_config" test/bdev/bdevperf/test_config.sh
 		if [[ $(uname -s) == Linux ]]; then
-			run_test "spdk_dd" test/dd/dd.sh
 			run_test "reactor_set_interrupt" test/interrupt/reactor_set_interrupt.sh
 		fi
 	fi
 
+	if [[ $(uname -s) == Linux ]]; then
+		if [[ $SPDK_TEST_BLOCKDEV -eq 1 || $SPDK_TEST_URING -eq 1 ]]; then
+			run_test "spdk_dd" test/dd/dd.sh
+		fi
+	fi
+
 	if [ $SPDK_TEST_JSON -eq 1 ]; then
 		run_test "test_converter" test/config_converter/test_converter.sh
 	fi
diff --git a/test/dd/dd.sh b/test/dd/dd.sh
index e2b8bb86a..778991104 100755
--- a/test/dd/dd.sh
+++ b/test/dd/dd.sh
@@ -8,6 +8,11 @@ nvmes=($(nvme_in_userspace))
 
 check_liburing
 
+if ((liburing_in_use == 0 && SPDK_TEST_URING == 1)); then
+	printf 'SPDK_TEST_URING is set but spdk_dd is not linked to liburing, aborting\n' >&2
+	exit 1
+fi
+
 run_test "spdk_dd_basic_rw" "$testdir/basic_rw.sh" "${nvmes[@]}"
 run_test "spdk_dd_posix" "$testdir/posix.sh"
 run_test "spdk_dd_bdev_to_bdev" "$testdir/bdev_to_bdev.sh" "${nvmes[@]}"
-- 
2.26.2


From 5f61a0c9196dbe09e741828b3e2823a3c0053faf Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Tue, 11 May 2021 12:02:33 +0200
Subject: [PATCH 176/342] scripts/common: Cache the pci driver

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Ie0ab6b31757b0446c697f59bfc789e78207b6e34
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7847
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/common.sh | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/scripts/common.sh b/scripts/common.sh
index d560107bf..fd5d492ac 100644
--- a/scripts/common.sh
+++ b/scripts/common.sh
@@ -32,16 +32,18 @@ cache_pci_init() {
 	local -gA pci_bus_cache
 	local -gA pci_ids_vendor
 	local -gA pci_ids_device
+	local -gA pci_bus_driver
 
 	[[ -z ${pci_bus_cache[*]} || $CMD == reset ]] || return 1
 
 	pci_bus_cache=()
 	pci_bus_ids_vendor=()
 	pci_bus_ids_device=()
+	pci_bus_driver=()
 }
 
 cache_pci() {
-	local pci=$1 class=$2 vendor=$3 device=$4
+	local pci=$1 class=$2 vendor=$3 device=$4 driver=$5
 
 	if [[ -n $class ]]; then
 		class=0x${class/0x/}
@@ -54,6 +56,9 @@ cache_pci() {
 		pci_ids_vendor["$pci"]=$vendor
 		pci_ids_device["$pci"]=$device
 	fi
+	if [[ -n $driver ]]; then
+		pci_bus_driver["$pci"]=$driver
+	fi
 }
 
 cache_pci_bus_sysfs() {
@@ -62,11 +67,17 @@ cache_pci_bus_sysfs() {
 	cache_pci_init || return 0
 
 	local pci
-	local class vendor device
+	local class vendor device driver
 
 	for pci in /sys/bus/pci/devices/*; do
-		class=$(< "$pci/class") vendor=$(< "$pci/vendor") device=$(< "$pci/device")
-		cache_pci "${pci##*/}" "$class" "$vendor" "$device"
+		class=$(< "$pci/class") vendor=$(< "$pci/vendor") device=$(< "$pci/device") driver=""
+		if [[ -e $pci/driver ]]; then
+			driver=$(readlink -f "$pci/driver")
+			driver=${driver##*/}
+		else
+			driver=unbound
+		fi
+		cache_pci "${pci##*/}" "$class" "$vendor" "$device" "$driver"
 	done
 }
 
-- 
2.26.2


From 9b3773db687c6fe995cc12de63d135aa1312e056 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Tue, 11 May 2021 12:07:09 +0200
Subject: [PATCH 177/342] scripts/common: Cache pci modalias

Additionally, include the first resolved alias of the module.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I71c7c15398ea36f3dea3340f5c98568ff6b6a68a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7848
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 scripts/common.sh | 29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

diff --git a/scripts/common.sh b/scripts/common.sh
index fd5d492ac..2edd0eddf 100644
--- a/scripts/common.sh
+++ b/scripts/common.sh
@@ -28,11 +28,23 @@ function pci_can_use() {
 	return 1
 }
 
+resolve_mod() {
+	local mod=$1 aliases=()
+
+	if aliases=($(modprobe -R "$mod")); then
+		echo "${aliases[0]}"
+	else
+		echo "unknown"
+	fi 2> /dev/null
+}
+
 cache_pci_init() {
 	local -gA pci_bus_cache
 	local -gA pci_ids_vendor
 	local -gA pci_ids_device
 	local -gA pci_bus_driver
+	local -gA pci_mod_driver
+	local -gA pci_mod_resolved
 
 	[[ -z ${pci_bus_cache[*]} || $CMD == reset ]] || return 1
 
@@ -40,10 +52,12 @@ cache_pci_init() {
 	pci_bus_ids_vendor=()
 	pci_bus_ids_device=()
 	pci_bus_driver=()
+	pci_mod_driver=()
+	pci_mod_resolved=()
 }
 
 cache_pci() {
-	local pci=$1 class=$2 vendor=$3 device=$4 driver=$5
+	local pci=$1 class=$2 vendor=$3 device=$4 driver=$5 mod=$6
 
 	if [[ -n $class ]]; then
 		class=0x${class/0x/}
@@ -59,6 +73,10 @@ cache_pci() {
 	if [[ -n $driver ]]; then
 		pci_bus_driver["$pci"]=$driver
 	fi
+	if [[ -n $mod ]]; then
+		pci_mod_driver["$pci"]=$mod
+		pci_mod_resolved["$pci"]=$(resolve_mod "$mod")
+	fi
 }
 
 cache_pci_bus_sysfs() {
@@ -67,17 +85,20 @@ cache_pci_bus_sysfs() {
 	cache_pci_init || return 0
 
 	local pci
-	local class vendor device driver
+	local class vendor device driver mod
 
 	for pci in /sys/bus/pci/devices/*; do
-		class=$(< "$pci/class") vendor=$(< "$pci/vendor") device=$(< "$pci/device") driver=""
+		class=$(< "$pci/class") vendor=$(< "$pci/vendor") device=$(< "$pci/device") driver="" mod=""
 		if [[ -e $pci/driver ]]; then
 			driver=$(readlink -f "$pci/driver")
 			driver=${driver##*/}
 		else
 			driver=unbound
 		fi
-		cache_pci "${pci##*/}" "$class" "$vendor" "$device" "$driver"
+		if [[ -e $pci/modalias ]]; then
+			mod=$(< "$pci/modalias")
+		fi
+		cache_pci "${pci##*/}" "$class" "$vendor" "$device" "$driver" "$mod"
 	done
 }
 
-- 
2.26.2


From fead05c0257591d9cf152e119c62c11232a5aaf0 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Tue, 11 May 2021 16:16:26 +0200
Subject: [PATCH 178/342] test/nvmf: Rework the traps

Declare single trap from nvmftestinit() instead overriding main trap
depending on the use-case (veth vs phy).

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I23c66fc5728510d06eee9837843f0734b2d03dcf
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7850
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/nvmf/common.sh | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/test/nvmf/common.sh b/test/nvmf/common.sh
index 8c18d17f6..252681850 100644
--- a/test/nvmf/common.sh
+++ b/test/nvmf/common.sh
@@ -280,8 +280,6 @@ function nvmf_veth_init() {
 	"${NVMF_TARGET_NS_CMD[@]}" ip link delete $NVMF_TARGET_INTERFACE2 || true
 	ip netns del $NVMF_TARGET_NAMESPACE || true
 
-	trap 'nvmf_veth_fini; exit 1' SIGINT SIGTERM EXIT
-
 	# Create network namespace
 	ip netns add $NVMF_TARGET_NAMESPACE
 
@@ -368,8 +366,6 @@ function nvmf_tcp_init() {
 	ip -4 addr flush $NVMF_TARGET_INTERFACE || true
 	ip -4 addr flush $NVMF_INITIATOR_INTERFACE || true
 
-	trap 'nvmf_tcp_fini; exit 1' SIGINT SIGTERM
-
 	# Create network namespace
 	ip netns add $NVMF_TARGET_NAMESPACE
 
@@ -401,8 +397,10 @@ function nvmf_tcp_fini() {
 		nvmf_veth_fini
 		return 0
 	fi
-	ip netns del $NVMF_TARGET_NAMESPACE
-	ip -4 addr flush $NVMF_INITIATOR_INTERFACE
+	if [[ -n $NVMF_TARGET_NAMESPACE && -e /var/run/netns/$NVMF_TARGET_NAMESPACE ]]; then
+		ip netns del $NVMF_TARGET_NAMESPACE
+	fi
+	ip -4 addr flush $NVMF_INITIATOR_INTERFACE || :
 }
 
 function nvmftestinit() {
@@ -410,6 +408,9 @@ function nvmftestinit() {
 		echo "transport not specified - use --transport= to specify"
 		return 1
 	fi
+
+	trap 'process_shm --id $NVMF_APP_SHM_ID || :; nvmftestfini' SIGINT SIGTERM EXIT
+
 	if [ "$TEST_MODE" == "iso" ]; then
 		$rootdir/scripts/setup.sh
 		if [[ "$TEST_TRANSPORT" == "rdma" ]]; then
@@ -448,7 +449,6 @@ function nvmfappstart() {
 	timing_enter start_nvmf_tgt
 	"${NVMF_APP[@]}" "$@" &
 	nvmfpid=$!
-	trap 'process_shm --id $NVMF_APP_SHM_ID; nvmftestfini; exit 1' SIGINT SIGTERM EXIT
 	waitforlisten $nvmfpid
 	timing_exit start_nvmf_tgt
 }
-- 
2.26.2


From aebbce25206db5ce247d69dbf72d97b1965e37c7 Mon Sep 17 00:00:00 2001
From: Evgeniy Kochetov <evgeniik@nvidia.com>
Date: Thu, 28 Jan 2021 16:33:07 +0200
Subject: [PATCH 179/342] nvme: Refactor active namespace list retrieval

Previous implementation allocated memory just once at the beginning of
active NS list retrieval procedure. It allocated memory for maximum
possible number of active namespaces, i.e. 'cdata.nn'.

This patch changes allocation logic. One page is allocated at the
beginning. If more is needed, reallocation is done with one more
page.

This patch also removes SPDK_MALLOC_DMA flag from allocation since we
don't do RDMA directly into this buffer.

Signed-off-by: Evgeniy Kochetov <evgeniik@nvidia.com>
Change-Id: Iaa80c4d70c54daaf71dcbf755c63a01a1d83b772
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6502
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/nvme/nvme_ctrlr.c                         |  68 ++++++---
 lib/nvme/nvme_internal.h                      |   1 +
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 143 ++++++++++++++++--
 3 files changed, 180 insertions(+), 32 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 2684d2d70..5a9a3a3ab 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -1784,7 +1784,6 @@ typedef void (*nvme_active_ns_ctx_deleter)(struct nvme_active_ns_ctx *);
 struct nvme_active_ns_ctx {
 	struct spdk_nvme_ctrlr *ctrlr;
 	uint32_t page;
-	uint32_t num_pages;
 	uint32_t next_nsid;
 	uint32_t *new_ns_list;
 	nvme_active_ns_ctx_deleter deleter;
@@ -1796,7 +1795,6 @@ static struct nvme_active_ns_ctx *
 nvme_active_ns_ctx_create(struct spdk_nvme_ctrlr *ctrlr, nvme_active_ns_ctx_deleter deleter)
 {
 	struct nvme_active_ns_ctx *ctx;
-	uint32_t num_pages = 0;
 	uint32_t *new_ns_list = NULL;
 
 	ctx = calloc(1, sizeof(*ctx));
@@ -1805,19 +1803,14 @@ nvme_active_ns_ctx_create(struct spdk_nvme_ctrlr *ctrlr, nvme_active_ns_ctx_dele
 		return NULL;
 	}
 
-	if (ctrlr->num_ns) {
-		/* The allocated size must be a multiple of sizeof(struct spdk_nvme_ns_list) */
-		num_pages = (ctrlr->num_ns * sizeof(new_ns_list[0]) - 1) / sizeof(struct spdk_nvme_ns_list) + 1;
-		new_ns_list = spdk_zmalloc(num_pages * sizeof(struct spdk_nvme_ns_list), ctrlr->page_size,
-					   NULL, SPDK_ENV_LCORE_ID_ANY, SPDK_MALLOC_DMA | SPDK_MALLOC_SHARE);
-		if (!new_ns_list) {
-			NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate active_ns_list!\n");
-			free(ctx);
-			return NULL;
-		}
+	new_ns_list = spdk_zmalloc(sizeof(struct spdk_nvme_ns_list), ctrlr->page_size,
+				   NULL, SPDK_ENV_LCORE_ID_ANY, SPDK_MALLOC_SHARE);
+	if (!new_ns_list) {
+		NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate active_ns_list!\n");
+		free(ctx);
+		return NULL;
 	}
 
-	ctx->num_pages = num_pages;
 	ctx->new_ns_list = new_ns_list;
 	ctx->ctrlr = ctrlr;
 	ctx->deleter = deleter;
@@ -1835,8 +1828,12 @@ nvme_active_ns_ctx_destroy(struct nvme_active_ns_ctx *ctx)
 static void
 nvme_ctrlr_identify_active_ns_swap(struct spdk_nvme_ctrlr *ctrlr, uint32_t **new_ns_list)
 {
+	uint32_t max_active_ns_idx = 0;
+
+	while ((*new_ns_list)[max_active_ns_idx++]);
 	spdk_free(ctrlr->active_ns_list);
 	ctrlr->active_ns_list = *new_ns_list;
+	ctrlr->max_active_ns_idx = max_active_ns_idx;
 	*new_ns_list = NULL;
 }
 
@@ -1844,6 +1841,7 @@ static void
 nvme_ctrlr_identify_active_ns_async_done(void *arg, const struct spdk_nvme_cpl *cpl)
 {
 	struct nvme_active_ns_ctx *ctx = arg;
+	uint32_t *new_ns_list = NULL;
 
 	if (spdk_nvme_cpl_is_error(cpl)) {
 		ctx->state = NVME_ACTIVE_NS_STATE_ERROR;
@@ -1851,11 +1849,22 @@ nvme_ctrlr_identify_active_ns_async_done(void *arg, const struct spdk_nvme_cpl *
 	}
 
 	ctx->next_nsid = ctx->new_ns_list[1024 * ctx->page + 1023];
-	if (ctx->next_nsid == 0 || ++ctx->page == ctx->num_pages) {
+	if (ctx->next_nsid == 0) {
 		ctx->state = NVME_ACTIVE_NS_STATE_DONE;
 		goto out;
 	}
 
+	ctx->page++;
+	new_ns_list = spdk_realloc(ctx->new_ns_list,
+				   (ctx->page + 1) * sizeof(struct spdk_nvme_ns_list),
+				   ctx->ctrlr->page_size);
+	if (!new_ns_list) {
+		SPDK_ERRLOG("Failed to reallocate active_ns_list!\n");
+		ctx->state = NVME_ACTIVE_NS_STATE_ERROR;
+		goto out;
+	}
+
+	ctx->new_ns_list = new_ns_list;
 	nvme_ctrlr_identify_active_ns_async(ctx);
 	return;
 
@@ -1872,7 +1881,7 @@ nvme_ctrlr_identify_active_ns_async(struct nvme_active_ns_ctx *ctx)
 	uint32_t i;
 	int rc;
 
-	if (ctrlr->num_ns == 0) {
+	if (ctrlr->cdata.nn == 0) {
 		ctx->state = NVME_ACTIVE_NS_STATE_DONE;
 		goto out;
 	}
@@ -1884,7 +1893,27 @@ nvme_ctrlr_identify_active_ns_async(struct nvme_active_ns_ctx *ctx)
 	 * an active ns list, i.e. all namespaces report as active
 	 */
 	if (ctrlr->vs.raw < SPDK_NVME_VERSION(1, 1, 0) || ctrlr->quirks & NVME_QUIRK_IDENTIFY_CNS) {
-		for (i = 0; i < ctrlr->num_ns; i++) {
+		uint32_t *new_ns_list;
+		uint32_t num_pages;
+
+		/*
+		 * Active NS list must always end with zero element.
+		 * So, we allocate for cdata.nn+1.
+		 */
+		num_pages = spdk_divide_round_up(ctrlr->cdata.nn + 1,
+						 sizeof(struct spdk_nvme_ns_list) / sizeof(new_ns_list[0]));
+		new_ns_list = spdk_realloc(ctx->new_ns_list,
+					   num_pages * sizeof(struct spdk_nvme_ns_list),
+					   ctx->ctrlr->page_size);
+		if (!new_ns_list) {
+			SPDK_ERRLOG("Failed to reallocate active_ns_list!\n");
+			ctx->state = NVME_ACTIVE_NS_STATE_ERROR;
+			goto out;
+		}
+
+		ctx->new_ns_list = new_ns_list;
+		ctx->new_ns_list[ctrlr->cdata.nn] = 0;
+		for (i = 0; i < ctrlr->cdata.nn; i++) {
 			ctx->new_ns_list[i] = i + 1;
 		}
 
@@ -2498,6 +2527,7 @@ nvme_ctrlr_destruct_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 
 	spdk_free(ctrlr->active_ns_list);
 	ctrlr->active_ns_list = NULL;
+	ctrlr->max_active_ns_idx = 0;
 }
 
 static void
@@ -3631,12 +3661,12 @@ nvme_ctrlr_active_ns_idx(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
 {
 	int32_t result = -1;
 
-	if (ctrlr->active_ns_list == NULL || nsid == 0 || nsid > ctrlr->num_ns) {
+	if (ctrlr->active_ns_list == NULL || nsid == 0 || nsid > ctrlr->cdata.nn) {
 		return result;
 	}
 
 	int32_t lower = 0;
-	int32_t upper = ctrlr->num_ns - 1;
+	int32_t upper = ctrlr->max_active_ns_idx;
 	int32_t mid;
 
 	while (lower <= upper) {
@@ -3673,7 +3703,7 @@ uint32_t
 spdk_nvme_ctrlr_get_next_active_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t prev_nsid)
 {
 	int32_t nsid_idx = nvme_ctrlr_active_ns_idx(ctrlr, prev_nsid);
-	if (ctrlr->active_ns_list && nsid_idx >= 0 && (uint32_t)nsid_idx < ctrlr->num_ns - 1) {
+	if (nsid_idx >= 0 && (uint32_t)nsid_idx < ctrlr->max_active_ns_idx) {
 		return ctrlr->active_ns_list[nsid_idx + 1];
 	}
 	return 0;
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index 115f33ec1..21397623a 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -826,6 +826,7 @@ struct spdk_nvme_ctrlr {
 	/**
 	 * Keep track of active namespaces
 	 */
+	uint32_t			max_active_ns_idx;
 	uint32_t			*active_ns_list;
 
 	struct spdk_bit_array		*free_io_qids;
diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index 22e65434c..8378b2f2c 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -2,7 +2,7 @@
  *   BSD LICENSE
  *
  *   Copyright (c) Intel Corporation. All rights reserved.
- *   Copyright (c) 2020 Mellanox Technologies LTD. All rights reserved.
+ *   Copyright (c) 2020, 2021 Mellanox Technologies LTD. All rights reserved.
  *
  *   Redistribution and use in source and binary forms, with or without
  *   modification, are permitted provided that the following conditions
@@ -387,6 +387,9 @@ nvme_ctrlr_cmd_set_async_event_config(struct spdk_nvme_ctrlr *ctrlr,
 	return 0;
 }
 
+static uint32_t *g_active_ns_list = NULL;
+static uint32_t g_active_ns_list_length = 0;
+
 int
 nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cntid, uint32_t nsid,
 			uint8_t csi, void *payload, size_t payload_size,
@@ -397,14 +400,29 @@ nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cnt
 		uint32_t i = 0;
 		struct spdk_nvme_ns_list *ns_list = (struct spdk_nvme_ns_list *)payload;
 
-		for (i = 1; i <= ctrlr->num_ns; i++) {
-			if (i <= nsid) {
-				continue;
+		memset(payload, 0, payload_size);
+		if (g_active_ns_list == NULL) {
+			for (i = 1; i <= ctrlr->num_ns; i++) {
+				if (i <= nsid) {
+					continue;
+				}
+
+				ns_list->ns_list[count++] = i;
+				if (count == SPDK_COUNTOF(ns_list->ns_list)) {
+					break;
+				}
 			}
-
-			ns_list->ns_list[count++] = i;
-			if (count == SPDK_COUNTOF(ns_list->ns_list)) {
-				break;
+		} else {
+			for (i = 0; i < g_active_ns_list_length; i++) {
+				uint32_t cur_nsid = g_active_ns_list[i];
+				if (cur_nsid <= nsid) {
+					continue;
+				}
+
+				ns_list->ns_list[count++] = cur_nsid;
+				if (count == SPDK_COUNTOF(ns_list->ns_list)) {
+					break;
+				}
 			}
 		}
 
@@ -1882,17 +1900,17 @@ test_nvme_ctrlr_test_active_ns(void)
 		ctrlr.vs.bits.mjr = 1;
 		ctrlr.vs.bits.mnr = minor;
 		ctrlr.vs.bits.ter = 0;
-		ctrlr.num_ns = 1531;
+		ctrlr.num_ns = ctrlr.cdata.nn = 1531;
 		nvme_ctrlr_identify_active_ns(&ctrlr);
 
 		for (nsid = 1; nsid <= ctrlr.num_ns; nsid++) {
 			CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, nsid) == true);
 		}
-		ctrlr.num_ns = 1559;
-		for (; nsid <= ctrlr.num_ns; nsid++) {
+
+		for (; nsid <= 1559; nsid++) {
 			CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, nsid) == false);
 		}
-		ctrlr.num_ns = 1531;
+
 		for (nsid = 0; nsid < ctrlr.num_ns; nsid++) {
 			ctrlr.active_ns_list[nsid] = 0;
 		}
@@ -1940,7 +1958,7 @@ test_nvme_ctrlr_test_active_ns_error_case(void)
 	ctrlr.vs.bits.mjr = 1;
 	ctrlr.vs.bits.mnr = 2;
 	ctrlr.vs.bits.ter = 0;
-	ctrlr.num_ns = 2;
+	ctrlr.cdata.nn = 2;
 
 	set_status_code = SPDK_NVME_SC_INVALID_FIELD;
 	rc = nvme_ctrlr_identify_active_ns(&ctrlr);
@@ -2474,6 +2492,103 @@ test_nvme_ctrlr_set_state(void)
 	MOCK_CLEAR(spdk_get_ticks);
 }
 
+static void
+test_nvme_ctrlr_active_ns_list_v0(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+
+	ctrlr.vs.bits.mjr = 1;
+	ctrlr.vs.bits.mnr = 0;
+	ctrlr.vs.bits.ter = 0;
+	ctrlr.cdata.nn = 1024;
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
+	CU_ASSERT(spdk_nvme_ctrlr_get_first_active_ns(&ctrlr) == 1);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1023) == 1024);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1024) == 0);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1025) == 0);
+
+	nvme_ctrlr_destruct(&ctrlr);
+}
+
+static void
+test_nvme_ctrlr_active_ns_list_v2(void)
+{
+	uint32_t i;
+	uint32_t active_ns_list[1024];
+	DECLARE_AND_CONSTRUCT_CTRLR();
+
+	ctrlr.vs.bits.mjr = 1;
+	ctrlr.vs.bits.mnr = 2;
+	ctrlr.vs.bits.ter = 0;
+	ctrlr.cdata.nn = 4096;
+
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+
+	/* No active namespaces */
+	memset(active_ns_list, 0, sizeof(active_ns_list));
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
+	CU_ASSERT(spdk_nvme_ctrlr_get_first_active_ns(&ctrlr) == 0);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1024) == 0);
+
+	nvme_ctrlr_destruct(&ctrlr);
+
+	/* 1024 active namespaces - one full page */
+	memset(active_ns_list, 0, sizeof(active_ns_list));
+	for (i = 0; i < 1024; ++i) {
+		active_ns_list[i] = i + 1;
+	}
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
+	CU_ASSERT(spdk_nvme_ctrlr_get_first_active_ns(&ctrlr) == 1);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1023) == 1024);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1024) == 0);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1025) == 0);
+
+	nvme_ctrlr_destruct(&ctrlr);
+
+	/* 1023 active namespaces - full page minus one	 */
+	memset(active_ns_list, 0, sizeof(active_ns_list));
+	for (i = 0; i < 1023; ++i) {
+		active_ns_list[i] = i + 1;
+	}
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1023));
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
+	CU_ASSERT(spdk_nvme_ctrlr_get_first_active_ns(&ctrlr) == 1);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1023) == 0);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1024) == 0);
+	CU_ASSERT(spdk_nvme_ctrlr_get_next_active_ns(&ctrlr, 1025) == 0);
+
+	nvme_ctrlr_destruct(&ctrlr);
+
+	g_active_ns_list = NULL;
+	g_active_ns_list_length = 0;
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -2518,6 +2633,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_cmd_map_sgls);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_set_arbitration_feature);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_set_state);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_active_ns_list_v0);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_active_ns_list_v2);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 75ddfd6511f4acd71a916d4cbc2689f0b6d7dda1 Mon Sep 17 00:00:00 2001
From: Evgeniy Kochetov <evgeniik@nvidia.com>
Date: Tue, 13 Apr 2021 13:32:25 +0300
Subject: [PATCH 180/342] nvme/ctrlr: Handle namespaces construction failure

Signed-off-by: Evgeniy Kochetov <evgeniik@nvidia.com>
Change-Id: I3b14e2dce3bd4b2ce42e3946592cfde9d4300f28
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7361
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/nvme/nvme_ctrlr.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 5a9a3a3ab..44c8bebae 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -2605,6 +2605,8 @@ nvme_ctrlr_construct_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 
 fail:
 	nvme_ctrlr_destruct_namespaces(ctrlr);
+	NVME_CTRLR_ERRLOG(ctrlr, "Failed to construct namespaces, err %d\n", rc);
+	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_ERROR, NVME_TIMEOUT_INFINITE);
 	return rc;
 }
 
@@ -3240,8 +3242,10 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 
 	case NVME_CTRLR_STATE_CONSTRUCT_NS:
 		rc = nvme_ctrlr_construct_namespaces(ctrlr);
-		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS,
-				     ctrlr->opts.admin_timeout_ms);
+		if (!rc) {
+			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS,
+					     ctrlr->opts.admin_timeout_ms);
+		}
 		break;
 
 	case NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS:
-- 
2.26.2


From 65ff07719d3092fc4a89da972a565ebc5bd10d97 Mon Sep 17 00:00:00 2001
From: Evgeniy Kochetov <evgeniik@nvidia.com>
Date: Mon, 1 Feb 2021 16:13:49 +0200
Subject: [PATCH 181/342] nvme/ctrlr: Retrieve active NS list before NS
 construct

This patch changes the order of IDENTIFY_ACTIVE_NS and CONSTRUCT_NS
controller states. It is required to further improve memory management
for namespaces by allocating memory only for active ones.

Signed-off-by: Evgeniy Kochetov <evgeniik@nvidia.com>
Change-Id: Ie540442b1bd9e897afcbaa4319c139109dd0c515
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6503
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/nvme/nvme_ctrlr.c                         | 25 ++++++++--------
 lib/nvme/nvme_internal.h                      | 10 +++----
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 30 ++++++++++++-------
 3 files changed, 37 insertions(+), 28 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 44c8bebae..044c409f4 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -1161,12 +1161,12 @@ nvme_ctrlr_state_string(enum nvme_ctrlr_state state)
 		return "set number of queues";
 	case NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES:
 		return "wait for set number of queues";
-	case NVME_CTRLR_STATE_CONSTRUCT_NS:
-		return "construct namespaces";
 	case NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS:
 		return "identify active ns";
 	case NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_ACTIVE_NS:
 		return "wait for identify active ns";
+	case NVME_CTRLR_STATE_CONSTRUCT_NS:
+		return "construct namespaces";
 	case NVME_CTRLR_STATE_IDENTIFY_NS:
 		return "identify ns";
 	case NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_NS:
@@ -1953,7 +1953,7 @@ _nvme_active_ns_ctx_deleter(struct nvme_active_ns_ctx *ctx)
 	assert(ctx->state == NVME_ACTIVE_NS_STATE_DONE);
 	nvme_ctrlr_identify_active_ns_swap(ctrlr, &ctx->new_ns_list);
 	nvme_active_ns_ctx_destroy(ctx);
-	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_NS, ctrlr->opts.admin_timeout_ms);
+	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_CONSTRUCT_NS, ctrlr->opts.admin_timeout_ms);
 }
 
 static void
@@ -2332,7 +2332,7 @@ nvme_ctrlr_set_num_queues_done(void *arg, const struct spdk_nvme_cpl *cpl)
 		spdk_nvme_ctrlr_free_qid(ctrlr, i);
 	}
 
-	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_CONSTRUCT_NS,
+	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS,
 			     ctrlr->opts.admin_timeout_ms);
 }
 
@@ -2524,10 +2524,6 @@ nvme_ctrlr_destruct_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 		ctrlr->ns = NULL;
 		ctrlr->num_ns = 0;
 	}
-
-	spdk_free(ctrlr->active_ns_list);
-	ctrlr->active_ns_list = NULL;
-	ctrlr->max_active_ns_idx = 0;
 }
 
 static void
@@ -3240,18 +3236,18 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 		rc = nvme_ctrlr_set_num_queues(ctrlr);
 		break;
 
+	case NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS:
+		_nvme_ctrlr_identify_active_ns(ctrlr);
+		break;
+
 	case NVME_CTRLR_STATE_CONSTRUCT_NS:
 		rc = nvme_ctrlr_construct_namespaces(ctrlr);
 		if (!rc) {
-			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS,
+			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_NS,
 					     ctrlr->opts.admin_timeout_ms);
 		}
 		break;
 
-	case NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS:
-		_nvme_ctrlr_identify_active_ns(ctrlr);
-		break;
-
 	case NVME_CTRLR_STATE_IDENTIFY_NS:
 		rc = nvme_ctrlr_identify_namespaces(ctrlr);
 		break;
@@ -3485,6 +3481,9 @@ nvme_ctrlr_destruct_poll_async(struct spdk_nvme_ctrlr *ctrlr,
 	}
 
 	nvme_ctrlr_destruct_namespaces(ctrlr);
+	spdk_free(ctrlr->active_ns_list);
+	ctrlr->active_ns_list = NULL;
+	ctrlr->max_active_ns_idx = 0;
 
 	spdk_bit_array_free(&ctrlr->free_io_qids);
 
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index 21397623a..495ff9424 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -587,11 +587,6 @@ enum nvme_ctrlr_state {
 	 */
 	NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES,
 
-	/**
-	 * Construct Namespace data structures of the controller.
-	 */
-	NVME_CTRLR_STATE_CONSTRUCT_NS,
-
 	/**
 	 * Get active Namespace list of the controller.
 	 */
@@ -602,6 +597,11 @@ enum nvme_ctrlr_state {
 	 */
 	NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_ACTIVE_NS,
 
+	/**
+	 * Construct Namespace data structures of the controller.
+	 */
+	NVME_CTRLR_STATE_CONSTRUCT_NS,
+
 	/**
 	 * Get Identify Namespace Data structure for each NS.
 	 */
diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index 8378b2f2c..9883e0855 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -2083,6 +2083,8 @@ test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_NUM_QUEUES);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS);
+	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 
 	CU_ASSERT(ctrlr.ioccsz_bytes == 0);
@@ -2100,6 +2102,8 @@ test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_NUM_QUEUES);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS);
+	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 
 	CU_ASSERT(ctrlr.ioccsz_bytes == 4096);
@@ -2119,6 +2123,8 @@ test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_NUM_QUEUES);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS);
+	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 
 	CU_ASSERT(ctrlr.ioccsz_bytes == 4096);
@@ -2138,6 +2144,8 @@ test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_NUM_QUEUES);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS);
+	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 
 	CU_ASSERT(ctrlr.ioccsz_bytes == 4096);
@@ -2157,6 +2165,8 @@ test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_SET_NUM_QUEUES);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS);
+	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 
 	CU_ASSERT(ctrlr.ioccsz_bytes == 0);
@@ -2181,8 +2191,8 @@ test_nvme_ctrlr_init_set_num_queues(void)
 	ctrlr.opts.num_io_queues = 64;
 	/* Num queues is zero-based. So, use 31 to get 32 queues */
 	fake_cpl.cdw0 = 31 + (31 << 16);
-	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> CONSTRUCT_NS */
-	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
+	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_ACTIVE_NS */
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS);
 	CU_ASSERT(ctrlr.opts.num_io_queues == 32);
 	fake_cpl.cdw0 = 0;
 
@@ -2503,8 +2513,8 @@ test_nvme_ctrlr_active_ns_list_v0(void)
 	ctrlr.cdata.nn = 1024;
 
 	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
-	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
-	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> CONSTRUCT_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
 	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
 	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
@@ -2534,8 +2544,8 @@ test_nvme_ctrlr_active_ns_list_v2(void)
 	/* No active namespaces */
 	memset(active_ns_list, 0, sizeof(active_ns_list));
 	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
-	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
-	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> CONSTRUCT_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
 	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
 	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
@@ -2553,8 +2563,8 @@ test_nvme_ctrlr_active_ns_list_v2(void)
 	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
 	g_active_ns_list = active_ns_list;
 	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
-	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
-	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> CONSTRUCT_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
 	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
 	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1025));
@@ -2572,8 +2582,8 @@ test_nvme_ctrlr_active_ns_list_v2(void)
 	}
 
 	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
-	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> IDENTIFY_NS */
-	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_IDENTIFY_NS);
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0); /* -> CONSTRUCT_NS */
+	SPDK_CU_ASSERT_FATAL(ctrlr.state == NVME_CTRLR_STATE_CONSTRUCT_NS);
 	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1));
 	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1023));
 	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 1024));
-- 
2.26.2


From f0e248586ea0a76eadbd2d60b472d17d99aac6b3 Mon Sep 17 00:00:00 2001
From: Evgeniy Kochetov <evgeniik@nvidia.com>
Date: Mon, 16 Nov 2020 09:25:13 +0200
Subject: [PATCH 182/342] nvme/ctrlr: Always access namespaces via getter
 function

Signed-off-by: Evgeniy Kochetov <evgeniik@nvidia.com>
Change-Id: I16e327c0c0485057dc90a87cae316c4d6b62720d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6504
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/nvme/nvme_ctrlr.c                          | 18 ++++++++++++------
 lib/nvme/nvme_ctrlr_cmd.c                      |  7 ++++---
 .../nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c  | 16 +++++++++++++---
 3 files changed, 29 insertions(+), 12 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 044c409f4..7d319bc24 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -738,7 +738,8 @@ nvme_ctrlr_update_ns_ana_states(const struct spdk_nvme_ana_group_descriptor *des
 			continue;
 		}
 
-		ns = &ctrlr->ns[nsid - 1];
+		ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid);
+		assert(ns != NULL);
 
 		ns->ana_group_id = desc->ana_group_id;
 		ns->ana_state = desc->ana_state;
@@ -2534,9 +2535,10 @@ nvme_ctrlr_update_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 	bool ns_is_active;
 
 	for (i = 0; i < nn; i++) {
-		struct spdk_nvme_ns	*ns = &ctrlr->ns[i];
 		uint32_t		nsid = i + 1;
+		struct spdk_nvme_ns	*ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid);
 
+		assert(ns != NULL);
 		nsdata = &ns->nsdata;
 		ns_is_active = spdk_nvme_ctrlr_is_active_ns(ctrlr, nsid);
 
@@ -3834,7 +3836,8 @@ spdk_nvme_ctrlr_attach_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid,
 		return res;
 	}
 
-	ns = &ctrlr->ns[nsid - 1];
+	ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid);
+	assert(ns != NULL);
 	return nvme_ns_construct(ns, nsid, ctrlr);
 }
 
@@ -3876,7 +3879,8 @@ spdk_nvme_ctrlr_detach_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid,
 		return res;
 	}
 
-	ns = &ctrlr->ns[nsid - 1];
+	ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid);
+	assert(ns != NULL);
 	/* Inactive NS */
 	nvme_ns_destruct(ns);
 
@@ -3915,7 +3919,8 @@ spdk_nvme_ctrlr_create_ns(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns_dat
 
 	assert(nsid > 0);
 
-	ns = &ctrlr->ns[nsid - 1];
+	ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid);
+	assert(ns != NULL);
 	/* Inactive NS */
 	res = nvme_ns_construct(ns, nsid, ctrlr);
 	if (res) {
@@ -3962,7 +3967,8 @@ spdk_nvme_ctrlr_delete_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
 		return res;
 	}
 
-	ns = &ctrlr->ns[nsid - 1];
+	ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid);
+	assert(ns != NULL);
 	nvme_ns_destruct(ns);
 
 	return 0;
diff --git a/lib/nvme/nvme_ctrlr_cmd.c b/lib/nvme/nvme_ctrlr_cmd.c
index 1e99341f2..3d54ba363 100644
--- a/lib/nvme/nvme_ctrlr_cmd.c
+++ b/lib/nvme/nvme_ctrlr_cmd.c
@@ -1,8 +1,8 @@
 /*-
  *   BSD LICENSE
  *
- *   Copyright (c) Intel Corporation.
- *   All rights reserved.
+ *   Copyright (c) Intel Corporation. All rights reserved.
+ *   Copyright (c) 2021 Mellanox Technologies LTD. All rights reserved.
  *
  *   Redistribution and use in source and binary forms, with or without
  *   modification, are permitted provided that the following conditions
@@ -93,8 +93,9 @@ spdk_nvme_ctrlr_cmd_io_raw_with_md(struct spdk_nvme_ctrlr *ctrlr,
 
 	/* Caculate metadata length */
 	if (md_buf) {
-		struct spdk_nvme_ns *ns = &ctrlr->ns[cmd->nsid - 1];
+		struct spdk_nvme_ns *ns = spdk_nvme_ctrlr_get_ns(ctrlr, cmd->nsid);
 
+		assert(ns != NULL);
 		assert(ns->sector_size != 0);
 		md_len =  len / ns->sector_size * ns->md_size;
 	}
diff --git a/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c b/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
index 893f4f9ab..8077ee7d9 100644
--- a/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr_cmd.c/nvme_ctrlr_cmd_ut.c
@@ -2,8 +2,8 @@
 /*-
  *   BSD LICENSE
  *
- *   Copyright (c) Intel Corporation.
- *   All rights reserved.
+ *   Copyright (c) Intel Corporation. All rights reserved.
+ *   Copyright (c) 2021 Mellanox Technologies LTD. All rights reserved.
  *
  *   Redistribution and use in source and binary forms, with or without
  *   modification, are permitted provided that the following conditions
@@ -368,7 +368,17 @@ nvme_ctrlr_submit_admin_request(struct spdk_nvme_ctrlr *ctrlr, struct nvme_reque
 	return 0;
 }
 
-#define DECLARE_AND_CONSTRUCT_CTRLR()	\
+struct spdk_nvme_ns *
+spdk_nvme_ctrlr_get_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
+{
+	if (nsid < 1 || nsid > ctrlr->num_ns) {
+		return NULL;
+	}
+
+	return &ctrlr->ns[nsid - 1];
+}
+
+#define DECLARE_AND_CONSTRUCT_CTRLR()		\
 	struct spdk_nvme_ctrlr	ctrlr = {};	\
 	struct spdk_nvme_qpair	adminq = {};	\
 	struct nvme_request	req;		\
-- 
2.26.2


From d8eb6957a074e7838e1b929280de923f77bb636d Mon Sep 17 00:00:00 2001
From: Evgeniy Kochetov <evgeniik@nvidia.com>
Date: Tue, 16 Feb 2021 15:10:49 +0200
Subject: [PATCH 183/342] ut/nvme: Add tests for NVMe controller namespace
 handling

Signed-off-by: Evgeniy Kochetov <evgeniik@nvidia.com>
Change-Id: Id2d3d1a15df22512f8d0d4414b5b3d35e79149f4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6505
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 248 +++++++++++++++++-
 1 file changed, 244 insertions(+), 4 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index 9883e0855..41de5a505 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -53,6 +53,8 @@ struct nvme_driver _g_nvme_driver = {
 struct nvme_driver *g_spdk_nvme_driver = &_g_nvme_driver;
 
 struct spdk_nvme_registers g_ut_nvme_regs = {};
+typedef void (*set_reg_cb)(void);
+set_reg_cb g_set_reg_cb;
 
 __thread int    nvme_thread_ioq_index = -1;
 
@@ -107,6 +109,9 @@ nvme_transport_ctrlr_set_reg_4(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, u
 {
 	SPDK_CU_ASSERT_FATAL(offset <= sizeof(struct spdk_nvme_registers) - 4);
 	*(uint32_t *)((uintptr_t)&g_ut_nvme_regs + offset) = value;
+	if (g_set_reg_cb) {
+		g_set_reg_cb();
+	}
 	return 0;
 }
 
@@ -115,6 +120,9 @@ nvme_transport_ctrlr_set_reg_8(struct spdk_nvme_ctrlr *ctrlr, uint32_t offset, u
 {
 	SPDK_CU_ASSERT_FATAL(offset <= sizeof(struct spdk_nvme_registers) - 8);
 	*(uint64_t *)((uintptr_t)&g_ut_nvme_regs + offset) = value;
+	if (g_set_reg_cb) {
+		g_set_reg_cb();
+	}
 	return 0;
 }
 
@@ -389,18 +397,19 @@ nvme_ctrlr_cmd_set_async_event_config(struct spdk_nvme_ctrlr *ctrlr,
 
 static uint32_t *g_active_ns_list = NULL;
 static uint32_t g_active_ns_list_length = 0;
+static struct spdk_nvme_ctrlr_data *g_cdata = NULL;
 
 int
 nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cntid, uint32_t nsid,
 			uint8_t csi, void *payload, size_t payload_size,
 			spdk_nvme_cmd_cb cb_fn, void *cb_arg)
 {
+	memset(payload, 0, payload_size);
 	if (cns == SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST) {
 		uint32_t count = 0;
 		uint32_t i = 0;
 		struct spdk_nvme_ns_list *ns_list = (struct spdk_nvme_ns_list *)payload;
 
-		memset(payload, 0, payload_size);
 		if (g_active_ns_list == NULL) {
 			for (i = 1; i <= ctrlr->num_ns; i++) {
 				if (i <= nsid) {
@@ -425,7 +434,10 @@ nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cnt
 				}
 			}
 		}
-
+	} else if (cns == SPDK_NVME_IDENTIFY_CTRLR) {
+		if (g_cdata) {
+			memcpy(payload, g_cdata, sizeof(*g_cdata));
+		}
 	}
 
 	fake_cpl_sc(cb_fn, cb_arg);
@@ -466,6 +478,7 @@ int
 nvme_ctrlr_cmd_create_ns(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns_data *payload,
 			 spdk_nvme_cmd_cb cb_fn, void *cb_arg)
 {
+	fake_cpl_sc(cb_fn, cb_arg);
 	return 0;
 }
 
@@ -2068,10 +2081,12 @@ test_spdk_nvme_ctrlr_set_trid(void)
 static void
 test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 {
+	struct spdk_nvme_ctrlr_data cdata = {};
 	DECLARE_AND_CONSTRUCT_CTRLR();
 	/* equivalent of 4096 bytes */
-	ctrlr.cdata.nvmf_specific.ioccsz = 260;
-	ctrlr.cdata.nvmf_specific.icdoff = 1;
+	cdata.nvmf_specific.ioccsz = 260;
+	cdata.nvmf_specific.icdoff = 1;
+	g_cdata = &cdata;
 
 	/* Check PCI trtype, */
 	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_construct(&ctrlr) == 0);
@@ -2173,6 +2188,8 @@ test_nvme_ctrlr_init_set_nvmf_ioccsz(void)
 	CU_ASSERT(ctrlr.icdoff == 0);
 
 	nvme_ctrlr_destruct(&ctrlr);
+
+	g_cdata = NULL;
 }
 
 static void
@@ -2255,6 +2272,7 @@ test_alloc_io_qpair_fail(void)
 	/* Verify that the qpair is removed from the lists */
 	SPDK_CU_ASSERT_FATAL(TAILQ_EMPTY(&ctrlr.active_io_qpairs));
 
+	g_connect_qpair_return_code = 0;
 	cleanup_qpairs(&ctrlr);
 }
 
@@ -2599,6 +2617,224 @@ test_nvme_ctrlr_active_ns_list_v2(void)
 	g_active_ns_list_length = 0;
 }
 
+static void
+test_nvme_ctrlr_ns_mgmt(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+	uint32_t active_ns_list[] = { 1, 2, 100, 1024 };
+	uint32_t active_ns_list2[] = { 1, 2, 3, 100, 1024 };
+	struct spdk_nvme_ns_data nsdata = {};
+	struct spdk_nvme_ctrlr_list ctrlr_list = {};
+	uint32_t nsid;
+
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_construct(&ctrlr) == 0);
+
+	ctrlr.vs.bits.mjr = 1;
+	ctrlr.vs.bits.mnr = 2;
+	ctrlr.vs.bits.ter = 0;
+	ctrlr.cdata.nn = 4096;
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+	while (ctrlr.state != NVME_CTRLR_STATE_READY) {
+		SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
+
+	fake_cpl.cdw0 = 3;
+	nsid = spdk_nvme_ctrlr_create_ns(&ctrlr, &nsdata);
+	fake_cpl.cdw0 = 0;
+	CU_ASSERT(nsid == 3);
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 3));
+	CU_ASSERT(spdk_nvme_ctrlr_get_ns(&ctrlr, 3) != NULL);
+
+	g_active_ns_list = active_ns_list2;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list2);
+	CU_ASSERT(spdk_nvme_ctrlr_attach_ns(&ctrlr, 3, &ctrlr_list) == 0);
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 3));
+	CU_ASSERT(spdk_nvme_ctrlr_get_ns(&ctrlr, 3) != NULL);
+
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+	CU_ASSERT(spdk_nvme_ctrlr_detach_ns(&ctrlr, 3, &ctrlr_list) == 0);
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 3));
+	CU_ASSERT(spdk_nvme_ctrlr_get_ns(&ctrlr, 3) != NULL);
+
+	CU_ASSERT(spdk_nvme_ctrlr_delete_ns(&ctrlr, 3) == 0);
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 3));
+	CU_ASSERT(spdk_nvme_ctrlr_get_ns(&ctrlr, 3) != NULL);
+	g_active_ns_list = 0;
+	g_active_ns_list_length = 0;
+
+	nvme_ctrlr_destruct(&ctrlr);
+}
+
+static void check_en_set_rdy(void)
+{
+	if (g_ut_nvme_regs.cc.bits.en == 1) {
+		g_ut_nvme_regs.csts.bits.rdy = 1;
+	}
+}
+
+static void
+test_nvme_ctrlr_reset(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+	struct spdk_nvme_ctrlr_data cdata = { .nn = 4096 };
+	uint32_t active_ns_list[] = { 1, 2, 100, 1024 };
+	uint32_t active_ns_list2[] = { 1, 100, 1024 };
+
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_construct(&ctrlr) == 0);
+
+	ctrlr.vs.bits.mjr = 1;
+	ctrlr.vs.bits.mnr = 2;
+	ctrlr.vs.bits.ter = 0;
+	ctrlr.cdata.nn = 2048;
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+	while (ctrlr.state != NVME_CTRLR_STATE_READY) {
+		SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
+	CU_ASSERT(spdk_nvme_ctrlr_get_num_ns(&ctrlr) == 2048);
+	CU_ASSERT(spdk_nvme_ctrlr_get_ns(&ctrlr, 2) != NULL);
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 2));
+
+	/* Reset controller with changed number of namespaces */
+	g_cdata = &cdata;
+	g_active_ns_list = active_ns_list2;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list2);
+	STAILQ_INSERT_HEAD(&adminq.free_req, &req, stailq);
+	memset(&g_ut_nvme_regs, 0, sizeof(g_ut_nvme_regs));
+	g_set_reg_cb = check_en_set_rdy;
+	CU_ASSERT(spdk_nvme_ctrlr_reset(&ctrlr) == 0);
+	g_set_reg_cb = NULL;
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_READY);
+	g_cdata = NULL;
+	g_active_ns_list = 0;
+	g_active_ns_list_length = 0;
+
+	CU_ASSERT(spdk_nvme_ctrlr_get_num_ns(&ctrlr) == 4096);
+	CU_ASSERT(spdk_nvme_ctrlr_get_ns(&ctrlr, 2) != NULL);
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 2));
+
+	g_ut_nvme_regs.csts.bits.shst = SPDK_NVME_SHST_COMPLETE;
+	nvme_ctrlr_destruct(&ctrlr);
+}
+
+static uint32_t g_aer_cb_counter;
+
+static void
+aer_cb(void *aer_cb_arg, const struct spdk_nvme_cpl *cpl)
+{
+	g_aer_cb_counter++;
+}
+
+static void
+test_nvme_ctrlr_aer_callback(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+	uint32_t active_ns_list[] = { 1, 2, 100, 1024 };
+	union spdk_nvme_async_event_completion	aer_event = {
+		.bits.async_event_type = SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE,
+		.bits.async_event_info = SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED
+	};
+	struct spdk_nvme_cpl aer_cpl = {
+		.status.sct = SPDK_NVME_SCT_GENERIC,
+		.status.sc = SPDK_NVME_SC_SUCCESS,
+		.cdw0 = aer_event.raw
+	};
+
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_construct(&ctrlr) == 0);
+
+	ctrlr.vs.bits.mjr = 1;
+	ctrlr.vs.bits.mnr = 2;
+	ctrlr.vs.bits.ter = 0;
+	ctrlr.cdata.nn = 4096;
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+	while (ctrlr.state != NVME_CTRLR_STATE_READY) {
+		SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
+
+	CU_ASSERT(nvme_ctrlr_add_process(&ctrlr, NULL) == 0);
+	spdk_nvme_ctrlr_register_aer_callback(&ctrlr, aer_cb, NULL);
+
+	/* Async event */
+	g_aer_cb_counter = 0;
+	nvme_ctrlr_async_event_cb(&ctrlr.aer[0], &aer_cpl);
+	nvme_ctrlr_complete_queued_async_events(&ctrlr);
+	CU_ASSERT(g_aer_cb_counter == 1);
+	g_active_ns_list = 0;
+	g_active_ns_list_length = 0;
+
+	nvme_ctrlr_free_processes(&ctrlr);
+	nvme_ctrlr_destruct(&ctrlr);
+}
+
+static void
+test_nvme_ctrlr_ns_attr_changed(void)
+{
+	DECLARE_AND_CONSTRUCT_CTRLR();
+	uint32_t active_ns_list[] = { 1, 2, 100, 1024 };
+	uint32_t active_ns_list2[] = { 1, 2, 1024 };
+	uint32_t active_ns_list3[] = { 1, 2, 101, 1024 };
+	union spdk_nvme_async_event_completion	aer_event = {
+		.bits.async_event_type = SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE,
+		.bits.async_event_info = SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED
+	};
+	struct spdk_nvme_cpl aer_cpl = {
+		.status.sct = SPDK_NVME_SCT_GENERIC,
+		.status.sc = SPDK_NVME_SC_SUCCESS,
+		.cdw0 = aer_event.raw
+	};
+
+	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_construct(&ctrlr) == 0);
+
+	ctrlr.vs.bits.mjr = 1;
+	ctrlr.vs.bits.mnr = 3;
+	ctrlr.vs.bits.ter = 0;
+	ctrlr.cap.bits.css |= SPDK_NVME_CAP_CSS_IOCS;
+	ctrlr.cdata.nn = 4096;
+
+	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
+	g_active_ns_list = active_ns_list;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list);
+	while (ctrlr.state != NVME_CTRLR_STATE_READY) {
+		SPDK_CU_ASSERT_FATAL(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
+
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 100));
+
+	CU_ASSERT(nvme_ctrlr_add_process(&ctrlr, NULL) == 0);
+	spdk_nvme_ctrlr_register_aer_callback(&ctrlr, aer_cb, NULL);
+
+	/* Remove NS 100 */
+	g_aer_cb_counter = 0;
+	g_active_ns_list = active_ns_list2;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list2);
+	nvme_ctrlr_async_event_cb(&ctrlr.aer[0], &aer_cpl);
+	nvme_ctrlr_complete_queued_async_events(&ctrlr);
+	CU_ASSERT(g_aer_cb_counter == 1);
+	CU_ASSERT(!spdk_nvme_ctrlr_is_active_ns(&ctrlr, 100));
+
+	/* Add NS 101 */
+	g_active_ns_list = active_ns_list3;
+	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list3);
+	nvme_ctrlr_async_event_cb(&ctrlr.aer[0], &aer_cpl);
+	nvme_ctrlr_complete_queued_async_events(&ctrlr);
+	CU_ASSERT(g_aer_cb_counter == 2);
+	CU_ASSERT(spdk_nvme_ctrlr_is_active_ns(&ctrlr, 101));
+
+	g_active_ns_list = 0;
+	g_active_ns_list_length = 0;
+	nvme_ctrlr_free_processes(&ctrlr);
+	nvme_ctrlr_destruct(&ctrlr);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -2645,6 +2881,10 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_ctrlr_set_state);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_active_ns_list_v0);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_active_ns_list_v2);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_ns_mgmt);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_reset);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_aer_callback);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_ns_attr_changed);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 103f5c62f5f02f88c73fde2a8c5619518f5ff8cc Mon Sep 17 00:00:00 2001
From: Alexey Marchuk <alexeymar@mellanox.com>
Date: Fri, 14 May 2021 15:14:01 +0300
Subject: [PATCH 184/342] nvmf: Remove qpair from poll group when it is deleted

That prevents nvmf target from starting to destroy poll
groups prematurely

Signed-off-by: Alexey Marchuk <alexeymar@mellanox.com>
Change-Id: I833f6198ef0e3083fdadf70dd3b62844c905aceb
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7881
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/nvmf/nvmf.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/nvmf/nvmf.c b/lib/nvmf/nvmf.c
index a04beee78..d1ebe2331 100644
--- a/lib/nvmf/nvmf.c
+++ b/lib/nvmf/nvmf.c
@@ -929,6 +929,7 @@ _nvmf_transport_qpair_fini(void *ctx)
 {
 	struct nvmf_qpair_disconnect_ctx *qpair_ctx = ctx;
 
+	spdk_nvmf_poll_group_remove(qpair_ctx->qpair);
 	nvmf_transport_qpair_fini(qpair_ctx->qpair, _nvmf_transport_qpair_fini_complete, qpair_ctx);
 }
 
@@ -998,9 +999,8 @@ _nvmf_qpair_destroy(void *ctx, int status)
 	assert(qpair->state == SPDK_NVMF_QPAIR_DEACTIVATING);
 	qpair_ctx->qid = qpair->qid;
 
-	spdk_nvmf_poll_group_remove(qpair);
-
 	if (!ctrlr || !ctrlr->thread) {
+		spdk_nvmf_poll_group_remove(qpair);
 		nvmf_transport_qpair_fini(qpair, _nvmf_transport_qpair_fini_complete, qpair_ctx);
 		return;
 	}
-- 
2.26.2


From 5cc565999ecd48bdd7d8fa0395437b7f6f090875 Mon Sep 17 00:00:00 2001
From: yupeng <yupeng0921@gmail.com>
Date: Sun, 16 May 2021 10:45:11 +0000
Subject: [PATCH 185/342] nvmf: support NVME ACRE feature

Support ACRE (Advanced Command Retry Enable) feature. Currently set
all crdt to 0 and only select crdt[0] (crd=1) when the IO has any
error.

Signed-off-by: Peng Yu <yupeng0921@gmail.com>
Change-Id: If7bc30f91f5b2d0839002dead17188a4b3a52d5d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7885
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvmf/ctrlr.c         | 56 ++++++++++++++++++++++++++++++++++++++++
 lib/nvmf/nvmf_internal.h |  1 +
 2 files changed, 57 insertions(+)

diff --git a/lib/nvmf/ctrlr.c b/lib/nvmf/ctrlr.c
index bcef8de6a..763e9251a 100644
--- a/lib/nvmf/ctrlr.c
+++ b/lib/nvmf/ctrlr.c
@@ -1589,6 +1589,41 @@ nvmf_ctrlr_set_features_reservation_persistence(struct spdk_nvmf_request *req)
 	return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
 }
 
+static int
+nvmf_ctrlr_set_features_host_behavior_support(struct spdk_nvmf_request *req)
+{
+	struct spdk_nvmf_ctrlr *ctrlr = req->qpair->ctrlr;
+	struct spdk_nvme_cpl *response = &req->rsp->nvme_cpl;
+	struct spdk_nvme_host_behavior *host_behavior;
+
+	SPDK_DEBUGLOG(nvmf, "Set Features - Host Behavior Support\n");
+	if (req->iovcnt != 1) {
+		SPDK_ERRLOG("Host Behavior Support invalid iovcnt: %d\n", req->iovcnt);
+		response->status.sct = SPDK_NVME_SCT_GENERIC;
+		response->status.sc = SPDK_NVME_SC_INVALID_FIELD;
+		return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
+	}
+	if (req->iov[0].iov_len != sizeof(struct spdk_nvme_host_behavior)) {
+		SPDK_ERRLOG("Host Behavior Support invalid iov_len: %ld\n", req->iov[0].iov_len);
+		response->status.sct = SPDK_NVME_SCT_GENERIC;
+		response->status.sc = SPDK_NVME_SC_INVALID_FIELD;
+		return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
+	}
+
+	host_behavior = (struct spdk_nvme_host_behavior *)req->iov[0].iov_base;
+	if (host_behavior->acre == 0) {
+		ctrlr->acre_enabled = false;
+	} else if (host_behavior->acre == 1) {
+		ctrlr->acre_enabled = true;
+	} else {
+		SPDK_ERRLOG("Host Behavior Support invalid acre: 0x%02x\n", host_behavior->acre);
+		response->status.sct = SPDK_NVME_SCT_GENERIC;
+		response->status.sc = SPDK_NVME_SC_INVALID_FIELD;
+		return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
+	}
+	return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
+}
+
 static int
 nvmf_ctrlr_set_features_keep_alive_timer(struct spdk_nvmf_request *req)
 {
@@ -2249,6 +2284,14 @@ spdk_nvmf_ctrlr_identify_ctrlr(struct spdk_nvmf_ctrlr *ctrlr, struct spdk_nvme_c
 
 		nvmf_ctrlr_populate_oacs(ctrlr, cdata);
 
+		/*
+		 * FIXME: Set all crdt to 0 currently,
+		 * will provide an API to customize them later.
+		 */
+		cdata->crdt[0] = 0;
+		cdata->crdt[1] = 0;
+		cdata->crdt[2] = 0;
+
 		SPDK_DEBUGLOG(nvmf, "ext ctrlr data: ioccsz 0x%x\n",
 			      cdata->nvmf_specific.ioccsz);
 		SPDK_DEBUGLOG(nvmf, "ext ctrlr data: iorcsz 0x%x\n",
@@ -2742,6 +2785,8 @@ nvmf_ctrlr_set_features(struct spdk_nvmf_request *req)
 		return nvmf_ctrlr_set_features_reservation_notification_mask(req);
 	case SPDK_NVME_FEAT_HOST_RESERVE_PERSIST:
 		return nvmf_ctrlr_set_features_reservation_persistence(req);
+	case SPDK_NVME_FEAT_HOST_BEHAVIOR_SUPPORT:
+		return nvmf_ctrlr_set_features_host_behavior_support(req);
 	default:
 		SPDK_ERRLOG("Set Features command with unsupported feature ID 0x%02x\n", feature);
 		response->status.sc = SPDK_NVME_SC_INVALID_FIELD;
@@ -3490,6 +3535,17 @@ _nvmf_request_complete(void *ctx)
 		sgroup = &qpair->group->sgroups[qpair->ctrlr->subsys->id];
 		assert(sgroup != NULL);
 		is_aer = req->cmd->nvme_cmd.opc == SPDK_NVME_OPC_ASYNC_EVENT_REQUEST;
+
+		/*
+		 * Set the crd value.
+		 * If the the IO has any error, and dnr (DoNotRetry) is not 1,
+		 * and ACRE is enabled, we will set the crd to 1 to select the first CRDT.
+		 */
+		if (spdk_nvme_cpl_is_error(rsp) &&
+		    rsp->status.dnr == 0 &&
+		    qpair->ctrlr->acre_enabled) {
+			rsp->status.crd = 1;
+		}
 	} else if (spdk_unlikely(nvmf_request_is_fabric_connect(req))) {
 		sgroup = nvmf_subsystem_pg_from_connect_cmd(req);
 	}
diff --git a/lib/nvmf/nvmf_internal.h b/lib/nvmf/nvmf_internal.h
index 9c6510305..8e300429a 100644
--- a/lib/nvmf/nvmf_internal.h
+++ b/lib/nvmf/nvmf_internal.h
@@ -261,6 +261,7 @@ struct spdk_nvmf_ctrlr {
 	bool				dif_insert_or_strip;
 	bool				in_destruct;
 	bool				disconnect_in_progress;
+	bool				acre_enabled;
 
 	TAILQ_ENTRY(spdk_nvmf_ctrlr)	link;
 };
-- 
2.26.2


From 3703ebc71055939570ac03f1ec9009640c9124eb Mon Sep 17 00:00:00 2001
From: Maciej Szwed <maciej.szwed@intel.com>
Date: Wed, 12 May 2021 11:22:31 +0200
Subject: [PATCH 186/342] doc: Add information about shutdown_cb

Fixes GH 1539

Signed-off-by: Maciej Szwed <maciej.szwed@intel.com>
Change-Id: I5256a53c619b13951382fcc0439a157aa29b61aa
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7859
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 doc/event.md | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/doc/event.md b/doc/event.md
index 657ca93e1..c0eb975e3 100644
--- a/doc/event.md
+++ b/doc/event.md
@@ -73,3 +73,11 @@ spdk_app_start() is called, it will block the current thread until the applicati
 terminates by calling spdk_app_stop() or an error condition occurs during the
 initialization code within spdk_app_start(), itself, before invoking the caller's
 supplied function.
+
+## Custom shutdown callback {#event_component_shutdown}
+
+When creating SPDK based application user may add custom shutdown callback which
+will be called before the application framework starts the shutdown process.
+To do that set shutdown_cb function callback in spdk_app_opts structure passed
+to spdk_app_start(). Custom shutdown callback should call spdk_app_stop() before
+returning to continue application shutdown process.
-- 
2.26.2


From b73d3e6894102c51188aea371382a60cb7caaae7 Mon Sep 17 00:00:00 2001
From: Krishna Kanth Reddy <krish.reddy@samsung.com>
Date: Thu, 20 May 2021 14:08:56 +0530
Subject: [PATCH 187/342] test/nvme: Simple Copy Command takes nlb as a 0's
 based value

Signed-off-by: Krishna Kanth Reddy <krish.reddy@samsung.com>
Change-Id: I10a33d6478ce10fd2786c8eca2f179a9809764dc
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7973
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 test/nvme/simple_copy/simple_copy.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/nvme/simple_copy/simple_copy.c b/test/nvme/simple_copy/simple_copy.c
index 0f96c65c0..585833647 100644
--- a/test/nvme/simple_copy/simple_copy.c
+++ b/test/nvme/simple_copy/simple_copy.c
@@ -266,7 +266,7 @@ simple_copy_test(void)
 			exit(1);
 		}
 
-		range.nlb = NUM_LBAS;
+		range.nlb = NUM_LBAS - 1;
 		range.slba = 0;
 
 		rc = spdk_nvme_ns_cmd_copy(ns_entry->ns, ns_entry->qpair,
-- 
2.26.2


From c41508b7e22afa7d2aff019b43e8e035d1b33392 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@nutanix.com>
Date: Thu, 20 May 2021 19:33:15 +0100
Subject: [PATCH 188/342] libvfio-user: update submodule

Update libvfio-user to the current version, updating the client for the relevant
changes.

Signed-off-by: John Levon <john.levon@nutanix.com>
Change-Id: Ic64ace08ac0c7e9676f04f8d1f47a9c0388a2652
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7983
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk/vfio_user_spec.h | 3 ++-
 lib/vfio_user/vfio_user.c     | 2 +-
 libvfio-user                  | 2 +-
 3 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/include/spdk/vfio_user_spec.h b/include/spdk/vfio_user_spec.h
index 1da127b98..9c2ee4bef 100644
--- a/include/spdk/vfio_user_spec.h
+++ b/include/spdk/vfio_user_spec.h
@@ -50,6 +50,7 @@ enum vfio_user_command {
 	VFIO_USER_DMA_WRITE			= 11,
 	VFIO_USER_VM_INTERRUPT			= 12,
 	VFIO_USER_DEVICE_RESET			= 13,
+	VFIO_USER_DIRTY_PAGES			= 14,
 	VFIO_USER_MAX,
 };
 
@@ -107,7 +108,7 @@ struct vfio_user_region_access {
 
 struct vfio_user_dma_region_access {
 	uint64_t    addr;
-	uint32_t    count;
+	uint64_t    count;
 	uint8_t     data[];
 } __attribute__((packed));
 
diff --git a/lib/vfio_user/vfio_user.c b/lib/vfio_user/vfio_user.c
index 53f297001..eed6c1576 100644
--- a/lib/vfio_user/vfio_user.c
+++ b/lib/vfio_user/vfio_user.c
@@ -296,7 +296,7 @@ vfio_user_get_dev_info(struct vfio_device *dev, struct vfio_user_device_info *de
 int
 vfio_user_dev_dma_map_unmap(struct vfio_device *dev, struct vfio_memory_region *mr, bool map)
 {
-	struct vfio_user_dma_region region;
+	struct vfio_user_dma_region region = { 0 };
 
 	region.addr = mr->iova;
 	region.size = mr->size;
diff --git a/libvfio-user b/libvfio-user
index 702a4cad4..cfe990191 160000
--- a/libvfio-user
+++ b/libvfio-user
@@ -1 +1 @@
-Subproject commit 702a4cad49c40406ff498e0da4a80c6d07b4fc83
+Subproject commit cfe9901919943f14961e1da1c4a823336ff79555
-- 
2.26.2


From b2c0e3761bf4524fdb090f705e86a8cb976afe68 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Thu, 13 May 2021 11:38:11 +0900
Subject: [PATCH 189/342] bdev/nvme: Consolidate exit paths of get_buf_cb()

I/Os will be retried if spdk_bdev_io_complete() is called with
SPDK_BDEV_IO_STATUS_FAILED. To do it easier, consolidate exit paths
of bdev_nvme_get_buf_cb().

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I0a67b88a107d616c5a5b0fc5ff963ad1402f5651
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7487
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/nvme/bdev_nvme.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 071fcba4e..4154b4af0 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -707,13 +707,13 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 	int ret;
 
 	if (!success) {
-		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
-		return;
+		ret = -EINVAL;
+		goto exit;
 	}
 
 	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair))) {
-		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
-		return;
+		ret = -ENXIO;
+		goto exit;
 	}
 
 	ret = bdev_nvme_readv(nvme_ns->ns,
@@ -726,6 +726,7 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 			      bdev_io->u.bdev.offset_blocks,
 			      bdev->dif_check_flags);
 
+exit:
 	if (spdk_likely(ret == 0)) {
 		return;
 	} else if (ret == -ENOMEM) {
-- 
2.26.2


From 5a6cd5b31c0ac967dae66ab960e5629f9f11ab2d Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Thu, 13 May 2021 11:09:53 +0900
Subject: [PATCH 190/342] bdev/nvme: Inline _bdev_nvme_submit_request()

This is called only in a place. Inlining this into bdev_nvme_submit_request()
will simplify the following patches by removing unnecessary cast.

Besides, use -ENXIO if I/O path is not found. This will be better than -1.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ib6c38f89db1c1e651941aad18d31dd0891f380de
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7871
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/nvme/bdev_nvme.c | 213 +++++++++++++++++------------------
 1 file changed, 105 insertions(+), 108 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 4154b4af0..b82ea804d 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -736,8 +736,8 @@ exit:
 	}
 }
 
-static int
-_bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
+static void
+bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
 	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
 	struct spdk_bdev *bdev = bdev_io->bdev;
@@ -746,31 +746,44 @@ _bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_
 	struct nvme_bdev_io *nbdev_io_to_abort;
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
+	int rc = 0;
 
 	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair))) {
-		return -1;
+		rc = -ENXIO;
+		goto exit;
 	}
 
 	switch (bdev_io->type) {
 	case SPDK_BDEV_IO_TYPE_READ:
 		if (bdev_io->u.bdev.iovs && bdev_io->u.bdev.iovs[0].iov_base) {
-			return bdev_nvme_readv(nvme_ns->ns,
-					       qpair,
-					       nbdev_io,
-					       bdev_io->u.bdev.iovs,
-					       bdev_io->u.bdev.iovcnt,
-					       bdev_io->u.bdev.md_buf,
-					       bdev_io->u.bdev.num_blocks,
-					       bdev_io->u.bdev.offset_blocks,
-					       bdev->dif_check_flags);
+			rc = bdev_nvme_readv(nvme_ns->ns,
+					     qpair,
+					     nbdev_io,
+					     bdev_io->u.bdev.iovs,
+					     bdev_io->u.bdev.iovcnt,
+					     bdev_io->u.bdev.md_buf,
+					     bdev_io->u.bdev.num_blocks,
+					     bdev_io->u.bdev.offset_blocks,
+					     bdev->dif_check_flags);
 		} else {
 			spdk_bdev_io_get_buf(bdev_io, bdev_nvme_get_buf_cb,
 					     bdev_io->u.bdev.num_blocks * bdev->blocklen);
-			return 0;
+			rc = 0;
 		}
-
+		break;
 	case SPDK_BDEV_IO_TYPE_WRITE:
-		return bdev_nvme_writev(nvme_ns->ns,
+		rc = bdev_nvme_writev(nvme_ns->ns,
+				      qpair,
+				      nbdev_io,
+				      bdev_io->u.bdev.iovs,
+				      bdev_io->u.bdev.iovcnt,
+				      bdev_io->u.bdev.md_buf,
+				      bdev_io->u.bdev.num_blocks,
+				      bdev_io->u.bdev.offset_blocks,
+				      bdev->dif_check_flags);
+		break;
+	case SPDK_BDEV_IO_TYPE_COMPARE:
+		rc = bdev_nvme_comparev(nvme_ns->ns,
 					qpair,
 					nbdev_io,
 					bdev_io->u.bdev.iovs,
@@ -779,116 +792,100 @@ _bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_
 					bdev_io->u.bdev.num_blocks,
 					bdev_io->u.bdev.offset_blocks,
 					bdev->dif_check_flags);
-
-	case SPDK_BDEV_IO_TYPE_COMPARE:
-		return bdev_nvme_comparev(nvme_ns->ns,
-					  qpair,
-					  nbdev_io,
-					  bdev_io->u.bdev.iovs,
-					  bdev_io->u.bdev.iovcnt,
-					  bdev_io->u.bdev.md_buf,
-					  bdev_io->u.bdev.num_blocks,
-					  bdev_io->u.bdev.offset_blocks,
-					  bdev->dif_check_flags);
-
+		break;
 	case SPDK_BDEV_IO_TYPE_COMPARE_AND_WRITE:
-		return bdev_nvme_comparev_and_writev(nvme_ns->ns,
-						     qpair,
-						     nbdev_io,
-						     bdev_io->u.bdev.iovs,
-						     bdev_io->u.bdev.iovcnt,
-						     bdev_io->u.bdev.fused_iovs,
-						     bdev_io->u.bdev.fused_iovcnt,
-						     bdev_io->u.bdev.md_buf,
-						     bdev_io->u.bdev.num_blocks,
-						     bdev_io->u.bdev.offset_blocks,
-						     bdev->dif_check_flags);
-
+		rc = bdev_nvme_comparev_and_writev(nvme_ns->ns,
+						   qpair,
+						   nbdev_io,
+						   bdev_io->u.bdev.iovs,
+						   bdev_io->u.bdev.iovcnt,
+						   bdev_io->u.bdev.fused_iovs,
+						   bdev_io->u.bdev.fused_iovcnt,
+						   bdev_io->u.bdev.md_buf,
+						   bdev_io->u.bdev.num_blocks,
+						   bdev_io->u.bdev.offset_blocks,
+						   bdev->dif_check_flags);
+		break;
 	case SPDK_BDEV_IO_TYPE_UNMAP:
-		return bdev_nvme_unmap(nvme_ns->ns,
-				       qpair,
-				       nbdev_io,
-				       bdev_io->u.bdev.offset_blocks,
-				       bdev_io->u.bdev.num_blocks);
-
+		rc = bdev_nvme_unmap(nvme_ns->ns,
+				     qpair,
+				     nbdev_io,
+				     bdev_io->u.bdev.offset_blocks,
+				     bdev_io->u.bdev.num_blocks);
+		break;
 	case SPDK_BDEV_IO_TYPE_RESET:
-		return bdev_nvme_reset(nvme_ch, nbdev_io);
-
+		rc = bdev_nvme_reset(nvme_ch, nbdev_io);
+		break;
 	case SPDK_BDEV_IO_TYPE_FLUSH:
-		return bdev_nvme_flush(nvme_ns->ns,
-				       qpair,
-				       nbdev_io,
-				       bdev_io->u.bdev.offset_blocks,
-				       bdev_io->u.bdev.num_blocks);
-
+		rc = bdev_nvme_flush(nvme_ns->ns,
+				     qpair,
+				     nbdev_io,
+				     bdev_io->u.bdev.offset_blocks,
+				     bdev_io->u.bdev.num_blocks);
+		break;
 	case SPDK_BDEV_IO_TYPE_ZONE_APPEND:
-		return bdev_nvme_zone_appendv(nvme_ns->ns,
-					      qpair,
-					      nbdev_io,
-					      bdev_io->u.bdev.iovs,
-					      bdev_io->u.bdev.iovcnt,
-					      bdev_io->u.bdev.md_buf,
-					      bdev_io->u.bdev.num_blocks,
-					      bdev_io->u.bdev.offset_blocks,
-					      bdev->dif_check_flags);
-
+		rc = bdev_nvme_zone_appendv(nvme_ns->ns,
+					    qpair,
+					    nbdev_io,
+					    bdev_io->u.bdev.iovs,
+					    bdev_io->u.bdev.iovcnt,
+					    bdev_io->u.bdev.md_buf,
+					    bdev_io->u.bdev.num_blocks,
+					    bdev_io->u.bdev.offset_blocks,
+					    bdev->dif_check_flags);
+		break;
 	case SPDK_BDEV_IO_TYPE_GET_ZONE_INFO:
-		return bdev_nvme_get_zone_info(nvme_ns->ns,
+		rc = bdev_nvme_get_zone_info(nvme_ns->ns,
+					     qpair,
+					     nbdev_io,
+					     bdev_io->u.zone_mgmt.zone_id,
+					     bdev_io->u.zone_mgmt.num_zones,
+					     bdev_io->u.zone_mgmt.buf);
+		break;
+	case SPDK_BDEV_IO_TYPE_ZONE_MANAGEMENT:
+		rc = bdev_nvme_zone_management(nvme_ns->ns,
 					       qpair,
 					       nbdev_io,
 					       bdev_io->u.zone_mgmt.zone_id,
-					       bdev_io->u.zone_mgmt.num_zones,
-					       bdev_io->u.zone_mgmt.buf);
-
-	case SPDK_BDEV_IO_TYPE_ZONE_MANAGEMENT:
-		return bdev_nvme_zone_management(nvme_ns->ns,
-						 qpair,
-						 nbdev_io,
-						 bdev_io->u.zone_mgmt.zone_id,
-						 bdev_io->u.zone_mgmt.zone_action);
-
+					       bdev_io->u.zone_mgmt.zone_action);
+		break;
 	case SPDK_BDEV_IO_TYPE_NVME_ADMIN:
-		return bdev_nvme_admin_passthru(nvme_ch,
-						nbdev_io,
-						&bdev_io->u.nvme_passthru.cmd,
-						bdev_io->u.nvme_passthru.buf,
-						bdev_io->u.nvme_passthru.nbytes);
-
+		rc = bdev_nvme_admin_passthru(nvme_ch,
+					      nbdev_io,
+					      &bdev_io->u.nvme_passthru.cmd,
+					      bdev_io->u.nvme_passthru.buf,
+					      bdev_io->u.nvme_passthru.nbytes);
+		break;
 	case SPDK_BDEV_IO_TYPE_NVME_IO:
-		return bdev_nvme_io_passthru(nvme_ns->ns,
-					     qpair,
-					     nbdev_io,
-					     &bdev_io->u.nvme_passthru.cmd,
-					     bdev_io->u.nvme_passthru.buf,
-					     bdev_io->u.nvme_passthru.nbytes);
-
+		rc = bdev_nvme_io_passthru(nvme_ns->ns,
+					   qpair,
+					   nbdev_io,
+					   &bdev_io->u.nvme_passthru.cmd,
+					   bdev_io->u.nvme_passthru.buf,
+					   bdev_io->u.nvme_passthru.nbytes);
+		break;
 	case SPDK_BDEV_IO_TYPE_NVME_IO_MD:
-		return bdev_nvme_io_passthru_md(nvme_ns->ns,
-						qpair,
-						nbdev_io,
-						&bdev_io->u.nvme_passthru.cmd,
-						bdev_io->u.nvme_passthru.buf,
-						bdev_io->u.nvme_passthru.nbytes,
-						bdev_io->u.nvme_passthru.md_buf,
-						bdev_io->u.nvme_passthru.md_len);
-
+		rc = bdev_nvme_io_passthru_md(nvme_ns->ns,
+					      qpair,
+					      nbdev_io,
+					      &bdev_io->u.nvme_passthru.cmd,
+					      bdev_io->u.nvme_passthru.buf,
+					      bdev_io->u.nvme_passthru.nbytes,
+					      bdev_io->u.nvme_passthru.md_buf,
+					      bdev_io->u.nvme_passthru.md_len);
+		break;
 	case SPDK_BDEV_IO_TYPE_ABORT:
 		nbdev_io_to_abort = (struct nvme_bdev_io *)bdev_io->u.abort.bio_to_abort->driver_ctx;
-		return bdev_nvme_abort(nvme_ch,
-				       nbdev_io,
-				       nbdev_io_to_abort);
-
+		rc = bdev_nvme_abort(nvme_ch,
+				     nbdev_io,
+				     nbdev_io_to_abort);
+		break;
 	default:
-		return -EINVAL;
+		rc = -EINVAL;
+		break;
 	}
-	return 0;
-}
-
-static void
-bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
-{
-	int rc = _bdev_nvme_submit_request(ch, bdev_io);
 
+exit:
 	if (spdk_unlikely(rc != 0)) {
 		if (rc == -ENOMEM) {
 			spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_NOMEM);
-- 
2.26.2


From 30d17fff30cc8976fe6907f789245a6ca26fe60c Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 11 May 2021 03:54:36 +0900
Subject: [PATCH 191/342] bdev/nvme: Delegate processing -EBUSY of
 bdev_nvme_reset() to its caller

bdev_nvme_submit_request() calls spdk_bdev_io_complete() with failed
if bdev_nvme_reset() returns negated rc other than -ENOMEM.

So let bdev_nvme_submit_request() process it.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I2569634ff0f18fb433cb685de1366e43abf5a9fe
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7524
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/nvme/bdev_nvme.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index b82ea804d..f50a50fd9 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -595,9 +595,6 @@ bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio)
 	if (rc == 0) {
 		assert(nvme_ch->ctrlr->reset_bio == NULL);
 		nvme_ch->ctrlr->reset_bio = bio;
-	} else if (rc == -EBUSY) {
-		/* Don't bother resetting if the controller is in the process of being destructed. */
-		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 	} else if (rc == -EAGAIN) {
 		/*
 		 * Reset call is queued only if it is from the app framework. This is on purpose so that
-- 
2.26.2


From e4ec38c33638664f5e4426d0e2d9238cced5b030 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Thu, 13 May 2021 05:56:42 +0900
Subject: [PATCH 192/342] bdev/nvme: Factor out
 spdk_bdev_io_complete_nvme_status() calls into a helper function

Factor out spdk_bdev_io_complete_nvme_status() calls into a helper
function bdev_nvme_io_complete_nvme_status().

This simplifies the code a little and will be helpful for the following
patches to retry I/Os. Specify inline explicitly to avoid performance
regression.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I1ac451486e1c6a4401842490411e986fac191d59
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7484
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/bdev/nvme/bdev_nvme.c | 49 +++++++++++++++++++++---------------
 1 file changed, 29 insertions(+), 20 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index f50a50fd9..bb1c8f056 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -251,6 +251,16 @@ static struct spdk_bdev_module nvme_if = {
 };
 SPDK_BDEV_MODULE_REGISTER(nvme, &nvme_if)
 
+static inline void
+bdev_nvme_io_complete_nvme_status(struct nvme_bdev_io *bio,
+				  const struct spdk_nvme_cpl *cpl)
+{
+	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
+
+	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct,
+					  cpl->status.sc);
+}
+
 static void
 bdev_nvme_disconnected_qpair_cb(struct spdk_nvme_qpair *qpair, void *poll_group_ctx)
 {
@@ -2485,8 +2495,7 @@ bdev_nvme_no_pi_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	}
 
 	/* Return original completion status */
-	spdk_bdev_io_complete_nvme_status(bdev_io, bio->cpl.cdw0, bio->cpl.status.sct,
-					  bio->cpl.status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, &bio->cpl);
 }
 
 static void
@@ -2525,13 +2534,14 @@ bdev_nvme_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		}
 	}
 
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 }
 
 static void
 bdev_nvme_writev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx((struct nvme_bdev_io *)ref);
+	struct nvme_bdev_io *bio = ref;
+	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	if (spdk_nvme_cpl_is_pi_error(cpl)) {
 		SPDK_ERRLOG("writev completed with PI error (sct=%d, sc=%d)\n",
@@ -2540,13 +2550,14 @@ bdev_nvme_writev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		bdev_nvme_verify_pi_error(bdev_io);
 	}
 
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 }
 
 static void
 bdev_nvme_zone_appendv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx((struct nvme_bdev_io *)ref);
+	struct nvme_bdev_io *bio = ref;
+	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	/* spdk_bdev_io_get_append_location() requires that the ALBA is stored in offset_blocks.
 	 * Additionally, offset_blocks has to be set before calling bdev_nvme_verify_pi_error().
@@ -2560,13 +2571,14 @@ bdev_nvme_zone_appendv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		bdev_nvme_verify_pi_error(bdev_io);
 	}
 
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 }
 
 static void
 bdev_nvme_comparev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx((struct nvme_bdev_io *)ref);
+	struct nvme_bdev_io *bio = ref;
+	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	if (spdk_nvme_cpl_is_pi_error(cpl)) {
 		SPDK_ERRLOG("comparev completed with PI error (sct=%d, sc=%d)\n",
@@ -2575,14 +2587,13 @@ bdev_nvme_comparev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		bdev_nvme_verify_pi_error(bdev_io);
 	}
 
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 }
 
 static void
 bdev_nvme_comparev_and_writev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
 	struct nvme_bdev_io *bio = ref;
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	/* Compare operation completion */
 	if ((cpl->cdw0 & 0xFF) == SPDK_NVME_OPC_COMPARE) {
@@ -2600,18 +2611,18 @@ bdev_nvme_comparev_and_writev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 			SPDK_ERRLOG("Unexpected write success after compare failure.\n");
 		}
 
-		spdk_bdev_io_complete_nvme_status(bdev_io, bio->cpl.cdw0, bio->cpl.status.sct, bio->cpl.status.sc);
+		bdev_nvme_io_complete_nvme_status(bio, &bio->cpl);
 	} else {
-		spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+		bdev_nvme_io_complete_nvme_status(bio, cpl);
 	}
 }
 
 static void
 bdev_nvme_queued_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx((struct nvme_bdev_io *)ref);
+	struct nvme_bdev_io *bio = ref;
 
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 }
 
 static int
@@ -2725,7 +2736,7 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 out_complete_io_nvme_cpl:
 	free(bio->zone_report_buf);
 	bio->zone_report_buf = NULL;
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 	return;
 
 out_complete_io_status:
@@ -2737,19 +2748,17 @@ out_complete_io_status:
 static void
 bdev_nvme_zone_management_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx((struct nvme_bdev_io *)ref);
+	struct nvme_bdev_io *bio = ref;
 
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct, cpl->status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, cpl);
 }
 
 static void
 bdev_nvme_admin_passthru_completion(void *ctx)
 {
 	struct nvme_bdev_io *bio = ctx;
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
-	spdk_bdev_io_complete_nvme_status(bdev_io,
-					  bio->cpl.cdw0, bio->cpl.status.sct, bio->cpl.status.sc);
+	bdev_nvme_io_complete_nvme_status(bio, &bio->cpl);
 }
 
 static void
-- 
2.26.2


From 81b4379cd8d6f9ea3908afee868e5b5a8cd0ec53 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 21 Apr 2021 07:54:59 +0900
Subject: [PATCH 193/342] bdev/nvme: Factor out spdk_bdev_io_complete() calls
 into a helper function

Factor out spdk_bdev_io_complete() calls into a helper function
bdev_nvme_io_complete().

This simplifies the code a little and will be helpful for the following
patches to retry I/Os. These are not performance critical but we
specify inline explicitly by following bdev_nvme_io_complete_nvme_status().

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I9fafacfd8571c037c3bc34382c251317309da334
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7497
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/nvme/bdev_nvme.c | 60 +++++++++++++++++++-----------------
 1 file changed, 32 insertions(+), 28 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index bb1c8f056..f78fdf710 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -261,6 +261,23 @@ bdev_nvme_io_complete_nvme_status(struct nvme_bdev_io *bio,
 					  cpl->status.sc);
 }
 
+static inline void
+bdev_nvme_io_complete(struct nvme_bdev_io *bio, int rc)
+{
+	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
+	enum spdk_bdev_io_status io_status;
+
+	if (rc == 0) {
+		io_status = SPDK_BDEV_IO_STATUS_SUCCESS;
+	} else if (rc == -ENOMEM) {
+		io_status = SPDK_BDEV_IO_STATUS_NOMEM;
+	} else {
+		io_status = SPDK_BDEV_IO_STATUS_FAILED;
+	}
+
+	spdk_bdev_io_complete(bdev_io, io_status);
+}
+
 static void
 bdev_nvme_disconnected_qpair_cb(struct spdk_nvme_qpair *qpair, void *poll_group_ctx)
 {
@@ -348,7 +365,7 @@ static int
 bdev_nvme_flush(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		struct nvme_bdev_io *bio, uint64_t offset, uint64_t nbytes)
 {
-	spdk_bdev_io_complete(spdk_bdev_io_from_ctx(bio), SPDK_BDEV_IO_STATUS_SUCCESS);
+	bdev_nvme_io_complete(bio, 0);
 
 	return 0;
 }
@@ -706,6 +723,7 @@ static void
 bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 		     bool success)
 {
+	struct nvme_bdev_io *bio = (struct nvme_bdev_io *)bdev_io->driver_ctx;
 	struct spdk_bdev *bdev = bdev_io->bdev;
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev->ctxt;
 	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
@@ -734,12 +752,8 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 			      bdev->dif_check_flags);
 
 exit:
-	if (spdk_likely(ret == 0)) {
-		return;
-	} else if (ret == -ENOMEM) {
-		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_NOMEM);
-	} else {
-		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
+	if (spdk_unlikely(ret != 0)) {
+		bdev_nvme_io_complete(bio, ret);
 	}
 }
 
@@ -894,11 +908,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 
 exit:
 	if (spdk_unlikely(rc != 0)) {
-		if (rc == -ENOMEM) {
-			spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_NOMEM);
-		} else {
-			spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
-		}
+		bdev_nvme_io_complete(nbdev_io, rc);
 	}
 }
 
@@ -2673,7 +2683,6 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	uint64_t zone_id = bdev_io->u.zone_mgmt.zone_id;
 	uint32_t zones_to_copy = bdev_io->u.zone_mgmt.num_zones;
 	struct spdk_bdev_zone_info *info = bdev_io->u.zone_mgmt.buf;
-	enum spdk_bdev_io_status status;
 	uint64_t max_zones_per_buf, i;
 	uint32_t zone_report_bufsize;
 	struct nvme_bdev_ns *nvme_ns;
@@ -2685,8 +2694,8 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	}
 
 	if (!bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair)) {
-		status = SPDK_BDEV_IO_STATUS_FAILED;
-		goto out_complete_io_status;
+		ret = -ENXIO;
+		goto out_complete_io_ret;
 	}
 
 	zone_report_bufsize = spdk_nvme_ns_get_max_io_xfer_size(nvme_ns->ns);
@@ -2694,21 +2703,20 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 			    sizeof(bio->zone_report_buf->descs[0]);
 
 	if (bio->zone_report_buf->nr_zones > max_zones_per_buf) {
-		status = SPDK_BDEV_IO_STATUS_FAILED;
-		goto out_complete_io_status;
+		ret = -EINVAL;
+		goto out_complete_io_ret;
 	}
 
 	if (!bio->zone_report_buf->nr_zones) {
-		status = SPDK_BDEV_IO_STATUS_FAILED;
-		goto out_complete_io_status;
+		ret = -EINVAL;
+		goto out_complete_io_ret;
 	}
 
 	for (i = 0; i < bio->zone_report_buf->nr_zones && bio->handled_zones < zones_to_copy; i++) {
 		ret = fill_zone_from_report(&info[bio->handled_zones],
 					    &bio->zone_report_buf->descs[i]);
 		if (ret) {
-			status = SPDK_BDEV_IO_STATUS_FAILED;
-			goto out_complete_io_status;
+			goto out_complete_io_ret;
 		}
 		bio->handled_zones++;
 	}
@@ -2724,12 +2732,8 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 						 bdev_nvme_get_zone_info_done, bio);
 		if (!ret) {
 			return;
-		} else if (ret == -ENOMEM) {
-			status = SPDK_BDEV_IO_STATUS_NOMEM;
-			goto out_complete_io_status;
 		} else {
-			status = SPDK_BDEV_IO_STATUS_FAILED;
-			goto out_complete_io_status;
+			goto out_complete_io_ret;
 		}
 	}
 
@@ -2739,10 +2743,10 @@ out_complete_io_nvme_cpl:
 	bdev_nvme_io_complete_nvme_status(bio, cpl);
 	return;
 
-out_complete_io_status:
+out_complete_io_ret:
 	free(bio->zone_report_buf);
 	bio->zone_report_buf = NULL;
-	spdk_bdev_io_complete(bdev_io, status);
+	bdev_nvme_io_complete(bio, ret);
 }
 
 static void
-- 
2.26.2


From 73b4b9ad68296fbab2fa4d281443e071376665f2 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 11 May 2021 03:14:58 +0900
Subject: [PATCH 194/342] bdev/nvme: Put all nvme_bdev_ctrlr accesses into a
 place in bdev_nvme_create_cb()

When multipath is supported, a subsystem has multiple controllers and
bdev_nvme_create_cb() will create a channel per nvme_bdev_ctrlr by
iterating the list of nvme_bdev_ctrlrs, and will hold lock while
doing it.

If the code to access nvme_bdev_ctrlr is put in a place, the
following patches will be easier and smaller.

Hence reorder the code of bdev_nvme_create_cb() as a preparation.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I2f2e66758c3374c678cc44bbb0116f4611c6753a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7754
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/bdev/nvme/bdev_nvme.c | 23 +++++++++++------------
 1 file changed, 11 insertions(+), 12 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index f78fdf710..e041759d1 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -980,20 +980,12 @@ bdev_nvme_create_cb(void *io_device, void *ctx_buf)
 {
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = io_device;
 	struct nvme_io_channel *nvme_ch = ctx_buf;
-	struct spdk_io_channel *pg_ch = NULL;
+	struct spdk_io_channel *pg_ch;
 	int rc;
 
-	if (spdk_nvme_ctrlr_is_ocssd_supported(nvme_bdev_ctrlr->ctrlr)) {
-		rc = bdev_ocssd_create_io_channel(nvme_ch);
-		if (rc != 0) {
-			return rc;
-		}
-	}
-
 	pg_ch = spdk_get_io_channel(&g_nvme_bdev_ctrlrs);
 	if (!pg_ch) {
-		rc = -1;
-		goto err_pg_ch;
+		return -1;
 	}
 
 	nvme_ch->group = spdk_io_channel_get_ctx(pg_ch);
@@ -1006,6 +998,13 @@ bdev_nvme_create_cb(void *io_device, void *ctx_buf)
 
 	TAILQ_INIT(&nvme_ch->pending_resets);
 
+	if (spdk_nvme_ctrlr_is_ocssd_supported(nvme_bdev_ctrlr->ctrlr)) {
+		rc = bdev_ocssd_create_io_channel(nvme_ch);
+		if (rc != 0) {
+			goto err_ocssd_ch;
+		}
+	}
+
 	nvme_ch->ctrlr = nvme_bdev_ctrlr;
 
 	rc = bdev_nvme_create_qpair(nvme_ch);
@@ -1016,11 +1015,11 @@ bdev_nvme_create_cb(void *io_device, void *ctx_buf)
 	return 0;
 
 err_qpair:
-	spdk_put_io_channel(pg_ch);
-err_pg_ch:
 	if (nvme_ch->ocssd_ch) {
 		bdev_ocssd_destroy_io_channel(nvme_ch);
 	}
+err_ocssd_ch:
+	spdk_put_io_channel(pg_ch);
 
 	return rc;
 }
-- 
2.26.2


From a0ea25239913a865b2449ea27909d2489fadb840 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Sun, 11 Apr 2021 17:56:02 +0900
Subject: [PATCH 195/342] bdev/nvme: Factor out reset_io completion into a
 helper function

This will be helpful to simplify the following patches.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I66939f2953c66582bfcb79cfe187814280e89680
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7324
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/bdev/nvme/bdev_nvme.c | 38 ++++++++++++++++++++++++++----------
 1 file changed, 28 insertions(+), 10 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index e041759d1..31b18e989 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -481,18 +481,36 @@ bdev_nvme_abort_pending_resets(struct spdk_io_channel_iter *i)
 	spdk_for_each_channel_continue(i, 0);
 }
 
+static void
+bdev_nvme_reset_io_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
+			    struct nvme_bdev_io *bio, int rc)
+{
+	enum spdk_bdev_io_status io_status = SPDK_BDEV_IO_STATUS_SUCCESS;
+
+	if (rc) {
+		io_status = SPDK_BDEV_IO_STATUS_FAILED;
+	}
+
+	spdk_bdev_io_complete(spdk_bdev_io_from_ctx(bio), io_status);
+
+	/* Make sure we clear any pending resets before returning. */
+	spdk_for_each_channel(nvme_bdev_ctrlr,
+			      rc == 0 ? bdev_nvme_complete_pending_resets :
+			      bdev_nvme_abort_pending_resets,
+			      nvme_bdev_ctrlr,
+			      _bdev_nvme_check_pending_destruct);
+}
+
 static void
 _bdev_nvme_reset_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, int rc)
 {
 	struct nvme_bdev_ctrlr_trid *curr_trid;
 	struct nvme_bdev_io *bio = nvme_bdev_ctrlr->reset_bio;
-	enum spdk_bdev_io_status io_status = SPDK_BDEV_IO_STATUS_SUCCESS;
 
 	nvme_bdev_ctrlr->reset_bio = NULL;
 
 	if (rc) {
 		SPDK_ERRLOG("Resetting controller failed.\n");
-		io_status = SPDK_BDEV_IO_STATUS_FAILED;
 	} else {
 		SPDK_NOTICELOG("Resetting controller successful.\n");
 	}
@@ -515,15 +533,15 @@ _bdev_nvme_reset_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, int rc)
 	pthread_mutex_unlock(&nvme_bdev_ctrlr->mutex);
 
 	if (bio) {
-		spdk_bdev_io_complete(spdk_bdev_io_from_ctx(bio), io_status);
+		bdev_nvme_reset_io_complete(nvme_bdev_ctrlr, bio, rc);
+	} else {
+		/* Make sure we clear any pending resets before returning. */
+		spdk_for_each_channel(nvme_bdev_ctrlr,
+				      rc == 0 ? bdev_nvme_complete_pending_resets :
+				      bdev_nvme_abort_pending_resets,
+				      nvme_bdev_ctrlr,
+				      _bdev_nvme_check_pending_destruct);
 	}
-
-	/* Make sure we clear any pending resets before returning. */
-	spdk_for_each_channel(nvme_bdev_ctrlr,
-			      rc == 0 ? bdev_nvme_complete_pending_resets :
-			      bdev_nvme_abort_pending_resets,
-			      nvme_bdev_ctrlr,
-			      _bdev_nvme_check_pending_destruct);
 }
 
 static void
-- 
2.26.2


From 9391bc33a7f6cba4c9457aee2c07cbfc75a8d7f3 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 11 May 2021 07:31:47 +0900
Subject: [PATCH 196/342] bdev/nvme: Factor out the internal of
 _bdev_nvme_check_pending_destruct()

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I27d7e81fe0ecc35b374277c8e40233db2a3ed914
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7273
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/nvme/bdev_nvme.c | 16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 31b18e989..1576bb5c5 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -430,10 +430,8 @@ bdev_nvme_destroy_qpair(struct nvme_io_channel *nvme_ch)
 }
 
 static void
-_bdev_nvme_check_pending_destruct(struct spdk_io_channel_iter *i, int status)
+_bdev_nvme_check_pending_destruct(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr)
 {
-	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = spdk_io_channel_iter_get_ctx(i);
-
 	pthread_mutex_lock(&nvme_bdev_ctrlr->mutex);
 	if (nvme_bdev_ctrlr->destruct_after_reset) {
 		assert(nvme_bdev_ctrlr->ref == 0 && nvme_bdev_ctrlr->destruct);
@@ -446,6 +444,14 @@ _bdev_nvme_check_pending_destruct(struct spdk_io_channel_iter *i, int status)
 	}
 }
 
+static void
+bdev_nvme_check_pending_destruct(struct spdk_io_channel_iter *i, int status)
+{
+	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = spdk_io_channel_iter_get_ctx(i);
+
+	_bdev_nvme_check_pending_destruct(nvme_bdev_ctrlr);
+}
+
 static void
 _bdev_nvme_complete_pending_resets(struct nvme_io_channel *nvme_ch,
 				   enum spdk_bdev_io_status status)
@@ -498,7 +504,7 @@ bdev_nvme_reset_io_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 			      rc == 0 ? bdev_nvme_complete_pending_resets :
 			      bdev_nvme_abort_pending_resets,
 			      nvme_bdev_ctrlr,
-			      _bdev_nvme_check_pending_destruct);
+			      bdev_nvme_check_pending_destruct);
 }
 
 static void
@@ -540,7 +546,7 @@ _bdev_nvme_reset_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, int rc)
 				      rc == 0 ? bdev_nvme_complete_pending_resets :
 				      bdev_nvme_abort_pending_resets,
 				      nvme_bdev_ctrlr,
-				      _bdev_nvme_check_pending_destruct);
+				      bdev_nvme_check_pending_destruct);
 	}
 }
 
-- 
2.26.2


From 9e1c13c5f107e6d672a30b688623576b3a095b1a Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 12 May 2021 16:22:58 +0900
Subject: [PATCH 197/342] bdev/nvme: Move bdev_nvme_compare_ns() up in a file

bdev_nvme_compare_ns() will be used to check if all namespaces of
one nvme_bdev are identical, and this is the convenient location.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I3fa6072c1cceec53268e53bf398fa1e8f069035e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7169
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 module/bdev/nvme/bdev_nvme.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 1576bb5c5..544209a28 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -1418,6 +1418,17 @@ nvme_bdev_create(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, struct nvme_bdev_ns *n
 	return 0;
 }
 
+static bool
+bdev_nvme_compare_ns(struct spdk_nvme_ns *ns1, struct spdk_nvme_ns *ns2)
+{
+	const struct spdk_nvme_ns_data *nsdata1, *nsdata2;
+
+	nsdata1 = spdk_nvme_ns_get_data(ns1);
+	nsdata2 = spdk_nvme_ns_get_data(ns2);
+
+	return memcmp(nsdata1->nguid, nsdata2->nguid, sizeof(nsdata1->nguid));
+}
+
 static void
 nvme_ctrlr_populate_standard_namespace(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 				       struct nvme_bdev_ns *nvme_ns, struct nvme_async_probe_ctx *ctx)
@@ -2134,17 +2145,6 @@ bdev_nvme_compare_trids(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 	return 0;
 }
 
-static bool
-bdev_nvme_compare_ns(struct spdk_nvme_ns *ns1, struct spdk_nvme_ns *ns2)
-{
-	const struct spdk_nvme_ns_data *nsdata1, *nsdata2;
-
-	nsdata1 = spdk_nvme_ns_get_data(ns1);
-	nsdata2 = spdk_nvme_ns_get_data(ns2);
-
-	return memcmp(nsdata1->nguid, nsdata2->nguid, sizeof(nsdata1->nguid));
-}
-
 static int
 bdev_nvme_compare_namespaces(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 			     struct spdk_nvme_ctrlr *new_ctrlr)
-- 
2.26.2


From 5a1c74bfa4bd21737dc965b1c539fc356a196295 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 31 Mar 2021 22:33:20 +0000
Subject: [PATCH 198/342] usdt: add User Space DTrace support to SPDK

For now, we will keep this disabled by default,
enable with --with-usdt option to the configure
script.  Long-term we will want to enable this by
default, and only disable via configure.

Modules can include spdk_internal/usdt.h and add
probes such as:

SPDK_DTRACE_PROBE2(probe_name, ptr, val);

When USDT is enabled, these will translate to
DTRACE_PROBE2(spdk, probe_name, ptr, val).  When
USDT is disabled, these will translate to nothing.

Later patches will add some probe points to the
nvmf target, some bpftrace scripts, and instructions
for how to successfully capture data with these
probe points and scripts.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Id168e2c800fa5522815a175026386319014cfdaa
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7173
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 CONFIG                       |  3 ++
 configure                    |  8 +++++
 include/spdk_internal/usdt.h | 59 ++++++++++++++++++++++++++++++++++++
 scripts/pkgdep/debian.sh     |  2 ++
 scripts/pkgdep/rhel.sh       |  2 ++
 5 files changed, 74 insertions(+)
 create mode 100644 include/spdk_internal/usdt.h

diff --git a/CONFIG b/CONFIG
index 8c49c7d2b..f464f440e 100644
--- a/CONFIG
+++ b/CONFIG
@@ -172,3 +172,6 @@ CONFIG_RAID5=n
 
 # Build with IDXD support
 CONFIG_IDXD=n
+
+# Build with USDT support
+CONFIG_USDT=n
diff --git a/configure b/configure
index ce9fba177..95162e9b8 100755
--- a/configure
+++ b/configure
@@ -98,6 +98,8 @@ function usage() {
 	echo "                           No path required."
 	echo " wpdk                      Build using WPDK to provide support for Windows (experimental)."
 	echo "                           The argument must be a directory containing lib and include."
+	echo " usdt                      Build with userspace DTrace probes enabled."
+	echo "                           No path required."
 	echo ""
 	echo "Environment variables:"
 	echo ""
@@ -452,6 +454,12 @@ for i in "$@"; do
 		--without-idxd)
 			CONFIG[IDXD]=n
 			;;
+		--with-usdt)
+			CONFIG[USDT]=y
+			;;
+		--without-usdt)
+			CONFIG[USDT]=n
+			;;
 		--)
 			break
 			;;
diff --git a/include/spdk_internal/usdt.h b/include/spdk_internal/usdt.h
new file mode 100644
index 000000000..27fef1e2c
--- /dev/null
+++ b/include/spdk_internal/usdt.h
@@ -0,0 +1,59 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SPDK_INTERNAL_USDT_H
+#define SPDK_INTERNAL_USDT_H
+
+#include "spdk/config.h"
+
+#ifdef SPDK_CONFIG_USDT
+
+#include <sys/sdt.h>
+
+#define SPDK_DTRACE_PROBE(name)			DTRACE_PROBE(spdk,name)
+#define SPDK_DTRACE_PROBE1(name,a1)		DTRACE_PROBE1(spdk,name,a1)
+#define SPDK_DTRACE_PROBE2(name,a1,a2)		DTRACE_PROBE2(spdk,name,a1,a2)
+#define SPDK_DTRACE_PROBE3(name,a1,a2,a3)	DTRACE_PROBE3(spdk,name,a1,a2,a3)
+#define SPDK_DTRACE_PROBE4(name,a1,a2,a3,a4)	DTRACE_PROBE4(spdk,name,a1,a2,a3,a4)
+
+#else
+
+#define SPDK_DTRACE_PROBE(...)
+#define SPDK_DTRACE_PROBE1(...)
+#define SPDK_DTRACE_PROBE2(...)
+#define SPDK_DTRACE_PROBE3(...)
+#define SPDK_DTRACE_PROBE4(...)
+
+#endif
+
+#endif /* SPDK_INTERNAL_USDT_H */
diff --git a/scripts/pkgdep/debian.sh b/scripts/pkgdep/debian.sh
index 88dd5bdea..40149af15 100755
--- a/scripts/pkgdep/debian.sh
+++ b/scripts/pkgdep/debian.sh
@@ -27,6 +27,8 @@ fi
 apt-get install -y libnuma-dev
 # Additional dependencies for ISA-L used in compression
 apt-get install -y autoconf automake libtool help2man
+# Additional dependencies for USDT
+apt-get install -y systemtap-sdt-dev
 if [[ $INSTALL_DEV_TOOLS == "true" ]]; then
 	# Tools for developers
 	apt-get install -y git astyle pep8 lcov clang sg3-utils pciutils shellcheck abigail-tools bash-completion
diff --git a/scripts/pkgdep/rhel.sh b/scripts/pkgdep/rhel.sh
index 653c57f81..00c82c989 100755
--- a/scripts/pkgdep/rhel.sh
+++ b/scripts/pkgdep/rhel.sh
@@ -104,6 +104,8 @@ fi
 yum install -y autoconf automake libtool help2man
 # Additional dependencies for DPDK
 yum install -y numactl-devel nasm
+# Additional dependencies for USDT
+yum install -y systemtap-sdt-devel
 if [[ $INSTALL_DEV_TOOLS == "true" ]]; then
 	# Tools for developers
 	if echo "$ID $VERSION_ID" | grep -E -q 'centos 8'; then
-- 
2.26.2


From af0bf0f006813d188bfdd085b5158b7237db96f4 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 30 Apr 2021 22:14:51 +0000
Subject: [PATCH 199/342] scripts: add bpftrace.sh

This script simplifies execution of bpftrace scripts
for SPDK application analysis. The script should be
invoked as:

scripts/bpftrace.sh `pidof spdk_tgt` script.bt

where 'script.bt' is the name of the bpftrace script
you wish to execute.

The script helps simplify the following:

1) replace __EXE__ markers in the bpftrace script with
   the full path of the spdk executable (required for
   usdt probes);  it uses /proc/<pid>/exe to get the
   full path
2) replace __PID__ markers in the bpftrace script with
   the PID of the spdk process under analysis - this
   allows for doing things like filtering system call
   counts for just the SPDK process
3) invoke bpftrace with the -p <pid> option

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ib271f26efe4ba326d951a7b30f61b22be755dda7
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7710
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 scripts/bpftrace.sh | 9 +++++++++
 1 file changed, 9 insertions(+)
 create mode 100755 scripts/bpftrace.sh

diff --git a/scripts/bpftrace.sh b/scripts/bpftrace.sh
new file mode 100755
index 000000000..d35714b15
--- /dev/null
+++ b/scripts/bpftrace.sh
@@ -0,0 +1,9 @@
+#!/usr/bin/env bash
+if [ $# -lt 2 ]; then
+	echo "usage: $0 <pid> <script>"
+	exit 1
+fi
+SCRIPTS_DIR=$(readlink -f $(dirname $0))
+BIN_PATH=$(readlink -f /proc/$1/exe)
+BPF_SCRIPT=$(sed "s#__EXE__#${BIN_PATH}#g" "${@:2}" | sed "s#__PID__#${1}#g")
+bpftrace -p $1 -e "$BPF_SCRIPT"
-- 
2.26.2


From cbb57e0d9635b6760f4037cb792c7b6e10665b14 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 30 Apr 2021 22:22:31 +0000
Subject: [PATCH 200/342] scripts: add bpf/send_msg.bt

This script tracks spdk_thread_send_msg and
spdk_for_each_channel calls.  It also uses usym
to get the name of the function pointer passed to
these calls.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ia0cf5b50538bd26a3e15e35cbab765fe3c327c73
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7711
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 scripts/bpf/send_msg.bt | 7 +++++++
 1 file changed, 7 insertions(+)
 create mode 100644 scripts/bpf/send_msg.bt

diff --git a/scripts/bpf/send_msg.bt b/scripts/bpf/send_msg.bt
new file mode 100644
index 000000000..2e1bedf5f
--- /dev/null
+++ b/scripts/bpf/send_msg.bt
@@ -0,0 +1,7 @@
+uprobe:__EXE__:spdk_thread_send_msg {
+	@send_msg[usym(arg1)] = count();
+}
+
+uprobe:__EXE__:spdk_for_each_channel {
+	@for_each_channel[usym(arg1)] = count();
+}
-- 
2.26.2


From dca7ef27596ef24cca4ac18a04d59fba1a888030 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 30 Apr 2021 22:35:01 +0000
Subject: [PATCH 201/342] scripts: add bpf/readv.bt

This script captures a histogram of the returned values
from the readv syscall.  It can be useful for analyzing
the efficiency of our sock/posix implementation.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I910eb2e81e3416855cda7a3854982cd02476850e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7712
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 scripts/bpf/readv.bt | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 scripts/bpf/readv.bt

diff --git a/scripts/bpf/readv.bt b/scripts/bpf/readv.bt
new file mode 100644
index 000000000..36abebf56
--- /dev/null
+++ b/scripts/bpf/readv.bt
@@ -0,0 +1,3 @@
+tracepoint:syscalls:sys_exit_readv /pid == __PID__/ {
+	@bytes = hist(args->ret);
+}
-- 
2.26.2


From 887109bf9ebd0d9409e3d35755d493b7d72403cc Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 30 Apr 2021 22:39:28 +0000
Subject: [PATCH 202/342] scripts: add bpf/syscalls.bt

This script counts how many times each syscall
is called by the SPDK application.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ife5efccee73e407e1d819293786f2acdfa317f78
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7713
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 scripts/bpf/syscalls.bt | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 scripts/bpf/syscalls.bt

diff --git a/scripts/bpf/syscalls.bt b/scripts/bpf/syscalls.bt
new file mode 100644
index 000000000..3c8cd70bc
--- /dev/null
+++ b/scripts/bpf/syscalls.bt
@@ -0,0 +1,3 @@
+tracepoint:syscalls:sys_enter_* /pid == __PID__/ {
+	@syscall[probe] = count();
+}
-- 
2.26.2


From dd9350c7e6327fd60b0758c9a8e3070a770fe02b Mon Sep 17 00:00:00 2001
From: Jacek Kalwas <jacek.kalwas@intel.com>
Date: Tue, 6 Apr 2021 08:59:49 -0400
Subject: [PATCH 203/342] build: fix missing pthread dependency for syslibs pc

SYS_LIBS var is used to generate Lib.private section of
spdk_syslibs.pc

lack of pthread can result in linking issue when spdk's *.pc are used

please note that usage of -lpthread and -pthread is not consisent
within system wide pc files

Signed-off-by: Jacek Kalwas <jacek.kalwas@intel.com>
Change-Id: I2dd327371d5621ea12f1e2f7abdfe6b7aa6602eb
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7253
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Maciej Szulik <maciej.szulik@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 mk/spdk.common.mk | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mk/spdk.common.mk b/mk/spdk.common.mk
index d3bf5689b..b76d8d0e4 100644
--- a/mk/spdk.common.mk
+++ b/mk/spdk.common.mk
@@ -286,7 +286,7 @@ endif
 
 ifneq ($(OS),Windows)
 COMMON_CFLAGS += -pthread
-LDFLAGS += -pthread
+SYS_LIBS += -pthread
 endif
 
 CFLAGS   += $(COMMON_CFLAGS) -Wno-pointer-sign -Wstrict-prototypes -Wold-style-definition -std=gnu99
-- 
2.26.2


From b686c825810e2b4e63ba22edca8a13d1bce44b93 Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Thu, 20 May 2021 17:09:31 +0200
Subject: [PATCH 204/342] scripts/nvmf_perf: update add_listener rpc call

nvmf_subsystem_add_listener() in rpc/nvmf was modified
by 64debe0453499f55ce068d9dd261b567dcac0d38 and the
change was not reflected in performance scripts.

Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Change-Id: I7bb8c39ab225421964e37883aa7b0f824e8df683
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7978
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 scripts/perf/nvmf/run_nvmf.py | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/scripts/perf/nvmf/run_nvmf.py b/scripts/perf/nvmf/run_nvmf.py
index 87867b56c..01cfd68c0 100755
--- a/scripts/perf/nvmf/run_nvmf.py
+++ b/scripts/perf/nvmf/run_nvmf.py
@@ -1107,7 +1107,8 @@ class SPDKTarget(Target):
                                                allow_any_host=True, max_namespaces=8)
                 rpc.nvmf.nvmf_subsystem_add_ns(self.client, nqn, bdev_name)
 
-                rpc.nvmf.nvmf_subsystem_add_listener(self.client, nqn,
+                rpc.nvmf.nvmf_subsystem_add_listener(self.client,
+                                                     nqn=nqn,
                                                      trtype=self.transport,
                                                      traddr=ip,
                                                      trsvcid=port,
-- 
2.26.2


From bb27314c038f2cd9c72ff580c52dfb7244f7928a Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Mon, 17 May 2021 10:43:04 +0800
Subject: [PATCH 205/342] test/nvme_pcie: cases for mapping io cmd

Change-Id: Icf174668e9b1361bb232db4a0cc53921423a17a4
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7671
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c | 95 +++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
index a1be9f9a4..d1d189262 100644
--- a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
@@ -799,6 +799,100 @@ test_nvme_pcie_ctrlr_map_unmap_cmb(void)
 	CU_ASSERT(pctrlr.ctrlr.opts.use_cmb_sqs == false);
 }
 
+
+static void
+prepare_map_io_cmd(struct nvme_pcie_ctrlr *pctrlr)
+{
+	union spdk_nvme_cmbsz_register cmbsz = {};
+	union spdk_nvme_cmbloc_register cmbloc = {};
+
+	cmbsz.bits.sz = 512;
+	cmbsz.bits.wds = 1;
+	cmbsz.bits.rds = 1;
+
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr->ctrlr, offsetof(struct spdk_nvme_registers, cmbsz.raw),
+				  cmbsz.raw);
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr->ctrlr, offsetof(struct spdk_nvme_registers, cmbloc.raw),
+				  cmbloc.raw);
+
+	pctrlr->cmb.bar_va = (void *)0x7F7C0080D000;
+	pctrlr->cmb.bar_pa = 0xFC800000;
+	pctrlr->cmb.current_offset = 1ULL << 22;
+	pctrlr->cmb.size = (1ULL << 22) * 512;
+	pctrlr->cmb.mem_register_addr = NULL;
+	pctrlr->ctrlr.opts.use_cmb_sqs = false;
+}
+
+static void
+test_nvme_pcie_ctrlr_map_io_cmb(void)
+{
+	struct nvme_pcie_ctrlr pctrlr = {};
+	volatile struct spdk_nvme_registers regs = {};
+	union spdk_nvme_cmbsz_register cmbsz = {};
+	void *mem_reg_addr = NULL;
+	size_t size;
+	int rc;
+
+	pctrlr.regs = &regs;
+	prepare_map_io_cmd(&pctrlr);
+
+	mem_reg_addr = nvme_pcie_ctrlr_map_io_cmb(&pctrlr.ctrlr, &size);
+	/* Ceil the current cmb vaddr and cmb size to 2MB_aligned */
+	CU_ASSERT(mem_reg_addr == (void *)0x7F7C00E00000);
+	CU_ASSERT(size == 0x7FE00000);
+
+	rc = nvme_pcie_ctrlr_unmap_io_cmb(&pctrlr.ctrlr);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(pctrlr.cmb.mem_register_addr == NULL);
+	CU_ASSERT(pctrlr.cmb.mem_register_size == 0);
+
+	/* cmb mem_register_addr not NULL */
+	prepare_map_io_cmd(&pctrlr);
+	pctrlr.cmb.mem_register_addr = (void *)0xDEADBEEF;
+	pctrlr.cmb.mem_register_size = 1024;
+
+	mem_reg_addr = nvme_pcie_ctrlr_map_io_cmb(&pctrlr.ctrlr, &size);
+	CU_ASSERT(size == 1024);
+	CU_ASSERT(mem_reg_addr == (void *)0xDEADBEEF);
+
+	/* cmb.bar_va is NULL */
+	prepare_map_io_cmd(&pctrlr);
+	pctrlr.cmb.bar_va = NULL;
+
+	mem_reg_addr = nvme_pcie_ctrlr_map_io_cmb(&pctrlr.ctrlr, &size);
+	CU_ASSERT(mem_reg_addr == NULL);
+	CU_ASSERT(size == 0);
+
+	/* submission queue already used */
+	prepare_map_io_cmd(&pctrlr);
+	pctrlr.ctrlr.opts.use_cmb_sqs = true;
+
+	mem_reg_addr = nvme_pcie_ctrlr_map_io_cmb(&pctrlr.ctrlr, &size);
+	CU_ASSERT(mem_reg_addr == NULL);
+	CU_ASSERT(size == 0);
+
+	pctrlr.ctrlr.opts.use_cmb_sqs = false;
+
+	/* Only SQS is supported */
+	prepare_map_io_cmd(&pctrlr);
+	cmbsz.bits.wds = 0;
+	cmbsz.bits.rds = 0;
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr, offsetof(struct spdk_nvme_registers, cmbsz.raw),
+				  cmbsz.raw);
+
+	mem_reg_addr = nvme_pcie_ctrlr_map_io_cmb(&pctrlr.ctrlr, &size);
+	CU_ASSERT(mem_reg_addr == NULL);
+	CU_ASSERT(size == 0);
+
+	/* CMB size is less than 4MB */
+	prepare_map_io_cmd(&pctrlr);
+	pctrlr.cmb.size = 1ULL << 16;
+
+	mem_reg_addr = nvme_pcie_ctrlr_map_io_cmb(&pctrlr.ctrlr, &size);
+	CU_ASSERT(mem_reg_addr == NULL);
+	CU_ASSERT(size == 0);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -818,6 +912,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_build_contig_request);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_regs_get_set);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_map_unmap_cmb);
+	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_map_io_cmb);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 7908736c22849cab13d34ded877516909ca950e7 Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Mon, 17 May 2021 17:06:36 +0200
Subject: [PATCH 206/342] autobuild: update patches for mainline DPDK

Patches stopped applying cleanly because of dpdk/dpdk changes:
7d5cfaa7508de0fd248b05effbf421a98317006a
4ad4b20a79052d9c8062b64eaf0170c16a333ff8
Needed to rebase custom patches.

Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Change-Id: I1006f7f6ba21a3cee5b607cfc44adedb4c1d5830
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7903
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 autobuild.sh | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/autobuild.sh b/autobuild.sh
index 4edde9691..686543f10 100755
--- a/autobuild.sh
+++ b/autobuild.sh
@@ -133,8 +133,8 @@ function build_native_dpdk() {
 			wget https://github.com/karlatec/dpdk/commit/3219c0cfc38803aec10c809dde16e013b370bda9.patch -O dpdk-pci.patch
 			wget https://github.com/karlatec/dpdk/commit/adf8f7638de29bc4bf9ba3faf12bbdae73acda0c.patch -O dpdk-qat.patch
 		else
-			wget https://github.com/karlatec/dpdk/commit/eac05db0580091ef8e4d338aa5d2210695521894.patch -O dpdk-pci.patch
-			wget https://github.com/karlatec/dpdk/commit/d649d5efb7bb404ce59dea81768adeb994b284f7.patch -O dpdk-qat.patch
+			wget https://github.com/karlatec/dpdk/commit/f95e331be3a1f856b816948990dd2afc67ea4020.patch -O dpdk-pci.patch
+			wget https://github.com/karlatec/dpdk/commit/6fd2fa906ffdcee04e6ce5da40e61cb841be9827.patch -O dpdk-qat.patch
 		fi
 		git config --local user.name "spdk"
 		git config --local user.email "nomail@all.com"
-- 
2.26.2


From 274f52b52707d78027c7fe32737cf851d5cba807 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 10 Mar 2021 10:06:40 +0100
Subject: [PATCH 207/342] autobuild: Separate unit tests from autobuild

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: If6ce4d3f7bc58855ba61b352be71dff404c87720
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6819
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autobuild.sh | 9 ++++++++-
 autorun.sh   | 5 ++++-
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/autobuild.sh b/autobuild.sh
index 686543f10..28dcc7209 100755
--- a/autobuild.sh
+++ b/autobuild.sh
@@ -278,6 +278,11 @@ function autobuild_test_suite() {
 	run_test "autobuild_build_doc" build_doc
 }
 
+function unittest_build() {
+	"$rootdir/configure" $config_params --without-shared
+	$MAKE $MAKEFLAGS
+}
+
 if [ $SPDK_RUN_VALGRIND -eq 1 ]; then
 	run_test "valgrind" echo "using valgrind"
 fi
@@ -301,8 +306,10 @@ $MAKE cc_version
 $MAKE cxx_version
 echo "** END ** Info for Hostname: $HOSTNAME"
 
-if [ "$SPDK_TEST_AUTOBUILD" -eq 1 ]; then
+if [[ $SPDK_TEST_AUTOBUILD -eq 1 ]]; then
 	run_test "autobuild" autobuild_test_suite $1
+elif [[ $SPDK_TEST_UNITTEST -eq 1 ]]; then
+	run_test "unittest_build" unittest_build
 else
 	if [ "$SPDK_TEST_OCF" -eq 1 ]; then
 		run_test "autobuild_ocf_precompile" ocf_precompile
diff --git a/autorun.sh b/autorun.sh
index c85fdb217..9b5207e1a 100755
--- a/autorun.sh
+++ b/autorun.sh
@@ -12,11 +12,14 @@ if [[ ! -f $conf ]]; then
 	echo "ERROR: $conf doesn't exist"
 	exit 1
 fi
+source "$conf"
 
 echo "Test configuration:"
 cat "$conf"
 
 # Runs agent scripts
 $rootdir/autobuild.sh "$conf"
-sudo -E $rootdir/autotest.sh "$conf"
+if ((SPDK_TEST_UNITTEST == 1 || SPDK_RUN_FUNCTIONAL_TEST == 1)); then
+	sudo -E $rootdir/autotest.sh "$conf"
+fi
 $rootdir/autopackage.sh "$conf"
-- 
2.26.2


From eb5a1113984f9eb78ceec44fcf2bc41e817d9b6f Mon Sep 17 00:00:00 2001
From: paul luse <paul.e.luse@intel.com>
Date: Tue, 4 May 2021 14:52:48 -0400
Subject: [PATCH 208/342] lib/idxd: move the crc destination * from the desc to
 comp record

Was using reserved field in CRC to store the final address of where
to put the result, this not legal.  Move to the completion record
and slightly re-arrange the struct to keep it at 96 bytes.

Refacorted the IO prep function so the caller can udpate both the
descriptor and completion records instead of continuing to add
parameters to the prep function for opcodes that need something
unique in the completion record.  This also allowed for a minor
fix where the prep function was returning NULL when vtophys failed
which would have indicated busy as opposed to failire.  Now we can
proprely fail that path.

fixes #1929

Signed-off-by: paul luse <paul.e.luse@intel.com>
Change-Id: Ic23bc7b68bdd5757c30b7963880677f423368e20
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7735
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/idxd/idxd.c | 71 +++++++++++++++++++++++++------------------------
 lib/idxd/idxd.h |  3 ++-
 2 files changed, 38 insertions(+), 36 deletions(-)

diff --git a/lib/idxd/idxd.c b/lib/idxd/idxd.c
index dbe925179..1b58955d2 100644
--- a/lib/idxd/idxd.c
+++ b/lib/idxd/idxd.c
@@ -406,9 +406,9 @@ _vtophys(const void *buf, uint64_t *buf_addr, uint64_t size)
 	return 0;
 }
 
-static struct idxd_hw_desc *
+static int
 _idxd_prep_command(struct spdk_idxd_io_channel *chan, spdk_idxd_req_cb cb_fn,
-		   void *cb_arg, struct idxd_batch *batch)
+		   void *cb_arg, struct idxd_hw_desc **_desc, struct idxd_comp **_comp)
 {
 	uint32_t index;
 	struct idxd_hw_desc *desc;
@@ -419,18 +419,18 @@ _idxd_prep_command(struct spdk_idxd_io_channel *chan, spdk_idxd_req_cb cb_fn,
 	index = spdk_bit_array_find_first_clear(chan->ring_slots, 0);
 	if (index == UINT32_MAX) {
 		/* ran out of ring slots */
-		return NULL;
+		return -EBUSY;
 	}
 
 	spdk_bit_array_set(chan->ring_slots, index);
 
-	desc = &chan->desc[index];
-	comp = &chan->completions[index];
+	desc = *_desc = &chan->desc[index];
+	comp = *_comp = &chan->completions[index];
 
 	rc = _vtophys(&comp->hw, &comp_hw_addr, sizeof(struct idxd_hw_comp_record));
 	if (rc) {
 		spdk_bit_array_clear(chan->ring_slots, index);
-		return NULL;
+		return rc;
 	}
 
 	_track_comp(chan, false, index, comp, desc, NULL);
@@ -439,9 +439,8 @@ _idxd_prep_command(struct spdk_idxd_io_channel *chan, spdk_idxd_req_cb cb_fn,
 	desc->completion_addr = comp_hw_addr;
 	comp->cb_arg = cb_arg;
 	comp->cb_fn = cb_fn;
-	comp->batch = batch;
 
-	return desc;
+	return 0;
 }
 
 int
@@ -449,13 +448,14 @@ spdk_idxd_submit_copy(struct spdk_idxd_io_channel *chan, void *dst, const void *
 		      uint64_t nbytes, spdk_idxd_req_cb cb_fn, void *cb_arg)
 {
 	struct idxd_hw_desc *desc;
+	struct idxd_comp *comp;
 	uint64_t src_addr, dst_addr;
 	int rc;
 
 	/* Common prep. */
-	desc = _idxd_prep_command(chan, cb_fn, cb_arg, NULL);
-	if (desc == NULL) {
-		return -EBUSY;
+	rc = _idxd_prep_command(chan, cb_fn, cb_arg, &desc, &comp);
+	if (rc) {
+		return rc;
 	}
 
 	rc = _vtophys(src, &src_addr, nbytes);
@@ -486,6 +486,7 @@ spdk_idxd_submit_dualcast(struct spdk_idxd_io_channel *chan, void *dst1, void *d
 			  const void *src, uint64_t nbytes, spdk_idxd_req_cb cb_fn, void *cb_arg)
 {
 	struct idxd_hw_desc *desc;
+	struct idxd_comp *comp;
 	uint64_t src_addr, dst1_addr, dst2_addr;
 	int rc;
 
@@ -495,9 +496,9 @@ spdk_idxd_submit_dualcast(struct spdk_idxd_io_channel *chan, void *dst1, void *d
 	}
 
 	/* Common prep. */
-	desc = _idxd_prep_command(chan, cb_fn, cb_arg, NULL);
-	if (desc == NULL) {
-		return -EBUSY;
+	rc = _idxd_prep_command(chan, cb_fn, cb_arg, &desc, &comp);
+	if (rc) {
+		return rc;
 	}
 
 	rc = _vtophys(src, &src_addr, nbytes);
@@ -533,13 +534,14 @@ spdk_idxd_submit_compare(struct spdk_idxd_io_channel *chan, void *src1, const vo
 			 uint64_t nbytes, spdk_idxd_req_cb cb_fn, void *cb_arg)
 {
 	struct idxd_hw_desc *desc;
+	struct idxd_comp *comp;
 	uint64_t src1_addr, src2_addr;
 	int rc;
 
 	/* Common prep. */
-	desc = _idxd_prep_command(chan, cb_fn, cb_arg, NULL);
-	if (desc == NULL) {
-		return -EBUSY;
+	rc = _idxd_prep_command(chan, cb_fn, cb_arg, &desc, &comp);
+	if (rc) {
+		return rc;
 	}
 
 	rc = _vtophys(src1, &src1_addr, nbytes);
@@ -569,13 +571,14 @@ spdk_idxd_submit_fill(struct spdk_idxd_io_channel *chan, void *dst, uint64_t fil
 		      uint64_t nbytes, spdk_idxd_req_cb cb_fn, void *cb_arg)
 {
 	struct idxd_hw_desc *desc;
+	struct idxd_comp *comp;
 	uint64_t dst_addr;
 	int rc;
 
 	/* Common prep. */
-	desc = _idxd_prep_command(chan, cb_fn, cb_arg, NULL);
-	if (desc == NULL) {
-		return -EBUSY;
+	rc = _idxd_prep_command(chan, cb_fn, cb_arg, &desc, &comp);
+	if (rc) {
+		return rc;
 	}
 
 	rc = _vtophys(dst, &dst_addr, nbytes);
@@ -601,32 +604,29 @@ spdk_idxd_submit_crc32c(struct spdk_idxd_io_channel *chan, uint32_t *dst, void *
 			spdk_idxd_req_cb cb_fn, void *cb_arg)
 {
 	struct idxd_hw_desc *desc;
-	uint64_t src_addr, dst_addr;
+	struct idxd_comp *comp;
+	uint64_t src_addr;
 	int rc;
 
 	/* Common prep. */
-	desc = _idxd_prep_command(chan, cb_fn, cb_arg, NULL);
-	if (desc == NULL) {
-		return -EBUSY;
-	}
-
-	rc = _vtophys(src, &src_addr, nbytes);
+	rc = _idxd_prep_command(chan, cb_fn, cb_arg, &desc, &comp);
 	if (rc) {
 		return rc;
 	}
 
-	rc = _vtophys(dst, &dst_addr, nbytes);
+	rc = _vtophys(src, &src_addr, nbytes);
 	if (rc) {
 		return rc;
 	}
 
 	/* Command specific. */
 	desc->opcode = IDXD_OPCODE_CRC32C_GEN;
-	desc->dst_addr = dst_addr;
+	desc->dst_addr = 0; /* Per spec, needs to be clear. */
 	desc->src_addr = src_addr;
 	desc->flags &= IDXD_CLEAR_CRC_FLAGS;
 	desc->crc32c.seed = seed;
 	desc->xfer_size = nbytes;
+	comp->crc_dst = dst;
 
 	/* Submit operation. */
 	movdir64b(chan->portal, desc);
@@ -709,6 +709,7 @@ spdk_idxd_batch_submit(struct spdk_idxd_io_channel *chan, struct idxd_batch *bat
 		       spdk_idxd_req_cb cb_fn, void *cb_arg)
 {
 	struct idxd_hw_desc *desc;
+	struct idxd_comp *comp;
 	uint64_t desc_addr;
 	int i, rc;
 
@@ -725,10 +726,9 @@ spdk_idxd_batch_submit(struct spdk_idxd_io_channel *chan, struct idxd_batch *bat
 	}
 
 	/* Common prep. */
-	desc = _idxd_prep_command(chan, cb_fn, cb_arg, batch);
-	if (desc == NULL) {
-		SPDK_DEBUGLOG(idxd, "Busy, can't submit batch %p\n", batch);
-		return -EBUSY;
+	rc = _idxd_prep_command(chan, cb_fn, cb_arg, &desc, &comp);
+	if (rc) {
+		return rc;
 	}
 
 	rc = _vtophys(batch->user_desc, &desc_addr, batch->remaining * sizeof(struct idxd_hw_desc));
@@ -740,6 +740,7 @@ spdk_idxd_batch_submit(struct spdk_idxd_io_channel *chan, struct idxd_batch *bat
 	desc->opcode = IDXD_OPCODE_BATCH;
 	desc->desc_list_addr = desc_addr;
 	desc->desc_count = batch->remaining = batch->index;
+	comp->batch = batch;
 	assert(batch->index <= DESC_PER_BATCH);
 
 	/* Add the batch elements completion contexts to the outstanding list to be polled. */
@@ -1042,8 +1043,8 @@ spdk_idxd_process_events(struct spdk_idxd_io_channel *chan)
 				SPDK_DEBUGLOG(idxd, "Complete batch %p\n", comp_ctx->batch);
 				break;
 			case IDXD_OPCODE_CRC32C_GEN:
-				*(uint32_t *)comp_ctx->desc->dst_addr = comp_ctx->hw.crc32c_val;
-				*(uint32_t *)comp_ctx->desc->dst_addr ^= ~0;
+				*(uint32_t *)comp_ctx->crc_dst = comp_ctx->hw.crc32c_val;
+				*(uint32_t *)comp_ctx->crc_dst ^= ~0;
 				break;
 			case IDXD_OPCODE_COMPARE:
 				if (status == 0) {
diff --git a/lib/idxd/idxd.h b/lib/idxd/idxd.h
index 9ee8e817c..717f7ee93 100644
--- a/lib/idxd/idxd.h
+++ b/lib/idxd/idxd.h
@@ -164,9 +164,10 @@ struct idxd_comp {
 	void				*cb_arg;
 	spdk_idxd_req_cb		cb_fn;
 	struct idxd_batch		*batch;
-	bool				batch_op;
 	struct idxd_hw_desc		*desc;
+	uint32_t			*crc_dst;
 	uint32_t			index;
+	bool				batch_op;
 	char				pad[3];
 	TAILQ_ENTRY(idxd_comp)		link;
 };
-- 
2.26.2


From e2b6cf2f960e8c457f38a57a4ec28aab6ba9e3ac Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Tue, 18 May 2021 14:35:10 +0200
Subject: [PATCH 209/342] spdk_top: move sort_threads function

This function is going to be needed in get_data() in the next patch.

Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: I9368b4567a92ca20d830c3475e3120ee691b84c1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7947
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 app/spdk_top/spdk_top.c | 115 ++++++++++++++++++++--------------------
 1 file changed, 58 insertions(+), 57 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index fca9da36c..cbf3740d0 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -547,6 +547,64 @@ rpc_send_req(char *rpc_name, struct spdk_jsonrpc_client_response **resp)
 	return 0;
 }
 
+
+static int
+sort_threads(const void *p1, const void *p2)
+{
+	const struct rpc_thread_info *thread_info1 = *(struct rpc_thread_info **)p1;
+	const struct rpc_thread_info *thread_info2 = *(struct rpc_thread_info **)p2;
+	uint64_t count1, count2;
+
+	/* thread IDs may not be allocated contiguously, so we need
+	 * to account for NULL thread_info pointers */
+	if (thread_info1 == NULL && thread_info2 == NULL) {
+		return 0;
+	} else if (thread_info1 == NULL) {
+		return 1;
+	} else if (thread_info2 == NULL) {
+		return -1;
+	}
+
+	switch (g_current_sort_col[THREADS_TAB]) {
+	case 0: /* Sort by name */
+		return strcmp(thread_info1->name, thread_info2->name);
+	case 1: /* Sort by core */
+		count2 = thread_info1->core_num;
+		count1 = thread_info2->core_num;
+		break;
+	case 2: /* Sort by active pollers number */
+		count1 = thread_info1->active_pollers_count;
+		count2 = thread_info2->active_pollers_count;
+		break;
+	case 3: /* Sort by timed pollers number */
+		count1 = thread_info1->timed_pollers_count;
+		count2 = thread_info2->timed_pollers_count;
+		break;
+	case 4: /* Sort by paused pollers number */
+		count1 = thread_info1->paused_pollers_count;
+		count2 = thread_info2->paused_pollers_count;
+		break;
+	case 5: /* Sort by idle time */
+		count1 = thread_info1->idle - thread_info1->last_idle;
+		count2 = thread_info2->idle - thread_info2->last_idle;
+		break;
+	case 6: /* Sort by busy time */
+		count1 = thread_info1->busy - thread_info1->last_busy;
+		count2 = thread_info2->busy - thread_info2->last_busy;
+		break;
+	default:
+		return 0;
+	}
+
+	if (count2 > count1) {
+		return 1;
+	} else if (count2 < count1) {
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
 static int
 get_data(void)
 {
@@ -798,63 +856,6 @@ get_time_str(uint64_t ticks, char *time_str)
 	snprintf(time_str, MAX_TIME_STR_LEN, "%" PRIu64, time);
 }
 
-static int
-sort_threads(const void *p1, const void *p2)
-{
-	const struct rpc_thread_info *thread_info1 = *(struct rpc_thread_info **)p1;
-	const struct rpc_thread_info *thread_info2 = *(struct rpc_thread_info **)p2;
-	uint64_t count1, count2;
-
-	/* thread IDs may not be allocated contiguously, so we need
-	 * to account for NULL thread_info pointers */
-	if (thread_info1 == NULL && thread_info2 == NULL) {
-		return 0;
-	} else if (thread_info1 == NULL) {
-		return 1;
-	} else if (thread_info2 == NULL) {
-		return -1;
-	}
-
-	switch (g_current_sort_col[THREADS_TAB]) {
-	case 0: /* Sort by name */
-		return strcmp(thread_info1->name, thread_info2->name);
-	case 1: /* Sort by core */
-		count2 = thread_info1->core_num;
-		count1 = thread_info2->core_num;
-		break;
-	case 2: /* Sort by active pollers number */
-		count1 = thread_info1->active_pollers_count;
-		count2 = thread_info2->active_pollers_count;
-		break;
-	case 3: /* Sort by timed pollers number */
-		count1 = thread_info1->timed_pollers_count;
-		count2 = thread_info2->timed_pollers_count;
-		break;
-	case 4: /* Sort by paused pollers number */
-		count1 = thread_info1->paused_pollers_count;
-		count2 = thread_info2->paused_pollers_count;
-		break;
-	case 5: /* Sort by idle time */
-		count1 = thread_info1->idle - thread_info1->last_idle;
-		count2 = thread_info2->idle - thread_info2->last_idle;
-		break;
-	case 6: /* Sort by busy time */
-		count1 = thread_info1->busy - thread_info1->last_busy;
-		count2 = thread_info2->busy - thread_info2->last_busy;
-		break;
-	default:
-		return 0;
-	}
-
-	if (count2 > count1) {
-		return 1;
-	} else if (count2 < count1) {
-		return -1;
-	} else {
-		return 0;
-	}
-}
-
 static void
 draw_row_background(uint8_t item_index, uint8_t tab)
 {
-- 
2.26.2


From 22edbe962674fb143efb3f36230fabb31f2f8224 Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Wed, 19 May 2021 12:58:35 +0200
Subject: [PATCH 210/342] spdk_top: change where get_data() and free_data() are
 called

Move part of code with get_data(), refresh_tab() and free_data()
inside show_stats() upwards to make sure data structures are
up to date for pop-up details windows.

Delete get_data(), free_data() calls from show_thread(), show_poller()
and show_core functions.

Add data freeing right before rpc calls inside get_data() to let
pop-up details windows to use updated data before freeing it.

Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: I0d78eb7a48b0cdff4284815afc1a214b0effd7fc
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7953
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 app/spdk_top/spdk_top.c | 68 +++++++++++++++++++----------------------
 1 file changed, 31 insertions(+), 37 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index cbf3740d0..5fabce073 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -619,6 +619,9 @@ get_data(void)
 		goto end;
 	}
 
+	/* Free old threads values before allocating memory for new ones */
+	free_rpc_threads_stats(&g_threads_stats);
+
 	/* Decode json */
 	memset(&g_threads_stats, 0, sizeof(g_threads_stats));
 	if (spdk_json_decode_object(json_resp->result, rpc_threads_stats_decoders,
@@ -639,6 +642,9 @@ get_data(void)
 		goto end;
 	}
 
+	/* Free old pollers values before allocating memory for new ones */
+	free_rpc_pollers_stats(&g_pollers_stats);
+
 	/* Decode json */
 	memset(&g_pollers_stats, 0, sizeof(g_pollers_stats));
 	if (spdk_json_decode_object(json_resp->result, rpc_pollers_stats_decoders,
@@ -654,6 +660,9 @@ get_data(void)
 		goto end;
 	}
 
+	/* Free old cores values before allocating memory for new ones */
+	free_rpc_cores_stats(&g_cores_stats);
+
 	/* Decode json */
 	memset(&g_cores_stats, 0, sizeof(g_cores_stats));
 	if (spdk_json_decode_object(json_resp->result, rpc_cores_stats_decoders,
@@ -2086,18 +2095,12 @@ show_thread(uint8_t current_page)
 	uint64_t thread_number = current_page * g_max_data_rows + g_selected_row;
 	uint64_t i;
 
-	get_data();
-
 	assert(thread_number < g_threads_stats.threads.threads_count);
 	for (i = 0; i < g_threads_stats.threads.threads_count; i++) {
 		thread_info[i] = &g_threads_stats.threads.thread_info[i];
 	}
 
-	qsort(thread_info, g_threads_stats.threads.threads_count, sizeof(thread_info[0]), sort_threads);
-
 	display_thread(thread_info[thread_number]);
-
-	free_data();
 }
 
 static void
@@ -2127,8 +2130,6 @@ show_core(uint8_t current_page)
 	bool stop_loop = false;
 	char idle_time[MAX_TIME_STR_LEN], busy_time[MAX_TIME_STR_LEN];
 
-	get_data();
-
 	assert(core_number < g_cores_stats.cores.cores_count);
 	for (i = 0; i < g_cores_stats.cores.cores_count; i++) {
 		core_info[i] = &g_cores_stats.cores.core[i];
@@ -2234,8 +2235,6 @@ show_core(uint8_t current_page)
 
 	del_panel(core_panel);
 	delwin(core_win);
-
-	free_data();
 }
 
 static void
@@ -2250,8 +2249,6 @@ show_poller(uint8_t current_page)
 	char poller_period[MAX_TIME_STR_LEN];
 	int c;
 
-	get_data();
-
 	prepare_poller_data(current_page, pollers, &count, current_page);
 	assert(poller_number < count);
 
@@ -2317,8 +2314,6 @@ show_poller(uint8_t current_page)
 
 	del_panel(poller_panel);
 	delwin(poller_win);
-
-	free_data();
 }
 
 static void
@@ -2354,6 +2349,27 @@ show_stats(void)
 			resize_interface(active_tab);
 		}
 
+		clock_gettime(CLOCK_REALTIME, &time_now);
+		time_dif = time_now.tv_sec - time_last;
+		if (time_dif < 0) {
+			time_dif = g_sleep_time;
+		}
+
+		if (time_dif >= g_sleep_time || force_refresh) {
+			time_last = time_now.tv_sec;
+			rc = get_data();
+			if (rc) {
+				mvprintw(g_max_row - 1, g_max_col - strlen(refresh_error) - 2, refresh_error);
+			}
+
+			max_pages = refresh_tab(active_tab, current_page);
+
+			snprintf(current_page_str, CURRENT_PAGE_STR_LEN - 1, "Page: %d/%d", current_page + 1, max_pages);
+			mvprintw(g_max_row - 1, 1, current_page_str);
+
+			refresh();
+		}
+
 		c = getch();
 		if (c == 'q') {
 			free_resources();
@@ -2432,30 +2448,8 @@ show_stats(void)
 			force_refresh = false;
 			break;
 		}
-
-		clock_gettime(CLOCK_REALTIME, &time_now);
-		time_dif = time_now.tv_sec - time_last;
-		if (time_dif < 0) {
-			time_dif = g_sleep_time;
-		}
-
-		if (time_dif >= g_sleep_time || force_refresh) {
-			time_last = time_now.tv_sec;
-			rc = get_data();
-			if (rc) {
-				mvprintw(g_max_row - 1, g_max_col - strlen(refresh_error) - 2, refresh_error);
-			}
-
-			max_pages = refresh_tab(active_tab, current_page);
-
-			snprintf(current_page_str, CURRENT_PAGE_STR_LEN - 1, "Page: %d/%d", current_page + 1, max_pages);
-			mvprintw(g_max_row - 1, 1, current_page_str);
-
-			free_data();
-
-			refresh();
-		}
 	}
+	free_data();
 }
 
 static void
-- 
2.26.2


From 081a4a09433a25fcaac5c726bdf4803454c6ea27 Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Fri, 23 Apr 2021 13:48:02 +0200
Subject: [PATCH 211/342] spdk_top: reduce number of global thread data
 structures

Deletes g_thread_history and g_thread_info to use g_threads_stats
across the whole application to simplify spdk_top code.
Now instead of separate struct, fields last_busy and last_idle are
being used.

get_data() function now uses local structure to get RPC data instead
of filling global one. This has been changed so that g_threads_stats
keeps its last_busy and last_idle fields unchanged.
free_rpc_threads_stats has been moved down so that in future patches,
when multithreading is implemented, there is no need to lock
g_threads_stats during RPC call.

Changes places of allocation/deallocation of g_threads_stats, since
we want to save last_idle and last_busy fields instead of zeroing them
out each application loop.

Changes show_thread() function to use local copy of threads array
instead of pointers to global struct. This is for the convenience
in the future patches implementing multithreading to avoid the need
to lock the global struct for details display.


Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: I0dc87eac4c1b89fa16f14f5387d94ee176dfdf43
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7587
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 app/spdk_top/spdk_top.c | 115 ++++++++++++++--------------------------
 1 file changed, 41 insertions(+), 74 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index 5fabce073..d03a1cf02 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -143,7 +143,6 @@ struct core_info {
 uint8_t g_sleep_time = 1;
 uint16_t g_selected_row;
 uint16_t g_max_selected_row;
-struct rpc_thread_info *g_thread_info[MAX_THREADS];
 const char *poller_type_str[SPDK_POLLER_TYPES_COUNT] = {"Active", "Timed", "Paused"};
 const char *g_tab_title[NUMBER_OF_TABS] = {"[1] THREADS", "[2] POLLERS", "[3] CORES"};
 struct spdk_jsonrpc_client *g_rpc_client;
@@ -277,7 +276,6 @@ struct rpc_threads_stats g_threads_stats;
 struct rpc_pollers_stats g_pollers_stats;
 struct rpc_cores_stats g_cores_stats;
 struct rpc_poller_info g_pollers_history[RPC_MAX_POLLERS];
-struct rpc_thread_info g_thread_history[RPC_MAX_THREADS];
 
 static void
 init_str_len(void)
@@ -551,46 +549,36 @@ rpc_send_req(char *rpc_name, struct spdk_jsonrpc_client_response **resp)
 static int
 sort_threads(const void *p1, const void *p2)
 {
-	const struct rpc_thread_info *thread_info1 = *(struct rpc_thread_info **)p1;
-	const struct rpc_thread_info *thread_info2 = *(struct rpc_thread_info **)p2;
+	const struct rpc_thread_info thread_info1 = *(struct rpc_thread_info *)p1;
+	const struct rpc_thread_info thread_info2 = *(struct rpc_thread_info *)p2;
 	uint64_t count1, count2;
 
-	/* thread IDs may not be allocated contiguously, so we need
-	 * to account for NULL thread_info pointers */
-	if (thread_info1 == NULL && thread_info2 == NULL) {
-		return 0;
-	} else if (thread_info1 == NULL) {
-		return 1;
-	} else if (thread_info2 == NULL) {
-		return -1;
-	}
-
 	switch (g_current_sort_col[THREADS_TAB]) {
 	case 0: /* Sort by name */
-		return strcmp(thread_info1->name, thread_info2->name);
+		return strcmp(thread_info1.name, thread_info2.name);
 	case 1: /* Sort by core */
-		count2 = thread_info1->core_num;
-		count1 = thread_info2->core_num;
+		count2 = thread_info1.core_num;
+		count1 = thread_info2.core_num;
 		break;
 	case 2: /* Sort by active pollers number */
-		count1 = thread_info1->active_pollers_count;
-		count2 = thread_info2->active_pollers_count;
+		count1 = thread_info1.active_pollers_count;
+		count2 = thread_info2.active_pollers_count;
 		break;
 	case 3: /* Sort by timed pollers number */
-		count1 = thread_info1->timed_pollers_count;
-		count2 = thread_info2->timed_pollers_count;
+		count1 = thread_info1.timed_pollers_count;
+		count2 = thread_info2.timed_pollers_count;
 		break;
 	case 4: /* Sort by paused pollers number */
-		count1 = thread_info1->paused_pollers_count;
-		count2 = thread_info2->paused_pollers_count;
+		count1 = thread_info1.paused_pollers_count;
+		count2 = thread_info2.paused_pollers_count;
 		break;
 	case 5: /* Sort by idle time */
-		count1 = thread_info1->idle - thread_info1->last_idle;
-		count2 = thread_info2->idle - thread_info2->last_idle;
+		count1 = thread_info1.idle - thread_info1.last_idle;
+		count2 = thread_info2.idle - thread_info2.last_idle;
 		break;
 	case 6: /* Sort by busy time */
-		count1 = thread_info1->busy - thread_info1->last_busy;
-		count2 = thread_info2->busy - thread_info2->last_busy;
+		count1 = thread_info1.busy - thread_info1.last_busy;
+		count2 = thread_info2.busy - thread_info2.last_busy;
 		break;
 	default:
 		return 0;
@@ -609,8 +597,8 @@ static int
 get_data(void)
 {
 	struct spdk_jsonrpc_client_response *json_resp = NULL;
-	struct rpc_thread_info *thread_info;
 	struct rpc_core_info *core_info;
+	struct rpc_threads_stats threads_stats;
 	uint64_t i, j;
 	int rc = 0;
 
@@ -619,23 +607,29 @@ get_data(void)
 		goto end;
 	}
 
-	/* Free old threads values before allocating memory for new ones */
-	free_rpc_threads_stats(&g_threads_stats);
-
 	/* Decode json */
-	memset(&g_threads_stats, 0, sizeof(g_threads_stats));
+	memset(&threads_stats, 0, sizeof(threads_stats));
 	if (spdk_json_decode_object(json_resp->result, rpc_threads_stats_decoders,
-				    SPDK_COUNTOF(rpc_threads_stats_decoders), &g_threads_stats)) {
+				    SPDK_COUNTOF(rpc_threads_stats_decoders), &threads_stats)) {
 		rc = -EINVAL;
 		goto end;
 	}
 
+	/* This is to free allocated char arrays with old thread names */
+	free_rpc_threads_stats(&g_threads_stats);
 	spdk_jsonrpc_client_free_response(json_resp);
 
-	for (i = 0; i < g_threads_stats.threads.threads_count; i++) {
-		thread_info = &g_threads_stats.threads.thread_info[i];
-		g_thread_info[thread_info->id] = thread_info;
+	for (i = 0; i < threads_stats.threads.threads_count; i++) {
+		for (j = 0; j < g_threads_stats.threads.threads_count; j++) {
+			if (g_threads_stats.threads.thread_info[j].id == threads_stats.threads.thread_info[i].id) {
+				threads_stats.threads.thread_info[i].last_busy = g_threads_stats.threads.thread_info[j].busy;
+				threads_stats.threads.thread_info[i].last_idle = g_threads_stats.threads.thread_info[j].idle;
+			}
+		}
 	}
+	memcpy(&g_threads_stats, &threads_stats, sizeof(struct rpc_threads_stats));
+	qsort(&g_threads_stats.threads.thread_info, threads_stats.threads.threads_count,
+	      sizeof(g_threads_stats.threads.thread_info[0]), sort_threads);
 
 	rc = rpc_send_req("thread_get_pollers", &json_resp);
 	if (rc) {
@@ -675,7 +669,7 @@ get_data(void)
 		core_info = &g_cores_stats.cores.core[i];
 
 		for (j = 0; j < core_info->threads.threads_count; j++) {
-			g_thread_info[core_info->threads.thread[j].id]->core_num = core_info->lcore;
+			g_threads_stats.threads.thread_info[j].core_num = core_info->lcore;
 		}
 	}
 
@@ -883,7 +877,7 @@ refresh_threads_tab(uint8_t current_page)
 {
 	struct col_desc *col_desc = g_col_desc[THREADS_TAB];
 	uint64_t i, threads_count;
-	uint16_t j, k;
+	uint16_t j;
 	uint16_t col;
 	uint8_t max_pages, item_index;
 	static uint8_t last_page = 0;
@@ -904,35 +898,16 @@ refresh_threads_tab(uint8_t current_page)
 		g_last_threads_count = threads_count;
 	}
 
-	/* From g_thread_info copy to thread_info without null elements.
-	 * The index of g_thread_info equals to Thread IDs, so it starts from '1'. */
-	for (i = 0, j = 1; i <  g_threads_stats.threads.threads_count; i++) {
-		while (g_thread_info[j] == NULL) {
-			j++;
-		}
-		memcpy(&thread_info[i], &g_thread_info[j], sizeof(struct rpc_thread_info *));
-		j++;
+	for (i = 0; i < threads_count; i++) {
+		thread_info[i] = &g_threads_stats.threads.thread_info[i];
 	}
 
 	if (last_page != current_page) {
-		for (i = 0; i < threads_count; i++) {
-			/* Thread IDs start from 1, so we have to do i + 1 */
-			g_threads_stats.threads.thread_info[i].last_idle = g_thread_info[i + 1]->idle;
-			g_threads_stats.threads.thread_info[i].last_busy = g_thread_info[i + 1]->busy;
-		}
-
 		last_page = current_page;
 	}
 
 	max_pages = (threads_count + g_max_data_rows - 1) / g_max_data_rows;
 
-	qsort(thread_info, threads_count, sizeof(thread_info[0]), sort_threads);
-
-	for (k = 0; k < threads_count; k++) {
-		g_thread_history[thread_info[k]->id].busy = thread_info[k]->busy - thread_info[k]->last_busy;
-		g_thread_history[thread_info[k]->id].idle = thread_info[k]->idle - thread_info[k]->last_idle;
-	}
-
 	for (i = current_page * g_max_data_rows;
 	     i < spdk_min(threads_count, (uint64_t)((current_page + 1) * g_max_data_rows));
 	     i++) {
@@ -976,7 +951,6 @@ refresh_threads_tab(uint8_t current_page)
 			col += col_desc[4].max_data_string + 2;
 		}
 
-		g_thread_history[thread_info[i]->id].idle = thread_info[i]->idle - thread_info[i]->last_idle;
 		if (!col_desc[5].disabled) {
 			if (g_interval_data == true) {
 				get_time_str(thread_info[i]->idle - thread_info[i]->last_idle, idle_time);
@@ -988,7 +962,6 @@ refresh_threads_tab(uint8_t current_page)
 			col += col_desc[5].max_data_string;
 		}
 
-		g_thread_history[thread_info[i]->id].busy = thread_info[i]->busy - thread_info[i]->last_busy;
 		if (!col_desc[6].disabled) {
 			if (g_interval_data == true) {
 				get_time_str(thread_info[i]->busy - thread_info[i]->last_busy, busy_time);
@@ -1004,11 +977,6 @@ refresh_threads_tab(uint8_t current_page)
 		}
 	}
 
-	for (k = 0; k < threads_count; k++) {
-		thread_info[k]->last_idle = thread_info[k]->idle;
-		thread_info[k]->last_busy = thread_info[k]->busy;
-	}
-
 	g_max_selected_row = i - current_page * g_max_data_rows - 1;
 
 	return max_pages;
@@ -2007,9 +1975,9 @@ display_thread(struct rpc_thread_info *thread_info)
 		  thread_info->core_num);
 
 	if (g_interval_data) {
-		get_time_str(g_thread_history[thread_info->id].idle, idle_time);
+		get_time_str(thread_info->idle - thread_info->last_idle, idle_time);
 		mvwprintw(thread_win, 3, THREAD_WIN_FIRST_COL + 32, idle_time);
-		get_time_str(g_thread_history[thread_info->id].busy, busy_time);
+		get_time_str(thread_info->busy - thread_info->last_busy, busy_time);
 		mvwprintw(thread_win, 3, THREAD_WIN_FIRST_COL + 54, busy_time);
 	} else {
 		get_time_str(thread_info->idle, idle_time);
@@ -2091,16 +2059,13 @@ display_thread(struct rpc_thread_info *thread_info)
 static void
 show_thread(uint8_t current_page)
 {
-	struct rpc_thread_info *thread_info[g_threads_stats.threads.threads_count];
+	struct rpc_thread_info thread_info;
 	uint64_t thread_number = current_page * g_max_data_rows + g_selected_row;
-	uint64_t i;
 
 	assert(thread_number < g_threads_stats.threads.threads_count);
-	for (i = 0; i < g_threads_stats.threads.threads_count; i++) {
-		thread_info[i] = &g_threads_stats.threads.thread_info[i];
-	}
+	thread_info = g_threads_stats.threads.thread_info[thread_number];
 
-	display_thread(thread_info[thread_number]);
+	display_thread(&thread_info);
 }
 
 static void
@@ -2335,6 +2300,8 @@ show_stats(void)
 	clock_gettime(CLOCK_REALTIME, &time_now);
 	time_last = time_now.tv_sec;
 
+	memset(&g_threads_stats, 0, sizeof(g_threads_stats));
+
 	switch_tab(THREADS_TAB);
 
 	while (1) {
-- 
2.26.2


From 39950bc8f9b242a10744f30aed2fd70e029ec7fa Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Mon, 17 May 2021 16:52:19 +0200
Subject: [PATCH 212/342] spdk_top: reduce number of poller global structures

Deletes g_pollers_history and store_pollers_last_stats() function
to simplify spdk_top code.

Adds last_run_counter to show_poller() function to get last state
of poller's run counter for comparision with current value and
display in pop-up window.

Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: I236fbcac31e67a617d37ba15888aeb30e3763e01
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7925
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 app/spdk_top/spdk_top.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index d03a1cf02..969d02844 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -275,7 +275,6 @@ struct rpc_cores_stats {
 struct rpc_threads_stats g_threads_stats;
 struct rpc_pollers_stats g_pollers_stats;
 struct rpc_cores_stats g_cores_stats;
-struct rpc_poller_info g_pollers_history[RPC_MAX_POLLERS];
 
 static void
 init_str_len(void)
@@ -1102,13 +1101,6 @@ copy_pollers(struct rpc_pollers *pollers, uint64_t pollers_count, enum spdk_poll
 	}
 }
 
-static void
-store_pollers_last_stats(uint64_t poller, uint64_t run_counter, uint64_t period_ticks_counter)
-{
-	g_pollers_history[poller].run_count = run_counter;
-	g_pollers_history[poller].period_ticks = period_ticks_counter;
-}
-
 static uint8_t
 prepare_poller_data(uint8_t current_page, struct rpc_poller_info **pollers,
 		    uint64_t *count, uint8_t last_page)
@@ -1212,7 +1204,6 @@ refresh_pollers_tab(uint8_t current_page)
 			col += col_desc[2].max_data_string + 1;
 		}
 
-		store_pollers_last_stats(i, pollers[i]->run_count - *last_run_counter, pollers[i]->period_ticks);
 		if (!col_desc[3].disabled) {
 			if (g_interval_data == true) {
 				snprintf(run_count, MAX_TIME_STR_LEN, "%" PRIu64, pollers[i]->run_count - *last_run_counter);
@@ -2208,6 +2199,7 @@ show_poller(uint8_t current_page)
 	PANEL *poller_panel;
 	WINDOW *poller_win;
 	uint64_t count = 0;
+	uint64_t *last_run_counter;
 	uint64_t poller_number = current_page * g_max_data_rows + g_selected_row;
 	struct rpc_poller_info *pollers[RPC_MAX_POLLERS];
 	bool stop_loop = false;
@@ -2217,6 +2209,10 @@ show_poller(uint8_t current_page)
 	prepare_poller_data(current_page, pollers, &count, current_page);
 	assert(poller_number < count);
 
+	last_run_counter = get_last_run_counter(pollers[poller_number]->name,
+						pollers[poller_number]->thread_id);
+	assert(last_run_counter != NULL);
+
 	poller_win = newwin(POLLER_WIN_HEIGHT, POLLER_WIN_WIDTH,
 			    get_position_for_window(POLLER_WIN_HEIGHT, g_max_row),
 			    get_position_for_window(POLLER_WIN_WIDTH, g_max_col));
@@ -2243,7 +2239,7 @@ show_poller(uint8_t current_page)
 
 	if (g_interval_data) {
 		mvwprintw(poller_win, 4, POLLER_WIN_FIRST_COL, "%" PRIu64,
-			  g_pollers_history[poller_number].run_count);
+			  pollers[poller_number]->run_count - *last_run_counter);
 	} else {
 		mvwprintw(poller_win, 4, POLLER_WIN_FIRST_COL, "%" PRIu64,
 			  pollers[poller_number]->run_count);
@@ -2251,7 +2247,7 @@ show_poller(uint8_t current_page)
 
 	if (pollers[poller_number]->period_ticks != 0) {
 		print_left(poller_win, 4, 28, POLLER_WIN_WIDTH, "Period:", COLOR_PAIR(5));
-		get_time_str(g_pollers_history[poller_number].period_ticks, poller_period);
+		get_time_str(pollers[poller_number]->period_ticks, poller_period);
 		mvwprintw(poller_win, 4, POLLER_WIN_FIRST_COL + 23, poller_period);
 	}
 	mvwhline(poller_win, 5, 1, ACS_HLINE, POLLER_WIN_WIDTH - 2);
-- 
2.26.2


From 49bc3005f528cfcdfa4eac98e3d328a4f7843a9d Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Wed, 19 May 2021 12:25:08 +0200
Subject: [PATCH 213/342] spdk_top: move store_last_run_counter() function

Moves store_last_run_counter() function to allow next patch to
call it earlier in the code, inside get_data() function.

Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: I1e37080ec86309bbf33442fa12cbe9dc575cc864
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7950
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 app/spdk_top/spdk_top.c | 48 ++++++++++++++++++++---------------------
 1 file changed, 24 insertions(+), 24 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index 969d02844..1235e8c7e 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -592,6 +592,30 @@ sort_threads(const void *p1, const void *p2)
 	}
 }
 
+static void
+store_last_run_counter(const char *poller_name, uint64_t thread_id, uint64_t last_run_counter)
+{
+	struct run_counter_history *history;
+
+	TAILQ_FOREACH(history, &g_run_counter_history, link) {
+		if (!strcmp(history->poller_name, poller_name) && history->thread_id == thread_id) {
+			history->last_run_counter = last_run_counter;
+			return;
+		}
+	}
+
+	history = calloc(1, sizeof(*history));
+	if (history == NULL) {
+		fprintf(stderr, "Unable to allocate a history object in store_last_run_counter.\n");
+		return;
+	}
+	history->poller_name = strdup(poller_name);
+	history->thread_id = thread_id;
+	history->last_run_counter = last_run_counter;
+
+	TAILQ_INSERT_TAIL(&g_run_counter_history, history, link);
+}
+
 static int
 get_data(void)
 {
@@ -995,30 +1019,6 @@ get_last_run_counter(const char *poller_name, uint64_t thread_id)
 	return NULL;
 }
 
-static void
-store_last_run_counter(const char *poller_name, uint64_t thread_id, uint64_t last_run_counter)
-{
-	struct run_counter_history *history;
-
-	TAILQ_FOREACH(history, &g_run_counter_history, link) {
-		if (!strcmp(history->poller_name, poller_name) && history->thread_id == thread_id) {
-			history->last_run_counter = last_run_counter;
-			return;
-		}
-	}
-
-	history = calloc(1, sizeof(*history));
-	if (history == NULL) {
-		fprintf(stderr, "Unable to allocate a history object in store_last_run_counter.\n");
-		return;
-	}
-	history->poller_name = strdup(poller_name);
-	history->thread_id = thread_id;
-	history->last_run_counter = last_run_counter;
-
-	TAILQ_INSERT_TAIL(&g_run_counter_history, history, link);
-}
-
 enum sort_type {
 	BY_NAME,
 	USE_GLOBAL,
-- 
2.26.2


From 6f9d1248886e635d51df3423ed5512d9c437e4c7 Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Wed, 19 May 2021 12:08:59 +0200
Subject: [PATCH 214/342] spdk_top: change where sore_last_run_counter() is
 called

Changes where store_last_run_function() is called. Before this patch
this function was used inside refresh_pollers_tab() and it overwrote
last run counters of each poller before show_poller() function had a
chance to use them. As a result poller details window was always
showing zeroes instead of actual difference in run count between each
application loop.

Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: I96219698f7f0b51b94ffe8c0d6bf40f73cbf8a82
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7951
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 app/spdk_top/spdk_top.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index 1235e8c7e..463e441f8 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -622,6 +622,8 @@ get_data(void)
 	struct spdk_jsonrpc_client_response *json_resp = NULL;
 	struct rpc_core_info *core_info;
 	struct rpc_threads_stats threads_stats;
+	struct rpc_pollers *pollers;
+	struct rpc_poller_info *poller;
 	uint64_t i, j;
 	int rc = 0;
 
@@ -659,6 +661,25 @@ get_data(void)
 		goto end;
 	}
 
+	/* Save last run counter of each poller before updating g_pollers_stats */
+	for (i = 0; i < g_pollers_stats.pollers_threads.threads_count; i++) {
+		pollers = &g_pollers_stats.pollers_threads.threads[i].active_pollers;
+		for (j = 0; j < pollers->pollers_count; j++) {
+			poller = &pollers->pollers[j];
+			store_last_run_counter(poller->name, poller->thread_id, poller->run_count);
+		}
+		pollers = &g_pollers_stats.pollers_threads.threads[i].timed_pollers;
+		for (j = 0; j < pollers->pollers_count; j++) {
+			poller = &pollers->pollers[j];
+			store_last_run_counter(poller->name, poller->thread_id, poller->run_count);
+		}
+		pollers = &g_pollers_stats.pollers_threads.threads[i].paused_pollers;
+		for (j = 0; j < pollers->pollers_count; j++) {
+			poller = &pollers->pollers[j];
+			store_last_run_counter(poller->name, poller->thread_id, poller->run_count);
+		}
+	}
+
 	/* Free old pollers values before allocating memory for new ones */
 	free_rpc_pollers_stats(&g_pollers_stats);
 
@@ -1224,8 +1245,6 @@ refresh_pollers_tab(uint8_t current_page)
 			col += col_desc[3].max_data_string + 4;
 		}
 
-		store_last_run_counter(pollers[i]->name, pollers[i]->thread_id, pollers[i]->run_count);
-
 		if (!col_desc[5].disabled) {
 			if (pollers[i]->busy_count > 0) {
 				if (item_index != g_selected_row) {
-- 
2.26.2


From 994be25fe1416c39f133a8090daccc33d7808fb4 Mon Sep 17 00:00:00 2001
From: Krzysztof Karas <krzysztof.karas@intel.com>
Date: Wed, 19 May 2021 14:17:20 +0200
Subject: [PATCH 215/342] spdk_top: move mvhline() function call inside
 show_core

Moves "mvwhline(core_win, 6, 1, ACS_HLINE, CORE_WIN_WIDTH - 2);"
upwards to increase readability by placing this call in order
(to print the line in 6th row after data in 5th row is done printing)

Signed-off-by: Krzysztof Karas <krzysztof.karas@intel.com>
Change-Id: Icec340231090aeb57c600f52b3c687dbc78cc4b9
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7959
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 app/spdk_top/spdk_top.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/app/spdk_top/spdk_top.c b/app/spdk_top/spdk_top.c
index 463e441f8..781084402 100644
--- a/app/spdk_top/spdk_top.c
+++ b/app/spdk_top/spdk_top.c
@@ -2153,6 +2153,7 @@ show_core(uint8_t current_page)
 		get_time_str(core_info[core_number]->busy, busy_time);
 	}
 	mvwprintw(core_win, 5, CORE_WIN_FIRST_COL + 20, idle_time);
+	mvwhline(core_win, 6, 1, ACS_HLINE, CORE_WIN_WIDTH - 2);
 
 	print_left(core_win, 7, 1, CORE_WIN_WIDTH, "Poller count:          Busy time:", COLOR_PAIR(5));
 	mvwprintw(core_win, 7, CORE_WIN_FIRST_COL, "%" PRIu64,
@@ -2160,7 +2161,6 @@ show_core(uint8_t current_page)
 
 	mvwprintw(core_win, 7, CORE_WIN_FIRST_COL + 20, busy_time);
 
-	mvwhline(core_win, 6, 1, ACS_HLINE, CORE_WIN_WIDTH - 2);
 	mvwhline(core_win, 8, 1, ACS_HLINE, CORE_WIN_WIDTH - 2);
 	print_left(core_win, 9, 1, CORE_WIN_WIDTH, "Threads on this core", COLOR_PAIR(5));
 
-- 
2.26.2


From 0c25e6fbbc51e5ee4a8f4e646d4e8c3b6e276788 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 16 Apr 2021 10:32:28 +0200
Subject: [PATCH 216/342] test/openstack: Clean up the test

This is done as part of the work to fix currently existing CI job
using this particular test suite.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Id5e9e8a814fb3025f192871650b8aa317f2de910
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7440
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Maciej Szwed <maciej.szwed@intel.com>
Reviewed-by: Maciej Wawryk <maciejx.wawryk@intel.com>
---
 test/openstack/install_devstack.sh    | 29 ++++++++++++++++++---------
 test/openstack/run_openstack_tests.sh |  8 ++++++--
 2 files changed, 26 insertions(+), 11 deletions(-)

diff --git a/test/openstack/install_devstack.sh b/test/openstack/install_devstack.sh
index 44772c903..c0e64da8d 100755
--- a/test/openstack/install_devstack.sh
+++ b/test/openstack/install_devstack.sh
@@ -2,6 +2,7 @@
 
 testdir=$(readlink -f $(dirname $0))
 rootdir=$(readlink -f $testdir/../..)
+source "$rootdir/test/common/autotest_common.sh"
 
 function usage() {
 	[[ -n $2 ]] && (
@@ -31,25 +32,35 @@ while getopts 'h-:' optchar; do
 	esac
 done
 
-cd /opt/stack/devstack
-su -c "./unstack.sh" -s /bin/bash stack
+if [[ -e /opt/stack/devstack/unstack.sh ]]; then
+	cd /opt/stack/devstack
+	su -c "./unstack.sh" -s /bin/bash stack
+fi
 
-cd /opt/stack
-rm -rf cinder devstack glance keystone heat horizon neutron nova placement requirements tacker tacker-horizon tempest
+mkdir -p /opt/stack
+rm -rf /opt/stack/*
 
 r=0
-until [[ $r -ge 20 ]]; do
+until ((++r >= 20)); do
 	if [[ $branch == "master" ]]; then
-		su -c "git clone --depth 1 https://opendev.org/openstack-dev/devstack" -s /bin/bash stack && break
+		git clone --depth 1 https://opendev.org/openstack-dev/devstack /opt/stack/devstack && break
 	else
-		su -c "git clone --depth 1 https://opendev.org/openstack-dev/devstack -b stable/$branch" -s /bin/bash stack && break
+		git clone --depth 1 https://opendev.org/openstack-dev/devstack -b "stable/$branch" /opt/stack/devstack && break
 	fi
-	r=$((r + 1))
 done
+
+# Check if we reached max retries count
+((r < 20))
+
+git clone https://github.com/openstack/os-brick.git /opt/stack/os-brick
+cd /opt/stack/os-brick
+python3 ./setup.py install
+
 cp $rootdir/scripts/vagrant/local.conf /opt/stack/devstack/local.conf
 
 cd /opt/stack/devstack
-sudo sed -i "s|http://download.cirros-cloud.net|https://download.cirros-cloud.net|g" stackrc
+./tools/create-stack-user.sh
+chown -R stack:stack /opt/stack
 su -c "./stack.sh" -s /bin/bash stack
 source openrc admin admin
 openstack volume type create SPDK --public
diff --git a/test/openstack/run_openstack_tests.sh b/test/openstack/run_openstack_tests.sh
index b96adafbc..781275f5e 100755
--- a/test/openstack/run_openstack_tests.sh
+++ b/test/openstack/run_openstack_tests.sh
@@ -3,11 +3,13 @@
 testdir=$(readlink -f $(dirname $0))
 rootdir=$(readlink -f $testdir/../..)
 rpc_py=$rootdir/scripts/rpc.py
+
+set -- "--iso" "--transport=rdma" "$@"
+
 source $rootdir/test/common/autotest_common.sh
 source $rootdir/test/nvmf/common.sh
-TEST_TRANSPORT='rdma'
 
-nvmftestinit
+HUGE_EVEN_ALLOC=yes HUGEMEM=1024 nvmftestinit
 
 function finish_test() {
 	{
@@ -41,6 +43,8 @@ sudo systemctl restart devstack@c-*
 sleep 10
 timing_exit restart_cinder
 
+rxe_cfg status
+
 # Start testing spdk with openstack using tempest (openstack tool that allow testing an openstack functionalities)
 # In this tests is checked if spdk can correctly cooperate with openstack spdk driver
 timing_enter tempest_tests
-- 
2.26.2


From 7bea0a074f28941724784c87971e082a5f7a7662 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 16 Apr 2021 10:34:43 +0200
Subject: [PATCH 217/342] scripts/vagrant: Create user netdev for openstack
 network

The openstack tests require to have one interface available under
specific ip, 10.0.2.15. This ip is a first lease VM receives from
the user network which is preconfigured in libvirt environment.

Use this instead of defining completely separate network which
by the very default will serve its own DHCP service as well. This
may result in a cosmetic issues (e.g. two ips, static one and
dynamic one on the interface) of having inconsistent config on the
VM depending on how the net device is configured by the underlying
distribution.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Ie3da26eebcfb0de668166c4a0120c65aec104540
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7441
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Maciej Szwed <maciej.szwed@intel.com>
Reviewed-by: Maciej Wawryk <maciejx.wawryk@intel.com>
---
 scripts/vagrant/Vagrantfile | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/scripts/vagrant/Vagrantfile b/scripts/vagrant/Vagrantfile
index 912786109..aab518e83 100644
--- a/scripts/vagrant/Vagrantfile
+++ b/scripts/vagrant/Vagrantfile
@@ -278,6 +278,14 @@ def setup_libvirt(config, vmcpu, vmram, distro)
       end
     }
 
+    # Add network interface for openstack tests
+    if ENV['SPDK_OPENSTACK_NETWORK'] == "1"
+      libvirt.qemuargs :value => "-device"
+      libvirt.qemuargs :value => "virtio-net,netdev=openstack.0"
+      libvirt.qemuargs :value => "-netdev"
+      libvirt.qemuargs :value => "user,id=openstack.0"
+    end
+
     if ENV['VAGRANT_HUGE_MEM'] == "1"
       libvirt.memorybacking :hugepages
     end
@@ -295,7 +303,6 @@ provider = (ENV['SPDK_VAGRANT_PROVIDER'] || "virtualbox")
 # Get all variables for creating vm
 vmcpu = (ENV['SPDK_VAGRANT_VMCPU'] || 2)
 vmram = (ENV['SPDK_VAGRANT_VMRAM'] || 4096)
-openstack_network = (ENV['SPDK_OPENSTACK_NETWORK'] || false)
 
 # generic/freebsd boxes do not work properly with vagrant-proxyconf and
 # have issues installing rsync and sshfs for syncing files. NFS is
@@ -319,10 +326,6 @@ Vagrant.configure(2) do |config|
   config.vm.box_check_update = false
   config.vm.synced_folder '.', '/vagrant', disabled: true
 
-  # Add network interface for openstack tests
-  if openstack_network == "1"
-    config.vm.network "private_network", ip: "10.0.2.15"
-  end
   # Copy in the .gitconfig if it exists
   copy_gitconfig(config)
 
-- 
2.26.2


From 119158cda827570dc6d19cd68d5357955f74fab2 Mon Sep 17 00:00:00 2001
From: Rajarshi Chowdhury <rajarshi.chowdhury@oracle.com>
Date: Fri, 16 Apr 2021 22:09:30 -0700
Subject: [PATCH 218/342] configure: Added --disable-apps option.

Together with options to disable examples, tests and unit-tests
this will enable us to build SPDK without linking any executables.

This is useful for packaging SPDK in applications - especially
those using own ENV.

Fixes #1877

Signed-off-by: Rajarshi Chowdhury <rajarshi.chowdhury@oracle.com>
Change-Id: I0467ec497d2abe2fad40cdb4ba723a240bee46d6
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7462
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 CONFIG    | 3 +++
 Makefile  | 3 ++-
 configure | 7 +++++++
 3 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/CONFIG b/CONFIG
index f464f440e..a4e76204d 100644
--- a/CONFIG
+++ b/CONFIG
@@ -76,6 +76,9 @@ CONFIG_UNIT_TESTS=y
 # Build examples
 CONFIG_EXAMPLES=y
 
+# Build apps
+CONFIG_APPS=y
+
 # Build with Control-flow Enforcement Technology (CET)
 CONFIG_CET=n
 
diff --git a/Makefile b/Makefile
index 2bff27ae3..617e656f1 100644
--- a/Makefile
+++ b/Makefile
@@ -40,8 +40,9 @@ include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 DIRS-y += lib
 DIRS-y += module
 DIRS-$(CONFIG_SHARED) += shared_lib
-DIRS-y += app include
+DIRS-y += include
 DIRS-$(CONFIG_EXAMPLES) += examples
+DIRS-$(CONFIG_APPS) += app
 DIRS-y += test
 DIRS-$(CONFIG_IPSEC_MB) += ipsecbuild
 DIRS-$(CONFIG_ISAL) += isalbuild
diff --git a/configure b/configure
index 95162e9b8..308eda2bc 100755
--- a/configure
+++ b/configure
@@ -35,6 +35,7 @@ function usage() {
 	echo " --disable-tests           Disable building of functional tests"
 	echo " --disable-unit-tests      Disable building of unit tests"
 	echo " --disable-examples        Disable building of examples"
+	echo " --disable-apps            Disable building of apps"
 	echo ""
 	echo "Specifying Dependencies:"
 	echo "--with-DEPENDENCY[=path]   Use the given dependency. Optionally, provide the"
@@ -265,6 +266,12 @@ for i in "$@"; do
 		--disable-examples)
 			CONFIG[EXAMPLES]=n
 			;;
+		--enable-apps)
+			CONFIG[APPS]=y
+			;;
+		--disable-apps)
+			CONFIG[APPS]=N
+			;;
 		--enable-werror)
 			CONFIG[WERROR]=y
 			;;
-- 
2.26.2


From ceaa0c7fa962ad4b286d0ad00bb6b777d2e750c6 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 27 Apr 2021 07:39:01 -0400
Subject: [PATCH 219/342] lib/blob: complete multiple persists

When blob persist starts, there can already be multiple
of such requests pending. It is possible to complete
a set of persists at once, if blob state after their
execution would be the same. This is the case when
persists are already pending when a particular persist
request is started.

This patch implements such mechanism by introducing
persists_to_complete queue, containing entries that
were previously queued up before starting the current
persist request. If there are any entries in this queue,
further requests are put into pending_persists.

When first request from persists_to_complete is persisted,
completions are issued for all requests on that queue at once.
If at that point there are any new entries on pending_persists,
all of them are put into persists_to_complete. Persist process is started
again with the first request from that queue.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I10063e55d6f821b1863de016d3148da6a719a422
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7643
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/blob/blobstore.c | 33 +++++++++++++++++++++------------
 lib/blob/blobstore.h |  1 +
 2 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/lib/blob/blobstore.c b/lib/blob/blobstore.c
index 225fa11db..3476bed13 100644
--- a/lib/blob/blobstore.c
+++ b/lib/blob/blobstore.c
@@ -300,6 +300,7 @@ blob_alloc(struct spdk_blob_store *bs, spdk_blob_id id)
 	TAILQ_INIT(&blob->xattrs);
 	TAILQ_INIT(&blob->xattrs_internal);
 	TAILQ_INIT(&blob->pending_persists);
+	TAILQ_INIT(&blob->persists_to_complete);
 
 	return blob;
 }
@@ -322,6 +323,7 @@ blob_free(struct spdk_blob *blob)
 {
 	assert(blob != NULL);
 	assert(TAILQ_EMPTY(&blob->pending_persists));
+	assert(TAILQ_EMPTY(&blob->persists_to_complete));
 
 	free(blob->active.extent_pages);
 	free(blob->clean.extent_pages);
@@ -1635,24 +1637,31 @@ blob_persist_complete_cb(void *arg)
 static void
 blob_persist_complete(spdk_bs_sequence_t *seq, struct spdk_blob_persist_ctx *ctx, int bserrno)
 {
-	struct spdk_blob_persist_ctx	*next_persist;
+	struct spdk_blob_persist_ctx	*next_persist, *tmp;
 	struct spdk_blob		*blob = ctx->blob;
 
 	if (bserrno == 0) {
 		blob_mark_clean(blob);
 	}
 
-	assert(ctx == TAILQ_FIRST(&blob->pending_persists));
-	TAILQ_REMOVE(&blob->pending_persists, ctx, link);
+	assert(ctx == TAILQ_FIRST(&blob->persists_to_complete));
 
-	next_persist = TAILQ_FIRST(&blob->pending_persists);
-
-	spdk_thread_send_msg(spdk_get_thread(), blob_persist_complete_cb, ctx);
+	/* Complete all persists that were pending when the current persist started */
+	TAILQ_FOREACH_SAFE(next_persist, &blob->persists_to_complete, link, tmp) {
+		TAILQ_REMOVE(&blob->persists_to_complete, next_persist, link);
+		spdk_thread_send_msg(spdk_get_thread(), blob_persist_complete_cb, next_persist);
+	}
 
-	if (next_persist != NULL) {
-		blob->state = SPDK_BLOB_STATE_DIRTY;
-		blob_persist_check_dirty(next_persist);
+	if (TAILQ_EMPTY(&blob->pending_persists)) {
+		return;
 	}
+
+	/* Queue up all pending persists for completion and start blob persist with first one */
+	TAILQ_SWAP(&blob->persists_to_complete, &blob->pending_persists, spdk_blob_persist_ctx, link);
+	next_persist = TAILQ_FIRST(&blob->persists_to_complete);
+
+	blob->state = SPDK_BLOB_STATE_DIRTY;
+	blob_persist_check_dirty(next_persist);
 }
 
 static void
@@ -2272,7 +2281,7 @@ blob_persist(spdk_bs_sequence_t *seq, struct spdk_blob *blob,
 
 	blob_verify_md_op(blob);
 
-	if (blob->state == SPDK_BLOB_STATE_CLEAN && TAILQ_EMPTY(&blob->pending_persists)) {
+	if (blob->state == SPDK_BLOB_STATE_CLEAN && TAILQ_EMPTY(&blob->persists_to_complete)) {
 		cb_fn(seq, cb_arg, 0);
 		return;
 	}
@@ -2289,11 +2298,11 @@ blob_persist(spdk_bs_sequence_t *seq, struct spdk_blob *blob,
 
 	/* Multiple blob persists can affect one another, via blob->state or
 	 * blob mutable data changes. To prevent it, queue up the persists. */
-	if (!TAILQ_EMPTY(&blob->pending_persists)) {
+	if (!TAILQ_EMPTY(&blob->persists_to_complete)) {
 		TAILQ_INSERT_TAIL(&blob->pending_persists, ctx, link);
 		return;
 	}
-	TAILQ_INSERT_HEAD(&blob->pending_persists, ctx, link);
+	TAILQ_INSERT_HEAD(&blob->persists_to_complete, ctx, link);
 
 	blob_persist_check_dirty(ctx);
 }
diff --git a/lib/blob/blobstore.h b/lib/blob/blobstore.h
index 0c308ebed..950536c2e 100644
--- a/lib/blob/blobstore.h
+++ b/lib/blob/blobstore.h
@@ -168,6 +168,7 @@ struct spdk_blob {
 
 	/* A list of pending metadata pending_persists */
 	TAILQ_HEAD(, spdk_blob_persist_ctx) pending_persists;
+	TAILQ_HEAD(, spdk_blob_persist_ctx) persists_to_complete;
 
 	/* Number of data clusters retrived from extent table,
 	 * that many have to be read from extent pages. */
-- 
2.26.2


From 1180c390c1c258b1c4611bc79fb70c65b5a453b9 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Wed, 19 May 2021 07:17:57 -0400
Subject: [PATCH 220/342] lib/thread: fix iterating over paused pollers

(cd83ea4a)thread: Add SPDK internal APIs spdk_thread_get_first/next_active/timed/paused_poller()
Patch above by mistake iterates over active_pollers list
for function that lists paused pollers.

Fixes #1947

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I1b69d942675f34f5f046ec46feacc8d81d89f015
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7952
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/thread/thread.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index c07fbe15d..3cee7de00 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -1703,7 +1703,7 @@ spdk_thread_get_next_timed_poller(struct spdk_poller *prev)
 struct spdk_poller *
 spdk_thread_get_first_paused_poller(struct spdk_thread *thread)
 {
-	return TAILQ_FIRST(&thread->active_pollers);
+	return TAILQ_FIRST(&thread->paused_pollers);
 }
 
 struct spdk_poller *
-- 
2.26.2


From d33f44866d8ba73a65571bf0c42d60fd76a39d6b Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Sat, 22 May 2021 00:14:28 +0800
Subject: [PATCH 221/342] rbd: Fix the name comparison bug.

Checked the definition of strncmp. If substring s1
is found in strnmp(s1, s2, len), then it will return 0.

For the len value, it is better to use strcmp. Otherwise,
if s1=cluster1, s2=cluster & len=strlen(s2),
strncmp will return 0. But they are two different strings. For
cluster names, they are different.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: I15a06184d834cd1567b329d0322cd6bdea6fee4b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7991
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/rbd/bdev_rbd.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/module/bdev/rbd/bdev_rbd.c b/module/bdev/rbd/bdev_rbd.c
index ff981cb4e..c46d3fb22 100644
--- a/module/bdev/rbd/bdev_rbd.c
+++ b/module/bdev/rbd/bdev_rbd.c
@@ -256,7 +256,7 @@ bdev_rbd_get_cluster(const char *cluster_name, rados_t **cluster)
 
 	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
 	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
-		if (strncmp(cluster_name, entry->name, strlen(entry->name)) == 0) {
+		if (strcmp(cluster_name, entry->name) == 0) {
 			entry->ref++;
 			*cluster = &entry->cluster;
 			pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
@@ -692,7 +692,7 @@ bdev_rbd_cluster_dump_entry(const char *cluster_name, struct spdk_json_write_ctx
 
 	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
 	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
-		if (strncmp(cluster_name, entry->name, strlen(entry->name))) {
+		if (strcmp(cluster_name, entry->name)) {
 			continue;
 		}
 		if (entry->user_id) {
@@ -808,7 +808,7 @@ rbd_register_cluster(const char *name, const char *user_id, const char *const *c
 
 	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
 	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
-		if (strncmp(name, entry->name, strlen(entry->name)) == 0) {
+		if (strcmp(name, entry->name) == 0) {
 			SPDK_ERRLOG("Cluster name=%s already exists\n", name);
 			pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
 			return -1;
@@ -907,7 +907,7 @@ bdev_rbd_unregister_cluster(const char *name)
 
 	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
 	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
-		if (strncmp(name, entry->name, strlen(entry->name)) == 0) {
+		if (strcmp(name, entry->name) == 0) {
 			if (entry->ref == 0) {
 				STAILQ_REMOVE(&g_map_bdev_rbd_cluster, entry, bdev_rbd_cluster, link);
 				rados_shutdown(entry->cluster);
-- 
2.26.2


From 15ae31fb0c43d52d343ea445041fe2f137293480 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Mon, 10 May 2021 15:25:48 -0700
Subject: [PATCH 222/342] nvmf: Rearrange spdk_nvmf_requset for cache line
 locality

Get all of the hot stuff to the first cache line.

* Shrink the xfer enum to one byte (it only has 3 values).
* Pull out the dif enabled flag form the dif structure so it
  can be access separately
* Rearrange the members

Change-Id: Id4a2fe90a49c055a4672642faac0028671ebfae9
Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7827
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 include/spdk/nvmf_transport.h       | 19 +++++++++++--------
 lib/nvmf/rdma.c                     | 14 +++++++-------
 lib/nvmf/tcp.c                      | 18 +++++++++---------
 test/unit/lib/nvmf/rdma.c/rdma_ut.c | 18 +++++++++---------
 4 files changed, 36 insertions(+), 33 deletions(-)

diff --git a/include/spdk/nvmf_transport.h b/include/spdk/nvmf_transport.h
index b09eb04b2..10952f560 100644
--- a/include/spdk/nvmf_transport.h
+++ b/include/spdk/nvmf_transport.h
@@ -74,7 +74,6 @@ SPDK_STATIC_ASSERT(sizeof(union nvmf_c2h_msg) == 16, "Incorrect size");
 
 struct spdk_nvmf_dif_info {
 	struct spdk_dif_ctx			dif_ctx;
-	bool					dif_insert_or_strip;
 	uint32_t				elba_length;
 	uint32_t				orig_length;
 };
@@ -82,23 +81,27 @@ struct spdk_nvmf_dif_info {
 struct spdk_nvmf_request {
 	struct spdk_nvmf_qpair		*qpair;
 	uint32_t			length;
-	enum spdk_nvme_data_transfer	xfer;
+	uint8_t				xfer; /* type enum spdk_nvme_data_transfer */
+	bool				data_from_pool;
+	bool				dif_enabled;
 	void				*data;
 	union nvmf_h2c_msg		*cmd;
 	union nvmf_c2h_msg		*rsp;
-	void				*buffers[NVMF_REQ_MAX_BUFFERS];
-	struct iovec			iov[NVMF_REQ_MAX_BUFFERS];
+	STAILQ_ENTRY(spdk_nvmf_request)	buf_link;
+	uint64_t			timeout_tsc;
+
 	uint32_t			iovcnt;
-	bool				data_from_pool;
-	struct spdk_bdev_io_wait_entry	bdev_io_wait;
+	struct iovec			iov[NVMF_REQ_MAX_BUFFERS];
+	void				*buffers[NVMF_REQ_MAX_BUFFERS];
+
 	struct spdk_nvmf_dif_info	dif;
+
+	struct spdk_bdev_io_wait_entry	bdev_io_wait;
 	spdk_nvmf_nvme_passthru_cmd_cb	cmd_cb_fn;
 	struct spdk_nvmf_request	*first_fused_req;
 	struct spdk_nvmf_request	*req_to_abort;
 	struct spdk_poller		*poller;
-	uint64_t			timeout_tsc;
 
-	STAILQ_ENTRY(spdk_nvmf_request)	buf_link;
 	TAILQ_ENTRY(spdk_nvmf_request)	link;
 };
 
diff --git a/lib/nvmf/rdma.c b/lib/nvmf/rdma.c
index 9d45fc89a..b2f2d4415 100644
--- a/lib/nvmf/rdma.c
+++ b/lib/nvmf/rdma.c
@@ -1451,7 +1451,7 @@ nvmf_rdma_fill_wr_sgl(struct spdk_nvmf_rdma_poll_group *rgroup,
 	uint32_t lkey, remaining;
 	int rc;
 
-	if (spdk_unlikely(rdma_req->req.dif.dif_insert_or_strip)) {
+	if (spdk_unlikely(rdma_req->req.dif_enabled)) {
 		dif_ctx = &rdma_req->req.dif.dif_ctx;
 		remaining_data_block = dif_ctx->block_size - dif_ctx->md_size;
 	}
@@ -1590,7 +1590,7 @@ nvmf_rdma_request_fill_iovs(struct spdk_nvmf_rdma_transport *rtransport,
 
 	rdma_req->iovpos = 0;
 
-	if (spdk_unlikely(req->dif.dif_insert_or_strip)) {
+	if (spdk_unlikely(req->dif_enabled)) {
 		num_wrs = nvmf_rdma_calc_num_wrs(length, rtransport->transport.opts.io_unit_size,
 						 req->dif.dif_ctx.block_size);
 		if (num_wrs > 1) {
@@ -1649,7 +1649,7 @@ nvmf_rdma_request_fill_iovs_multi_sgl(struct spdk_nvmf_rdma_transport *rtranspor
 
 	desc = (struct spdk_nvme_sgl_descriptor *)rdma_req->recv->buf + inline_segment->address;
 	for (i = 0; i < num_sgl_descriptors; i++) {
-		if (spdk_likely(!req->dif.dif_insert_or_strip)) {
+		if (spdk_likely(!req->dif_enabled)) {
 			lengths[i] = desc->keyed.length;
 		} else {
 			req->dif.orig_length += desc->keyed.length;
@@ -1763,7 +1763,7 @@ nvmf_rdma_request_parse_sgl(struct spdk_nvmf_rdma_transport *rtransport,
 		/* fill request length and populate iovs */
 		req->length = length;
 
-		if (spdk_unlikely(req->dif.dif_insert_or_strip)) {
+		if (spdk_unlikely(req->dif_enabled)) {
 			req->dif.orig_length = length;
 			length = spdk_dif_get_length_with_md(length, &req->dif.dif_ctx);
 			req->dif.elba_length = length;
@@ -1936,7 +1936,7 @@ nvmf_rdma_request_process(struct spdk_nvmf_rdma_transport *rtransport,
 			}
 
 			if (spdk_unlikely(spdk_nvmf_request_get_dif_ctx(&rdma_req->req, &rdma_req->req.dif.dif_ctx))) {
-				rdma_req->req.dif.dif_insert_or_strip = true;
+				rdma_req->req.dif_enabled = true;
 			}
 
 #ifdef SPDK_CONFIG_RDMA_SEND_WITH_INVAL
@@ -2039,7 +2039,7 @@ nvmf_rdma_request_process(struct spdk_nvmf_rdma_transport *rtransport,
 			spdk_trace_record(TRACE_RDMA_REQUEST_STATE_READY_TO_EXECUTE, 0, 0,
 					  (uintptr_t)rdma_req, (uintptr_t)rqpair->cm_id);
 
-			if (spdk_unlikely(rdma_req->req.dif.dif_insert_or_strip)) {
+			if (spdk_unlikely(rdma_req->req.dif_enabled)) {
 				if (rdma_req->req.xfer == SPDK_NVME_DATA_HOST_TO_CONTROLLER) {
 					/* generate DIF for write operation */
 					num_blocks = SPDK_CEIL_DIV(rdma_req->req.dif.elba_length, rdma_req->req.dif.dif_ctx.block_size);
@@ -2079,7 +2079,7 @@ nvmf_rdma_request_process(struct spdk_nvmf_rdma_transport *rtransport,
 			} else {
 				rdma_req->state = RDMA_REQUEST_STATE_READY_TO_COMPLETE;
 			}
-			if (spdk_unlikely(rdma_req->req.dif.dif_insert_or_strip)) {
+			if (spdk_unlikely(rdma_req->req.dif_enabled)) {
 				/* restore the original length */
 				rdma_req->req.length = rdma_req->req.dif.orig_length;
 
diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index 8409f38b3..3dadbaed0 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -380,7 +380,7 @@ nvmf_tcp_req_get(struct spdk_nvmf_tcp_qpair *tqpair)
 	memset(&tcp_req->rsp, 0, sizeof(tcp_req->rsp));
 	tcp_req->h2c_offset = 0;
 	tcp_req->has_incapsule_data = false;
-	tcp_req->req.dif.dif_insert_or_strip = false;
+	tcp_req->req.dif_enabled = false;
 
 	TAILQ_REMOVE(&tqpair->tcp_req_free_queue, tcp_req, state_link);
 	TAILQ_INSERT_TAIL(&tqpair->tcp_req_working_queue, tcp_req, state_link);
@@ -1464,7 +1464,7 @@ nvmf_tcp_h2c_data_hdr_handle(struct spdk_nvmf_tcp_transport *ttransport,
 
 	pdu->req = tcp_req;
 
-	if (spdk_unlikely(tcp_req->req.dif.dif_insert_or_strip)) {
+	if (spdk_unlikely(tcp_req->req.dif_enabled)) {
 		pdu->dif_ctx = &tcp_req->req.dif.dif_ctx;
 	}
 
@@ -2110,7 +2110,7 @@ nvmf_tcp_req_parse_sgl(struct spdk_nvmf_tcp_req *tcp_req,
 
 		SPDK_DEBUGLOG(nvmf_tcp, "Data requested length= 0x%x\n", length);
 
-		if (spdk_unlikely(req->dif.dif_insert_or_strip)) {
+		if (spdk_unlikely(req->dif_enabled)) {
 			req->dif.orig_length = length;
 			length = spdk_dif_get_length_with_md(length, &req->dif.dif_ctx);
 			req->dif.elba_length = length;
@@ -2175,7 +2175,7 @@ nvmf_tcp_req_parse_sgl(struct spdk_nvmf_tcp_req *tcp_req,
 		req->length = length;
 		req->data_from_pool = false;
 
-		if (spdk_unlikely(req->dif.dif_insert_or_strip)) {
+		if (spdk_unlikely(req->dif_enabled)) {
 			length = spdk_dif_get_length_with_md(length, &req->dif.dif_ctx);
 			req->dif.elba_length = length;
 		}
@@ -2268,7 +2268,7 @@ _nvmf_tcp_send_c2h_data(struct spdk_nvmf_tcp_qpair *tqpair,
 
 	c2h_data->common.plen = plen;
 
-	if (spdk_unlikely(tcp_req->req.dif.dif_insert_or_strip)) {
+	if (spdk_unlikely(tcp_req->req.dif_enabled)) {
 		rsp_pdu->dif_ctx = &tcp_req->req.dif.dif_ctx;
 	}
 
@@ -2283,7 +2283,7 @@ _nvmf_tcp_send_c2h_data(struct spdk_nvmf_tcp_qpair *tqpair,
 		c2h_data->common.flags |= SPDK_NVME_TCP_C2H_DATA_FLAGS_SUCCESS;
 	}
 
-	if (spdk_unlikely(tcp_req->req.dif.dif_insert_or_strip)) {
+	if (spdk_unlikely(tcp_req->req.dif_enabled)) {
 		struct spdk_nvme_cpl *rsp = &tcp_req->req.rsp->nvme_cpl;
 		struct spdk_dif_error err_blk = {};
 		uint32_t mapped_length = 0;
@@ -2441,7 +2441,7 @@ nvmf_tcp_req_process(struct spdk_nvmf_tcp_transport *ttransport,
 			tcp_req->cmd = tqpair->pdu_in_progress->hdr.capsule_cmd.ccsqe;
 
 			if (spdk_unlikely(spdk_nvmf_request_get_dif_ctx(&tcp_req->req, &tcp_req->req.dif.dif_ctx))) {
-				tcp_req->req.dif.dif_insert_or_strip = true;
+				tcp_req->req.dif_enabled = true;
 				tqpair->pdu_in_progress->dif_ctx = &tcp_req->req.dif.dif_ctx;
 			}
 
@@ -2542,7 +2542,7 @@ nvmf_tcp_req_process(struct spdk_nvmf_tcp_transport *ttransport,
 		case TCP_REQUEST_STATE_READY_TO_EXECUTE:
 			spdk_trace_record(TRACE_TCP_REQUEST_STATE_READY_TO_EXECUTE, 0, 0, (uintptr_t)tcp_req, 0);
 
-			if (spdk_unlikely(tcp_req->req.dif.dif_insert_or_strip)) {
+			if (spdk_unlikely(tcp_req->req.dif_enabled)) {
 				assert(tcp_req->req.dif.elba_length >= tcp_req->req.length);
 				tcp_req->req.length = tcp_req->req.dif.elba_length;
 			}
@@ -2558,7 +2558,7 @@ nvmf_tcp_req_process(struct spdk_nvmf_tcp_transport *ttransport,
 		case TCP_REQUEST_STATE_EXECUTED:
 			spdk_trace_record(TRACE_TCP_REQUEST_STATE_EXECUTED, 0, 0, (uintptr_t)tcp_req, 0);
 
-			if (spdk_unlikely(tcp_req->req.dif.dif_insert_or_strip)) {
+			if (spdk_unlikely(tcp_req->req.dif_enabled)) {
 				tcp_req->req.length = tcp_req->req.dif.orig_length;
 			}
 
diff --git a/test/unit/lib/nvmf/rdma.c/rdma_ut.c b/test/unit/lib/nvmf/rdma.c/rdma_ut.c
index f1e6ff6cd..f81a56f50 100644
--- a/test/unit/lib/nvmf/rdma.c/rdma_ut.c
+++ b/test/unit/lib/nvmf/rdma.c/rdma_ut.c
@@ -913,7 +913,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = data_bs * 8;
 	sgl->keyed.length = data_bs * 4;
 
@@ -943,7 +943,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = data_bs * 4;
 	sgl->keyed.length = data_bs * 4;
 
@@ -980,7 +980,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = data_bs;
 	sgl->keyed.length = data_bs;
 
@@ -1015,7 +1015,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = (data_bs + md_size) * 4;
 	sgl->keyed.length = data_bs * 4;
 
@@ -1045,7 +1045,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = (data_bs + md_size) * 2;
 	sgl->keyed.length = data_bs * 4;
 
@@ -1078,7 +1078,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = data_bs * 4;
 	sgl->keyed.length = data_bs * 6;
 
@@ -1126,7 +1126,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = data_bs * 16;
 	sgl->keyed.length = data_bs * 16;
 
@@ -1169,7 +1169,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1, SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK,
 			  0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = 516;
 	sgl->keyed.length = data_bs * 2;
 
@@ -1210,7 +1210,7 @@ test_spdk_nvmf_rdma_request_parse_sgl_with_md(void)
 	spdk_dif_ctx_init(&rdma_req.req.dif.dif_ctx, data_bs + md_size, md_size, true, false,
 			  SPDK_DIF_TYPE1,
 			  SPDK_DIF_FLAGS_GUARD_CHECK | SPDK_DIF_FLAGS_REFTAG_CHECK, 0, 0, 0, 0, 0);
-	rdma_req.req.dif.dif_insert_or_strip = true;
+	rdma_req.req.dif_enabled = true;
 	rtransport.transport.opts.io_unit_size = (data_bs + md_size) * 4;
 	sgl->unkeyed.length = 2 * sizeof(struct spdk_nvme_sgl_descriptor);
 
-- 
2.26.2


From 022ecaa7f1c070e83a7be0cf39fc63fd88e1297b Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Thu, 20 May 2021 20:20:38 +0200
Subject: [PATCH 223/342] vm_setup: Don't fail on freebsd if etc_os-release
 package is missing

This package is not available under latest 13.0 release, however,
the /etc/os-release we are looking for is already installed there.
For older versions, and in case this package is missing, we still
can determine that we are running under freebsd as part of the
fallback check to uname().

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I6a04eb66392d91899a4b55d4eb508bef140e924a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7985
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/common/config/pkgdep/pkg  | 1 -
 test/common/config/vm_setup.sh | 6 ------
 2 files changed, 7 deletions(-)

diff --git a/test/common/config/pkgdep/pkg b/test/common/config/pkgdep/pkg
index 170c7aaf6..3f3f41725 100644
--- a/test/common/config/pkgdep/pkg
+++ b/test/common/config/pkgdep/pkg
@@ -11,7 +11,6 @@ install() {
 }
 
 packages=(
-	etc_os-release
 	pciutils
 	jq
 	gdb
diff --git a/test/common/config/vm_setup.sh b/test/common/config/vm_setup.sh
index 6ee58e788..59dbff6a7 100755
--- a/test/common/config/vm_setup.sh
+++ b/test/common/config/vm_setup.sh
@@ -57,12 +57,6 @@ function error() {
 }
 
 function set_os_id_version() {
-	if [[ $(uname -s) == FreeBSD ]] && ! pkg info -q etc_os-release; then
-		echo "Please install 'etc_os-release' package" >&2
-		echo "pkg install -y etc_os-release" >&2
-		exit 2
-	fi
-
 	if [[ -f /etc/os-release ]]; then
 		source /etc/os-release
 	elif [[ -f /usr/local/etc/os-release ]]; then
-- 
2.26.2


From f8d6541d04873a98fe6a13e04cf07ea153b47a7d Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Thu, 20 May 2021 23:16:24 +0200
Subject: [PATCH 224/342] freebsd: Replace use of \s with [[:space:]]

In latest 13.0 release of freebsd sed is not accepting \s anymore,
hence it needs to be replaced. Note that only parts of the repo
which are touched by freebsd during the tests are updated.

Details https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=253893

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I217208511af8f98e7033f8f24a343b5ca9c48825
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7986
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 configure          | 4 ++--
 dpdkbuild/Makefile | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/configure b/configure
index 308eda2bc..7d063f4ef 100755
--- a/configure
+++ b/configure
@@ -852,7 +852,7 @@ if (($(grep -cE "^\s*CONFIG_[[:alnum:]_]+=" "$rootdir/CONFIG") != ${#CONFIG[@]})
 	echo "BUG: Some configuration options are not present in CONFIG file. Please update this file."
 	echo "Missing options in CONFIG (+) file and in current config (-): "
 	diff -u --label "CONFIG file" --label "CONFIG[@]" \
-		<(sed -r -e '/^\s*$/d; /^\s*#.*/d; s/(CONFIG_[[:alnum:]_]+)=.*/\1/g' CONFIG | sort) \
+		<(sed -r -e '/^[[:space:]]*$/d; /^[[:space:]]*#.*/d; s/(CONFIG_[[:alnum:]_]+)=.*/\1/g' CONFIG | sort) \
 		<(printf "CONFIG_%s\n" "${!CONFIG[@]}" | sort)
 	exit 1
 fi
@@ -860,7 +860,7 @@ fi
 echo -n "Creating mk/config.mk..."
 cp -f $rootdir/CONFIG $rootdir/mk/config.mk
 for key in "${!CONFIG[@]}"; do
-	sed -i.bak -r "s#^\s*CONFIG_${key}=.*#CONFIG_${key}\?=${CONFIG[$key]}#g" $rootdir/mk/config.mk
+	sed -i.bak -r "s#[[:space:]]*CONFIG_${key}=.*#CONFIG_${key}\?=${CONFIG[$key]}#g" $rootdir/mk/config.mk
 done
 # On FreeBSD sed -i 'SUFFIX' - SUFFIX is mandatory. So no way but to delete the backed file.
 rm -f $rootdir/mk/config.mk.bak
diff --git a/dpdkbuild/Makefile b/dpdkbuild/Makefile
index b540d2fa0..d4af3a0a4 100644
--- a/dpdkbuild/Makefile
+++ b/dpdkbuild/Makefile
@@ -137,7 +137,7 @@ ifeq ($(MAKE_PID),)
 MAKE_PID := $(shell echo $$PPID)
 endif
 
-MAKE_NUMJOBS := $(shell ps T | sed -nE 's/\s*$(MAKE_PID)\s.* (-j|--jobs=)( *[0-9]+).*/\1\2/p')
+MAKE_NUMJOBS := $(shell ps T | sed -nE 's/[[:space:]]*$(MAKE_PID)[[:space:]].* (-j|--jobs=)( *[0-9]+).*/\1\2/p')
 
 all: $(SPDK_ROOT_DIR)/dpdk/build-tmp
 	$(Q)# DPDK doesn't handle nested make calls, so unset MAKEFLAGS
-- 
2.26.2


From ef68667a824185a6fc0b2d4eb395560f44507f21 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 21 May 2021 00:01:45 +0200
Subject: [PATCH 225/342] pkgdep/git: Remove 20.01 release workarounds

There's already a new LTS release in place, hence these workarounds
are not needed anymore.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Idf597a5cf8da18d75f2630d59a277d4545fadc0f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7987
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/common/config/pkgdep/git | 44 ++---------------------------------
 1 file changed, 2 insertions(+), 42 deletions(-)

diff --git a/test/common/config/pkgdep/git b/test/common/config/pkgdep/git
index c1ebea43a..b5c8d1d8e 100644
--- a/test/common/config/pkgdep/git
+++ b/test/common/config/pkgdep/git
@@ -37,35 +37,9 @@ function install_refspdk() {
 		cp -R "$GIT_REPOS/spdk_repo/spdk" "$output_dir"
 	fi
 
-	lts_2001_fallback=false
-	if [[ "$release" == v20.01* ]]; then
-		# We switch to a .x branch in order to slurp all the backports which fix spdk_abi_lts
-		# build for this particular release. Fetch the branch explicitly as in case of our CI,
-		# jenkins will set remote.*.fetch to a particular ref the build run against, so plain
-		# git fetch won't include any branches from the repo. FIXME: This could be removed
-		# after new LTS is in place.
-		release=${release%%-*}.x
-		git -C "$output_dir" fetch origin "+refs/heads/$release:refs/heads/$release"
-		lts_2001_fallback=true
-	fi
 	git -C "$output_dir" checkout "$release"
 	git -C "$output_dir" submodule update --init
 
-	if [[ "$release" == v20.01* ]]; then
-		makefiles=(
-			"$output_dir/dpdk/drivers/crypto/aesni_gcm/Makefile"
-			"$output_dir/dpdk/drivers/crypto/aesni_mb/Makefile"
-			"$output_dir/dpdk/drivers/crypto/kasumi/Makefile"
-			"$output_dir/dpdk/drivers/crypto/snow3g/Makefile"
-		)
-		# Attempt to replicate dpdk's 2a860943b8 commit which fixes builds under make 4.3
-		# FIXME: Remove this when LTS changes!
-		for makefile in "${makefiles[@]}"; do
-			# This sed call is meant to be compatible with its FreeBSD implementation
-			echo "$(sed -e 's/\\#/\$H/g' -e '/IMB_HDR =/i\
-				H := \\#' "$makefile")" > "$makefile"
-		done
-	fi
 	cat > $HOME/autorun-spdk.conf <<- EOF
 		SPDK_BUILD_SHARED_OBJECT=1
 		SPDK_TEST_AUTOBUILD=1
@@ -99,25 +73,11 @@ function install_refspdk() {
 		if [[ $OSID == freebsd ]]; then
 			config_params="--enable-debug"
 			config_params+=" --without-isal --with-fio=/usr/src/fio"
-
-			# TODO: Remove this if-block after 21.01 LTS is released and 20.01 LTS is deprecated.
-			if ! "$lts_2001_fallback"; then
-				config_params+=" --with-idxd --disable-unit-tests"
-			fi
+			config_params+=" --with-idxd --disable-unit-tests"
 
 			MAKE=gmake
 		else
-			# TODO: "get_config_params" was not available in 20.01 LTS release.
-			# Remove this if-block after 21.01 release.
-			if "$lts_2001_fallback"; then
-				config_params="--enable-debug --enable-werror --with-rdma"
-				config_params+=" --with-fio=/usr/src/fio --with-iscsi-initiator"
-				config_params+=" --with-nvme-cuse --with-pmdk --with-reduce"
-				config_params+=" --with-rbd --with-crypto --with-ocf --enable-ubsan"
-				config_params+=" --enable-asan --with-fuse --with-uring"
-			else
-				config_params="$(get_config_params)"
-			fi
+			config_params="$(get_config_params)"
 		fi
 		$output_dir/configure $(echo $config_params | sed 's/--enable-coverage//g')
 		if [[ $OSID != freebsd ]]; then
-- 
2.26.2


From 6c1a1a3dcac557f7bce0267f59311ea98e435eef Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 21 May 2021 19:50:08 +0200
Subject: [PATCH 226/342] scripts/rpc: Make sure address argument is properly
 interpreted

In case the addr argument was not an existing unix socket file the rpc
client would consider it to be an actual ip address. As a result
connect() would be called with improper set of arguments. This could
cause the rpc.py to block for undesired amount of time until connect()
finally decided to return (seen on some fedora33 builds).

This was affecting sh wrapper functions like waitforlisten() which
use rpc.py to determine if given app is ready to be talk to blocking
execution of the tests for way too long then intendent.

To avoid such a scenario determine the format of the address and use
routines proper for given address family.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Iaac701d72c772629fa7c6478ff4781b0c5d485d5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7777
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
---
 scripts/rpc/client.py | 43 ++++++++++++++++++++++++++++++-------------
 1 file changed, 30 insertions(+), 13 deletions(-)

diff --git a/scripts/rpc/client.py b/scripts/rpc/client.py
index f84a1cf00..caecda144 100644
--- a/scripts/rpc/client.py
+++ b/scripts/rpc/client.py
@@ -14,6 +14,22 @@ def print_json(s):
     print(json.dumps(s, indent=2).strip('"'))
 
 
+def get_addr_type(addr):
+    try:
+        socket.inet_pton(socket.AF_INET, addr)
+        return socket.AF_INET
+    except Exception as e:
+        pass
+    try:
+        socket.inet_pton(socket.AF_INET6, addr)
+        return socket.AF_INET6
+    except Exception as e:
+        pass
+    if os.path.exists(addr):
+        return socket.AF_UNIX
+    return None
+
+
 class JSONRPCException(Exception):
     def __init__(self, message):
         self.message = message
@@ -54,23 +70,24 @@ class JSONRPCClient(object):
 
     def _connect(self, addr, port):
         try:
-            if os.path.exists(addr):
+            addr_type = get_addr_type(addr)
+
+            if addr_type == socket.AF_UNIX:
                 self._logger.debug("Trying to connect to UNIX socket: %s", addr)
                 self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                 self.sock.connect(addr)
-            elif port:
-                if ':' in addr:
-                    self._logger.debug("Trying to connect to IPv6 address addr:%s, port:%i", addr, port)
-                    for res in socket.getaddrinfo(addr, port, socket.AF_INET6, socket.SOCK_STREAM, socket.SOL_TCP):
-                        af, socktype, proto, canonname, sa = res
-                    self.sock = socket.socket(af, socktype, proto)
-                    self.sock.connect(sa)
-                else:
-                    self._logger.debug("Trying to connect to IPv4 address addr:%s, port:%i'", addr, port)
-                    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-                    self.sock.connect((addr, port))
+            elif addr_type == socket.AF_INET6:
+                self._logger.debug("Trying to connect to IPv6 address addr:%s, port:%i", addr, port)
+                for res in socket.getaddrinfo(addr, port, socket.AF_INET6, socket.SOCK_STREAM, socket.SOL_TCP):
+                    af, socktype, proto, canonname, sa = res
+                self.sock = socket.socket(af, socktype, proto)
+                self.sock.connect(sa)
+            elif addr_type == socket.AF_INET:
+                self._logger.debug("Trying to connect to IPv4 address addr:%s, port:%i'", addr, port)
+                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+                self.sock.connect((addr, port))
             else:
-                raise socket.error("Unix socket '%s' does not exist" % addr)
+                raise socket.error("Invalid or non-existing address: '%s'" % addr)
         except socket.error as ex:
             raise JSONRPCException("Error while connecting to %s\n"
                                    "Is SPDK application running?\n"
-- 
2.26.2


From 24e0f403b8ee80e65eda5b4f7599aa83098ac1ef Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 7 May 2021 20:56:01 +0200
Subject: [PATCH 227/342] test/make: Fix LTS tag lookup

Replicating 00afb74669.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I19049e35ad959a34342cd714d805db6bdd933ea4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7814
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/make/check_so_deps.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/make/check_so_deps.sh b/test/make/check_so_deps.sh
index a42c68338..e6bd5aa2c 100755
--- a/test/make/check_so_deps.sh
+++ b/test/make/check_so_deps.sh
@@ -2,7 +2,7 @@
 shopt -s extglob
 
 function get_git_tag() {
-	git -C "${1:-$rootdir}" describe --tags --abbrev=0
+	git -C "${1:-$rootdir}" describe --tags --abbrev=0 --exclude=LTS
 }
 
 if [ "$(uname -s)" = "FreeBSD" ]; then
-- 
2.26.2


From cf091238f59729852919119bf530f8d2ba053b17 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 7 May 2021 20:59:00 +0200
Subject: [PATCH 228/342] test/make: Ignore abidiff's exit status

Upon running abidiff to get the list of impacted interfaces it seems
to exit with != 0 status. This triggers errexit causing the script
to exit in the middle of processing the lib files so we don't get
the full picture of all potentially impacted files. Ignore the
exit status in this case and allow the loop to go through all the
.sos.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I7edc5122161b0927fdd9a918571419f32fd46dac
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7815
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/make/check_so_deps.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/make/check_so_deps.sh b/test/make/check_so_deps.sh
index e6bd5aa2c..30eee1d36 100755
--- a/test/make/check_so_deps.sh
+++ b/test/make/check_so_deps.sh
@@ -158,7 +158,7 @@ EOF
 			fi
 
 			if ((abidiff_output == 1)); then
-				"${cmd_args[@]}" --impacted-interfaces
+				"${cmd_args[@]}" --impacted-interfaces || :
 			fi
 		fi
 		processed_so=$((processed_so + 1))
-- 
2.26.2


From f596245ce659de2b0c820232f3e8b9757ec9df14 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Mon, 26 Apr 2021 20:11:08 +0800
Subject: [PATCH 229/342] test/nvmf/ctrlr: cases for ctrlr creating and
 destruct

Change-Id: Ib4b3c124e6906e63409afc7e225d5afb89a28e76
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7612
Community-CI: Broadcom CI
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c | 106 ++++++++++++++++++++++++++
 1 file changed, 106 insertions(+)

diff --git a/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c b/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
index aa2912f6f..0ae8f13e5 100644
--- a/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
+++ b/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
@@ -1998,6 +1998,111 @@ test_rae(void)
 	cleanup_pending_async_events(&ctrlr);
 }
 
+static void
+test_nvmf_ctrlr_create_destruct(void)
+{
+	struct spdk_nvmf_fabric_connect_data connect_data = {};
+	struct spdk_nvmf_poll_group group = {};
+	struct spdk_nvmf_subsystem_poll_group sgroups[2] = {};
+	struct spdk_nvmf_transport transport = {};
+	struct spdk_nvmf_transport_ops tops = {};
+	struct spdk_nvmf_subsystem subsystem = {};
+	struct spdk_nvmf_request req = {};
+	struct spdk_nvmf_qpair qpair = {};
+	struct spdk_nvmf_ctrlr *ctrlr = NULL;
+	struct spdk_nvmf_tgt tgt = {};
+	union nvmf_h2c_msg cmd = {};
+	union nvmf_c2h_msg rsp = {};
+	const uint8_t hostid[16] = {
+		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+		0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
+	};
+	const char subnqn[] = "nqn.2016-06.io.spdk:subsystem1";
+	const char hostnqn[] = "nqn.2016-06.io.spdk:host1";
+
+	group.thread = spdk_get_thread();
+	transport.ops = &tops;
+	transport.opts.max_aq_depth = 32;
+	transport.opts.max_queue_depth = 64;
+	transport.opts.max_qpairs_per_ctrlr = 3;
+	transport.opts.dif_insert_or_strip = true;
+	transport.tgt = &tgt;
+	qpair.transport = &transport;
+	qpair.group = &group;
+	qpair.state = SPDK_NVMF_QPAIR_ACTIVE;
+	TAILQ_INIT(&qpair.outstanding);
+
+	memcpy(connect_data.hostid, hostid, sizeof(hostid));
+	connect_data.cntlid = 0xFFFF;
+	snprintf(connect_data.subnqn, sizeof(connect_data.subnqn), "%s", subnqn);
+	snprintf(connect_data.hostnqn, sizeof(connect_data.hostnqn), "%s", hostnqn);
+
+	subsystem.thread = spdk_get_thread();
+	subsystem.id = 1;
+	TAILQ_INIT(&subsystem.ctrlrs);
+	subsystem.tgt = &tgt;
+	subsystem.subtype = SPDK_NVMF_SUBTYPE_NVME;
+	subsystem.state = SPDK_NVMF_SUBSYSTEM_ACTIVE;
+	snprintf(subsystem.subnqn, sizeof(subsystem.subnqn), "%s", subnqn);
+
+	group.sgroups = sgroups;
+
+	cmd.connect_cmd.opcode = SPDK_NVME_OPC_FABRIC;
+	cmd.connect_cmd.cid = 1;
+	cmd.connect_cmd.fctype = SPDK_NVMF_FABRIC_COMMAND_CONNECT;
+	cmd.connect_cmd.recfmt = 0;
+	cmd.connect_cmd.qid = 0;
+	cmd.connect_cmd.sqsize = 31;
+	cmd.connect_cmd.cattr = 0;
+	cmd.connect_cmd.kato = 120000;
+
+	req.qpair = &qpair;
+	req.length = sizeof(connect_data);
+	req.xfer = SPDK_NVME_DATA_HOST_TO_CONTROLLER;
+	req.data = &connect_data;
+	req.cmd = &cmd;
+	req.rsp = &rsp;
+
+	TAILQ_INSERT_TAIL(&qpair.outstanding, &req, link);
+	sgroups[subsystem.id].mgmt_io_outstanding++;
+
+	ctrlr = nvmf_ctrlr_create(&subsystem, &req, &req.cmd->connect_cmd, req.data);
+	poll_threads();
+	SPDK_CU_ASSERT_FATAL(ctrlr != NULL);
+	CU_ASSERT(req.qpair->ctrlr == ctrlr);
+	CU_ASSERT(ctrlr->subsys == &subsystem);
+	CU_ASSERT(ctrlr->thread == req.qpair->group->thread);
+	CU_ASSERT(ctrlr->disconnect_in_progress == false);
+	CU_ASSERT(ctrlr->qpair_mask != NULL);
+	CU_ASSERT(ctrlr->feat.keep_alive_timer.bits.kato == 120000);
+	CU_ASSERT(ctrlr->feat.async_event_configuration.bits.ns_attr_notice == 1);
+	CU_ASSERT(ctrlr->feat.volatile_write_cache.bits.wce == 1);
+	CU_ASSERT(ctrlr->feat.number_of_queues.bits.ncqr == 1);
+	CU_ASSERT(ctrlr->feat.number_of_queues.bits.nsqr == 1);
+	CU_ASSERT(!strncmp((void *)&ctrlr->hostid, hostid, 16));
+	CU_ASSERT(ctrlr->vcprop.cap.bits.cqr == 1);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.mqes == 63);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.ams == 0);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.to == 1);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.dstrd == 0);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.css == SPDK_NVME_CAP_CSS_NVM);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.mpsmin == 0);
+	CU_ASSERT(ctrlr->vcprop.cap.bits.mpsmax == 0);
+	CU_ASSERT(ctrlr->vcprop.vs.bits.mjr == 1);
+	CU_ASSERT(ctrlr->vcprop.vs.bits.mnr == 3);
+	CU_ASSERT(ctrlr->vcprop.vs.bits.ter == 0);
+	CU_ASSERT(ctrlr->vcprop.cc.raw == 0);
+	CU_ASSERT(ctrlr->vcprop.cc.bits.en == 0);
+	CU_ASSERT(ctrlr->vcprop.csts.raw == 0);
+	CU_ASSERT(ctrlr->vcprop.csts.bits.rdy == 0);
+	CU_ASSERT(ctrlr->dif_insert_or_strip == true);
+
+	nvmf_ctrlr_destruct(ctrlr);
+	poll_threads();
+	CU_ASSERT(TAILQ_EMPTY(&subsystem.ctrlrs));
+	CU_ASSERT(TAILQ_EMPTY(&qpair.outstanding));
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -2026,6 +2131,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_get_ana_log_page);
 	CU_ADD_TEST(suite, test_multi_async_events);
 	CU_ADD_TEST(suite, test_rae);
+	CU_ADD_TEST(suite, test_nvmf_ctrlr_create_destruct);
 
 	allocate_threads(1);
 	set_thread(0);
-- 
2.26.2


From 36cb16219e60e942f0a58f8eb881b90b502b52ea Mon Sep 17 00:00:00 2001
From: ChengqiangMeng <chengqiangx.meng@intel.com>
Date: Fri, 14 May 2021 08:47:02 +0800
Subject: [PATCH 230/342] unittest/nvme_tcp: increase code coverage for some
 handle

nvme_tcp_c2h_data_payload_handle and nvme_tcp_c2h_term_req_payload_handle and nvme_tcp_icresp_handle code comprehensive coverage

Signed-off-by: ChengqiangMeng <chengqiangx.meng@intel.com>
Change-Id: Ib7ccc7dbab11990f851807c0b07e7c0e67e61bde
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7872
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c | 157 +++++++++++++++++++-
 1 file changed, 155 insertions(+), 2 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
index dcd42e24c..97fed0bfe 100644
--- a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
+++ b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
@@ -904,7 +904,7 @@ test_nvme_tcp_qpair_send_h2c_term_req(void)
 	tqpair.send_pdu = &send_pdu;
 	tqpair.recv_pdu = &recv_pdu;
 	TAILQ_INIT(&tqpair.send_queue);
-	/* case1: hlen < SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE, Except: copy_len == hlen */
+	/* case1: hlen < SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE, Expect: copy_len == hlen */
 	pdu.hdr.common.hlen = 64;
 	nvme_tcp_qpair_send_h2c_term_req(&tqpair, &pdu, fes, error_offset);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
@@ -913,7 +913,7 @@ test_nvme_tcp_qpair_send_h2c_term_req(void)
 		  pdu.hdr.common.hlen);
 	CU_ASSERT(tqpair.send_pdu->hdr.term_req.common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ);
 
-	/* case2: hlen > SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE, Except: copy_len == SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE */
+	/* case2: hlen > SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE, Expect: copy_len == SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE */
 	pdu.hdr.common.hlen = 255;
 	nvme_tcp_qpair_send_h2c_term_req(&tqpair, &pdu, fes, error_offset);
 	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
@@ -1138,6 +1138,157 @@ test_nvme_tcp_qpair_icreq_send(void)
 	CU_ASSERT(ic_req->dgst.bits.ddgst_enable == true);
 }
 
+static void
+test_nvme_tcp_c2h_payload_handle(void)
+{
+	struct nvme_tcp_qpair tqpair = {};
+	struct nvme_tcp_pdu pdu = {};
+	struct nvme_tcp_req tcp_req = {};
+	struct nvme_request	req = {};
+	struct nvme_tcp_pdu recv_pdu = {};
+	uint32_t reaped = 1;
+
+	tcp_req.req = &req;
+	tcp_req.req->qpair = &tqpair.qpair;
+	tcp_req.req->cb_fn = ut_nvme_complete_request;
+	tcp_req.tqpair = &tqpair;
+	tcp_req.cid = 1;
+
+	TAILQ_INIT(&tcp_req.tqpair->outstanding_reqs);
+
+	pdu.req = &tcp_req;
+	pdu.hdr.c2h_data.common.flags = SPDK_NVME_TCP_C2H_DATA_FLAGS_SUCCESS;
+	pdu.data_len = 1024;
+
+	tqpair.qpair.id = 1;
+	tqpair.recv_pdu = &recv_pdu;
+
+	/* case 1: nvme_tcp_c2h_data_payload_handle: tcp_req->datao != tcp_req->req->payload_size */
+	tcp_req.datao = 1024;
+	tcp_req.req->payload_size = 2048;
+	tcp_req.state = NVME_TCP_REQ_ACTIVE;
+	tcp_req.ordering.bits.send_ack = 1;
+	memset(&tcp_req.rsp, 0, sizeof(tcp_req.rsp));
+	tcp_req.ordering.bits.data_recv = 0;
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_ERROR;
+	TAILQ_INSERT_TAIL(&tcp_req.tqpair->outstanding_reqs, &tcp_req, link);
+
+	nvme_tcp_c2h_data_payload_handle(&tqpair, &pdu, &reaped);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(tcp_req.rsp.status.p == 0);
+	CU_ASSERT(tcp_req.rsp.cid == tcp_req.cid);
+	CU_ASSERT(tcp_req.rsp.sqid == tqpair.qpair.id);
+	CU_ASSERT(tcp_req.ordering.bits.data_recv == 1);
+	CU_ASSERT(reaped == 2);
+
+	/* case 2: nvme_tcp_c2h_data_payload_handle: tcp_req->datao == tcp_req->req->payload_size */
+	tcp_req.datao = 1024;
+	tcp_req.req->payload_size = 1024;
+	tcp_req.state = NVME_TCP_REQ_ACTIVE;
+	tcp_req.ordering.bits.send_ack = 1;
+	memset(&tcp_req.rsp, 0, sizeof(tcp_req.rsp));
+	tcp_req.ordering.bits.data_recv = 0;
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_ERROR;
+	TAILQ_INSERT_TAIL(&tcp_req.tqpair->outstanding_reqs, &tcp_req, link);
+
+	nvme_tcp_c2h_data_payload_handle(&tqpair, &pdu, &reaped);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(tcp_req.rsp.status.p == 1);
+	CU_ASSERT(tcp_req.rsp.cid == tcp_req.cid);
+	CU_ASSERT(tcp_req.rsp.sqid == tqpair.qpair.id);
+	CU_ASSERT(tcp_req.ordering.bits.data_recv == 1);
+	CU_ASSERT(reaped == 3);
+
+	/* case 3: nvme_tcp_c2h_data_payload_handle: flag does not have SPDK_NVME_TCP_C2H_DATA_FLAGS_SUCCESS */
+	pdu.hdr.c2h_data.common.flags = SPDK_NVME_TCP_C2H_DATA_FLAGS_LAST_PDU;
+	tcp_req.datao = 1024;
+	tcp_req.req->payload_size = 1024;
+	tcp_req.state = NVME_TCP_REQ_ACTIVE;
+	tcp_req.ordering.bits.send_ack = 1;
+	memset(&tcp_req.rsp, 0, sizeof(tcp_req.rsp));
+	tcp_req.ordering.bits.data_recv = 0;
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_ERROR;
+	TAILQ_INSERT_TAIL(&tcp_req.tqpair->outstanding_reqs, &tcp_req, link);
+
+	nvme_tcp_c2h_data_payload_handle(&tqpair, &pdu, &reaped);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(reaped == 3);
+
+	/* case 4: nvme_tcp_c2h_term_req_payload_handle: recv_state is NVME_TCP_PDU_RECV_STATE_ERROR */
+	pdu.hdr.term_req.fes = SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD;
+	nvme_tcp_c2h_term_req_payload_handle(&tqpair, &pdu);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
+}
+
+static void
+test_nvme_tcp_icresp_handle(void)
+{
+	struct nvme_tcp_qpair tqpair = {};
+	struct nvme_tcp_pdu pdu = {};
+	struct nvme_tcp_pdu send_pdu = {};
+	struct nvme_tcp_pdu recv_pdu = {};
+
+	tqpair.send_pdu = &send_pdu;
+	tqpair.recv_pdu = &recv_pdu;
+	TAILQ_INIT(&tqpair.send_queue);
+
+	/* case 1: Expected ICResp PFV and got are different. */
+	pdu.hdr.ic_resp.pfv = 1;
+
+	nvme_tcp_icresp_handle(&tqpair, &pdu);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
+
+	/* case 2: Expected ICResp maxh2cdata and got are different. */
+	pdu.hdr.ic_resp.pfv = 0;
+	pdu.hdr.ic_resp.maxh2cdata = 2048;
+
+	nvme_tcp_icresp_handle(&tqpair, &pdu);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
+
+	/* case 3: Expected ICResp cpda and got are different. */
+	pdu.hdr.ic_resp.maxh2cdata = NVME_TCP_PDU_H2C_MIN_DATA_SIZE;
+	pdu.hdr.ic_resp.cpda = 64;
+
+	nvme_tcp_icresp_handle(&tqpair, &pdu);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
+
+	/* case 4: waiting icreq ack. */
+	pdu.hdr.ic_resp.maxh2cdata = NVME_TCP_PDU_H2C_MIN_DATA_SIZE;
+	pdu.hdr.ic_resp.cpda = 30;
+	pdu.hdr.ic_resp.dgst.bits.hdgst_enable = true;
+	pdu.hdr.ic_resp.dgst.bits.ddgst_enable = true;
+	tqpair.flags.icreq_send_ack = 0;
+
+	nvme_tcp_icresp_handle(&tqpair, &pdu);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(tqpair.state == NVME_TCP_QPAIR_STATE_INITIALIZING);
+	CU_ASSERT(tqpair.maxh2cdata == pdu.hdr.ic_resp.maxh2cdata);
+	CU_ASSERT(tqpair.cpda == pdu.hdr.ic_resp.cpda);
+	CU_ASSERT(tqpair.flags.host_hdgst_enable == pdu.hdr.ic_resp.dgst.bits.hdgst_enable);
+	CU_ASSERT(tqpair.flags.host_ddgst_enable == pdu.hdr.ic_resp.dgst.bits.ddgst_enable);
+
+	/* case 5: Expect: PASS. */
+	tqpair.flags.icreq_send_ack = 1;
+
+	nvme_tcp_icresp_handle(&tqpair, &pdu);
+
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(tqpair.state == NVME_TCP_QPAIR_STATE_RUNNING);
+	CU_ASSERT(tqpair.maxh2cdata == pdu.hdr.ic_resp.maxh2cdata);
+	CU_ASSERT(tqpair.cpda == pdu.hdr.ic_resp.cpda);
+	CU_ASSERT(tqpair.flags.host_hdgst_enable == pdu.hdr.ic_resp.dgst.bits.hdgst_enable);
+	CU_ASSERT(tqpair.flags.host_ddgst_enable == pdu.hdr.ic_resp.dgst.bits.ddgst_enable);
+}
+
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -1164,6 +1315,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_tcp_pdu_ch_handle);
 	CU_ADD_TEST(suite, test_nvme_tcp_qpair_connect_sock);
 	CU_ADD_TEST(suite, test_nvme_tcp_qpair_icreq_send);
+	CU_ADD_TEST(suite, test_nvme_tcp_c2h_payload_handle);
+	CU_ADD_TEST(suite, test_nvme_tcp_icresp_handle);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From af935f768e20bbfa9e866251ff68841b1090eea8 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Fri, 26 Feb 2021 15:00:03 -0700
Subject: [PATCH 231/342] event: Shift subsystem initialization code to a
 separate library

This is useful for applications even if they elect not to use the SPDK
event framework.

This doesn't shift everything in one go - just the subsystem
initialization logic. Configuration file loading also needs to move
in a separate patch later.

Change-Id: Id419df1045442d416650ed90e5ee78adfdd623d7
Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6641
Community-CI: Broadcom CI
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 app/iscsi_tgt/Makefile                        |   2 +-
 app/nvmf_tgt/Makefile                         |   2 +-
 app/spdk_dd/Makefile                          |   2 +-
 app/spdk_tgt/Makefile                         |   2 +-
 app/vhost/Makefile                            |   2 +-
 examples/accel/perf/Makefile                  |   2 +-
 examples/bdev/fio_plugin/Makefile             |   2 +-
 examples/bdev/fio_plugin/fio_plugin.c         |   1 +
 examples/bdev/hello_world/Makefile            |   2 +-
 examples/blob/cli/Makefile                    |   2 +-
 examples/blob/hello_world/Makefile            |   2 +-
 examples/interrupt_tgt/Makefile               |   2 +-
 examples/nvmf/nvmf/Makefile                   |   2 +-
 examples/nvmf/nvmf/nvmf.c                     |   1 +
 examples/sock/hello_world/Makefile            |   2 +-
 include/spdk_internal/event.h                 |  48 +------
 include/spdk_internal/init.h                  | 125 ++++++++++++++++++
 lib/Makefile                                  |   2 +-
 lib/event/Makefile                            |   6 +-
 lib/event/app.c                               |   1 +
 lib/event/json_config.c                       |   5 +-
 lib/event/spdk_event.map                      |  12 --
 lib/init/Makefile                             |  45 +++++++
 lib/init/spdk_init.map                        |  19 +++
 lib/{event => init}/subsystem.c               |   4 +-
 lib/{event => init}/subsystem_rpc.c           |   3 +-
 mk/spdk.lib_deps.mk                           |  23 ++--
 module/event/subsystems/accel/accel.c         |   2 +-
 module/event/subsystems/bdev/bdev.c           |   2 +-
 module/event/subsystems/iscsi/iscsi.c         |   2 +-
 module/event/subsystems/nbd/nbd.c             |   2 +-
 module/event/subsystems/net/net.c             |   2 +-
 module/event/subsystems/nvmf/event_nvmf.h     |   2 +-
 module/event/subsystems/scsi/scsi.c           |   2 +-
 module/event/subsystems/sock/sock.c           |   2 +-
 module/event/subsystems/vhost/vhost.c         |   2 +-
 module/event/subsystems/vmd/vmd.c             |   5 +-
 test/app/bdev_svc/Makefile                    |   4 +-
 test/bdev/bdevio/Makefile                     |   2 +-
 test/bdev/bdevperf/Makefile                   |   2 +-
 test/blobfs/mkfs/Makefile                     |   2 +-
 test/event/app_repeat/Makefile                |   2 +-
 test/event/event_perf/event_perf.c            |   2 +-
 test/event/scheduler/Makefile                 |   2 +-
 test/external_code/hello_world/Makefile       |   8 +-
 test/unit/lib/Makefile                        |   2 +-
 test/unit/lib/event/Makefile                  |   2 +-
 test/unit/lib/init/Makefile                   |  44 ++++++
 .../{event => init}/subsystem.c/.gitignore    |   0
 .../lib/{event => init}/subsystem.c/Makefile  |   0
 .../subsystem.c/subsystem_ut.c                |   2 +-
 test/unit/unittest.sh                         |   7 +-
 52 files changed, 309 insertions(+), 116 deletions(-)
 create mode 100644 include/spdk_internal/init.h
 create mode 100644 lib/init/Makefile
 create mode 100644 lib/init/spdk_init.map
 rename lib/{event => init}/subsystem.c (99%)
 rename lib/{event => init}/subsystem_rpc.c (99%)
 create mode 100644 test/unit/lib/init/Makefile
 rename test/unit/lib/{event => init}/subsystem.c/.gitignore (100%)
 rename test/unit/lib/{event => init}/subsystem.c/Makefile (100%)
 rename test/unit/lib/{event => init}/subsystem.c/subsystem_ut.c (99%)

diff --git a/app/iscsi_tgt/Makefile b/app/iscsi_tgt/Makefile
index 31a273610..a5b38e90f 100644
--- a/app/iscsi_tgt/Makefile
+++ b/app/iscsi_tgt/Makefile
@@ -43,7 +43,7 @@ CFLAGS += -I$(SPDK_ROOT_DIR)/lib
 
 C_SRCS := iscsi_tgt.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_iscsi event_net
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_iscsi event_net
 
 ifeq ($(SPDK_ROOT_DIR)/lib/env_dpdk,$(CONFIG_ENV))
 SPDK_LIB_LIST += env_dpdk_rpc
diff --git a/app/nvmf_tgt/Makefile b/app/nvmf_tgt/Makefile
index a27d57ac5..282f0fe7e 100644
--- a/app/nvmf_tgt/Makefile
+++ b/app/nvmf_tgt/Makefile
@@ -39,7 +39,7 @@ APP = nvmf_tgt
 
 C_SRCS := nvmf_main.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_nvmf
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_nvmf
 
 ifeq ($(SPDK_ROOT_DIR)/lib/env_dpdk,$(CONFIG_ENV))
 SPDK_LIB_LIST += env_dpdk_rpc
diff --git a/app/spdk_dd/Makefile b/app/spdk_dd/Makefile
index f2b614dd5..e302c12f5 100644
--- a/app/spdk_dd/Makefile
+++ b/app/spdk_dd/Makefile
@@ -39,6 +39,6 @@ APP = spdk_dd
 
 C_SRCS := spdk_dd.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/app/spdk_tgt/Makefile b/app/spdk_tgt/Makefile
index 91d590aa7..627cfe269 100644
--- a/app/spdk_tgt/Makefile
+++ b/app/spdk_tgt/Makefile
@@ -41,7 +41,7 @@ C_SRCS := spdk_tgt.c
 
 SPDK_LIB_LIST = $(ALL_MODULES_LIST)
 
-SPDK_LIB_LIST += event_iscsi event_nvmf
+SPDK_LIB_LIST += event event_iscsi event_nvmf
 
 ifeq ($(SPDK_ROOT_DIR)/lib/env_dpdk,$(CONFIG_ENV))
 SPDK_LIB_LIST += env_dpdk_rpc
diff --git a/app/vhost/Makefile b/app/vhost/Makefile
index 7df6b0a9b..e6b6c2def 100644
--- a/app/vhost/Makefile
+++ b/app/vhost/Makefile
@@ -39,7 +39,7 @@ APP = vhost
 
 C_SRCS := vhost.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_vhost event_nbd
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_vhost event_nbd
 
 ifeq ($(SPDK_ROOT_DIR)/lib/env_dpdk,$(CONFIG_ENV))
 SPDK_LIB_LIST += env_dpdk_rpc
diff --git a/examples/accel/perf/Makefile b/examples/accel/perf/Makefile
index 53b9ae6cb..f1983d98f 100644
--- a/examples/accel/perf/Makefile
+++ b/examples/accel/perf/Makefile
@@ -39,6 +39,6 @@ APP = accel_perf
 
 C_SRCS := accel_perf.c
 
-SPDK_LIB_LIST = $(ACCEL_MODULES_LIST) event_accel
+SPDK_LIB_LIST = $(ACCEL_MODULES_LIST) event event_accel
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/examples/bdev/fio_plugin/Makefile b/examples/bdev/fio_plugin/Makefile
index 1d48d1e99..b93456651 100644
--- a/examples/bdev/fio_plugin/Makefile
+++ b/examples/bdev/fio_plugin/Makefile
@@ -40,6 +40,6 @@ FIO_PLUGIN := spdk_bdev
 
 C_SRCS = fio_plugin.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 include $(SPDK_ROOT_DIR)/mk/spdk.fio.mk
diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index 2ce5c8104..483664f99 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -43,6 +43,7 @@
 #include "spdk/queue.h"
 #include "spdk/util.h"
 
+#include "spdk_internal/init.h"
 #include "spdk_internal/event.h"
 
 #include "config-host.h"
diff --git a/examples/bdev/hello_world/Makefile b/examples/bdev/hello_world/Makefile
index e2848a7ce..ae413fdf3 100644
--- a/examples/bdev/hello_world/Makefile
+++ b/examples/bdev/hello_world/Makefile
@@ -37,6 +37,6 @@ APP = hello_bdev
 
 C_SRCS := hello_bdev.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/examples/blob/cli/Makefile b/examples/blob/cli/Makefile
index e658ebc87..e072ca6d7 100644
--- a/examples/blob/cli/Makefile
+++ b/examples/blob/cli/Makefile
@@ -38,6 +38,6 @@ APP = blobcli
 C_SRCS := blobcli.c
 
 # Don't link bdev_lvol in blobcli - otherwise this utility cannot operate on an lvolstore
-SPDK_LIB_LIST = $(filter-out bdev_lvol,$(ALL_MODULES_LIST)) event_bdev
+SPDK_LIB_LIST = $(filter-out bdev_lvol,$(ALL_MODULES_LIST)) event event_bdev
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/examples/blob/hello_world/Makefile b/examples/blob/hello_world/Makefile
index ad6c814cc..a93d47755 100644
--- a/examples/blob/hello_world/Makefile
+++ b/examples/blob/hello_world/Makefile
@@ -37,6 +37,6 @@ APP = hello_blob
 
 C_SRCS := hello_blob.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/examples/interrupt_tgt/Makefile b/examples/interrupt_tgt/Makefile
index 90a2b8a4d..e84eb4509 100644
--- a/examples/interrupt_tgt/Makefile
+++ b/examples/interrupt_tgt/Makefile
@@ -39,7 +39,7 @@ APP = interrupt_tgt
 
 C_SRCS := interrupt_tgt.c
 
-SPDK_LIB_LIST = $(INTR_BLOCKDEV_MODULES_LIST) event_bdev conf
+SPDK_LIB_LIST = $(INTR_BLOCKDEV_MODULES_LIST) event event_bdev conf
 
 SPDK_LIB_LIST += event_nbd
 SPDK_LIB_LIST += event_vhost
diff --git a/examples/nvmf/nvmf/Makefile b/examples/nvmf/nvmf/Makefile
index 4db21ca82..d83d278cc 100644
--- a/examples/nvmf/nvmf/Makefile
+++ b/examples/nvmf/nvmf/Makefile
@@ -38,6 +38,6 @@ include $(SPDK_ROOT_DIR)/mk/spdk.modules.mk
 APP := nvmf
 
 C_SRCS := nvmf.c
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev nvmf
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev nvmf
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/examples/nvmf/nvmf/nvmf.c b/examples/nvmf/nvmf/nvmf.c
index 8f7170980..5e77e1683 100644
--- a/examples/nvmf/nvmf/nvmf.c
+++ b/examples/nvmf/nvmf/nvmf.c
@@ -42,6 +42,7 @@
 #include "spdk/likely.h"
 
 #include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 #define NVMF_DEFAULT_SUBSYSTEMS		32
 #define ACCEPT_TIMEOUT_US		10000 /* 10ms */
diff --git a/examples/sock/hello_world/Makefile b/examples/sock/hello_world/Makefile
index f86df44cc..350c30570 100644
--- a/examples/sock/hello_world/Makefile
+++ b/examples/sock/hello_world/Makefile
@@ -38,6 +38,6 @@ APP = hello_sock
 C_SRCS := hello_sock.c
 
 SPDK_LIB_LIST = $(SOCK_MODULES_LIST)
-SPDK_LIB_LIST += event_net sock
+SPDK_LIB_LIST += event event_net sock
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/include/spdk_internal/event.h b/include/spdk_internal/event.h
index 9ecc4209d..73c2bf5c0 100644
--- a/include/spdk_internal/event.h
+++ b/include/spdk_internal/event.h
@@ -164,56 +164,12 @@ int spdk_reactor_set_interrupt_mode(uint32_t lcore, bool new_in_interrupt,
  */
 struct spdk_thread *_spdk_get_app_thread(void);
 
-struct spdk_subsystem {
-	const char *name;
-	/* User must call spdk_subsystem_init_next() when they are done with their initialization. */
-	void (*init)(void);
-	void (*fini)(void);
+typedef void (*spdk_app_init_fn)(int rc, void *ctx);
 
-	/**
-	 * Write JSON configuration handler.
-	 *
-	 * \param w JSON write context
-	 */
-	void (*write_config_json)(struct spdk_json_write_ctx *w);
-	TAILQ_ENTRY(spdk_subsystem) tailq;
-};
-
-struct spdk_subsystem *spdk_subsystem_find(const char *name);
-struct spdk_subsystem *spdk_subsystem_get_first(void);
-struct spdk_subsystem *spdk_subsystem_get_next(struct spdk_subsystem *cur_subsystem);
-
-struct spdk_subsystem_depend {
-	const char *name;
-	const char *depends_on;
-	TAILQ_ENTRY(spdk_subsystem_depend) tailq;
-};
-
-struct spdk_subsystem_depend *spdk_subsystem_get_first_depend(void);
-struct spdk_subsystem_depend *spdk_subsystem_get_next_depend(struct spdk_subsystem_depend
-		*cur_depend);
-
-void spdk_add_subsystem(struct spdk_subsystem *subsystem);
-void spdk_add_subsystem_depend(struct spdk_subsystem_depend *depend);
-
-typedef void (*spdk_subsystem_init_fn)(int rc, void *ctx);
-void spdk_subsystem_init(spdk_subsystem_init_fn cb_fn, void *cb_arg);
-void spdk_subsystem_fini(spdk_msg_fn cb_fn, void *cb_arg);
-void spdk_subsystem_init_next(int rc);
-void spdk_subsystem_fini_next(void);
 void spdk_app_json_config_load(const char *json_config_file, const char *rpc_addr,
-			       spdk_subsystem_init_fn cb_fn, void *cb_arg,
+			       spdk_app_init_fn cb_fn, void *cb_arg,
 			       bool stop_on_error);
 
-/**
- * Save pointed \c subsystem configuration to the JSON write context \c w. In case of
- * error \c null is written to the JSON context.
- *
- * \param w JSON write context
- * \param subsystem the subsystem to query
- */
-void spdk_subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsystem *subsystem);
-
 int spdk_rpc_initialize(const char *listen_addr);
 void spdk_rpc_finish(void);
 
diff --git a/include/spdk_internal/init.h b/include/spdk_internal/init.h
new file mode 100644
index 000000000..67fd6cd53
--- /dev/null
+++ b/include/spdk_internal/init.h
@@ -0,0 +1,125 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.  All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * \file
+ * SPDK Initialization Helper
+ */
+
+#ifndef SPDK_INIT_H
+#define SPDK_INIT_H
+
+#include "spdk/stdinc.h"
+#include "spdk/queue.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct spdk_json_write_ctx;
+
+struct spdk_subsystem {
+	const char *name;
+	/* User must call spdk_subsystem_init_next() when they are done with their initialization. */
+	void (*init)(void);
+	void (*fini)(void);
+
+	/**
+	 * Write JSON configuration handler.
+	 *
+	 * \param w JSON write context
+	 */
+	void (*write_config_json)(struct spdk_json_write_ctx *w);
+	TAILQ_ENTRY(spdk_subsystem) tailq;
+};
+
+struct spdk_subsystem *spdk_subsystem_find(const char *name);
+struct spdk_subsystem *spdk_subsystem_get_first(void);
+struct spdk_subsystem *spdk_subsystem_get_next(struct spdk_subsystem *cur_subsystem);
+
+struct spdk_subsystem_depend {
+	const char *name;
+	const char *depends_on;
+	TAILQ_ENTRY(spdk_subsystem_depend) tailq;
+};
+
+struct spdk_subsystem_depend *spdk_subsystem_get_first_depend(void);
+struct spdk_subsystem_depend *spdk_subsystem_get_next_depend(struct spdk_subsystem_depend
+		*cur_depend);
+
+void spdk_add_subsystem(struct spdk_subsystem *subsystem);
+void spdk_add_subsystem_depend(struct spdk_subsystem_depend *depend);
+
+typedef void (*spdk_subsystem_init_fn)(int rc, void *ctx);
+void spdk_subsystem_init(spdk_subsystem_init_fn cb_fn, void *cb_arg);
+
+typedef void (*spdk_subsystem_fini_fn)(void *ctx);
+void spdk_subsystem_fini(spdk_subsystem_fini_fn cb_fn, void *cb_arg);
+void spdk_subsystem_init_next(int rc);
+void spdk_subsystem_fini_next(void);
+
+/**
+ * Save pointed \c subsystem configuration to the JSON write context \c w. In case of
+ * error \c null is written to the JSON context.
+ *
+ * \param w JSON write context
+ * \param subsystem the subsystem to query
+ */
+void spdk_subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsystem *subsystem);
+
+/**
+ * \brief Register a new subsystem
+ */
+#define SPDK_SUBSYSTEM_REGISTER(_name) \
+	__attribute__((constructor)) static void _name ## _register(void)	\
+	{									\
+		spdk_add_subsystem(&_name);					\
+	}
+
+/**
+ * \brief Declare that a subsystem depends on another subsystem.
+ */
+#define SPDK_SUBSYSTEM_DEPEND(_name, _depends_on)						\
+	static struct spdk_subsystem_depend __subsystem_ ## _name ## _depend_on ## _depends_on = { \
+	.name = #_name,										\
+	.depends_on = #_depends_on,								\
+	};											\
+	__attribute__((constructor)) static void _name ## _depend_on ## _depends_on(void)	\
+	{											\
+		spdk_add_subsystem_depend(&__subsystem_ ## _name ## _depend_on ## _depends_on); \
+	}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/lib/Makefile b/lib/Makefile
index eab297ed0..58b0017b9 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -37,7 +37,7 @@ include $(SPDK_ROOT_DIR)/mk/spdk.lib_deps.mk
 
 DIRS-y += bdev blob blobfs conf accel event json jsonrpc \
           log lvol net rpc sock thread trace util nvme vmd nvmf scsi \
-          ioat ut_mock iscsi notify
+          ioat ut_mock iscsi notify init
 ifeq ($(OS),Linux)
 DIRS-y += nbd ftl
 endif
diff --git a/lib/event/Makefile b/lib/event/Makefile
index 359bfe81f..5cd155870 100644
--- a/lib/event/Makefile
+++ b/lib/event/Makefile
@@ -34,14 +34,14 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-SO_VER := 8
+SO_VER := 9
 SO_MINOR := 0
 
 CFLAGS += $(ENV_CFLAGS)
 
 LIBNAME = event
-C_SRCS = app.c reactor.c rpc.c subsystem.c json_config.c log_rpc.c \
-	 app_rpc.c subsystem_rpc.c scheduler_static.c
+C_SRCS = app.c reactor.c rpc.c json_config.c log_rpc.c \
+	 app_rpc.c scheduler_static.c
 
 # Do not compile schedulers and governors based on DPDK env
 # if non-DPDK env is used.
diff --git a/lib/event/app.c b/lib/event/app.c
index 3eb31da30..7ef66832a 100644
--- a/lib/event/app.c
+++ b/lib/event/app.c
@@ -35,6 +35,7 @@
 #include "spdk/version.h"
 
 #include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 #include "spdk/assert.h"
 #include "spdk/env.h"
diff --git a/lib/event/json_config.c b/lib/event/json_config.c
index da085846a..e42f30581 100644
--- a/lib/event/json_config.c
+++ b/lib/event/json_config.c
@@ -42,6 +42,7 @@
 #include "spdk/rpc.h"
 
 #include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 #define SPDK_DEBUG_APP_CFG(...) SPDK_DEBUGLOG(app_config, __VA_ARGS__)
 
@@ -85,7 +86,7 @@ typedef void (*client_resp_handler)(struct load_json_config_ctx *,
 struct load_json_config_ctx {
 	/* Thread used during configuration. */
 	struct spdk_thread *thread;
-	spdk_subsystem_init_fn cb_fn;
+	spdk_app_init_fn cb_fn;
 	void *cb_arg;
 	bool stop_on_error;
 
@@ -567,7 +568,7 @@ err:
 
 void
 spdk_app_json_config_load(const char *json_config_file, const char *rpc_addr,
-			  spdk_subsystem_init_fn cb_fn, void *cb_arg,
+			  spdk_app_init_fn cb_fn, void *cb_arg,
 			  bool stop_on_error)
 {
 	struct load_json_config_ctx *ctx = calloc(1, sizeof(*ctx));
diff --git a/lib/event/spdk_event.map b/lib/event/spdk_event.map
index 9a4ba5603..146dc29c4 100644
--- a/lib/event/spdk_event.map
+++ b/lib/event/spdk_event.map
@@ -25,19 +25,7 @@
 	spdk_reactor_get;
 	spdk_for_each_reactor;
 	spdk_reactor_set_interrupt_mode;
-	spdk_subsystem_find;
-	spdk_subsystem_get_first;
-	spdk_subsystem_get_next;
-	spdk_subsystem_get_first_depend;
-	spdk_subsystem_get_next_depend;
-	spdk_add_subsystem;
-	spdk_add_subsystem_depend;
-	spdk_subsystem_init;
-	spdk_subsystem_fini;
-	spdk_subsystem_init_next;
-	spdk_subsystem_fini_next;
 	spdk_app_json_config_load;
-	spdk_subsystem_config_json;
 	spdk_rpc_initialize;
 	spdk_rpc_finish;
 
diff --git a/lib/init/Makefile b/lib/init/Makefile
new file mode 100644
index 000000000..8cd598c06
--- /dev/null
+++ b/lib/init/Makefile
@@ -0,0 +1,45 @@
+#
+#  BSD LICENSE
+#
+#  Copyright (c) Intel Corporation.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Intel Corporation nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../..)
+include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
+
+SO_VER := 1
+SO_MINOR := 0
+
+C_SRCS = subsystem.c subsystem_rpc.c
+LIBNAME = init
+
+SPDK_MAP_FILE = $(abspath $(CURDIR)/spdk_init.map)
+
+include $(SPDK_ROOT_DIR)/mk/spdk.lib.mk
diff --git a/lib/init/spdk_init.map b/lib/init/spdk_init.map
new file mode 100644
index 000000000..2aa5b3dff
--- /dev/null
+++ b/lib/init/spdk_init.map
@@ -0,0 +1,19 @@
+{
+	global:
+
+	# Public functions
+	spdk_subsystem_find;
+	spdk_subsystem_get_first;
+	spdk_subsystem_get_next;
+	spdk_subsystem_get_first_depend;
+	spdk_subsystem_get_next_depend;
+	spdk_add_subsystem;
+	spdk_add_subsystem_depend;
+	spdk_subsystem_init;
+	spdk_subsystem_fini;
+	spdk_subsystem_init_next;
+	spdk_subsystem_fini_next;
+	spdk_subsystem_config_json;
+
+	local: *;
+};
diff --git a/lib/event/subsystem.c b/lib/init/subsystem.c
similarity index 99%
rename from lib/event/subsystem.c
rename to lib/init/subsystem.c
index a4f7092ea..a1475ded5 100644
--- a/lib/event/subsystem.c
+++ b/lib/init/subsystem.c
@@ -36,9 +36,11 @@
 #include "spdk/log.h"
 #include "spdk/thread.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 #include "spdk/env.h"
 
+#include "spdk/json.h"
+
 TAILQ_HEAD(spdk_subsystem_list, spdk_subsystem);
 struct spdk_subsystem_list g_subsystems = TAILQ_HEAD_INITIALIZER(g_subsystems);
 
diff --git a/lib/event/subsystem_rpc.c b/lib/init/subsystem_rpc.c
similarity index 99%
rename from lib/event/subsystem_rpc.c
rename to lib/init/subsystem_rpc.c
index 293493afa..cfee3e593 100644
--- a/lib/event/subsystem_rpc.c
+++ b/lib/init/subsystem_rpc.c
@@ -31,12 +31,13 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "spdk_internal/event.h"
 #include "spdk/rpc.h"
 #include "spdk/string.h"
 #include "spdk/util.h"
 #include "spdk/env.h"
 
+#include "spdk_internal/init.h"
+
 static void
 rpc_framework_get_subsystems(struct spdk_jsonrpc_request *request,
 			     const struct spdk_json_val *params)
diff --git a/mk/spdk.lib_deps.mk b/mk/spdk.lib_deps.mk
index 7b2912e06..e45ddba03 100644
--- a/mk/spdk.lib_deps.mk
+++ b/mk/spdk.lib_deps.mk
@@ -83,7 +83,8 @@ DEPDIRS-trace := log util $(JSON_LIBS)
 
 DEPDIRS-bdev := log util thread $(JSON_LIBS) notify trace
 DEPDIRS-blobfs := log thread blob trace
-DEPDIRS-event := log util thread $(JSON_LIBS) trace
+DEPDIRS-event := log util thread $(JSON_LIBS) trace init
+DEPDIRS-init := jsonrpc json log rpc thread
 
 DEPDIRS-ftl := log util thread trace bdev
 DEPDIRS-nbd := log util thread $(JSON_LIBS) bdev
@@ -159,16 +160,16 @@ endif
 # These depdirs include subsystem interdependencies which
 # are not related to symbols, but are defined directly in
 # the SPDK event subsystem code.
-DEPDIRS-event_accel := event accel
-DEPDIRS-event_net := event net
-DEPDIRS-event_vmd := event vmd $(JSON_LIBS) log thread
+DEPDIRS-event_accel := init accel
+DEPDIRS-event_net := init net
+DEPDIRS-event_vmd := init vmd $(JSON_LIBS) log thread
 
-DEPDIRS-event_bdev := event bdev event_accel event_vmd event_sock
+DEPDIRS-event_bdev := init bdev event_accel event_vmd event_sock
 
-DEPDIRS-event_nbd := event nbd event_bdev
-DEPDIRS-event_nvmf := event nvmf event_bdev event_sock thread log bdev $(JSON_LIBS)
-DEPDIRS-event_scsi := event scsi event_bdev
+DEPDIRS-event_nbd := init nbd event_bdev
+DEPDIRS-event_nvmf := init nvmf event_bdev event_sock thread log bdev $(JSON_LIBS)
+DEPDIRS-event_scsi := init scsi event_bdev
 
-DEPDIRS-event_iscsi := event iscsi event_scsi event_sock
-DEPDIRS-event_vhost := event vhost event_scsi
-DEPDIRS-event_sock := event sock
+DEPDIRS-event_iscsi := init iscsi event_scsi event_sock
+DEPDIRS-event_vhost := init vhost event_scsi
+DEPDIRS-event_sock := init sock
diff --git a/module/event/subsystems/accel/accel.c b/module/event/subsystems/accel/accel.c
index dd20c3b22..079cac9a6 100644
--- a/module/event/subsystems/accel/accel.c
+++ b/module/event/subsystems/accel/accel.c
@@ -35,7 +35,7 @@
 
 #include "spdk/accel_engine.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 #include "spdk/env.h"
 
 static void
diff --git a/module/event/subsystems/bdev/bdev.c b/module/event/subsystems/bdev/bdev.c
index 9b4917c7e..055e182c3 100644
--- a/module/event/subsystems/bdev/bdev.c
+++ b/module/event/subsystems/bdev/bdev.c
@@ -37,7 +37,7 @@
 #include "spdk/env.h"
 #include "spdk/thread.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 #include "spdk/env.h"
 
 static void
diff --git a/module/event/subsystems/iscsi/iscsi.c b/module/event/subsystems/iscsi/iscsi.c
index a131a6d30..19944cf05 100644
--- a/module/event/subsystems/iscsi/iscsi.c
+++ b/module/event/subsystems/iscsi/iscsi.c
@@ -35,7 +35,7 @@
 
 #include "iscsi/iscsi.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 static void
 iscsi_subsystem_init_complete(void *cb_arg, int rc)
diff --git a/module/event/subsystems/nbd/nbd.c b/module/event/subsystems/nbd/nbd.c
index 50340c5c7..1af23b06c 100644
--- a/module/event/subsystems/nbd/nbd.c
+++ b/module/event/subsystems/nbd/nbd.c
@@ -35,7 +35,7 @@
 
 #include "spdk/nbd.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 static void
 nbd_subsystem_init(void)
diff --git a/module/event/subsystems/net/net.c b/module/event/subsystems/net/net.c
index 60aca98dc..2086acf2b 100644
--- a/module/event/subsystems/net/net.c
+++ b/module/event/subsystems/net/net.c
@@ -35,7 +35,7 @@
 
 #include "spdk/net.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 static void
 interface_subsystem_init(void)
diff --git a/module/event/subsystems/nvmf/event_nvmf.h b/module/event/subsystems/nvmf/event_nvmf.h
index b22927ffc..59a884e3f 100644
--- a/module/event/subsystems/nvmf/event_nvmf.h
+++ b/module/event/subsystems/nvmf/event_nvmf.h
@@ -39,7 +39,7 @@
 #include "spdk/nvmf.h"
 #include "spdk/queue.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 #include "spdk/log.h"
 
 #define ACCEPT_TIMEOUT_US	10000 /* 10ms */
diff --git a/module/event/subsystems/scsi/scsi.c b/module/event/subsystems/scsi/scsi.c
index f068b0da6..daf818acf 100644
--- a/module/event/subsystems/scsi/scsi.c
+++ b/module/event/subsystems/scsi/scsi.c
@@ -35,7 +35,7 @@
 
 #include "spdk/scsi.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 static void
 scsi_subsystem_init(void)
diff --git a/module/event/subsystems/sock/sock.c b/module/event/subsystems/sock/sock.c
index fdcb2160a..5777555c8 100644
--- a/module/event/subsystems/sock/sock.c
+++ b/module/event/subsystems/sock/sock.c
@@ -32,7 +32,7 @@
 
 #include "spdk/stdinc.h"
 #include "spdk/sock.h"
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 static void
 sock_subsystem_init(void)
diff --git a/module/event/subsystems/vhost/vhost.c b/module/event/subsystems/vhost/vhost.c
index b348cca5d..1fa9b9f13 100644
--- a/module/event/subsystems/vhost/vhost.c
+++ b/module/event/subsystems/vhost/vhost.c
@@ -35,7 +35,7 @@
 
 #include "spdk/vhost.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 
 static void
 vhost_subsystem_init_done(int rc)
diff --git a/module/event/subsystems/vmd/vmd.c b/module/event/subsystems/vmd/vmd.c
index 2d496994c..07717453f 100644
--- a/module/event/subsystems/vmd/vmd.c
+++ b/module/event/subsystems/vmd/vmd.c
@@ -32,12 +32,15 @@
  */
 
 #include "spdk/stdinc.h"
+
+#include "spdk/json.h"
 #include "spdk/thread.h"
 #include "spdk/likely.h"
+#include "spdk/log.h"
 
 #include "spdk/vmd.h"
 
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 #include "event_vmd.h"
 
 static struct spdk_poller *g_hotplug_poller;
diff --git a/test/app/bdev_svc/Makefile b/test/app/bdev_svc/Makefile
index 9e560de0f..a13faf085 100644
--- a/test/app/bdev_svc/Makefile
+++ b/test/app/bdev_svc/Makefile
@@ -39,10 +39,10 @@ APP = bdev_svc
 
 C_SRCS := bdev_svc.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 ifeq ($(OS),Linux)
-SPDK_LIB_LIST += event_nbd
+SPDK_LIB_LIST += event event_nbd
 endif
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/test/bdev/bdevio/Makefile b/test/bdev/bdevio/Makefile
index a42ded076..166e48096 100644
--- a/test/bdev/bdevio/Makefile
+++ b/test/bdev/bdevio/Makefile
@@ -39,7 +39,7 @@ APP = bdevio
 
 C_SRCS := bdevio.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 LIBS += -lcunit
 
diff --git a/test/bdev/bdevperf/Makefile b/test/bdev/bdevperf/Makefile
index ef100188d..fac2d2104 100644
--- a/test/bdev/bdevperf/Makefile
+++ b/test/bdev/bdevperf/Makefile
@@ -39,7 +39,7 @@ APP = bdevperf
 
 C_SRCS := bdevperf.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev conf
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev conf
 
 ifeq ($(OS),Linux)
 SPDK_LIB_LIST += event_nbd
diff --git a/test/blobfs/mkfs/Makefile b/test/blobfs/mkfs/Makefile
index 775e49d98..6121cc524 100644
--- a/test/blobfs/mkfs/Makefile
+++ b/test/blobfs/mkfs/Makefile
@@ -39,6 +39,6 @@ APP = mkfs
 
 C_SRCS := mkfs.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/test/event/app_repeat/Makefile b/test/event/app_repeat/Makefile
index f73b4403c..a0ff1e8dc 100644
--- a/test/event/app_repeat/Makefile
+++ b/test/event/app_repeat/Makefile
@@ -47,6 +47,6 @@ BLOCKDEV_LIST = bdev_malloc bdev_null
 BLOCKDEV_LIST += bdev_aio
 SYS_LIBS += -laio
 
-SPDK_LIB_LIST += $(BLOCKDEV_LIST)
+SPDK_LIB_LIST += $(BLOCKDEV_LIST) event
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/test/event/event_perf/event_perf.c b/test/event/event_perf/event_perf.c
index 631ade161..77508fd28 100644
--- a/test/event/event_perf/event_perf.c
+++ b/test/event/event_perf/event_perf.c
@@ -35,7 +35,7 @@
 
 #include "spdk/env.h"
 #include "spdk/event.h"
-#include "spdk_internal/event.h"
+#include "spdk_internal/init.h"
 #include "spdk/log.h"
 #include "spdk/string.h"
 
diff --git a/test/event/scheduler/Makefile b/test/event/scheduler/Makefile
index 13aa0ab94..cd58c27e8 100644
--- a/test/event/scheduler/Makefile
+++ b/test/event/scheduler/Makefile
@@ -38,6 +38,6 @@ include $(SPDK_ROOT_DIR)/mk/spdk.modules.mk
 APP = scheduler
 C_SRCS := scheduler.c
 
-SPDK_LIB_LIST = $(ALL_MODULES_LIST) event_bdev conf
+SPDK_LIB_LIST = $(ALL_MODULES_LIST) event event_bdev conf
 
 include $(SPDK_ROOT_DIR)/mk/spdk.app.mk
diff --git a/test/external_code/hello_world/Makefile b/test/external_code/hello_world/Makefile
index 4e5de3ebd..96eba7583 100644
--- a/test/external_code/hello_world/Makefile
+++ b/test/external_code/hello_world/Makefile
@@ -34,8 +34,8 @@
 PKG_CONFIG_PATH = $(SPDK_LIB_DIR)/pkgconfig
 
 DPDK_LIB := $(shell PKG_CONFIG_PATH="$(PKG_CONFIG_PATH)" pkg-config --libs spdk_env_dpdk)
-SPDK_BDEV_LIB := $(shell PKG_CONFIG_PATH="$(PKG_CONFIG_PATH)" pkg-config --libs spdk_event_bdev)
-SPDK_DPDK_LIB := $(shell PKG_CONFIG_PATH="$(PKG_CONFIG_PATH)" pkg-config --libs spdk_event_bdev spdk_env_dpdk)
+SPDK_EVENT_LIB := $(shell PKG_CONFIG_PATH="$(PKG_CONFIG_PATH)" pkg-config --libs spdk_event spdk_event_bdev)
+SPDK_DPDK_LIB := $(shell PKG_CONFIG_PATH="$(PKG_CONFIG_PATH)" pkg-config --libs spdk_event spdk_event_bdev spdk_env_dpdk)
 SYS_LIB := $(shell PKG_CONFIG_PATH="$(PKG_CONFIG_PATH)" pkg-config --libs --static spdk_syslibs)
 
 # Shows how to compile both an external bdev and an external application against the SPDK combined shared object and dpdk shared objects.
@@ -46,7 +46,7 @@ bdev_shared_combo:
 # Shows how to compile both an external bdev and an external application against the SPDK individual shared objects and dpdk shared objects.
 bdev_shared_iso:
 	$(CC) $(COMMON_CFLAGS) -L../passthru -Wl,--no-as-needed -o hello_bdev ./hello_bdev.c \
-	-lpassthru_external $(SPDK_BDEV_LIB) \
+	-lpassthru_external $(SPDK_EVENT_LIB) \
 	$(DPDK_LIB)
 
 # Shows how to compile an external application against the SPDK combined shared object and dpdk shared objects.
@@ -56,7 +56,7 @@ alone_shared_combo:
 # Shows how to compile an external application against the SPDK individual shared objects and dpdk shared objects.
 alone_shared_iso:
 	$(CC) $(COMMON_CFLAGS) -Wl,-rpath=$(SPDK_LIB_DIR),--no-as-needed -o hello_bdev ./hello_bdev.c \
-	$(SPDK_BDEV_LIB) $(DPDK_LIB)
+	$(SPDK_EVENT_LIB) $(DPDK_LIB)
 
 # Shows how to compile an external application against the SPDK archives.
 alone_static:
diff --git a/test/unit/lib/Makefile b/test/unit/lib/Makefile
index c7fbc5345..a7ed1eea5 100644
--- a/test/unit/lib/Makefile
+++ b/test/unit/lib/Makefile
@@ -35,7 +35,7 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 DIRS-y = accel bdev blob blobfs event ioat iscsi json jsonrpc log lvol
-DIRS-y += notify nvme nvmf scsi sock thread util env_dpdk
+DIRS-y += notify nvme nvmf scsi sock thread util env_dpdk init
 DIRS-$(CONFIG_IDXD) += idxd
 DIRS-$(CONFIG_REDUCE) += reduce
 ifeq ($(OS),Linux)
diff --git a/test/unit/lib/event/Makefile b/test/unit/lib/event/Makefile
index ea411460c..d87b0b1e7 100644
--- a/test/unit/lib/event/Makefile
+++ b/test/unit/lib/event/Makefile
@@ -34,7 +34,7 @@
 SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
-DIRS-y = subsystem.c app.c reactor.c
+DIRS-y = app.c reactor.c
 
 .PHONY: all clean $(DIRS-y)
 
diff --git a/test/unit/lib/init/Makefile b/test/unit/lib/init/Makefile
new file mode 100644
index 000000000..862db3c0d
--- /dev/null
+++ b/test/unit/lib/init/Makefile
@@ -0,0 +1,44 @@
+#
+#  BSD LICENSE
+#
+#  Copyright (c) Intel Corporation.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Intel Corporation nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../../..)
+include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
+
+DIRS-y = subsystem.c
+
+.PHONY: all clean $(DIRS-y)
+
+all: $(DIRS-y)
+clean: $(DIRS-y)
+
+include $(SPDK_ROOT_DIR)/mk/spdk.subdirs.mk
diff --git a/test/unit/lib/event/subsystem.c/.gitignore b/test/unit/lib/init/subsystem.c/.gitignore
similarity index 100%
rename from test/unit/lib/event/subsystem.c/.gitignore
rename to test/unit/lib/init/subsystem.c/.gitignore
diff --git a/test/unit/lib/event/subsystem.c/Makefile b/test/unit/lib/init/subsystem.c/Makefile
similarity index 100%
rename from test/unit/lib/event/subsystem.c/Makefile
rename to test/unit/lib/init/subsystem.c/Makefile
diff --git a/test/unit/lib/event/subsystem.c/subsystem_ut.c b/test/unit/lib/init/subsystem.c/subsystem_ut.c
similarity index 99%
rename from test/unit/lib/event/subsystem.c/subsystem_ut.c
rename to test/unit/lib/init/subsystem.c/subsystem_ut.c
index 608f2e4b1..e56664aab 100644
--- a/test/unit/lib/event/subsystem.c/subsystem_ut.c
+++ b/test/unit/lib/init/subsystem.c/subsystem_ut.c
@@ -36,7 +36,7 @@
 #include "spdk_cunit.h"
 
 #include "unit/lib/json_mock.c"
-#include "event/subsystem.c"
+#include "init/subsystem.c"
 #include "common/lib/test_env.c"
 
 static struct spdk_subsystem g_ut_subsystems[8];
diff --git a/test/unit/unittest.sh b/test/unit/unittest.sh
index e9f688c0b..493076756 100755
--- a/test/unit/unittest.sh
+++ b/test/unit/unittest.sh
@@ -40,7 +40,6 @@ function unittest_blob() {
 }
 
 function unittest_event() {
-	$valgrind $testdir/lib/event/subsystem.c/subsystem_ut
 	$valgrind $testdir/lib/event/app.c/app_ut
 	$valgrind $testdir/lib/event/reactor.c/reactor_ut
 }
@@ -128,6 +127,10 @@ function unittest_util() {
 	$valgrind $testdir/lib/util/pipe.c/pipe_ut
 }
 
+function unittest_init() {
+	$valgrind $testdir/lib/init/subsystem.c/subsystem_ut
+}
+
 # if ASAN is enabled, use it.  If not use valgrind if installed but allow
 # the env variable to override the default shown below.
 if [ -z ${valgrind+x} ]; then
@@ -235,6 +238,8 @@ if grep -q '#define SPDK_CONFIG_VHOST 1' $rootdir/include/spdk/config.h; then
 	run_test "unittest_vhost" $valgrind $testdir/lib/vhost/vhost.c/vhost_ut
 fi
 
+run_test "unittest_init" unittest_init
+
 if [ "$cov_avail" = "yes" ] && ! [[ "$CC_TYPE" == *"clang"* ]]; then
 	$LCOV -q -d . -c -t "$(hostname)" -o $UT_COVERAGE/ut_cov_test.info
 	$LCOV -q -a $UT_COVERAGE/ut_cov_base.info -a $UT_COVERAGE/ut_cov_test.info -o $UT_COVERAGE/ut_cov_total.info
-- 
2.26.2


From 320fdaa325f1671cee1712995dd4467dfbde9c71 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 17 May 2021 10:17:04 -0400
Subject: [PATCH 232/342] ut/event: add current reactor tsc accounting

This patch does not change the UT in functional way.

Added accounting of last_tsc and spdk_get_ticks() similar
to the real application.
First the reactor_run() [not _reactor_run()] starts
reactor->tsc_last to current time. UT now set it at the start
and never touch it again directly.

Second the spdk_get_ticks() is updated to the elapsed time
to simulate flow of time, and make sure that its further
usage is up to date to the current time.

Fixed typo in test case description for test_reactor_stats.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: Iaa2eb00fa3bffc2f21f1692da0259f1d023086b8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7904
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Community-CI: Mellanox Build Bot
---
 test/unit/lib/event/reactor.c/reactor_ut.c | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/test/unit/lib/event/reactor.c/reactor_ut.c b/test/unit/lib/event/reactor.c/reactor_ut.c
index 347b0af29..7c7830d5b 100644
--- a/test/unit/lib/event/reactor.c/reactor_ut.c
+++ b/test/unit/lib/event/reactor.c/reactor_ut.c
@@ -371,7 +371,7 @@ test_reactor_stats(void)
 	 * - thread1 for 300 with idle
 	 * - thread2 for 400 with busy.
 	 * Then,
-	 * - both elapsed TSC of thread1 and thread2 should be 1000 (= 100 + 900).
+	 * - both elapsed TSC of thread1 and thread2 should be 1100 (= 100 + 1000).
 	 * - busy TSC of reactor should be 500 (= 100 + 400).
 	 * - idle TSC of reactor should be 500 (= 200 + 300).
 	 */
@@ -384,7 +384,12 @@ test_reactor_stats(void)
 
 	spdk_cpuset_set_cpu(&cpuset, 0, true);
 
+	reactor = spdk_reactor_get(0);
+	SPDK_CU_ASSERT_FATAL(reactor != NULL);
+
+	/* First reactor_run() sets the tsc_last. */
 	MOCK_SET(spdk_get_ticks, 100);
+	reactor->tsc_last = spdk_get_ticks();
 
 	thread1 = spdk_thread_create(NULL, &cpuset);
 	SPDK_CU_ASSERT_FATAL(thread1 != NULL);
@@ -392,11 +397,6 @@ test_reactor_stats(void)
 	thread2 = spdk_thread_create(NULL, &cpuset);
 	SPDK_CU_ASSERT_FATAL(thread2 != NULL);
 
-	reactor = spdk_reactor_get(0);
-	SPDK_CU_ASSERT_FATAL(reactor != NULL);
-
-	reactor->tsc_last = 100;
-
 	spdk_set_thread(thread1);
 	busy1 = spdk_poller_register(poller_run_busy, (void *)100, 0);
 	CU_ASSERT(busy1 != NULL);
@@ -421,6 +421,9 @@ test_reactor_stats(void)
 	CU_ASSERT(reactor->busy_tsc == 100);
 	CU_ASSERT(reactor->idle_tsc == 300);
 
+	/* 100 + 100 + 300 = 500 ticks elapsed */
+	CU_ASSERT(reactor->tsc_last == 500);
+
 	spdk_set_thread(thread1);
 	spdk_poller_unregister(&busy1);
 	idle1 = spdk_poller_register(poller_run_idle, (void *)200, 0);
@@ -447,6 +450,9 @@ test_reactor_stats(void)
 	CU_ASSERT(reactor->busy_tsc == 500);
 	CU_ASSERT(reactor->idle_tsc == 500);
 
+	/* 500 + 200 + 400 = 1100 ticks elapsed */
+	CU_ASSERT(reactor->tsc_last == 1100);
+
 	spdk_set_thread(thread1);
 	spdk_poller_unregister(&idle1);
 	spdk_thread_exit(thread1);
@@ -459,6 +465,9 @@ test_reactor_stats(void)
 
 	CU_ASSERT(TAILQ_EMPTY(&reactor->threads));
 
+	/* No further than 1100 ticks elapsed */
+	CU_ASSERT(reactor->tsc_last == 1100);
+
 	spdk_reactors_fini();
 
 	free_cores();
-- 
2.26.2


From 7438c388a0f9436bafa10cffc43044d2b919f59a Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Fri, 7 May 2021 12:52:05 -0400
Subject: [PATCH 233/342] lib/event: fix tsc_last for first thread on reactor

tsc_last value is used to update thread stats
during _reactor_run(). See:
spdk_thread_poll(thread, 0, reactor->tsc_last);

If no threads were present on the reactor,
this value got outdated and resulted in
adding time reactor spent with no threads to
stats of the first thread placed on that reactor.

This patch fixes thread stats by making sure
that argument to spdk_thread_poll() is up to date.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I0c35fdba1b63b6ee19a5a2b34751090839cb2438
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7845
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 lib/event/reactor.c                        |  8 ++++
 test/unit/lib/event/reactor.c/reactor_ut.c | 46 +++++++++++++++++++++-
 2 files changed, 52 insertions(+), 2 deletions(-)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index fd886c353..0e8536aa5 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -901,6 +901,14 @@ _reactor_run(struct spdk_reactor *reactor)
 
 	event_queue_run_batch(reactor);
 
+	/* If no threads are present on the reactor,
+	 * tsc_last gets outdated. Update it to track
+	 * thread execution time correctly. */
+	if (spdk_unlikely(TAILQ_EMPTY(&reactor->threads))) {
+		reactor->tsc_last = spdk_get_ticks();
+		return;
+	}
+
 	TAILQ_FOREACH_SAFE(lw_thread, &reactor->threads, link, tmp) {
 		thread = spdk_thread_get_from_ctx(lw_thread);
 		rc = spdk_thread_poll(thread, 0, reactor->tsc_last);
diff --git a/test/unit/lib/event/reactor.c/reactor_ut.c b/test/unit/lib/event/reactor.c/reactor_ut.c
index 7c7830d5b..eaeb38166 100644
--- a/test/unit/lib/event/reactor.c/reactor_ut.c
+++ b/test/unit/lib/event/reactor.c/reactor_ut.c
@@ -374,6 +374,15 @@ test_reactor_stats(void)
 	 * - both elapsed TSC of thread1 and thread2 should be 1100 (= 100 + 1000).
 	 * - busy TSC of reactor should be 500 (= 100 + 400).
 	 * - idle TSC of reactor should be 500 (= 200 + 300).
+	 *
+	 * After that reactor0 runs with no threads for 900 TSC.
+	 * Create thread1 on reactor0 at TSC = 2000.
+	 * Reactor runs
+	 * - thread1 for 100 with busy
+	 * Then,
+	 * - elapsed TSC of thread1 should be 2100 (= 2000+ 100).
+	 * - busy TSC of reactor should be 600 (= 500 + 100).
+	 * - idle TSC of reactor should be 500 (= 500 + 0).
 	 */
 
 	MOCK_SET(spdk_env_get_current_core, 0);
@@ -463,10 +472,43 @@ test_reactor_stats(void)
 
 	_reactor_run(reactor);
 
+	/* After 900 ticks new thread is created. */
+	/* 1100 + 900 = 2000 ticks elapsed */
+	MOCK_SET(spdk_get_ticks, 2000);
+	_reactor_run(reactor);
+	CU_ASSERT(reactor->tsc_last == 2000);
+
+	thread1 = spdk_thread_create(NULL, &cpuset);
+	SPDK_CU_ASSERT_FATAL(thread1 != NULL);
+
+	spdk_set_thread(thread1);
+	busy1 = spdk_poller_register(poller_run_busy, (void *)100, 0);
+	CU_ASSERT(busy1 != NULL);
+
+	_reactor_run(reactor);
+
+	spdk_set_thread(thread1);
+	CU_ASSERT(spdk_thread_get_last_tsc(thread1) == 2100);
+	CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+	CU_ASSERT(stats.busy_tsc == 100);
+	CU_ASSERT(stats.idle_tsc == 0);
+
+	CU_ASSERT(reactor->busy_tsc == 600);
+	CU_ASSERT(reactor->idle_tsc == 500);
+
+	/* 2000 + 100 = 2100 ticks elapsed */
+	CU_ASSERT(reactor->tsc_last == 2100);
+
+	spdk_set_thread(thread1);
+	spdk_poller_unregister(&busy1);
+	spdk_thread_exit(thread1);
+
+	_reactor_run(reactor);
+
 	CU_ASSERT(TAILQ_EMPTY(&reactor->threads));
 
-	/* No further than 1100 ticks elapsed */
-	CU_ASSERT(reactor->tsc_last == 1100);
+	/* No further than 2100 ticks elapsed */
+	CU_ASSERT(reactor->tsc_last == 2100);
 
 	spdk_reactors_fini();
 
-- 
2.26.2


From a5ad0f8051291dcd2c780464329d18ae4764562d Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 17 May 2021 09:05:44 -0400
Subject: [PATCH 234/342] lib/event: update reactor tsc_last going poll mode

Disabling interrupt mode on reactor now updates the tsc_last
to current time. So any further tsc caulations will not account
for the time when reactor was in interrupt mode.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I56fb8a738eea60ee5de3b49d586f7cb228b54510
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7901
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/event/reactor.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index 0e8536aa5..69addc8bc 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -363,6 +363,9 @@ _reactor_set_notify_cpuset_cpl(void *arg1, void *arg2)
 	struct spdk_reactor *target = arg1;
 
 	if (target->new_in_interrupt == false) {
+		/* Reactor is no longer in interrupt mode. Refresh the tsc_last to accurately
+		 * track reactor stats. */
+		target->tsc_last = spdk_get_ticks();
 		target->set_interrupt_mode_in_progress = false;
 		spdk_thread_send_msg(_spdk_get_app_thread(), target->set_interrupt_mode_cb_fn,
 				     target->set_interrupt_mode_cb_arg);
-- 
2.26.2


From e65310624b2248b606a0755b795626b045eb58bb Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 17 May 2021 08:59:46 -0400
Subject: [PATCH 235/342] lib/event: accumulate idle_tsc when reactor has no
 threads

Before this patch idle_tsc was sum of all idle tsc of all
threads running on a reactor.

There are cases when no threads are present on the reactor,
and _reactor_run() spins doing nothing.

To give more accurate representation of the reactors state,
the idle_tsc now adds time spent doing idle spinning.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: If797b2a03507d17b07367d56d5f6c40cefbbbd49
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7900
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/event/reactor.c                        | 4 +++-
 test/unit/lib/event/reactor.c/reactor_ut.c | 4 ++--
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index 69addc8bc..b890f6e24 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -908,7 +908,9 @@ _reactor_run(struct spdk_reactor *reactor)
 	 * tsc_last gets outdated. Update it to track
 	 * thread execution time correctly. */
 	if (spdk_unlikely(TAILQ_EMPTY(&reactor->threads))) {
-		reactor->tsc_last = spdk_get_ticks();
+		now = spdk_get_ticks();
+		reactor->idle_tsc += now - reactor->tsc_last;
+		reactor->tsc_last = now;
 		return;
 	}
 
diff --git a/test/unit/lib/event/reactor.c/reactor_ut.c b/test/unit/lib/event/reactor.c/reactor_ut.c
index eaeb38166..aaa138744 100644
--- a/test/unit/lib/event/reactor.c/reactor_ut.c
+++ b/test/unit/lib/event/reactor.c/reactor_ut.c
@@ -382,7 +382,7 @@ test_reactor_stats(void)
 	 * Then,
 	 * - elapsed TSC of thread1 should be 2100 (= 2000+ 100).
 	 * - busy TSC of reactor should be 600 (= 500 + 100).
-	 * - idle TSC of reactor should be 500 (= 500 + 0).
+	 * - idle TSC of reactor should be 500 (= 500 + 900).
 	 */
 
 	MOCK_SET(spdk_env_get_current_core, 0);
@@ -494,7 +494,7 @@ test_reactor_stats(void)
 	CU_ASSERT(stats.idle_tsc == 0);
 
 	CU_ASSERT(reactor->busy_tsc == 600);
-	CU_ASSERT(reactor->idle_tsc == 500);
+	CU_ASSERT(reactor->idle_tsc == 1400);
 
 	/* 2000 + 100 = 2100 ticks elapsed */
 	CU_ASSERT(reactor->tsc_last == 2100);
-- 
2.26.2


From 42ad9d0379b10b71df592382b450780ffbcc161c Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Fri, 21 May 2021 06:25:37 -0400
Subject: [PATCH 236/342] lib/blob: resize open_blobids on bs load

open_blobids holds bit array of currently open blobs,
this is a way for quicker determination than iterating
over all blobs. See patch introducing it:
(30ee8137)blob: Add a bitmask for quickly checking which blobs are open

That patch added resizes of this bit array to bs init
and bs recovery path (not shut down cleanly).

But that patch skipped over bs load from a clean shutdown.
This resulted in blob open having multiple blob pointers that
target the same blob id.

Fixes #1937

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I3c42a63d168d1f5b013b449f010c5b207936045b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7998
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/blob/blobstore.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/lib/blob/blobstore.c b/lib/blob/blobstore.c
index 3476bed13..b6f00c623 100644
--- a/lib/blob/blobstore.c
+++ b/lib/blob/blobstore.c
@@ -4366,6 +4366,12 @@ bs_load_super_cpl(spdk_bs_sequence_t *seq, void *cb_arg, int bserrno)
 	}
 	ctx->bs->md_start = ctx->super->md_start;
 	ctx->bs->md_len = ctx->super->md_len;
+	rc = spdk_bit_array_resize(&ctx->bs->open_blobids, ctx->bs->md_len);
+	if (rc < 0) {
+		bs_load_ctx_fail(ctx, -ENOMEM);
+		return;
+	}
+
 	ctx->bs->total_data_clusters = ctx->bs->total_clusters - spdk_divide_round_up(
 					       ctx->bs->md_start + ctx->bs->md_len, ctx->bs->pages_per_cluster);
 	ctx->bs->super_blob = ctx->super->super_blob;
-- 
2.26.2


From 7ee25c2e4c1896b29e07cc148a05987d6ed5e6c0 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Mon, 24 May 2021 20:19:20 +0800
Subject: [PATCH 237/342] examples/nvme/identify: rename get_features to
 get_ctrlr_features

This will help us to add get namespace features later.

Change-Id: I7e809cd9e3bcb3874ce141183b9c4ee82543616c
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8008
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: <dongx.yi@intel.com>
---
 examples/nvme/identify/identify.c | 36 +++++++++++++++++++------------
 1 file changed, 22 insertions(+), 14 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index d7812cb11..a923b67c7 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -201,7 +201,7 @@ get_zns_zone_report_completion(void *cb_arg, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-get_feature(struct spdk_nvme_ctrlr *ctrlr, uint8_t fid)
+get_feature(struct spdk_nvme_ctrlr *ctrlr, uint8_t fid, uint32_t nsid)
 {
 	struct spdk_nvme_cmd cmd = {};
 	struct feature *feature = &features[fid];
@@ -210,35 +210,28 @@ get_feature(struct spdk_nvme_ctrlr *ctrlr, uint8_t fid)
 
 	cmd.opc = SPDK_NVME_OPC_GET_FEATURES;
 	cmd.cdw10_bits.get_features.fid = fid;
+	cmd.nsid = nsid;
 
 	return spdk_nvme_ctrlr_cmd_admin_raw(ctrlr, &cmd, NULL, 0, get_feature_completion, feature);
 }
 
 static void
-get_features(struct spdk_nvme_ctrlr *ctrlr)
+get_features(struct spdk_nvme_ctrlr *ctrlr, uint8_t *features_to_get, size_t num_features,
+	     uint32_t nsid)
 {
 	size_t i;
 
-	uint8_t features_to_get[] = {
-		SPDK_NVME_FEAT_ARBITRATION,
-		SPDK_NVME_FEAT_POWER_MANAGEMENT,
-		SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD,
-		SPDK_NVME_FEAT_ERROR_RECOVERY,
-		SPDK_NVME_FEAT_NUMBER_OF_QUEUES,
-		SPDK_OCSSD_FEAT_MEDIA_FEEDBACK,
-	};
-
 	/* Submit only one GET FEATURES at a time. There is a known issue #1799
 	 * with Google Cloud Platform NVMe SSDs that do not handle overlapped
 	 * GET FEATURES commands correctly.
 	 */
 	outstanding_commands = 0;
-	for (i = 0; i < SPDK_COUNTOF(features_to_get); i++) {
+	for (i = 0; i < num_features; i++) {
 		if (!spdk_nvme_ctrlr_is_ocssd_supported(ctrlr) &&
 		    features_to_get[i] == SPDK_OCSSD_FEAT_MEDIA_FEEDBACK) {
 			continue;
 		}
-		if (get_feature(ctrlr, features_to_get[i]) == 0) {
+		if (get_feature(ctrlr, features_to_get[i], nsid) == 0) {
 			outstanding_commands++;
 		} else {
 			printf("get_feature(0x%02X) failed to submit command\n", features_to_get[i]);
@@ -251,6 +244,21 @@ get_features(struct spdk_nvme_ctrlr *ctrlr)
 
 }
 
+static void
+get_ctrlr_features(struct spdk_nvme_ctrlr *ctrlr)
+{
+	uint8_t features_to_get[] = {
+		SPDK_NVME_FEAT_ARBITRATION,
+		SPDK_NVME_FEAT_POWER_MANAGEMENT,
+		SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD,
+		SPDK_NVME_FEAT_ERROR_RECOVERY,
+		SPDK_NVME_FEAT_NUMBER_OF_QUEUES,
+		SPDK_OCSSD_FEAT_MEDIA_FEEDBACK,
+	};
+
+	get_features(ctrlr, features_to_get, SPDK_COUNTOF(features_to_get), 0);
+}
+
 static int
 get_error_log_page(struct spdk_nvme_ctrlr *ctrlr)
 {
@@ -1204,7 +1212,7 @@ print_controller(struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_transport
 		 * attempt GET_FEATURES when NOT targeting a
 		 * Discovery Controller.
 		 */
-		get_features(ctrlr);
+		get_ctrlr_features(ctrlr);
 	}
 	get_log_pages(ctrlr);
 
-- 
2.26.2


From 51b6cbb9a7b0688eacfc3623144156b34f65bf78 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Mon, 24 May 2021 20:30:02 +0800
Subject: [PATCH 238/342] examples/nvme/identify: pass nsid to Error Recovery
 feature

The P5800X drive will report the following error when getting Error Recovery
feature, according to the specification we should pass valid nsid.

nvme_qpair.c: 238:nvme_admin_qpair_print_command: *NOTICE*: GET FEATURES ERROR_RECOVERY cid:23 cdw10:00000005 PRP1 0x0 PRP2 0x0
nvme_qpair.c: 452:spdk_nvme_print_completion: *NOTICE*: INVALID NAMESPACE OR FORMAT (00/0b) qid:0 cid:23 cdw0:0 sqhd:000f p:1 m:0 dnr:1
get_feature(0x05) failed

Fix issue #1955

Change-Id: I30ce60cddcddbf78e57a8c172a2056a82ac72802
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8009
Reviewed-by: Chengqiang Meng <chengqiangx.meng@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 examples/nvme/identify/identify.c | 31 +++++++++++++++++++++----------
 1 file changed, 21 insertions(+), 10 deletions(-)

diff --git a/examples/nvme/identify/identify.c b/examples/nvme/identify/identify.c
index a923b67c7..8da8f5fc9 100644
--- a/examples/nvme/identify/identify.c
+++ b/examples/nvme/identify/identify.c
@@ -251,7 +251,6 @@ get_ctrlr_features(struct spdk_nvme_ctrlr *ctrlr)
 		SPDK_NVME_FEAT_ARBITRATION,
 		SPDK_NVME_FEAT_POWER_MANAGEMENT,
 		SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD,
-		SPDK_NVME_FEAT_ERROR_RECOVERY,
 		SPDK_NVME_FEAT_NUMBER_OF_QUEUES,
 		SPDK_OCSSD_FEAT_MEDIA_FEEDBACK,
 	};
@@ -259,6 +258,16 @@ get_ctrlr_features(struct spdk_nvme_ctrlr *ctrlr)
 	get_features(ctrlr, features_to_get, SPDK_COUNTOF(features_to_get), 0);
 }
 
+static void
+get_ns_features(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
+{
+	uint8_t features_to_get[] = {
+		SPDK_NVME_FEAT_ERROR_RECOVERY,
+	};
+
+	get_features(ctrlr, features_to_get, SPDK_COUNTOF(features_to_get), nsid);
+}
+
 static int
 get_error_log_page(struct spdk_nvme_ctrlr *ctrlr)
 {
@@ -950,6 +959,16 @@ print_namespace(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_ns *ns)
 	/* This function is only called for active namespaces. */
 	assert(spdk_nvme_ns_is_active(ns));
 
+	if (features[SPDK_NVME_FEAT_ERROR_RECOVERY].valid) {
+		unsigned tler = features[SPDK_NVME_FEAT_ERROR_RECOVERY].result & 0xFFFF;
+		printf("Error Recovery Timeout:                ");
+		if (tler == 0) {
+			printf("Unlimited\n");
+		} else {
+			printf("%u milliseconds\n", tler * 100);
+		}
+	}
+
 	printf("Command Set Identifier:                %s (%02Xh)\n",
 	       csi_name(spdk_nvme_ns_get_csi(ns)), spdk_nvme_ns_get_csi(ns));
 	printf("Deallocate:                            %s\n",
@@ -1273,15 +1292,6 @@ print_controller(struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_transport
 		printf("%" PRIu64 "\n", (uint64_t)1 << (12 + cap.bits.mpsmin + cdata->mdts));
 	}
 	printf("Max Number of Namespaces:              %d\n", cdata->nn);
-	if (features[SPDK_NVME_FEAT_ERROR_RECOVERY].valid) {
-		unsigned tler = features[SPDK_NVME_FEAT_ERROR_RECOVERY].result & 0xFFFF;
-		printf("Error Recovery Timeout:                ");
-		if (tler == 0) {
-			printf("Unlimited\n");
-		} else {
-			printf("%u milliseconds\n", tler * 100);
-		}
-	}
 	printf("NVMe Specification Version (VS):       %u.%u", vs.bits.mjr, vs.bits.mnr);
 	if (vs.bits.ter) {
 		printf(".%u", vs.bits.ter);
@@ -1963,6 +1973,7 @@ print_controller(struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_transport
 	printf("=================\n");
 	for (nsid = spdk_nvme_ctrlr_get_first_active_ns(ctrlr);
 	     nsid != 0; nsid = spdk_nvme_ctrlr_get_next_active_ns(ctrlr, nsid)) {
+		get_ns_features(ctrlr, nsid);
 		print_namespace(ctrlr, spdk_nvme_ctrlr_get_ns(ctrlr, nsid));
 	}
 
-- 
2.26.2


From 00b0dc66248cfd6e1e54bd71ec610d7e638b0fd5 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 25 May 2021 00:46:33 +0800
Subject: [PATCH 239/342] nvme/tcp: Do not offload header crc32c calculation if
 header digest is enabled.

The header size is very small, which does not have too much value to
offload such calculation by hardware.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: Iaa82f39312df7eef3282325a33677ea41ab735ab
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8011
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 include/spdk_internal/nvme_tcp.h |  1 -
 lib/nvme/nvme_tcp.c              | 32 +++-----------------------------
 2 files changed, 3 insertions(+), 30 deletions(-)

diff --git a/include/spdk_internal/nvme_tcp.h b/include/spdk_internal/nvme_tcp.h
index 8d2e20515..3345880c1 100644
--- a/include/spdk_internal/nvme_tcp.h
+++ b/include/spdk_internal/nvme_tcp.h
@@ -101,7 +101,6 @@ struct nvme_tcp_pdu {
 
 	bool						has_hdgst;
 	bool						ddgst_enable;
-	uint32_t					header_digest_crc32;
 	uint32_t					data_digest_crc32;
 	uint8_t						data_digest[SPDK_NVME_TCP_DIGEST_LEN];
 
diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index ce9fc0b92..218ccaea1 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -460,22 +460,6 @@ pdu_data_crc32_compute(struct nvme_tcp_pdu *pdu)
 	_tcp_write_pdu(pdu);
 }
 
-static void
-header_crc32_accel_done(void *cb_arg, int status)
-{
-	struct nvme_tcp_pdu *pdu = cb_arg;
-
-	pdu->header_digest_crc32 ^= SPDK_CRC32C_XOR;
-	MAKE_DIGEST_WORD((uint8_t *)pdu->hdr.raw + pdu->hdr.common.hlen, pdu->header_digest_crc32);
-	if (spdk_unlikely(status)) {
-		SPDK_ERRLOG("Failed to compute header digest on pdu=%p\n", pdu);
-		_pdu_write_done(pdu, status);
-		return;
-	}
-
-	pdu_data_crc32_compute(pdu);
-}
-
 static int
 nvme_tcp_qpair_write_pdu(struct nvme_tcp_qpair *tqpair,
 			 struct nvme_tcp_pdu *pdu,
@@ -484,27 +468,17 @@ nvme_tcp_qpair_write_pdu(struct nvme_tcp_qpair *tqpair,
 {
 	int hlen;
 	uint32_t crc32c;
-	struct nvme_tcp_poll_group *tgroup = nvme_tcp_poll_group(tqpair->qpair.poll_group);
 
 	hlen = pdu->hdr.common.hlen;
-
 	pdu->cb_fn = cb_fn;
 	pdu->cb_arg = cb_arg;
 	pdu->qpair = tqpair;
 
 	/* Header Digest */
 	if (g_nvme_tcp_hdgst[pdu->hdr.common.pdu_type] && tqpair->flags.host_hdgst_enable) {
-		if (tgroup != NULL && tgroup->group.group->accel_fn_table.submit_accel_crc32c) {
-			pdu->iov[0].iov_base = &pdu->hdr.raw;
-			pdu->iov[0].iov_len = hlen;
-			tgroup->group.group->accel_fn_table.submit_accel_crc32c(tgroup->group.group->ctx,
-					&pdu->header_digest_crc32,
-					pdu->iov, 1, 0, header_crc32_accel_done, pdu);
-			return 0;
-		} else {
-			crc32c = nvme_tcp_pdu_calc_header_digest(pdu);
-			MAKE_DIGEST_WORD((uint8_t *)pdu->hdr.raw + hlen, crc32c);
-		}
+		crc32c = nvme_tcp_pdu_calc_header_digest(pdu);
+		MAKE_DIGEST_WORD((uint8_t *)pdu->hdr.raw + hlen, crc32c);
+
 	}
 
 	pdu_data_crc32_compute(pdu);
-- 
2.26.2


From 1a8467b02cb3be18f0356f98ac49930c54600415 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Mon, 1 Mar 2021 13:55:15 -0700
Subject: [PATCH 240/342] init: Make some functions entirely private

There were some functions in the internal header that can be entirely
private to the init library. Move them over.

Also, remove the support for including the header from a C++ file
because these headers are internal to SPDK which is pure C.

Change-Id: Ic4323b2b8664e70106a57b3ca8acbc7c2efe621d
Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6642
Reviewed-by: Tom Nabarro <tom.nabarro@outlook.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk_internal/event.h | 22 ---------------
 include/spdk_internal/init.h  | 25 -----------------
 lib/init/spdk_init.map        |  6 ----
 lib/init/subsystem.c          | 18 ++++++------
 lib/init/subsystem.h          | 53 +++++++++++++++++++++++++++++++++++
 lib/init/subsystem_rpc.c      | 14 +++++----
 6 files changed, 71 insertions(+), 67 deletions(-)
 create mode 100644 lib/init/subsystem.h

diff --git a/include/spdk_internal/event.h b/include/spdk_internal/event.h
index 73c2bf5c0..2e65798b0 100644
--- a/include/spdk_internal/event.h
+++ b/include/spdk_internal/event.h
@@ -373,28 +373,6 @@ void _spdk_lw_thread_set_core(struct spdk_lw_thread *thread, uint32_t lcore);
 void _spdk_lw_thread_get_current_stats(struct spdk_lw_thread *thread,
 				       struct spdk_thread_stats *stats);
 
-/**
- * \brief Register a new subsystem
- */
-#define SPDK_SUBSYSTEM_REGISTER(_name) \
-	__attribute__((constructor)) static void _name ## _register(void)	\
-	{									\
-		spdk_add_subsystem(&_name);					\
-	}
-
-/**
- * \brief Declare that a subsystem depends on another subsystem.
- */
-#define SPDK_SUBSYSTEM_DEPEND(_name, _depends_on)						\
-	static struct spdk_subsystem_depend __subsystem_ ## _name ## _depend_on ## _depends_on = { \
-	.name = #_name,										\
-	.depends_on = #_depends_on,								\
-	};											\
-	__attribute__((constructor)) static void _name ## _depend_on ## _depends_on(void)	\
-	{											\
-		spdk_add_subsystem_depend(&__subsystem_ ## _name ## _depend_on ## _depends_on); \
-	}
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/spdk_internal/init.h b/include/spdk_internal/init.h
index 67fd6cd53..e40bd9c72 100644
--- a/include/spdk_internal/init.h
+++ b/include/spdk_internal/init.h
@@ -41,10 +41,6 @@
 #include "spdk/stdinc.h"
 #include "spdk/queue.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 struct spdk_json_write_ctx;
 
 struct spdk_subsystem {
@@ -62,20 +58,12 @@ struct spdk_subsystem {
 	TAILQ_ENTRY(spdk_subsystem) tailq;
 };
 
-struct spdk_subsystem *spdk_subsystem_find(const char *name);
-struct spdk_subsystem *spdk_subsystem_get_first(void);
-struct spdk_subsystem *spdk_subsystem_get_next(struct spdk_subsystem *cur_subsystem);
-
 struct spdk_subsystem_depend {
 	const char *name;
 	const char *depends_on;
 	TAILQ_ENTRY(spdk_subsystem_depend) tailq;
 };
 
-struct spdk_subsystem_depend *spdk_subsystem_get_first_depend(void);
-struct spdk_subsystem_depend *spdk_subsystem_get_next_depend(struct spdk_subsystem_depend
-		*cur_depend);
-
 void spdk_add_subsystem(struct spdk_subsystem *subsystem);
 void spdk_add_subsystem_depend(struct spdk_subsystem_depend *depend);
 
@@ -87,15 +75,6 @@ void spdk_subsystem_fini(spdk_subsystem_fini_fn cb_fn, void *cb_arg);
 void spdk_subsystem_init_next(int rc);
 void spdk_subsystem_fini_next(void);
 
-/**
- * Save pointed \c subsystem configuration to the JSON write context \c w. In case of
- * error \c null is written to the JSON context.
- *
- * \param w JSON write context
- * \param subsystem the subsystem to query
- */
-void spdk_subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsystem *subsystem);
-
 /**
  * \brief Register a new subsystem
  */
@@ -118,8 +97,4 @@ void spdk_subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsy
 		spdk_add_subsystem_depend(&__subsystem_ ## _name ## _depend_on ## _depends_on); \
 	}
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif
diff --git a/lib/init/spdk_init.map b/lib/init/spdk_init.map
index 2aa5b3dff..72088d6dd 100644
--- a/lib/init/spdk_init.map
+++ b/lib/init/spdk_init.map
@@ -2,18 +2,12 @@
 	global:
 
 	# Public functions
-	spdk_subsystem_find;
-	spdk_subsystem_get_first;
-	spdk_subsystem_get_next;
-	spdk_subsystem_get_first_depend;
-	spdk_subsystem_get_next_depend;
 	spdk_add_subsystem;
 	spdk_add_subsystem_depend;
 	spdk_subsystem_init;
 	spdk_subsystem_fini;
 	spdk_subsystem_init_next;
 	spdk_subsystem_fini_next;
-	spdk_subsystem_config_json;
 
 	local: *;
 };
diff --git a/lib/init/subsystem.c b/lib/init/subsystem.c
index a1475ded5..4a0899122 100644
--- a/lib/init/subsystem.c
+++ b/lib/init/subsystem.c
@@ -41,6 +41,8 @@
 
 #include "spdk/json.h"
 
+#include "subsystem.h"
+
 TAILQ_HEAD(spdk_subsystem_list, spdk_subsystem);
 struct spdk_subsystem_list g_subsystems = TAILQ_HEAD_INITIALIZER(g_subsystems);
 
@@ -82,32 +84,32 @@ _subsystem_find(struct spdk_subsystem_list *list, const char *name)
 }
 
 struct spdk_subsystem *
-spdk_subsystem_find(const char *name)
+subsystem_find(const char *name)
 {
 	return _subsystem_find(&g_subsystems, name);
 }
 
 struct spdk_subsystem *
-spdk_subsystem_get_first(void)
+subsystem_get_first(void)
 {
 	return TAILQ_FIRST(&g_subsystems);
 }
 
 struct spdk_subsystem *
-spdk_subsystem_get_next(struct spdk_subsystem *cur_subsystem)
+subsystem_get_next(struct spdk_subsystem *cur_subsystem)
 {
 	return TAILQ_NEXT(cur_subsystem, tailq);
 }
 
 
 struct spdk_subsystem_depend *
-spdk_subsystem_get_first_depend(void)
+subsystem_get_first_depend(void)
 {
 	return TAILQ_FIRST(&g_subsystems_deps);
 }
 
 struct spdk_subsystem_depend *
-spdk_subsystem_get_next_depend(struct spdk_subsystem_depend *cur_depend)
+subsystem_get_next_depend(struct spdk_subsystem_depend *cur_depend)
 {
 	return TAILQ_NEXT(cur_depend, tailq);
 }
@@ -196,12 +198,12 @@ spdk_subsystem_init(spdk_subsystem_init_fn cb_fn, void *cb_arg)
 
 	/* Verify that all dependency name and depends_on subsystems are registered */
 	TAILQ_FOREACH(dep, &g_subsystems_deps, tailq) {
-		if (!spdk_subsystem_find(dep->name)) {
+		if (!subsystem_find(dep->name)) {
 			SPDK_ERRLOG("subsystem %s is missing\n", dep->name);
 			g_subsystem_start_fn(-1, g_subsystem_start_arg);
 			return;
 		}
-		if (!spdk_subsystem_find(dep->depends_on)) {
+		if (!subsystem_find(dep->depends_on)) {
 			SPDK_ERRLOG("subsystem %s dependency %s is missing\n",
 				    dep->name, dep->depends_on);
 			g_subsystem_start_fn(-1, g_subsystem_start_arg);
@@ -268,7 +270,7 @@ spdk_subsystem_fini(spdk_msg_fn cb_fn, void *cb_arg)
 }
 
 void
-spdk_subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsystem *subsystem)
+subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsystem *subsystem)
 {
 	if (subsystem && subsystem->write_config_json) {
 		subsystem->write_config_json(w);
diff --git a/lib/init/subsystem.h b/lib/init/subsystem.h
new file mode 100644
index 000000000..d30d5b9cf
--- /dev/null
+++ b/lib/init/subsystem.h
@@ -0,0 +1,53 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.  All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SPDK_SUBSYSTEM_H
+#define SPDK_SUBSYSTEM_H
+
+struct spdk_subsystem *subsystem_find(const char *name);
+struct spdk_subsystem *subsystem_get_first(void);
+struct spdk_subsystem *subsystem_get_next(struct spdk_subsystem *cur_subsystem);
+
+struct spdk_subsystem_depend *subsystem_get_first_depend(void);
+struct spdk_subsystem_depend *subsystem_get_next_depend(struct spdk_subsystem_depend
+		*cur_depend);
+
+/**
+ * Save pointed \c subsystem configuration to the JSON write context \c w. In case of
+ * error \c null is written to the JSON context.
+ *
+ * \param w JSON write context
+ * \param subsystem the subsystem to query
+ */
+void subsystem_config_json(struct spdk_json_write_ctx *w, struct spdk_subsystem *subsystem);
+
+#endif
diff --git a/lib/init/subsystem_rpc.c b/lib/init/subsystem_rpc.c
index cfee3e593..3ff7fb376 100644
--- a/lib/init/subsystem_rpc.c
+++ b/lib/init/subsystem_rpc.c
@@ -38,6 +38,8 @@
 
 #include "spdk_internal/init.h"
 
+#include "subsystem.h"
+
 static void
 rpc_framework_get_subsystems(struct spdk_jsonrpc_request *request,
 			     const struct spdk_json_val *params)
@@ -54,22 +56,22 @@ rpc_framework_get_subsystems(struct spdk_jsonrpc_request *request,
 
 	w = spdk_jsonrpc_begin_result(request);
 	spdk_json_write_array_begin(w);
-	subsystem = spdk_subsystem_get_first();
+	subsystem = subsystem_get_first();
 	while (subsystem != NULL) {
 		spdk_json_write_object_begin(w);
 
 		spdk_json_write_named_string(w, "subsystem", subsystem->name);
 		spdk_json_write_named_array_begin(w, "depends_on");
-		deps = spdk_subsystem_get_first_depend();
+		deps = subsystem_get_first_depend();
 		while (deps != NULL) {
 			if (strcmp(subsystem->name, deps->name) == 0) {
 				spdk_json_write_string(w, deps->depends_on);
 			}
-			deps = spdk_subsystem_get_next_depend(deps);
+			deps = subsystem_get_next_depend(deps);
 		}
 		spdk_json_write_array_end(w);
 		spdk_json_write_object_end(w);
-		subsystem = spdk_subsystem_get_next(subsystem);
+		subsystem = subsystem_get_next(subsystem);
 	}
 	spdk_json_write_array_end(w);
 	spdk_jsonrpc_end_result(request, w);
@@ -100,7 +102,7 @@ rpc_framework_get_config(struct spdk_jsonrpc_request *request,
 		return;
 	}
 
-	subsystem = spdk_subsystem_find(req.name);
+	subsystem = subsystem_find(req.name);
 	if (!subsystem) {
 		spdk_jsonrpc_send_error_response_fmt(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
 						     "Subsystem '%s' not found", req.name);
@@ -111,7 +113,7 @@ rpc_framework_get_config(struct spdk_jsonrpc_request *request,
 	free(req.name);
 
 	w = spdk_jsonrpc_begin_result(request);
-	spdk_subsystem_config_json(w, subsystem);
+	subsystem_config_json(w, subsystem);
 	spdk_jsonrpc_end_result(request, w);
 }
 
-- 
2.26.2


From dc9374dd2fad340372496532e531dd61a67646e1 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Mon, 1 Mar 2021 14:06:04 -0700
Subject: [PATCH 241/342] init: Declare a formal public API

The functions to initialize the SPDK subsystems or tear them down
was previously an internal-only API. Make it public for use by
applications that aren't leverage SPDK's application framework.

Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Change-Id: I2ebfd020e6fa4c1947fa1c1a2ac509ce9b0242f8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6643
Reviewed-by: Tom Nabarro <tom.nabarro@outlook.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 examples/bdev/fio_plugin/fio_plugin.c |  2 +-
 examples/nvmf/nvmf/nvmf.c             |  3 +-
 include/spdk/init.h                   | 76 +++++++++++++++++++++++++++
 include/spdk_internal/init.h          | 14 +----
 lib/event/app.c                       |  2 +-
 lib/event/json_config.c               |  2 +-
 lib/init/subsystem.c                  |  2 +
 test/event/event_perf/event_perf.c    |  1 -
 8 files changed, 85 insertions(+), 17 deletions(-)
 create mode 100644 include/spdk/init.h

diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index 483664f99..844cb9841 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -37,13 +37,13 @@
 #include "spdk/bdev_zone.h"
 #include "spdk/accel_engine.h"
 #include "spdk/env.h"
+#include "spdk/init.h"
 #include "spdk/thread.h"
 #include "spdk/log.h"
 #include "spdk/string.h"
 #include "spdk/queue.h"
 #include "spdk/util.h"
 
-#include "spdk_internal/init.h"
 #include "spdk_internal/event.h"
 
 #include "config-host.h"
diff --git a/examples/nvmf/nvmf/nvmf.c b/examples/nvmf/nvmf/nvmf.c
index 5e77e1683..5529968ae 100644
--- a/examples/nvmf/nvmf/nvmf.c
+++ b/examples/nvmf/nvmf/nvmf.c
@@ -32,8 +32,10 @@
  */
 
 #include "spdk/stdinc.h"
+
 #include "spdk/env.h"
 #include "spdk/event.h"
+#include "spdk/init.h"
 #include "spdk/string.h"
 #include "spdk/thread.h"
 #include "spdk/bdev.h"
@@ -42,7 +44,6 @@
 #include "spdk/likely.h"
 
 #include "spdk_internal/event.h"
-#include "spdk_internal/init.h"
 
 #define NVMF_DEFAULT_SUBSYSTEMS		32
 #define ACCEPT_TIMEOUT_US		10000 /* 10ms */
diff --git a/include/spdk/init.h b/include/spdk/init.h
new file mode 100644
index 000000000..46e199966
--- /dev/null
+++ b/include/spdk/init.h
@@ -0,0 +1,76 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.  All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * \file
+ * SPDK Initialization Helper
+ */
+
+#ifndef SPDK_INIT_H
+#define SPDK_INIT_H
+
+#include "spdk/stdinc.h"
+#include "spdk/queue.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void (*spdk_subsystem_init_fn)(int rc, void *ctx);
+
+/**
+ * Begin the initialization process for all SPDK subsystems. SPDK is divided into subsystems at a macro-level
+ * and each subsystem automatically registers itself with this library at start up using a C
+ * constructor. Further, each subsystem can declare other subsystems that it depends on.
+ * Calling this function will correctly initialize all subsystems that are present, in the
+ * required order.
+ *
+ * \param cb_fn Function called when the process is complete.
+ * \param cb_arg User context passed to cb_fn.
+ */
+void spdk_subsystem_init(spdk_subsystem_init_fn cb_fn, void *cb_arg);
+
+typedef void (*spdk_subsystem_fini_fn)(void *ctx);
+
+/**
+ * Tear down all of the subsystems in the correct order.
+ *
+ * \param cb_fn Function called when the process is complete.
+ * \param cb_arg User context passed to cb_fn
+ */
+void spdk_subsystem_fini(spdk_subsystem_fini_fn cb_fn, void *cb_arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/spdk_internal/init.h b/include/spdk_internal/init.h
index e40bd9c72..0a43beb7f 100644
--- a/include/spdk_internal/init.h
+++ b/include/spdk_internal/init.h
@@ -30,13 +30,8 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/**
- * \file
- * SPDK Initialization Helper
- */
-
-#ifndef SPDK_INIT_H
-#define SPDK_INIT_H
+#ifndef SPDK_INIT_INTERNAL_H
+#define SPDK_INIT_INTERNAL_H
 
 #include "spdk/stdinc.h"
 #include "spdk/queue.h"
@@ -67,11 +62,6 @@ struct spdk_subsystem_depend {
 void spdk_add_subsystem(struct spdk_subsystem *subsystem);
 void spdk_add_subsystem_depend(struct spdk_subsystem_depend *depend);
 
-typedef void (*spdk_subsystem_init_fn)(int rc, void *ctx);
-void spdk_subsystem_init(spdk_subsystem_init_fn cb_fn, void *cb_arg);
-
-typedef void (*spdk_subsystem_fini_fn)(void *ctx);
-void spdk_subsystem_fini(spdk_subsystem_fini_fn cb_fn, void *cb_arg);
 void spdk_subsystem_init_next(int rc);
 void spdk_subsystem_fini_next(void);
 
diff --git a/lib/event/app.c b/lib/event/app.c
index 7ef66832a..f35d7230c 100644
--- a/lib/event/app.c
+++ b/lib/event/app.c
@@ -35,10 +35,10 @@
 #include "spdk/version.h"
 
 #include "spdk_internal/event.h"
-#include "spdk_internal/init.h"
 
 #include "spdk/assert.h"
 #include "spdk/env.h"
+#include "spdk/init.h"
 #include "spdk/log.h"
 #include "spdk/thread.h"
 #include "spdk/trace.h"
diff --git a/lib/event/json_config.c b/lib/event/json_config.c
index e42f30581..073537e93 100644
--- a/lib/event/json_config.c
+++ b/lib/event/json_config.c
@@ -33,6 +33,7 @@
 
 #include "spdk/stdinc.h"
 
+#include "spdk/init.h"
 #include "spdk/util.h"
 #include "spdk/file.h"
 #include "spdk/log.h"
@@ -42,7 +43,6 @@
 #include "spdk/rpc.h"
 
 #include "spdk_internal/event.h"
-#include "spdk_internal/init.h"
 
 #define SPDK_DEBUG_APP_CFG(...) SPDK_DEBUGLOG(app_config, __VA_ARGS__)
 
diff --git a/lib/init/subsystem.c b/lib/init/subsystem.c
index 4a0899122..60fa8613e 100644
--- a/lib/init/subsystem.c
+++ b/lib/init/subsystem.c
@@ -33,7 +33,9 @@
 
 #include "spdk/stdinc.h"
 
+#include "spdk/init.h"
 #include "spdk/log.h"
+#include "spdk/queue.h"
 #include "spdk/thread.h"
 
 #include "spdk_internal/init.h"
diff --git a/test/event/event_perf/event_perf.c b/test/event/event_perf/event_perf.c
index 77508fd28..e344abdc1 100644
--- a/test/event/event_perf/event_perf.c
+++ b/test/event/event_perf/event_perf.c
@@ -35,7 +35,6 @@
 
 #include "spdk/env.h"
 #include "spdk/event.h"
-#include "spdk_internal/init.h"
 #include "spdk/log.h"
 #include "spdk/string.h"
 
-- 
2.26.2


From 9f62796127c23a932d95aae57806ed126919ab8d Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Tue, 2 Mar 2021 12:22:03 -0700
Subject: [PATCH 242/342] event: Move RPC server initialization to init

I'm not sure whether this should go into lib/init or to lib/rpc
directly, but I've chosen lib/init for now.

This is to support applications that want to run the SPDK JSON
RPC server, but aren't using the SPDK application framework.

Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Change-Id: I79ca39aa0ca6e1a3a6905b0bf73e6cc99b086e55
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6644
Reviewed-by: Tom Nabarro <tom.nabarro@outlook.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk/event.h          |  3 +--
 include/spdk/init.h           | 17 +++++++++++++++++
 include/spdk_internal/event.h |  3 ---
 lib/event/Makefile            |  2 +-
 lib/event/spdk_event.map      |  2 --
 lib/init/Makefile             |  2 +-
 lib/{event => init}/rpc.c     |  3 +--
 lib/init/spdk_init.map        |  3 +++
 8 files changed, 24 insertions(+), 11 deletions(-)
 rename lib/{event => init}/rpc.c (98%)

diff --git a/include/spdk/event.h b/include/spdk/event.h
index d65c29172..74c946728 100644
--- a/include/spdk/event.h
+++ b/include/spdk/event.h
@@ -44,6 +44,7 @@
 #include "spdk/stdinc.h"
 
 #include "spdk/cpuset.h"
+#include "spdk/init.h"
 #include "spdk/queue.h"
 #include "spdk/log.h"
 #include "spdk/thread.h"
@@ -82,8 +83,6 @@ typedef void (*spdk_app_shutdown_cb)(void);
  */
 typedef void (*spdk_sighandler_t)(int signal);
 
-#define SPDK_DEFAULT_RPC_ADDR "/var/tmp/spdk.sock"
-
 /**
  * \brief Event framework initialization options
  */
diff --git a/include/spdk/init.h b/include/spdk/init.h
index 46e199966..339c8900c 100644
--- a/include/spdk/init.h
+++ b/include/spdk/init.h
@@ -45,6 +45,23 @@
 extern "C" {
 #endif
 
+#define SPDK_DEFAULT_RPC_ADDR "/var/tmp/spdk.sock"
+
+/**
+ * Create the SPDK JSON-RPC server and listen at the provided address. The RPC server is optional and is
+ * independent of subsystem initialization. The RPC server can be started and stopped at any time.
+ *
+ * \param listen_addr Path to a unix domain socket to listen on
+ *
+ * \return Negated errno on failure. 0 on success.
+ */
+int spdk_rpc_initialize(const char *listen_addr);
+
+/**
+ * Shut down the SPDK JSON-RPC target
+ */
+void spdk_rpc_finish(void);
+
 typedef void (*spdk_subsystem_init_fn)(int rc, void *ctx);
 
 /**
diff --git a/include/spdk_internal/event.h b/include/spdk_internal/event.h
index 2e65798b0..0a923b03a 100644
--- a/include/spdk_internal/event.h
+++ b/include/spdk_internal/event.h
@@ -170,9 +170,6 @@ void spdk_app_json_config_load(const char *json_config_file, const char *rpc_add
 			       spdk_app_init_fn cb_fn, void *cb_arg,
 			       bool stop_on_error);
 
-int spdk_rpc_initialize(const char *listen_addr);
-void spdk_rpc_finish(void);
-
 struct spdk_governor_capabilities {
 	bool freq_change;
 	bool freq_getset;
diff --git a/lib/event/Makefile b/lib/event/Makefile
index 5cd155870..6077e3d6e 100644
--- a/lib/event/Makefile
+++ b/lib/event/Makefile
@@ -40,7 +40,7 @@ SO_MINOR := 0
 CFLAGS += $(ENV_CFLAGS)
 
 LIBNAME = event
-C_SRCS = app.c reactor.c rpc.c json_config.c log_rpc.c \
+C_SRCS = app.c reactor.c json_config.c log_rpc.c \
 	 app_rpc.c scheduler_static.c
 
 # Do not compile schedulers and governors based on DPDK env
diff --git a/lib/event/spdk_event.map b/lib/event/spdk_event.map
index 146dc29c4..206670d5c 100644
--- a/lib/event/spdk_event.map
+++ b/lib/event/spdk_event.map
@@ -26,8 +26,6 @@
 	spdk_for_each_reactor;
 	spdk_reactor_set_interrupt_mode;
 	spdk_app_json_config_load;
-	spdk_rpc_initialize;
-	spdk_rpc_finish;
 
 	local: *;
 };
diff --git a/lib/init/Makefile b/lib/init/Makefile
index 8cd598c06..8f00ca240 100644
--- a/lib/init/Makefile
+++ b/lib/init/Makefile
@@ -37,7 +37,7 @@ include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 SO_VER := 1
 SO_MINOR := 0
 
-C_SRCS = subsystem.c subsystem_rpc.c
+C_SRCS = subsystem.c subsystem_rpc.c rpc.c
 LIBNAME = init
 
 SPDK_MAP_FILE = $(abspath $(CURDIR)/spdk_init.map)
diff --git a/lib/event/rpc.c b/lib/init/rpc.c
similarity index 98%
rename from lib/event/rpc.c
rename to lib/init/rpc.c
index 62c8d5bb2..2adaf8bde 100644
--- a/lib/event/rpc.c
+++ b/lib/init/rpc.c
@@ -34,12 +34,11 @@
 #include "spdk/stdinc.h"
 
 #include "spdk/env.h"
+#include "spdk/init.h"
 #include "spdk/thread.h"
 #include "spdk/log.h"
 #include "spdk/rpc.h"
 
-#include "spdk_internal/event.h"
-
 #define RPC_SELECT_INTERVAL	4000 /* 4ms */
 
 static struct spdk_poller *g_rpc_poller = NULL;
diff --git a/lib/init/spdk_init.map b/lib/init/spdk_init.map
index 72088d6dd..5a6d694f7 100644
--- a/lib/init/spdk_init.map
+++ b/lib/init/spdk_init.map
@@ -9,5 +9,8 @@
 	spdk_subsystem_init_next;
 	spdk_subsystem_fini_next;
 
+	spdk_rpc_initialize;
+	spdk_rpc_finish;
+
 	local: *;
 };
-- 
2.26.2


From dde419084b43997913f639a7b850683e926b26c8 Mon Sep 17 00:00:00 2001
From: Ben Walker <benjamin.walker@intel.com>
Date: Tue, 2 Mar 2021 12:34:25 -0700
Subject: [PATCH 243/342] event: Move json config loading to init

Loading subsystems and restoring state from a JSON config file is useful
outside of the SPDK application framework, so move it to lib/init.

Change-Id: I7dd3ceace2e7b1b28eef83c91ce6a4eedc85740e
Signed-off-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6645
Reviewed-by: Tom Nabarro <tom.nabarro@outlook.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 examples/bdev/fio_plugin/fio_plugin.c |  4 ++--
 include/spdk/init.h                   | 14 ++++++++++++++
 include/spdk_internal/event.h         |  6 ------
 lib/event/Makefile                    |  2 +-
 lib/event/app.c                       |  5 +++--
 lib/event/spdk_event.map              |  1 -
 lib/init/Makefile                     |  2 +-
 lib/{event => init}/json_config.c     |  8 ++++----
 lib/init/spdk_init.map                |  1 +
 mk/spdk.lib_deps.mk                   |  2 +-
 test/unit/lib/event/app.c/app_ut.c    |  3 ++-
 11 files changed, 29 insertions(+), 19 deletions(-)
 rename lib/{event => init}/json_config.c (98%)

diff --git a/examples/bdev/fio_plugin/fio_plugin.c b/examples/bdev/fio_plugin/fio_plugin.c
index 844cb9841..c235cc1e7 100644
--- a/examples/bdev/fio_plugin/fio_plugin.c
+++ b/examples/bdev/fio_plugin/fio_plugin.c
@@ -219,8 +219,8 @@ spdk_fio_bdev_init_start(void *arg)
 {
 	bool *done = arg;
 
-	spdk_app_json_config_load(g_json_config_file, SPDK_DEFAULT_RPC_ADDR,
-				  spdk_fio_bdev_init_done, done, true);
+	spdk_subsystem_init_from_json_config(g_json_config_file, SPDK_DEFAULT_RPC_ADDR,
+					     spdk_fio_bdev_init_done, done, true);
 }
 
 static void
diff --git a/include/spdk/init.h b/include/spdk/init.h
index 339c8900c..aa8abc174 100644
--- a/include/spdk/init.h
+++ b/include/spdk/init.h
@@ -76,6 +76,20 @@ typedef void (*spdk_subsystem_init_fn)(int rc, void *ctx);
  */
 void spdk_subsystem_init(spdk_subsystem_init_fn cb_fn, void *cb_arg);
 
+/**
+ * Like spdk_subsystem_init, but additionally configure each subsystem using the provided JSON config
+ * file. This will automatically start a JSON RPC server and then stop it.
+ *
+ * \param json_config_file Path to a JSON config file.
+ * \param rpc_addr Path to a unix domain socket to send configuration RPCs to.
+ * \param cb_fn Function called when the process is complete.
+ * \param cb_arg User context passed to cb_fn.
+ * \param stop_on_error Whether to stop initialization if one of the JSON RPCs fails.
+ */
+void spdk_subsystem_init_from_json_config(const char *json_config_file, const char *rpc_addr,
+		spdk_subsystem_init_fn cb_fn, void *cb_arg,
+		bool stop_on_error);
+
 typedef void (*spdk_subsystem_fini_fn)(void *ctx);
 
 /**
diff --git a/include/spdk_internal/event.h b/include/spdk_internal/event.h
index 0a923b03a..d900ed82d 100644
--- a/include/spdk_internal/event.h
+++ b/include/spdk_internal/event.h
@@ -164,12 +164,6 @@ int spdk_reactor_set_interrupt_mode(uint32_t lcore, bool new_in_interrupt,
  */
 struct spdk_thread *_spdk_get_app_thread(void);
 
-typedef void (*spdk_app_init_fn)(int rc, void *ctx);
-
-void spdk_app_json_config_load(const char *json_config_file, const char *rpc_addr,
-			       spdk_app_init_fn cb_fn, void *cb_arg,
-			       bool stop_on_error);
-
 struct spdk_governor_capabilities {
 	bool freq_change;
 	bool freq_getset;
diff --git a/lib/event/Makefile b/lib/event/Makefile
index 6077e3d6e..84640b789 100644
--- a/lib/event/Makefile
+++ b/lib/event/Makefile
@@ -40,7 +40,7 @@ SO_MINOR := 0
 CFLAGS += $(ENV_CFLAGS)
 
 LIBNAME = event
-C_SRCS = app.c reactor.c json_config.c log_rpc.c \
+C_SRCS = app.c reactor.c log_rpc.c \
 	 app_rpc.c scheduler_static.c
 
 # Do not compile schedulers and governors based on DPDK env
diff --git a/lib/event/app.c b/lib/event/app.c
index f35d7230c..090b1692f 100644
--- a/lib/event/app.c
+++ b/lib/event/app.c
@@ -403,8 +403,9 @@ bootstrap_fn(void *arg1)
 
 	if (g_spdk_app.json_config_file) {
 		g_delay_subsystem_init = false;
-		spdk_app_json_config_load(g_spdk_app.json_config_file, g_spdk_app.rpc_addr, app_start_rpc,
-					  NULL, !g_spdk_app.json_config_ignore_errors);
+		spdk_subsystem_init_from_json_config(g_spdk_app.json_config_file, g_spdk_app.rpc_addr,
+						     app_start_rpc,
+						     NULL, !g_spdk_app.json_config_ignore_errors);
 	} else {
 		if (!g_delay_subsystem_init) {
 			spdk_subsystem_init(app_start_rpc, NULL);
diff --git a/lib/event/spdk_event.map b/lib/event/spdk_event.map
index 206670d5c..b4a30f67c 100644
--- a/lib/event/spdk_event.map
+++ b/lib/event/spdk_event.map
@@ -25,7 +25,6 @@
 	spdk_reactor_get;
 	spdk_for_each_reactor;
 	spdk_reactor_set_interrupt_mode;
-	spdk_app_json_config_load;
 
 	local: *;
 };
diff --git a/lib/init/Makefile b/lib/init/Makefile
index 8f00ca240..0e852bd67 100644
--- a/lib/init/Makefile
+++ b/lib/init/Makefile
@@ -37,7 +37,7 @@ include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 SO_VER := 1
 SO_MINOR := 0
 
-C_SRCS = subsystem.c subsystem_rpc.c rpc.c
+C_SRCS = json_config.c subsystem.c subsystem_rpc.c rpc.c
 LIBNAME = init
 
 SPDK_MAP_FILE = $(abspath $(CURDIR)/spdk_init.map)
diff --git a/lib/event/json_config.c b/lib/init/json_config.c
similarity index 98%
rename from lib/event/json_config.c
rename to lib/init/json_config.c
index 073537e93..2c942a80f 100644
--- a/lib/event/json_config.c
+++ b/lib/init/json_config.c
@@ -86,7 +86,7 @@ typedef void (*client_resp_handler)(struct load_json_config_ctx *,
 struct load_json_config_ctx {
 	/* Thread used during configuration. */
 	struct spdk_thread *thread;
-	spdk_app_init_fn cb_fn;
+	spdk_subsystem_init_fn cb_fn;
 	void *cb_arg;
 	bool stop_on_error;
 
@@ -567,9 +567,9 @@ err:
 }
 
 void
-spdk_app_json_config_load(const char *json_config_file, const char *rpc_addr,
-			  spdk_app_init_fn cb_fn, void *cb_arg,
-			  bool stop_on_error)
+spdk_subsystem_init_from_json_config(const char *json_config_file, const char *rpc_addr,
+				     spdk_subsystem_init_fn cb_fn, void *cb_arg,
+				     bool stop_on_error)
 {
 	struct load_json_config_ctx *ctx = calloc(1, sizeof(*ctx));
 	int rc;
diff --git a/lib/init/spdk_init.map b/lib/init/spdk_init.map
index 5a6d694f7..c6061c458 100644
--- a/lib/init/spdk_init.map
+++ b/lib/init/spdk_init.map
@@ -8,6 +8,7 @@
 	spdk_subsystem_fini;
 	spdk_subsystem_init_next;
 	spdk_subsystem_fini_next;
+	spdk_subsystem_init_from_json_config;
 
 	spdk_rpc_initialize;
 	spdk_rpc_finish;
diff --git a/mk/spdk.lib_deps.mk b/mk/spdk.lib_deps.mk
index e45ddba03..bc812ac7f 100644
--- a/mk/spdk.lib_deps.mk
+++ b/mk/spdk.lib_deps.mk
@@ -84,7 +84,7 @@ DEPDIRS-trace := log util $(JSON_LIBS)
 DEPDIRS-bdev := log util thread $(JSON_LIBS) notify trace
 DEPDIRS-blobfs := log thread blob trace
 DEPDIRS-event := log util thread $(JSON_LIBS) trace init
-DEPDIRS-init := jsonrpc json log rpc thread
+DEPDIRS-init := jsonrpc json log rpc thread util
 
 DEPDIRS-ftl := log util thread trace bdev
 DEPDIRS-nbd := log util thread $(JSON_LIBS) bdev
diff --git a/test/unit/lib/event/app.c/app_ut.c b/test/unit/lib/event/app.c/app_ut.c
index 932eef8f7..dfd1ceddf 100644
--- a/test/unit/lib/event/app.c/app_ut.c
+++ b/test/unit/lib/event/app.c/app_ut.c
@@ -51,7 +51,8 @@ DEFINE_STUB_V(spdk_rpc_set_state, (uint32_t state));
 DEFINE_STUB(spdk_rpc_get_state, uint32_t, (void), SPDK_RPC_RUNTIME);
 DEFINE_STUB(spdk_rpc_initialize, int, (const char *listen_addr), 0);
 DEFINE_STUB_V(spdk_rpc_finish, (void));
-DEFINE_STUB_V(spdk_app_json_config_load, (const char *json_config_file, const char *rpc_addr,
+DEFINE_STUB_V(spdk_subsystem_init_from_json_config, (const char *json_config_file,
+		const char *rpc_addr,
 		spdk_subsystem_init_fn cb_fn, void *cb_arg, bool stop_on_error));
 DEFINE_STUB_V(spdk_reactors_start, (void));
 DEFINE_STUB_V(spdk_reactors_stop, (void *arg1));
-- 
2.26.2


From 9776b8944463138fefd1d994a003dca7e81718f5 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 25 May 2021 20:05:30 +0800
Subject: [PATCH 244/342] nvme/tcp: Fix the bug when doing offloading.

For nvme/tcp connection, we use the synced manner
if the qpair is not fully connected. Thus without
the check, we will stuck here. And this patch
fixes this issue.

Change-Id: I72815bf5b4c0b31c4866bc1b9034b0e42b81d3f1
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8025
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Community-CI: Mellanox Build Bot
---
 lib/nvme/nvme_tcp.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index 218ccaea1..e81bff319 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -444,8 +444,9 @@ pdu_data_crc32_compute(struct nvme_tcp_pdu *pdu)
 	/* Data Digest */
 	if (pdu->data_len > 0 && g_nvme_tcp_ddgst[pdu->hdr.common.pdu_type] &&
 	    tqpair->flags.host_ddgst_enable) {
-		/* Only suport this limitated case for the first step */
-		if (tgroup != NULL && tgroup->group.group->accel_fn_table.submit_accel_crc32c &&
+		/* Only suport this limited case for the first step */
+		if ((nvme_qpair_get_state(&tqpair->qpair) >= NVME_QPAIR_CONNECTED) &&
+		    (tgroup != NULL && tgroup->group.group->accel_fn_table.submit_accel_crc32c) &&
 		    spdk_likely(!pdu->dif_ctx && (pdu->data_len % SPDK_NVME_TCP_DIGEST_ALIGNMENT == 0))) {
 			tgroup->group.group->accel_fn_table.submit_accel_crc32c(tgroup->group.group->ctx,
 					&pdu->data_digest_crc32, pdu->data_iov,
-- 
2.26.2


From 2250abaeca189f1f54b06ca3d56bd042771f6c78 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 25 May 2021 23:12:20 +0800
Subject: [PATCH 245/342] nvme/tcp: Raname send_pdu to pdu in tcp_req.

Since we will reuse send_pdu for other purpose in the next
patch.

Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Change-Id: Iee5166131b70a25bc13aaa847bfc9066231f31a9
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8028
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/nvme/nvme_tcp.c                         | 10 +++++-----
 test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c |  8 ++++----
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index e81bff319..19ab9e933 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -148,7 +148,7 @@ struct nvme_tcp_req {
 			uint8_t				reserved : 4;
 		} bits;
 	} ordering;
-	struct nvme_tcp_pdu			*send_pdu;
+	struct nvme_tcp_pdu			*pdu;
 	struct iovec				iov[NVME_TCP_MAX_SGL_DESCRIPTORS];
 	uint32_t				iovcnt;
 	/* Used to hold a value received from subsequent R2T while we are still
@@ -205,7 +205,7 @@ nvme_tcp_req_get(struct nvme_tcp_qpair *tqpair)
 	tcp_req->active_r2ts = 0;
 	tcp_req->iovcnt = 0;
 	tcp_req->ordering.raw = 0;
-	memset(tcp_req->send_pdu, 0, sizeof(struct nvme_tcp_pdu));
+	memset(tcp_req->pdu, 0, sizeof(struct nvme_tcp_pdu));
 	memset(&tcp_req->rsp, 0, sizeof(struct spdk_nvme_cpl));
 	TAILQ_INSERT_TAIL(&tqpair->outstanding_reqs, tcp_req, link);
 
@@ -288,7 +288,7 @@ nvme_tcp_alloc_reqs(struct nvme_tcp_qpair *tqpair)
 		tcp_req = &tqpair->tcp_reqs[i];
 		tcp_req->cid = i;
 		tcp_req->tqpair = tqpair;
-		tcp_req->send_pdu = &tqpair->send_pdus[i];
+		tcp_req->pdu = &tqpair->send_pdus[i];
 		TAILQ_INSERT_TAIL(&tqpair->free_reqs, tcp_req, link);
 	}
 
@@ -670,7 +670,7 @@ nvme_tcp_qpair_capsule_cmd_send(struct nvme_tcp_qpair *tqpair,
 	uint8_t pdo;
 
 	SPDK_DEBUGLOG(nvme, "enter\n");
-	pdu = tcp_req->send_pdu;
+	pdu = tcp_req->pdu;
 
 	capsule_cmd = &pdu->hdr.capsule_cmd;
 	capsule_cmd->common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_CAPSULE_CMD;
@@ -1319,7 +1319,7 @@ nvme_tcp_send_h2c_data(struct nvme_tcp_req *tcp_req)
 	/* Reinit the send_ack and h2c_send_waiting_ack bits */
 	tcp_req->ordering.bits.send_ack = 0;
 	tcp_req->ordering.bits.h2c_send_waiting_ack = 0;
-	rsp_pdu = tcp_req->send_pdu;
+	rsp_pdu = tcp_req->pdu;
 	memset(rsp_pdu, 0, sizeof(*rsp_pdu));
 	h2c_data = &rsp_pdu->hdr.h2c_data;
 
diff --git a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
index 97fed0bfe..ae846ca96 100644
--- a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
+++ b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
@@ -586,7 +586,7 @@ test_nvme_tcp_req_get(void)
 	struct nvme_tcp_qpair tqpair = {};
 	struct nvme_tcp_pdu send_pdu = {};
 
-	tcp_req.send_pdu = &send_pdu;
+	tcp_req.pdu = &send_pdu;
 	tcp_req.state = NVME_TCP_REQ_FREE;
 
 	TAILQ_INIT(&tqpair.free_reqs);
@@ -623,7 +623,7 @@ test_nvme_tcp_qpair_capsule_cmd_send(void)
 	memset(iov_base0, 0xFF, 4096);
 	memset(iov_base1, 0xFF, 4096);
 	tcp_req.req = &req;
-	tcp_req.send_pdu = &pdu;
+	tcp_req.pdu = &pdu;
 	TAILQ_INIT(&tqpair.send_queue);
 
 	tcp_req.iov[0].iov_base = (void *)iov_base0;
@@ -854,7 +854,7 @@ test_nvme_tcp_alloc_reqs(void)
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(tqpair.tcp_reqs[0].cid == 0);
 	CU_ASSERT(tqpair.tcp_reqs[0].tqpair == &tqpair);
-	CU_ASSERT(tqpair.tcp_reqs[0].send_pdu == &tqpair.send_pdus[0]);
+	CU_ASSERT(tqpair.tcp_reqs[0].pdu == &tqpair.send_pdus[0]);
 	CU_ASSERT(tqpair.send_pdu == &tqpair.send_pdus[tqpair.num_entries]);
 	free(tqpair.tcp_reqs);
 	spdk_free(tqpair.send_pdus);
@@ -866,7 +866,7 @@ test_nvme_tcp_alloc_reqs(void)
 	for (int i = 0; i < tqpair.num_entries; i++) {
 		CU_ASSERT(tqpair.tcp_reqs[i].cid == i);
 		CU_ASSERT(tqpair.tcp_reqs[i].tqpair == &tqpair);
-		CU_ASSERT(tqpair.tcp_reqs[i].send_pdu == &tqpair.send_pdus[i]);
+		CU_ASSERT(tqpair.tcp_reqs[i].pdu == &tqpair.send_pdus[i]);
 	}
 	CU_ASSERT(tqpair.send_pdu == &tqpair.send_pdus[tqpair.num_entries]);
 
-- 
2.26.2


From d07c581b7d3d46959ae059dbe9591abb57c56280 Mon Sep 17 00:00:00 2001
From: Jiewei Ke <jiewei@smartx.com>
Date: Tue, 18 May 2021 05:04:57 -0400
Subject: [PATCH 246/342] nvmf: nvmf_get_ana_log_page should use iov to store
 the log page

nvmf_get_ana_log_page used req->data to store the log page result.
While the req->data only contains the first iov, if req->iovcnt is
larger than 1, the req->data may not hold the complete log page; and
even worse, the log page result may be written to invalid address and
cause memory corruption.

The following patch will fix the same issue for other commands in
nvmf_ctrlr_get_log_page.

Fix #1946

Signed-off-by: Jiewei Ke <jiewei@smartx.com>
Change-Id: I495f3be05c82be5cd53609772c655c8924b9179f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7923
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Community-CI: Mellanox Build Bot
---
 lib/nvmf/ctrlr.c                      | 72 +++++++++++++++++++++++----
 test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c | 16 +++++-
 2 files changed, 77 insertions(+), 11 deletions(-)

diff --git a/lib/nvmf/ctrlr.c b/lib/nvmf/ctrlr.c
index 763e9251a..ff684ceec 100644
--- a/lib/nvmf/ctrlr.c
+++ b/lib/nvmf/ctrlr.c
@@ -1742,6 +1742,56 @@ nvmf_ctrlr_async_event_request(struct spdk_nvmf_request *req)
 	return SPDK_NVMF_REQUEST_EXEC_STATUS_ASYNCHRONOUS;
 }
 
+struct copy_iovs_ctx {
+	struct iovec *iovs;
+	int iovcnt;
+	int cur_iov_idx;
+	size_t cur_iov_offset;
+};
+
+static void
+_init_copy_iovs_ctx(struct copy_iovs_ctx *copy_ctx, struct iovec *iovs, int iovcnt)
+{
+	copy_ctx->iovs = iovs;
+	copy_ctx->iovcnt = iovcnt;
+	copy_ctx->cur_iov_idx = 0;
+	copy_ctx->cur_iov_offset = 0;
+}
+
+static size_t
+_copy_buf_to_iovs(struct copy_iovs_ctx *copy_ctx, const void *buf, size_t buf_len)
+{
+	size_t len, iov_remain_len, copied_len = 0;
+	struct iovec *iov;
+
+	if (buf_len == 0) {
+		return 0;
+	}
+
+	while (copy_ctx->cur_iov_idx < copy_ctx->iovcnt) {
+		iov = &copy_ctx->iovs[copy_ctx->cur_iov_idx];
+		iov_remain_len = iov->iov_len - copy_ctx->cur_iov_offset;
+		if (iov_remain_len == 0) {
+			copy_ctx->cur_iov_idx++;
+			copy_ctx->cur_iov_offset = 0;
+			continue;
+		}
+
+		len = spdk_min(iov_remain_len, buf_len - copied_len);
+		memcpy((char *)iov->iov_base + copy_ctx->cur_iov_offset,
+		       (const char *)buf + copied_len,
+		       len);
+		copied_len += len;
+		copy_ctx->cur_iov_offset += len;
+
+		if (buf_len == copied_len) {
+			return copied_len;
+		}
+	}
+
+	return copied_len;
+}
+
 static void
 nvmf_get_firmware_slot_log_page(void *buffer, uint64_t offset, uint32_t length)
 {
@@ -1799,16 +1849,18 @@ nvmf_ctrlr_mask_aen(struct spdk_nvmf_ctrlr *ctrlr,
 #define SPDK_NVMF_ANA_DESC_SIZE	(sizeof(struct spdk_nvme_ana_group_descriptor) +	\
 				 sizeof(uint32_t))
 static void
-nvmf_get_ana_log_page(struct spdk_nvmf_ctrlr *ctrlr, void *data,
+nvmf_get_ana_log_page(struct spdk_nvmf_ctrlr *ctrlr, struct iovec *iovs, int iovcnt,
 		      uint64_t offset, uint32_t length, uint32_t rae)
 {
-	char *buf = data;
 	struct spdk_nvme_ana_page ana_hdr;
 	char _ana_desc[SPDK_NVMF_ANA_DESC_SIZE];
 	struct spdk_nvme_ana_group_descriptor *ana_desc;
-	size_t copy_len;
+	size_t copy_len, copied_len;
 	uint32_t num_ns = 0;
 	struct spdk_nvmf_ns *ns;
+	struct copy_iovs_ctx copy_ctx;
+
+	_init_copy_iovs_ctx(&copy_ctx, iovs, iovcnt);
 
 	if (length == 0) {
 		return;
@@ -1829,9 +1881,9 @@ nvmf_get_ana_log_page(struct spdk_nvmf_ctrlr *ctrlr, void *data,
 		ana_hdr.change_count = 0;
 
 		copy_len = spdk_min(sizeof(ana_hdr) - offset, length);
-		memcpy(buf, (const char *)&ana_hdr + offset, copy_len);
-		length -= copy_len;
-		buf += copy_len;
+		copied_len = _copy_buf_to_iovs(&copy_ctx, (const char *)&ana_hdr + offset, copy_len);
+		assert(copied_len == copy_len);
+		length -= copied_len;
 		offset = 0;
 	}
 
@@ -1858,9 +1910,9 @@ nvmf_get_ana_log_page(struct spdk_nvmf_ctrlr *ctrlr, void *data,
 		ana_desc->change_count = 0;
 
 		copy_len = spdk_min(SPDK_NVMF_ANA_DESC_SIZE - offset, length);
-		memcpy(buf, (const char *)ana_desc + offset, copy_len);
-		length -= copy_len;
-		buf += copy_len;
+		copied_len = _copy_buf_to_iovs(&copy_ctx, (const char *)ana_desc + offset, copy_len);
+		assert(copied_len == copy_len);
+		length -= copied_len;
 		offset = 0;
 
 		if (length == 0) {
@@ -2089,7 +2141,7 @@ nvmf_ctrlr_get_log_page(struct spdk_nvmf_request *req)
 			return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
 		case SPDK_NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS:
 			if (subsystem->flags.ana_reporting) {
-				nvmf_get_ana_log_page(ctrlr, req->data, offset, len, rae);
+				nvmf_get_ana_log_page(ctrlr, req->iov, req->iovcnt, offset, len, rae);
 				return SPDK_NVMF_REQUEST_EXEC_STATUS_COMPLETE;
 			} else {
 				goto invalid_log_page;
diff --git a/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c b/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
index 0ae8f13e5..5cf4295d5 100644
--- a/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
+++ b/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
@@ -1787,6 +1787,7 @@ test_get_ana_log_page(void)
 	int i;
 	char expected_page[UT_ANA_LOG_PAGE_SIZE] = {0};
 	char actual_page[UT_ANA_LOG_PAGE_SIZE] = {0};
+	struct iovec iov, iovs[2];
 	struct spdk_nvme_ana_page *ana_hdr;
 	char _ana_desc[UT_ANA_DESC_SIZE];
 	struct spdk_nvme_ana_group_descriptor *ana_desc;
@@ -1825,12 +1826,25 @@ test_get_ana_log_page(void)
 	offset = 0;
 	while (offset < UT_ANA_LOG_PAGE_SIZE) {
 		length = spdk_min(16, UT_ANA_LOG_PAGE_SIZE - offset);
-		nvmf_get_ana_log_page(&ctrlr, &actual_page[offset], offset, length, 0);
+		iov.iov_base = &actual_page[offset];
+		iov.iov_len = length;
+		nvmf_get_ana_log_page(&ctrlr, &iov, 1, offset, length, 0);
 		offset += length;
 	}
 
 	/* compare expected page and actual page */
 	CU_ASSERT(memcmp(expected_page, actual_page, UT_ANA_LOG_PAGE_SIZE) == 0);
+
+	memset(&actual_page[0], 0, UT_ANA_LOG_PAGE_SIZE);
+	offset = 0;
+	iovs[0].iov_base = &actual_page[offset];
+	iovs[0].iov_len = UT_ANA_LOG_PAGE_SIZE - UT_ANA_DESC_SIZE + 4;
+	offset += UT_ANA_LOG_PAGE_SIZE - UT_ANA_DESC_SIZE + 4;
+	iovs[1].iov_base = &actual_page[offset];
+	iovs[1].iov_len = UT_ANA_LOG_PAGE_SIZE - offset;
+	nvmf_get_ana_log_page(&ctrlr, &iovs[0], 2, 0, UT_ANA_LOG_PAGE_SIZE, 0);
+
+	CU_ASSERT(memcmp(expected_page, actual_page, UT_ANA_LOG_PAGE_SIZE) == 0);
 }
 
 static void
-- 
2.26.2


From 3f674e1e292545dcde3a57601385ce1ff1f05af1 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Mon, 24 May 2021 11:02:33 +0200
Subject: [PATCH 247/342] test/setup: Perform custom alloc based on hugepages'
 size not quantity

512 and 1024 number of hugpages is not a sensible value in case 1G
hugepages are in use. Instead of setting fixed number of hugepages,
determine it safely based on the default size and allocate 1GB for
node0, 2GB for node1 (if present).

Fixes: #1954

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I850ba877332527a68ec4ddf7408fcc183835cda6
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8012
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/setup/hugepages.sh | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/test/setup/hugepages.sh b/test/setup/hugepages.sh
index a8460c07d..fd6eb699a 100755
--- a/test/setup/hugepages.sh
+++ b/test/setup/hugepages.sh
@@ -134,28 +134,30 @@ odd_alloc() {
 }
 
 custom_alloc() {
-	# Custom alloc: node0 == 512 pages [node1 == 1024 pages]
+	# Custom alloc: node0 == 1GB [node1 == 2 GB]
 
 	local IFS=","
 
 	local node
 	local nodes_hp=()
 
-	local nr_hugepages=0
+	local nr_hugepages=0 _nr_hugepages=0
 
-	nodes_hp[0]=512
+	get_test_nr_hugepages $((1024 * 1024))
+	nodes_hp[0]=$nr_hugepages
 	if ((${#nodes_sys[@]} > 1)); then
-		nodes_hp[1]=1024
+		get_test_nr_hugepages $((2048 * 1024))
+		nodes_hp[1]=$nr_hugepages
 	fi
 
 	for node in "${!nodes_hp[@]}"; do
 		HUGENODE+=("nodes_hp[$node]=${nodes_hp[node]}")
-		((nr_hugepages += nodes_hp[node]))
+		((_nr_hugepages += nodes_hp[node]))
 	done
 
 	get_test_nr_hugepages_per_node
 	HUGENODE="${HUGENODE[*]}" setup
-	verify_nr_hugepages
+	nr_hugepages=$_nr_hugepages verify_nr_hugepages
 }
 
 hp_status() {
-- 
2.26.2


From fcc389490a4abe26c1efe6cc624dc2925ed6b670 Mon Sep 17 00:00:00 2001
From: Rui Chang <rui.chang@arm.com>
Date: Tue, 18 May 2021 15:32:56 +0800
Subject: [PATCH 248/342] configure: add gcc version check for ARM Neoverse-N1
 platform

When doing debug build on ARM Neoverse-N1 platform, if gcc version is
lower than 8.4.0, we may met following errors:

/tmp/cc24qua1.s: Assembler messages:
/tmp/cc24qua1.s:53: Error: selected processor does not support `casp x0,x1,x2,x3,[x4]'
/tmp/cc24qua1.s:85: Error: selected processor does not support `caspa x0,x1,x2,x3,[x4]'
/tmp/cc24qua1.s:117: Error: selected processor does not support `caspl x0,x1,x2,x3,[x4]'
/tmp/cc24qua1.s:149: Error: selected processor does not support `caspal x0,x1,x2,x3,[x4]'

The change also fix the problem by pass armv8.2-a+crypto as target architecture.

Signed-off-by: Rui Chang <rui.chang@arm.com>
Change-Id: I2053b9440e06873066480d63e471802df2e69d4e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7949
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 configure | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/configure b/configure
index 7d063f4ef..a2d0c5a62 100755
--- a/configure
+++ b/configure
@@ -845,6 +845,20 @@ if [[ "${CONFIG[ISAL]}" = "y" ]]; then
 	cd $rootdir
 fi
 
+# For ARM Neoverse-N1 platform, debug build needs gcc version newer than 8.4
+if [[ "${CONFIG[DEBUG]}" = "y" && $arch = aarch64* && "$CC_TYPE" = "gcc" ]]; then
+	GCC_VERSION=$($CC -dumpfullversion)
+	PART_NUM=$(grep -i -m 1 "CPU part" /proc/cpuinfo | awk '{print $4}')
+
+	if [[ "$(printf '%s\n' "8.4.0" "$GCC_VERSION" | sort -V | head -n1)" != "8.4.0" ]]; then
+		if [[ $PART_NUM = 0xd0c ]]; then
+			echo "WARNING: For ARM Neoverse-N1 platform, debug build needs GCC version newer than 8.4."
+			echo "         Will work around this by using armv8.2-a+crypto as target architecture for now."
+			CONFIG[ARCH]=armv8.2-a+crypto
+		fi
+	fi
+fi
+
 # We are now ready to generate final configuration. But first do sanity
 # check to see if all keys in CONFIG array have its reflection in CONFIG file.
 if (($(grep -cE "^\s*CONFIG_[[:alnum:]_]+=" "$rootdir/CONFIG") != ${#CONFIG[@]})); then
-- 
2.26.2


From f90eaf167237c730998af0408d735e357937cf1a Mon Sep 17 00:00:00 2001
From: ChengqiangMeng <chengqiangx.meng@intel.com>
Date: Mon, 24 May 2021 10:19:49 +0800
Subject: [PATCH 249/342] unittest/nvme_ctrlr: increase code coverage for
 nvme_ctrlr_identify_namespaces_iocs_specific_next

nvme_ctrlr_identify_namespaces_iocs_specific_next code comprehensive coverage.

Signed-off-by: ChengqiangMeng <chengqiangx.meng@intel.com>
Change-Id: Icf039e15a983b04fcd1b558559ba651e495a6cd1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8006
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
---
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 112 +++++++++++++++++-
 1 file changed, 110 insertions(+), 2 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index 41de5a505..a11dbf000 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -67,9 +67,7 @@ DEFINE_STUB(nvme_ctrlr_cmd_set_host_id, int,
 	     spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
 DEFINE_STUB_V(nvme_ns_set_identify_data, (struct spdk_nvme_ns *ns));
 DEFINE_STUB_V(nvme_ns_set_id_desc_list_data, (struct spdk_nvme_ns *ns));
-DEFINE_STUB_V(nvme_ns_free_zns_specific_data, (struct spdk_nvme_ns *ns));
 DEFINE_STUB_V(nvme_ns_free_iocs_specific_data, (struct spdk_nvme_ns *ns));
-DEFINE_STUB(nvme_ns_has_supported_iocs_specific_data, bool, (struct spdk_nvme_ns *ns), false);
 DEFINE_STUB_V(nvme_qpair_abort_reqs, (struct spdk_nvme_qpair *qpair, uint32_t dnr));
 DEFINE_STUB(spdk_nvme_poll_group_remove, int, (struct spdk_nvme_poll_group *group,
 		struct spdk_nvme_qpair *qpair), 0);
@@ -438,6 +436,10 @@ nvme_ctrlr_cmd_identify(struct spdk_nvme_ctrlr *ctrlr, uint8_t cns, uint16_t cnt
 		if (g_cdata) {
 			memcpy(payload, g_cdata, sizeof(*g_cdata));
 		}
+	} else if (nsid == 99) {
+		return 1;
+	} else if (cns == SPDK_NVME_IDENTIFY_NS_IOCS) {
+		return 0;
 	}
 
 	fake_cpl_sc(cb_fn, cb_arg);
@@ -541,6 +543,37 @@ nvme_ctrlr_cmd_fw_image_download(struct spdk_nvme_ctrlr *ctrlr,
 	return 0;
 }
 
+bool
+nvme_ns_has_supported_iocs_specific_data(struct spdk_nvme_ns *ns)
+{
+	switch (ns->csi) {
+	case SPDK_NVME_CSI_NVM:
+		/*
+		 * NVM Command Set Specific Identify Namespace data structure
+		 * is currently all-zeroes, reserved for future use.
+		 */
+		return false;
+	case SPDK_NVME_CSI_ZNS:
+		return true;
+	default:
+		SPDK_WARNLOG("Unsupported CSI: %u for NSID: %u\n", ns->csi, ns->id);
+		return false;
+	}
+}
+
+void
+nvme_ns_free_zns_specific_data(struct spdk_nvme_ns *ns)
+{
+	if (!ns->id) {
+		return;
+	}
+
+	if (ns->nsdata_zns) {
+		spdk_free(ns->nsdata_zns);
+		ns->nsdata_zns = NULL;
+	}
+}
+
 void
 nvme_ns_destruct(struct spdk_nvme_ns *ns)
 {
@@ -2835,6 +2868,80 @@ test_nvme_ctrlr_ns_attr_changed(void)
 	nvme_ctrlr_destruct(&ctrlr);
 }
 
+static void
+test_nvme_ctrlr_identify_namespaces_iocs_specific_next(void)
+{
+	struct spdk_nvme_ctrlr ctrlr = {};
+	uint32_t prev_nsid;
+	uint32_t active_ns_list[5] = {1, 2, 3, 4, 5};
+	struct spdk_nvme_ns ns[5] = {};
+	struct spdk_nvme_ctrlr ns_ctrlr[5] = {};
+	int rc = 0;
+
+	ctrlr.ns = ns;
+	ctrlr.cdata.nn = 5;
+	ctrlr.max_active_ns_idx = 5;
+	ctrlr.num_ns = 5;
+	/* case 1: No first/next active NS, move on to the next state, expect: pass */
+	prev_nsid = 0;
+	ctrlr.active_ns_list = NULL;
+	ctrlr.opts.admin_timeout_ms = NVME_TIMEOUT_INFINITE;
+	rc = nvme_ctrlr_identify_namespaces_iocs_specific_next(&ctrlr, prev_nsid);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONFIGURE_AER);
+	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+
+	/* case 2: move on to the next active NS, and no namespace with (supported) iocs specific data found , expect: pass */
+	memset(&ctrlr.state, 0x00, sizeof(ctrlr.state));
+	memset(&ctrlr.state_timeout_tsc, 0x00, sizeof(ctrlr.state_timeout_tsc));
+	prev_nsid = 1;
+	ctrlr.active_ns_list = active_ns_list;
+	ns[1].csi = SPDK_NVME_CSI_NVM;
+	ns[1].id = 2;
+	rc = nvme_ctrlr_identify_namespaces_iocs_specific_next(&ctrlr, prev_nsid);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_CONFIGURE_AER);
+	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+
+	/* case 3: ns.csi is SPDK_NVME_CSI_ZNS, do not loop, expect: pass */
+	memset(&ctrlr.state, 0x00, sizeof(ctrlr.state));
+	memset(&ctrlr.state_timeout_tsc, 0x00, sizeof(ctrlr.state_timeout_tsc));
+	ctrlr.opts.admin_timeout_ms = NVME_TIMEOUT_INFINITE;
+	prev_nsid = 0;
+	ctrlr.active_ns_list = active_ns_list;
+
+	for (int i = 0; i < 5; i++) {
+		ns[i].csi = SPDK_NVME_CSI_NVM;
+		ns[i].id = i + 1;
+		ns[i].ctrlr = &ns_ctrlr[i];
+	}
+	ns[4].csi = SPDK_NVME_CSI_ZNS;
+	ns_ctrlr[4].opts.admin_timeout_ms = NVME_TIMEOUT_INFINITE;
+
+	rc = nvme_ctrlr_identify_namespaces_iocs_specific_next(&ctrlr, prev_nsid);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(ctrlr.state == 0);
+	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+	CU_ASSERT(ns_ctrlr[4].state == NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_NS_IOCS_SPECIFIC);
+	CU_ASSERT(ns_ctrlr[4].state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+
+	for (int i = 0; i < 5; i++) {
+		nvme_ns_free_zns_specific_data(&ns[i]);
+	}
+
+	/* case 4: nvme_ctrlr_identify_ns_iocs_specific_async return 1, expect: false */
+	memset(&ctrlr.state, 0x00, sizeof(ctrlr.state));
+	memset(&ctrlr.state_timeout_tsc, 0x00, sizeof(ctrlr.state_timeout_tsc));
+	prev_nsid = 1;
+	ctrlr.active_ns_list = active_ns_list;
+	ns[1].csi = SPDK_NVME_CSI_ZNS;
+	ns[1].id = 99;
+	rc = nvme_ctrlr_identify_namespaces_iocs_specific_next(&ctrlr, prev_nsid);
+	CU_ASSERT(rc == 1);
+	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_ERROR);
+	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -2885,6 +2992,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_ctrlr_reset);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_aer_callback);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_ns_attr_changed);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_identify_namespaces_iocs_specific_next);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From c3cf9ec2950037da11ea013fc1703446d33ec00a Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 21 May 2021 19:24:44 +0800
Subject: [PATCH 250/342] rbd/rpc: Add a rpc call to get the info of the
 clusters.

Purpose: Let the users know the current available registered Rados
cluster and the related info.

Change-Id: I115c129ae6e4b0372579aad168fd88f8be136357
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7990
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 CHANGELOG.md                   |  3 ++
 doc/jsonrpc.md                 | 39 +++++++++++++++++++
 module/bdev/rbd/bdev_rbd.c     | 70 ++++++++++++++++++++++++++++++++++
 module/bdev/rbd/bdev_rbd.h     | 10 +++++
 module/bdev/rbd/bdev_rbd_rpc.c | 41 +++++++++++++++++++-
 scripts/rpc.py                 |  8 ++++
 scripts/rpc/bdev.py            | 15 ++++++++
 test/iscsi_tgt/rbd/rbd.sh      |  1 +
 8 files changed, 186 insertions(+), 1 deletion(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2554a7588..9b1f9310a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -30,6 +30,9 @@ device.
 Revised `bdev_rbd_create` parameter, it allows to use an optional parameter --cluster-name
 to create a rbd bdev with  an already registered Rados Cluster Object.
 
+New RPC `bdev_rbd_get_clusters_info` was added, it allows to get the info of the registered
+Rados Cluster names.
+
 ## v21.04:
 
 ### accel
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 264b0f33f..623997c3c 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -3405,6 +3405,45 @@ Example response:
 }
 ~~
 
+## bdev_rbd_get_clusters_info {#rpc_bdev_rbd_get_clusters_info}
+
+This method is available only if SPDK was build with Ceph RBD support.
+
+### Result
+
+Returns the cluster info of the Rados Cluster name if provided. Otherwise, it
+returns the cluster info of every registered Raods Cluster name.
+
+### Parameters
+
+Name                    | Optional | Type        | Description
+----------------------- | -------- | ----------- | -------------------------
+name                    | Optional | string      | Rados cluster object name
+
+### Example
+
+Example request:
+
+~~
+{
+  "params": {
+    "name": "rbd_cluster"
+  },
+  "jsonrpc": "2.0",
+  "method": "bdev_rbd_get_clusters_info",
+  "id": 1
+}
+~~
+
+Example response:
+
+~~
+{
+  "jsonrpc": "2.0",
+  "cluster_name": "rbd_cluster"
+}
+~~
+
 ## bdev_rbd_create {#rpc_bdev_rbd_create}
 
 Create @ref bdev_config_rbd bdev
diff --git a/module/bdev/rbd/bdev_rbd.c b/module/bdev/rbd/bdev_rbd.c
index c46d3fb22..e8a1a5e4f 100644
--- a/module/bdev/rbd/bdev_rbd.c
+++ b/module/bdev/rbd/bdev_rbd.c
@@ -790,6 +790,76 @@ bdev_rbd_write_config_json(struct spdk_bdev *bdev, struct spdk_json_write_ctx *w
 	spdk_json_write_object_end(w);
 }
 
+static void
+dump_single_cluster_entry(struct bdev_rbd_cluster *entry, struct spdk_json_write_ctx *w)
+{
+	assert(entry != NULL);
+
+	spdk_json_write_object_begin(w);
+	spdk_json_write_named_string(w, "cluster_name", entry->name);
+
+	if (entry->user_id) {
+		spdk_json_write_named_string(w, "user_id", entry->user_id);
+	}
+
+	if (entry->config_param) {
+		char **config_entry = entry->config_param;
+
+		spdk_json_write_named_object_begin(w, "config_param");
+		while (*config_entry) {
+			spdk_json_write_named_string(w, config_entry[0], config_entry[1]);
+			config_entry += 2;
+		}
+		spdk_json_write_object_end(w);
+	} else if (entry->config_file) {
+		spdk_json_write_named_string(w, "config_file", entry->config_file);
+	}
+
+	spdk_json_write_object_end(w);
+}
+
+int
+bdev_rbd_get_clusters_info(struct spdk_jsonrpc_request *request, const char *name)
+{
+	struct bdev_rbd_cluster *entry;
+	struct spdk_json_write_ctx *w;
+
+	pthread_mutex_lock(&g_map_bdev_rbd_cluster_mutex);
+
+	if (STAILQ_EMPTY(&g_map_bdev_rbd_cluster)) {
+		pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+		return -ENOENT;
+	}
+
+	/* If cluster name is provided */
+	if (name) {
+		STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+			if (strcmp(name, entry->name) == 0) {
+				w = spdk_jsonrpc_begin_result(request);
+				dump_single_cluster_entry(entry, w);
+				spdk_jsonrpc_end_result(request, w);
+
+				pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+				return 0;
+			}
+		}
+
+		pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+		return -ENOENT;
+	}
+
+	w = spdk_jsonrpc_begin_result(request);
+	spdk_json_write_array_begin(w);
+	STAILQ_FOREACH(entry, &g_map_bdev_rbd_cluster, link) {
+		dump_single_cluster_entry(entry, w);
+	}
+	spdk_json_write_array_end(w);
+	spdk_jsonrpc_end_result(request, w);
+	pthread_mutex_unlock(&g_map_bdev_rbd_cluster_mutex);
+
+	return 0;
+}
+
 static const struct spdk_bdev_fn_table rbd_fn_table = {
 	.destruct		= bdev_rbd_destruct,
 	.submit_request		= bdev_rbd_submit_request,
diff --git a/module/bdev/rbd/bdev_rbd.h b/module/bdev/rbd/bdev_rbd.h
index 4f6f0bad3..c7399251c 100644
--- a/module/bdev/rbd/bdev_rbd.h
+++ b/module/bdev/rbd/bdev_rbd.h
@@ -37,6 +37,7 @@
 #include "spdk/stdinc.h"
 
 #include "spdk/bdev.h"
+#include "spdk/rpc.h"
 
 struct cluster_register_info {
 	char *name;
@@ -86,4 +87,13 @@ int bdev_rbd_register_cluster(struct cluster_register_info *info);
  */
 int bdev_rbd_unregister_cluster(const char *name);
 
+/**
+ * Show the cluster info of a given name. If given name is empty,
+ * the info of every registered cluster name will be showed.
+ *
+ * \param request the json request.
+ * \param name the name of the cluster.
+ */
+int bdev_rbd_get_clusters_info(struct spdk_jsonrpc_request *request, const char *name);
+
 #endif /* SPDK_BDEV_RBD_H */
diff --git a/module/bdev/rbd/bdev_rbd_rpc.c b/module/bdev/rbd/bdev_rbd_rpc.c
index 8eee4400f..b066c1ee9 100644
--- a/module/bdev/rbd/bdev_rbd_rpc.c
+++ b/module/bdev/rbd/bdev_rbd_rpc.c
@@ -32,7 +32,6 @@
  */
 
 #include "bdev_rbd.h"
-#include "spdk/rpc.h"
 #include "spdk/util.h"
 #include "spdk/string.h"
 #include "spdk/log.h"
@@ -336,3 +335,43 @@ cleanup:
 	free_rpc_bdev_cluster_unregister(&req);
 }
 SPDK_RPC_REGISTER("bdev_rbd_unregister_cluster", rpc_bdev_rbd_unregister_cluster, SPDK_RPC_RUNTIME)
+
+struct rpc_bdev_rbd_get_cluster_info {
+	char *name;
+};
+
+static void
+free_rpc_bdev_rbd_get_cluster_info(struct rpc_bdev_rbd_get_cluster_info *req)
+{
+	free(req->name);
+}
+
+static const struct spdk_json_object_decoder rpc_bdev_rbd_get_cluster_info_decoders[] = {
+	{"name", offsetof(struct rpc_bdev_rbd_get_cluster_info, name), spdk_json_decode_string, true},
+};
+
+static void
+rpc_bdev_rbd_get_clusters_info(struct spdk_jsonrpc_request *request,
+			       const struct spdk_json_val *params)
+{
+	struct rpc_bdev_rbd_get_cluster_info req = {NULL};
+	int rc;
+
+	if (params && spdk_json_decode_object(params, rpc_bdev_rbd_get_cluster_info_decoders,
+					      SPDK_COUNTOF(rpc_bdev_rbd_get_cluster_info_decoders),
+					      &req)) {
+		spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INTERNAL_ERROR,
+						 "spdk_json_decode_object failed");
+		goto cleanup;
+	}
+
+	rc = bdev_rbd_get_clusters_info(request, req.name);
+	if (rc) {
+		spdk_jsonrpc_send_error_response(request, rc, spdk_strerror(-rc));
+		goto cleanup;
+	}
+
+cleanup:
+	free_rpc_bdev_rbd_get_cluster_info(&req);
+}
+SPDK_RPC_REGISTER("bdev_rbd_get_clusters_info", rpc_bdev_rbd_get_clusters_info, SPDK_RPC_RUNTIME)
diff --git a/scripts/rpc.py b/scripts/rpc.py
index 47cb5b087..174f0cff4 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -661,6 +661,14 @@ if __name__ == "__main__":
     p.add_argument('name', help='Name of the Rados Cluster only known to rbd bdev')
     p.set_defaults(func=bdev_rbd_unregister_cluster)
 
+    def bdev_rbd_get_clusters_info(args):
+        print_json(rpc.bdev.bdev_rbd_get_clusters_info(args.client, name=args.name))
+
+    p = subparsers.add_parser('bdev_rbd_get_clusters_info',
+                              help='Display registered Rados Cluster names and related info')
+    p.add_argument('-b', '--name', help="Name of the registered Rados Cluster Name. Example: Cluster1", required=False)
+    p.set_defaults(func=bdev_rbd_get_clusters_info)
+
     def bdev_rbd_create(args):
         config = None
         if args.config:
diff --git a/scripts/rpc/bdev.py b/scripts/rpc/bdev.py
index 4f75cb81a..94b749c51 100644
--- a/scripts/rpc/bdev.py
+++ b/scripts/rpc/bdev.py
@@ -693,6 +693,21 @@ def bdev_rbd_unregister_cluster(client, name):
     return client.call('bdev_rbd_unregister_cluster', params)
 
 
+def bdev_rbd_get_clusters_info(client, name):
+    """Get the cluster(s) info
+
+    Args:
+        name: name of Rados cluster object to query (optional; if omitted, query all clusters)
+
+    Returns:
+        List of registered Rados cluster information objects.
+    """
+    params = {}
+    if name:
+        params['name'] = name
+    return client.call('bdev_rbd_get_clusters_info', params)
+
+
 @deprecated_alias('construct_rbd_bdev')
 def bdev_rbd_create(client, pool_name, rbd_name, block_size, name=None, user=None, config=None, cluster_name=None):
     """Create a Ceph RBD block device.
diff --git a/test/iscsi_tgt/rbd/rbd.sh b/test/iscsi_tgt/rbd/rbd.sh
index 607ef9561..7e0721fea 100755
--- a/test/iscsi_tgt/rbd/rbd.sh
+++ b/test/iscsi_tgt/rbd/rbd.sh
@@ -32,6 +32,7 @@ timing_exit start_iscsi_tgt
 $rpc_py iscsi_create_portal_group $PORTAL_TAG $TARGET_IP:$ISCSI_PORT
 $rpc_py iscsi_create_initiator_group $INITIATOR_TAG $INITIATOR_NAME $NETMASK
 rbd_cluster_name="$($rpc_py bdev_rbd_register_cluster iscsi_rbd_cluster)"
+$rpc_py bdev_rbd_get_clusters_info -b $rbd_cluster_name
 rbd_bdev="$($rpc_py bdev_rbd_create $RBD_POOL $RBD_NAME 4096 -c $rbd_cluster_name)"
 $rpc_py bdev_get_bdevs
 
-- 
2.26.2


From 1a22f9b6acdb7ad1c54bb2736c083fcdc714ea86 Mon Sep 17 00:00:00 2001
From: Jiewei Ke <jiewei@smartx.com>
Date: Tue, 25 May 2021 05:28:51 -0400
Subject: [PATCH 251/342] bdev: clean up spdk_bdev_register()

Clean up spdk_bdev_register() to facilitate the upcoming patch which
uses RB tree to speed up bdev name lookup.

* move TAILQ_INSERT from bdev_start() into bdev_init();
* rename bdev_init() to bdev_register() and rename bdev_start_finished()
  to bdev_register_finished();
* inline bdev_start() into spdk_bdev_register().

Signed-off-by: Jiewei Ke <jiewei@smartx.com>
Change-Id: Idbfc800472bc8c6f9b615046e082772e9f6026e3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8043
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
---
 lib/bdev/bdev.c | 27 +++++++++++----------------
 1 file changed, 11 insertions(+), 16 deletions(-)

diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 19599bae3..f48f03ba7 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -5513,7 +5513,7 @@ spdk_bdev_io_get_io_channel(struct spdk_bdev_io *bdev_io)
 }
 
 static int
-bdev_init(struct spdk_bdev *bdev)
+bdev_register(struct spdk_bdev *bdev)
 {
 	char *bdev_name;
 
@@ -5593,6 +5593,10 @@ bdev_init(struct spdk_bdev *bdev)
 	free(bdev_name);
 
 	pthread_mutex_init(&bdev->internal.mutex, NULL);
+
+	SPDK_DEBUGLOG(bdev, "Inserting bdev %s into list\n", bdev->name);
+	TAILQ_INSERT_TAIL(&g_bdev_mgr.bdevs, bdev, internal.link);
+
 	return 0;
 }
 
@@ -5621,32 +5625,23 @@ bdev_destroy_cb(void *io_device)
 }
 
 static void
-bdev_start_finished(void *arg)
+bdev_register_finished(void *arg)
 {
 	struct spdk_bdev *bdev = arg;
 
 	spdk_notify_send("bdev_register", spdk_bdev_get_name(bdev));
 }
 
-static void
-bdev_start(struct spdk_bdev *bdev)
-{
-	SPDK_DEBUGLOG(bdev, "Inserting bdev %s into list\n", bdev->name);
-	TAILQ_INSERT_TAIL(&g_bdev_mgr.bdevs, bdev, internal.link);
-
-	/* Examine configuration before initializing I/O */
-	bdev_examine(bdev);
-
-	spdk_bdev_wait_for_examine(bdev_start_finished, bdev);
-}
-
 int
 spdk_bdev_register(struct spdk_bdev *bdev)
 {
-	int rc = bdev_init(bdev);
+	int rc = bdev_register(bdev);
 
 	if (rc == 0) {
-		bdev_start(bdev);
+		/* Examine configuration before initializing I/O */
+		bdev_examine(bdev);
+
+		spdk_bdev_wait_for_examine(bdev_register_finished, bdev);
 	}
 
 	return rc;
-- 
2.26.2


From eabe783cc4d79cf17a4cf22fa123a3d3a7e8c095 Mon Sep 17 00:00:00 2001
From: Jiewei Ke <jiewei@smartx.com>
Date: Tue, 11 May 2021 03:16:14 -0400
Subject: [PATCH 252/342] bdev: speed up bdev name lookup by using rbtree

Use the macros for red black tree provided by Free BSD to speed up bdev
name lookup in spdk_bdev_get_by_name().

In the bdev_multi_allocation test, we can get 3x ~ 5x speed up when
creating multiple bdevs for various bdev nums.

Signed-off-by: Jiewei Ke <jiewei@smartx.com>
Change-Id: I49a2fbcccf06d4c36cbd445ce59e0b0dd4ada31d
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7837
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 include/spdk/bdev_module.h                    | 12 ++-
 lib/bdev/bdev.c                               | 77 +++++++++++++------
 lib/bdev/bdev_rpc.c                           |  2 +-
 module/bdev/compress/vbdev_compress.c         |  2 +-
 module/bdev/lvol/vbdev_lvol.c                 |  4 +-
 test/unit/lib/bdev/bdev.c/bdev_ut.c           | 67 ++++++++++++++++
 .../lib/bdev/vbdev_lvol.c/vbdev_lvol_ut.c     | 20 +++--
 7 files changed, 150 insertions(+), 34 deletions(-)

diff --git a/include/spdk/bdev_module.h b/include/spdk/bdev_module.h
index 86876a4cc..cfc212d32 100644
--- a/include/spdk/bdev_module.h
+++ b/include/spdk/bdev_module.h
@@ -47,6 +47,7 @@
 #include "spdk/queue.h"
 #include "spdk/scsi_spec.h"
 #include "spdk/thread.h"
+#include "spdk/tree.h"
 #include "spdk/util.h"
 #include "spdk/uuid.h"
 
@@ -267,8 +268,14 @@ enum spdk_bdev_io_status {
 	SPDK_BDEV_IO_STATUS_SUCCESS = 1,
 };
 
+struct spdk_bdev_name {
+	char *name;
+	struct spdk_bdev *bdev;
+	RB_ENTRY(spdk_bdev_name) node;
+};
+
 struct spdk_bdev_alias {
-	char *alias;
+	struct spdk_bdev_name alias;
 	TAILQ_ENTRY(spdk_bdev_alias) tailq;
 };
 
@@ -501,6 +508,9 @@ struct spdk_bdev {
 		 *  locked due to overlapping with another locked range.
 		 */
 		lba_range_tailq_t pending_locked_ranges;
+
+		/** Bdev name used for quick lookup */
+		struct spdk_bdev_name bdev_name;
 	} internal;
 };
 
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index f48f03ba7..42d82c681 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -95,6 +95,16 @@ static const char *qos_rpc_type[] = {"rw_ios_per_sec",
 
 TAILQ_HEAD(spdk_bdev_list, spdk_bdev);
 
+RB_HEAD(bdev_name_tree, spdk_bdev_name);
+
+static int
+bdev_name_cmp(struct spdk_bdev_name *name1, struct spdk_bdev_name *name2)
+{
+	return strcmp(name1->name, name2->name);
+}
+
+RB_GENERATE_STATIC(bdev_name_tree, spdk_bdev_name, node, bdev_name_cmp);
+
 struct spdk_bdev_mgr {
 	struct spdk_mempool *bdev_io_pool;
 
@@ -106,6 +116,7 @@ struct spdk_bdev_mgr {
 	TAILQ_HEAD(bdev_module_list, spdk_bdev_module) bdev_modules;
 
 	struct spdk_bdev_list bdevs;
+	struct bdev_name_tree bdev_names;
 
 	bool init_complete;
 	bool module_init_complete;
@@ -120,6 +131,7 @@ struct spdk_bdev_mgr {
 static struct spdk_bdev_mgr g_bdev_mgr = {
 	.bdev_modules = TAILQ_HEAD_INITIALIZER(g_bdev_mgr.bdev_modules),
 	.bdevs = TAILQ_HEAD_INITIALIZER(g_bdev_mgr.bdevs),
+	.bdev_names = RB_INITIALIZER(g_bdev_mgr.bdev_names),
 	.init_complete = false,
 	.module_init_complete = false,
 	.mutex = PTHREAD_MUTEX_INITIALIZER,
@@ -546,7 +558,7 @@ bdev_in_examine_allowlist(struct spdk_bdev *bdev)
 		return true;
 	}
 	TAILQ_FOREACH(tmp, &bdev->aliases, tailq) {
-		if (bdev_examine_allowlist_check(tmp->alias)) {
+		if (bdev_examine_allowlist_check(tmp->alias.name)) {
 			return true;
 		}
 	}
@@ -716,21 +728,13 @@ spdk_bdev_next_leaf(struct spdk_bdev *prev)
 struct spdk_bdev *
 spdk_bdev_get_by_name(const char *bdev_name)
 {
-	struct spdk_bdev_alias *tmp;
-	struct spdk_bdev *bdev = spdk_bdev_first();
-
-	while (bdev != NULL) {
-		if (strcmp(bdev_name, bdev->name) == 0) {
-			return bdev;
-		}
-
-		TAILQ_FOREACH(tmp, &bdev->aliases, tailq) {
-			if (strcmp(bdev_name, tmp->alias) == 0) {
-				return bdev;
-			}
-		}
+	struct spdk_bdev_name find;
+	struct spdk_bdev_name *res;
 
-		bdev = spdk_bdev_next(bdev);
+	find.name = (char *)bdev_name;
+	res = RB_FIND(bdev_name_tree, &g_bdev_mgr.bdev_names, &find);
+	if (res != NULL) {
+		return res->bdev;
 	}
 
 	return NULL;
@@ -3176,10 +3180,32 @@ bdev_channel_destroy(void *io_device, void *ctx_buf)
 	bdev_channel_destroy_resource(ch);
 }
 
+static int
+bdev_name_add(struct spdk_bdev_name *bdev_name, struct spdk_bdev *bdev, const char *name)
+{
+	bdev_name->name = strdup(name);
+	if (bdev_name->name == NULL) {
+		SPDK_ERRLOG("Unable to allocate bdev name\n");
+		return -ENOMEM;
+	}
+
+	bdev_name->bdev = bdev;
+	RB_INSERT(bdev_name_tree, &g_bdev_mgr.bdev_names, bdev_name);
+	return 0;
+}
+
+static void
+bdev_name_del(struct spdk_bdev_name *bdev_name)
+{
+	RB_REMOVE(bdev_name_tree, &g_bdev_mgr.bdev_names, bdev_name);
+	free(bdev_name->name);
+}
+
 int
 spdk_bdev_alias_add(struct spdk_bdev *bdev, const char *alias)
 {
 	struct spdk_bdev_alias *tmp;
+	int ret;
 
 	if (alias == NULL) {
 		SPDK_ERRLOG("Empty alias passed\n");
@@ -3197,11 +3223,10 @@ spdk_bdev_alias_add(struct spdk_bdev *bdev, const char *alias)
 		return -ENOMEM;
 	}
 
-	tmp->alias = strdup(alias);
-	if (tmp->alias == NULL) {
+	ret = bdev_name_add(&tmp->alias, bdev, alias);
+	if (ret != 0) {
 		free(tmp);
-		SPDK_ERRLOG("Unable to allocate alias\n");
-		return -ENOMEM;
+		return ret;
 	}
 
 	TAILQ_INSERT_TAIL(&bdev->aliases, tmp, tailq);
@@ -3215,9 +3240,9 @@ spdk_bdev_alias_del(struct spdk_bdev *bdev, const char *alias)
 	struct spdk_bdev_alias *tmp;
 
 	TAILQ_FOREACH(tmp, &bdev->aliases, tailq) {
-		if (strcmp(alias, tmp->alias) == 0) {
+		if (strcmp(alias, tmp->alias.name) == 0) {
 			TAILQ_REMOVE(&bdev->aliases, tmp, tailq);
-			free(tmp->alias);
+			bdev_name_del(&tmp->alias);
 			free(tmp);
 			return 0;
 		}
@@ -3235,7 +3260,7 @@ spdk_bdev_alias_del_all(struct spdk_bdev *bdev)
 
 	TAILQ_FOREACH_SAFE(p, &bdev->aliases, tailq, tmp) {
 		TAILQ_REMOVE(&bdev->aliases, p, tailq);
-		free(p->alias);
+		bdev_name_del(&p->alias);
 		free(p);
 	}
 }
@@ -5516,6 +5541,7 @@ static int
 bdev_register(struct spdk_bdev *bdev)
 {
 	char *bdev_name;
+	int ret;
 
 	assert(bdev->module != NULL);
 
@@ -5548,6 +5574,12 @@ bdev_register(struct spdk_bdev *bdev)
 	bdev->internal.qd_poller = NULL;
 	bdev->internal.qos = NULL;
 
+	ret = bdev_name_add(&bdev->internal.bdev_name, bdev, bdev->name);
+	if (ret != 0) {
+		free(bdev_name);
+		return ret;
+	}
+
 	/* If the user didn't specify a uuid, generate one. */
 	if (spdk_mem_all_zero(&bdev->uuid, sizeof(bdev->uuid))) {
 		spdk_uuid_generate(&bdev->uuid);
@@ -5707,6 +5739,7 @@ bdev_unregister_unsafe(struct spdk_bdev *bdev)
 	if (rc == 0) {
 		TAILQ_REMOVE(&g_bdev_mgr.bdevs, bdev, internal.link);
 		SPDK_DEBUGLOG(bdev, "Removing bdev %s from list done\n", bdev->name);
+		bdev_name_del(&bdev->internal.bdev_name);
 		spdk_notify_send("bdev_unregister", spdk_bdev_get_name(bdev));
 	}
 
diff --git a/lib/bdev/bdev_rpc.c b/lib/bdev/bdev_rpc.c
index 9055c77dd..40985b2a8 100644
--- a/lib/bdev/bdev_rpc.c
+++ b/lib/bdev/bdev_rpc.c
@@ -363,7 +363,7 @@ rpc_dump_bdev_info(struct spdk_json_write_ctx *w,
 	spdk_json_write_named_array_begin(w, "aliases");
 
 	TAILQ_FOREACH(tmp, spdk_bdev_get_aliases(bdev), tailq) {
-		spdk_json_write_string(w, tmp->alias);
+		spdk_json_write_string(w, tmp->alias.name);
 	}
 
 	spdk_json_write_array_end(w);
diff --git a/module/bdev/compress/vbdev_compress.c b/module/bdev/compress/vbdev_compress.c
index 708e67b9b..929af824e 100644
--- a/module/bdev/compress/vbdev_compress.c
+++ b/module/bdev/compress/vbdev_compress.c
@@ -1591,7 +1591,7 @@ static int _set_compbdev_name(struct vbdev_compress *comp_bdev)
 
 	if (!TAILQ_EMPTY(spdk_bdev_get_aliases(comp_bdev->base_bdev))) {
 		aliases = TAILQ_FIRST(spdk_bdev_get_aliases(comp_bdev->base_bdev));
-		comp_bdev->comp_bdev.name = spdk_sprintf_alloc("COMP_%s", aliases->alias);
+		comp_bdev->comp_bdev.name = spdk_sprintf_alloc("COMP_%s", aliases->alias.name);
 		if (!comp_bdev->comp_bdev.name) {
 			SPDK_ERRLOG("could not allocate comp_bdev name for alias\n");
 			return -ENOMEM;
diff --git a/module/bdev/lvol/vbdev_lvol.c b/module/bdev/lvol/vbdev_lvol.c
index 58e035a72..6f2c0c976 100644
--- a/module/bdev/lvol/vbdev_lvol.c
+++ b/module/bdev/lvol/vbdev_lvol.c
@@ -92,13 +92,13 @@ _vbdev_lvol_change_bdev_alias(struct spdk_lvol *lvol, const char *new_lvol_name)
 	 * while we changed lvs name earlier, we have to iterate alias list to get one,
 	 * and check if there is only one alias */
 
-	TAILQ_FOREACH(tmp, &lvol->bdev->aliases, tailq) {
+	TAILQ_FOREACH(tmp, spdk_bdev_get_aliases(lvol->bdev), tailq) {
 		if (++alias_number > 1) {
 			SPDK_ERRLOG("There is more than 1 alias in bdev %s\n", lvol->bdev->name);
 			return -EINVAL;
 		}
 
-		old_alias = tmp->alias;
+		old_alias = tmp->alias.name;
 	}
 
 	if (alias_number == 0) {
diff --git a/test/unit/lib/bdev/bdev.c/bdev_ut.c b/test/unit/lib/bdev/bdev.c/bdev_ut.c
index 16656dae6..54c555f7b 100644
--- a/test/unit/lib/bdev/bdev.c/bdev_ut.c
+++ b/test/unit/lib/bdev/bdev.c/bdev_ut.c
@@ -4399,6 +4399,72 @@ bdev_set_options_test(void)
 	CU_ASSERT(rc == 0);
 }
 
+static uint64_t
+get_ns_time(void)
+{
+	int rc;
+	struct timespec ts;
+
+	rc = clock_gettime(CLOCK_MONOTONIC, &ts);
+	CU_ASSERT(rc == 0);
+	return ts.tv_sec * 1000 * 1000 * 1000 + ts.tv_nsec;
+}
+
+static int
+rb_tree_get_height(struct spdk_bdev_name *bdev_name)
+{
+	int h1, h2;
+
+	if (bdev_name == NULL) {
+		return -1;
+	} else {
+		h1 = rb_tree_get_height(RB_LEFT(bdev_name, node));
+		h2 = rb_tree_get_height(RB_RIGHT(bdev_name, node));
+
+		return spdk_max(h1, h2) + 1;
+	}
+}
+
+static void
+bdev_multi_allocation(void)
+{
+	const int max_bdev_num = 1024 * 16;
+	char name[max_bdev_num][10];
+	char noexist_name[] = "invalid_bdev";
+	struct spdk_bdev *bdev[max_bdev_num];
+	int i, j;
+	uint64_t last_time;
+	int bdev_num;
+	int height;
+
+	for (j = 0; j < max_bdev_num; j++) {
+		snprintf(name[j], sizeof(name[j]), "bdev%d", j);
+	}
+
+	for (i = 0; i < 16; i++) {
+		last_time = get_ns_time();
+		bdev_num = 1024 * (i + 1);
+		for (j = 0; j < bdev_num; j++) {
+			bdev[j] = allocate_bdev(name[j]);
+			height = rb_tree_get_height(&bdev[j]->internal.bdev_name);
+			CU_ASSERT(height <= (int)(spdk_u32log2(j + 1)));
+		}
+		SPDK_NOTICELOG("alloc bdev num %d takes %lu ms\n", bdev_num,
+			       (get_ns_time() - last_time) / 1000 / 1000);
+		for (j = 0; j < bdev_num; j++) {
+			CU_ASSERT(spdk_bdev_get_by_name(name[j]) != NULL);
+		}
+		CU_ASSERT(spdk_bdev_get_by_name(noexist_name) == NULL);
+
+		for (j = 0; j < bdev_num; j++) {
+			free_bdev(bdev[j]);
+		}
+		for (j = 0; j < bdev_num; j++) {
+			CU_ASSERT(spdk_bdev_get_by_name(name[j]) == NULL);
+		}
+	}
+}
+
 int
 main(int argc, char **argv)
 {
@@ -4440,6 +4506,7 @@ main(int argc, char **argv)
 	CU_ADD_TEST(suite, bdev_io_abort);
 	CU_ADD_TEST(suite, bdev_unmap);
 	CU_ADD_TEST(suite, bdev_set_options_test);
+	CU_ADD_TEST(suite, bdev_multi_allocation);
 
 	allocate_cores(1);
 	allocate_threads(1);
diff --git a/test/unit/lib/bdev/vbdev_lvol.c/vbdev_lvol_ut.c b/test/unit/lib/bdev/vbdev_lvol.c/vbdev_lvol_ut.c
index c66234736..80bb2403f 100644
--- a/test/unit/lib/bdev/vbdev_lvol.c/vbdev_lvol_ut.c
+++ b/test/unit/lib/bdev/vbdev_lvol.c/vbdev_lvol_ut.c
@@ -61,6 +61,12 @@ bool g_examine_done = false;
 bool g_bdev_alias_already_exists = false;
 bool g_lvs_with_name_already_exists = false;
 
+const struct spdk_bdev_aliases_list *
+spdk_bdev_get_aliases(const struct spdk_bdev *bdev)
+{
+	return &bdev->aliases;
+}
+
 int
 spdk_bdev_alias_add(struct spdk_bdev *bdev, const char *alias)
 {
@@ -75,8 +81,8 @@ spdk_bdev_alias_add(struct spdk_bdev *bdev, const char *alias)
 	tmp = calloc(1, sizeof(*tmp));
 	SPDK_CU_ASSERT_FATAL(tmp != NULL);
 
-	tmp->alias = strdup(alias);
-	SPDK_CU_ASSERT_FATAL(tmp->alias != NULL);
+	tmp->alias.name = strdup(alias);
+	SPDK_CU_ASSERT_FATAL(tmp->alias.name != NULL);
 
 	TAILQ_INSERT_TAIL(&bdev->aliases, tmp, tailq);
 
@@ -92,9 +98,9 @@ spdk_bdev_alias_del(struct spdk_bdev *bdev, const char *alias)
 
 	TAILQ_FOREACH(tmp, &bdev->aliases, tailq) {
 		SPDK_CU_ASSERT_FATAL(alias != NULL);
-		if (strncmp(alias, tmp->alias, SPDK_LVOL_NAME_MAX) == 0) {
+		if (strncmp(alias, tmp->alias.name, SPDK_LVOL_NAME_MAX) == 0) {
 			TAILQ_REMOVE(&bdev->aliases, tmp, tailq);
-			free(tmp->alias);
+			free(tmp->alias.name);
 			free(tmp);
 			return 0;
 		}
@@ -110,7 +116,7 @@ spdk_bdev_alias_del_all(struct spdk_bdev *bdev)
 
 	TAILQ_FOREACH_SAFE(p, &bdev->aliases, tailq, tmp) {
 		TAILQ_REMOVE(&bdev->aliases, p, tailq);
-		free(p->alias);
+		free(p->alias.name);
 		free(p);
 	}
 }
@@ -1393,7 +1399,7 @@ ut_lvs_rename(void)
 	vbdev_lvs_rename(lvs, "new_lvs_name", lvol_store_op_complete, NULL);
 	CU_ASSERT(g_lvserrno == 0);
 	CU_ASSERT_STRING_EQUAL(lvs->name, "new_lvs_name");
-	CU_ASSERT_STRING_EQUAL(TAILQ_FIRST(&g_lvol->bdev->aliases)->alias, "new_lvs_name/lvol");
+	CU_ASSERT_STRING_EQUAL(TAILQ_FIRST(&g_lvol->bdev->aliases)->alias.name, "new_lvs_name/lvol");
 
 	/* Trying to rename lvs with name already used by another lvs */
 	/* This is a bdev_lvol test, so g_lvs_with_name_already_exists simulates
@@ -1402,7 +1408,7 @@ ut_lvs_rename(void)
 	vbdev_lvs_rename(lvs, "another_new_lvs_name", lvol_store_op_complete, NULL);
 	CU_ASSERT(g_lvserrno == -EEXIST);
 	CU_ASSERT_STRING_EQUAL(lvs->name, "new_lvs_name");
-	CU_ASSERT_STRING_EQUAL(TAILQ_FIRST(&g_lvol->bdev->aliases)->alias, "new_lvs_name/lvol");
+	CU_ASSERT_STRING_EQUAL(TAILQ_FIRST(&g_lvol->bdev->aliases)->alias.name, "new_lvs_name/lvol");
 	g_lvs_with_name_already_exists = false;
 
 	/* Unload lvol store */
-- 
2.26.2


From 8c2738a8fe4ab9b91f9b417054c9e2498fa8184b Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 17 May 2021 06:47:51 +0900
Subject: [PATCH 253/342] bdev/nvme: Add UUID and EUI64 comparison to check if
 two namespaces are identical

Following Linux NVMe host, add UUID and EUI64 comparison to
bdev_nvme_compare_ns().

Besides, previously the return value of memcmp() had been used as
the return value of bdev_nvme_compare_ns() and this was wrong.
Fix it in this patch together.

Add unit test cases for bdev_nvme_compare_ns().

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I069ab53e77741d6348b847d51e84a9338e2f3787
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7755
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/nvme/bdev_nvme.c                  |  9 ++-
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  | 61 ++++++++++++++++++-
 2 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 544209a28..650d88a3d 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -1422,11 +1422,16 @@ static bool
 bdev_nvme_compare_ns(struct spdk_nvme_ns *ns1, struct spdk_nvme_ns *ns2)
 {
 	const struct spdk_nvme_ns_data *nsdata1, *nsdata2;
+	const struct spdk_uuid *uuid1, *uuid2;
 
 	nsdata1 = spdk_nvme_ns_get_data(ns1);
 	nsdata2 = spdk_nvme_ns_get_data(ns2);
+	uuid1 = spdk_nvme_ns_get_uuid(ns1);
+	uuid2 = spdk_nvme_ns_get_uuid(ns2);
 
-	return memcmp(nsdata1->nguid, nsdata2->nguid, sizeof(nsdata1->nguid));
+	return memcmp(nsdata1->nguid, nsdata2->nguid, sizeof(nsdata1->nguid)) == 0 &&
+	       nsdata1->eui64 == nsdata2->eui64 &&
+	       uuid1 != NULL && uuid2 != NULL && spdk_uuid_compare(uuid1, uuid2) == 0;
 }
 
 static void
@@ -2168,7 +2173,7 @@ bdev_nvme_compare_namespaces(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 		new_ns = spdk_nvme_ctrlr_get_ns(new_ctrlr, nsid);
 		assert(new_ns != NULL);
 
-		if (bdev_nvme_compare_ns(nvme_ns->ns, new_ns) != 0) {
+		if (!bdev_nvme_compare_ns(nvme_ns->ns, new_ns)) {
 			return -EINVAL;
 		}
 	}
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index edf55299c..c9f082c15 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -127,9 +127,6 @@ DEFINE_STUB(spdk_nvme_ns_get_dealloc_logical_block_read_value,
 
 DEFINE_STUB(spdk_nvme_ns_get_optimal_io_boundary, uint32_t, (struct spdk_nvme_ns *ns), 0);
 
-DEFINE_STUB(spdk_nvme_ns_get_uuid, const struct spdk_uuid *,
-	    (const struct spdk_nvme_ns *ns), NULL);
-
 DEFINE_STUB(spdk_nvme_ns_get_csi, enum spdk_nvme_csi,
 	    (const struct spdk_nvme_ns *ns), 0);
 
@@ -231,6 +228,7 @@ struct spdk_nvme_ns {
 	struct spdk_nvme_ctrlr		*ctrlr;
 	uint32_t			id;
 	bool				is_active;
+	struct spdk_uuid		uuid;
 };
 
 struct spdk_nvme_qpair {
@@ -742,6 +740,13 @@ spdk_nvme_ns_get_num_sectors(struct spdk_nvme_ns *ns)
 {
 	return _nvme_ns_get_data(ns)->nsze;
 }
+
+const struct spdk_uuid *
+spdk_nvme_ns_get_uuid(const struct spdk_nvme_ns *ns)
+{
+	return &ns->uuid;
+}
+
 int
 spdk_nvme_ns_cmd_read_with_md(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *buffer,
 			      void *metadata, uint64_t lba, uint32_t lba_count,
@@ -2251,6 +2256,55 @@ test_bdev_unregister(void)
 	CU_ASSERT(nvme_bdev_ctrlr_get_by_name("nvme0") == NULL);
 }
 
+static void
+test_compare_ns(void)
+{
+	struct spdk_nvme_ns_data nsdata1 = {}, nsdata2 = {};
+	struct spdk_nvme_ctrlr ctrlr1 = { .nsdata = &nsdata1, }, ctrlr2 = { .nsdata = &nsdata2, };
+	struct spdk_nvme_ns ns1 = { .id = 1, .ctrlr = &ctrlr1, }, ns2 = { .id = 1, .ctrlr = &ctrlr2, };
+
+	/* No IDs are defined. */
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == true);
+
+	/* Only EUI64 are defined and not matched. */
+	nsdata1.eui64 = 0xABCDEF0123456789;
+	nsdata2.eui64 = 0xBBCDEF0123456789;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == false);
+
+	/* Only EUI64 are defined and matched. */
+	nsdata2.eui64 = 0xABCDEF0123456789;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == true);
+
+	/* Only NGUID are defined and not matched. */
+	nsdata1.eui64 = 0x0;
+	nsdata2.eui64 = 0x0;
+	nsdata1.nguid[0] = 0x12;
+	nsdata2.nguid[0] = 0x10;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == false);
+
+	/* Only NGUID are defined and matched. */
+	nsdata2.nguid[0] = 0x12;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == true);
+
+	/* Only UUID are defined and not matched. */
+	nsdata1.nguid[0] = 0x0;
+	nsdata2.nguid[0] = 0x0;
+	ns1.uuid.u.raw[0] = 0xAA;
+	ns2.uuid.u.raw[0] = 0xAB;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == false);
+
+	/* Only UUID are defined and matched. */
+	ns1.uuid.u.raw[0] = 0xAB;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == true);
+
+	/* All EUI64, NGUID, and UUID are defined and matched. */
+	nsdata1.eui64 = 0x123456789ABCDEF;
+	nsdata2.eui64 = 0x123456789ABCDEF;
+	nsdata1.nguid[15] = 0x34;
+	nsdata2.nguid[15] = 0x34;
+	CU_ASSERT(bdev_nvme_compare_ns(&ns1, &ns2) == true);
+}
+
 static void
 init_accel(void)
 {
@@ -2288,6 +2342,7 @@ main(int argc, const char **argv)
 	CU_ADD_TEST(suite, test_abort);
 	CU_ADD_TEST(suite, test_get_io_qpair);
 	CU_ADD_TEST(suite, test_bdev_unregister);
+	CU_ADD_TEST(suite, test_compare_ns);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 
-- 
2.26.2


From 924bfd067e4ed4873ce72bfc27672367a9e982a7 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Tue, 20 Apr 2021 23:42:50 +0900
Subject: [PATCH 254/342] bdev/nvme: Add ANA state per namespace into JSON info
 dump

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Idc0e783a2a4373a4269276aab8b1d857ed73caae
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7509
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Monica Kenguva <monica.kenguva@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/nvme/bdev_nvme.c                  | 24 +++++++++++++++++++
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  |  3 +++
 2 files changed, 27 insertions(+)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 650d88a3d..ef6b3415e 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -1151,6 +1151,25 @@ bdev_nvme_get_module_ctx(void *ctx)
 	return bdev_nvme_get_ctrlr(&nvme_bdev->disk);
 }
 
+static const char *
+_nvme_ana_state_str(enum spdk_nvme_ana_state ana_state)
+{
+	switch (ana_state) {
+	case SPDK_NVME_ANA_OPTIMIZED_STATE:
+		return "optimized";
+	case SPDK_NVME_ANA_NON_OPTIMIZED_STATE:
+		return "non_optimized";
+	case SPDK_NVME_ANA_INACCESSIBLE_STATE:
+		return "inaccessible";
+	case SPDK_NVME_ANA_PERSISTENT_LOSS_STATE:
+		return "persistent_loss";
+	case SPDK_NVME_ANA_CHANGE_STATE:
+		return "change";
+	default:
+		return NULL;
+	}
+}
+
 static int
 bdev_nvme_dump_info_json(void *ctx, struct spdk_json_write_ctx *w)
 {
@@ -1250,6 +1269,11 @@ bdev_nvme_dump_info_json(void *ctx, struct spdk_json_write_ctx *w)
 
 	spdk_json_write_named_uint32(w, "id", spdk_nvme_ns_get_id(ns));
 
+	if (cdata->cmic.ana_reporting) {
+		spdk_json_write_named_string(w, "ana_state",
+					     _nvme_ana_state_str(spdk_nvme_ns_get_ana_state(ns)));
+	}
+
 	spdk_json_write_object_end(w);
 
 	if (cdata->oacs.security) {
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index c9f082c15..271ad4bcf 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -127,6 +127,9 @@ DEFINE_STUB(spdk_nvme_ns_get_dealloc_logical_block_read_value,
 
 DEFINE_STUB(spdk_nvme_ns_get_optimal_io_boundary, uint32_t, (struct spdk_nvme_ns *ns), 0);
 
+DEFINE_STUB(spdk_nvme_ns_get_ana_state, enum spdk_nvme_ana_state,
+	    (const struct spdk_nvme_ns *ns), 0);
+
 DEFINE_STUB(spdk_nvme_ns_get_csi, enum spdk_nvme_csi,
 	    (const struct spdk_nvme_ns *ns), 0);
 
-- 
2.26.2


From 940f06490c4ba6a6ac30026220c16588145184f0 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@nutanix.com>
Date: Mon, 24 May 2021 16:15:46 +0000
Subject: [PATCH 255/342] vfio-user: update for libvfio-user region offset API
 change

Now, vfu_setup_region() must specify the region fd offset (which is always zero
in our case).

Signed-off-by: John Levon <john.levon@nutanix.com>
Change-Id: I10795d848a4c73ee9e1e78ea63776074401c4b17
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8022
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvmf/vfio_user.c | 10 +++++-----
 libvfio-user         |  2 +-
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index dde650924..e0a9aeaba 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -1528,7 +1528,7 @@ vfio_user_dev_info_fill(struct nvmf_vfio_user_transport *vu_transport,
 	}
 
 	ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_CFG_REGION_IDX, NVME_REG_CFG_SIZE,
-			       access_pci_config, VFU_REGION_FLAG_RW, NULL, 0, -1);
+			       access_pci_config, VFU_REGION_FLAG_RW, NULL, 0, -1, 0);
 	if (ret < 0) {
 		SPDK_ERRLOG("vfu_ctx %p failed to setup cfg\n", vfu_ctx);
 		return ret;
@@ -1537,11 +1537,11 @@ vfio_user_dev_info_fill(struct nvmf_vfio_user_transport *vu_transport,
 	if (vu_transport->transport_opts.disable_mappable_bar0) {
 		ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR0_REGION_IDX, NVME_REG_BAR0_SIZE,
 				       access_bar0_fn, VFU_REGION_FLAG_RW | VFU_REGION_FLAG_MEM,
-				       NULL, 0, -1);
+				       NULL, 0, -1, 0);
 	} else {
 		ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR0_REGION_IDX, NVME_REG_BAR0_SIZE,
 				       access_bar0_fn, VFU_REGION_FLAG_RW | VFU_REGION_FLAG_MEM,
-				       sparse_mmap, 1, endpoint->fd);
+				       sparse_mmap, 1, endpoint->fd, 0);
 	}
 
 	if (ret < 0) {
@@ -1550,14 +1550,14 @@ vfio_user_dev_info_fill(struct nvmf_vfio_user_transport *vu_transport,
 	}
 
 	ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR4_REGION_IDX, PAGE_SIZE,
-			       NULL, VFU_REGION_FLAG_RW, NULL, 0, -1);
+			       NULL, VFU_REGION_FLAG_RW, NULL, 0, -1, 0);
 	if (ret < 0) {
 		SPDK_ERRLOG("vfu_ctx %p failed to setup bar 4\n", vfu_ctx);
 		return ret;
 	}
 
 	ret = vfu_setup_region(vfu_ctx, VFU_PCI_DEV_BAR5_REGION_IDX, PAGE_SIZE,
-			       NULL, VFU_REGION_FLAG_RW, NULL, 0, -1);
+			       NULL, VFU_REGION_FLAG_RW, NULL, 0, -1, 0);
 	if (ret < 0) {
 		SPDK_ERRLOG("vfu_ctx %p failed to setup bar 5\n", vfu_ctx);
 		return ret;
diff --git a/libvfio-user b/libvfio-user
index cfe990191..7443fbedd 160000
--- a/libvfio-user
+++ b/libvfio-user
@@ -1 +1 @@
-Subproject commit cfe9901919943f14961e1da1c4a823336ff79555
+Subproject commit 7443fbedd1f94288fbe0d3563b72c4938aa9ff2f
-- 
2.26.2


From c1a41845cfd3c885a6ea9243cc23ccfb0cd37e60 Mon Sep 17 00:00:00 2001
From: sunshihao520 <sunshihao@huawei.com>
Date: Thu, 13 May 2021 20:57:07 +0800
Subject: [PATCH 256/342] lib/bdev: Change spdk_bdev_read_blocks_with_md arg
 offset definiton from int64_t to uint64_t.

Signed-off-by: sunshihao520 <sunshihao@huawei.com>
Change-Id: I25c3ae4f12d0ab4e2f3811e36028a04a1f32d862
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7869
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 CHANGELOG.md        | 3 +++
 include/spdk/bdev.h | 2 +-
 lib/bdev/bdev.c     | 4 ++--
 3 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9b1f9310a..1d2cdf84c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,9 @@
 
 ## v21.07: (Upcoming Release)
 
+### bdev
+Change `spdk_bdev_read_blocks_with_md` arg offset definiton from int64_t to uint64_t.
+
 ### dpdk
 
 Updated DPDK submodule to DPDK 21.02.
diff --git a/include/spdk/bdev.h b/include/spdk/bdev.h
index 19b265735..36cdb02a3 100644
--- a/include/spdk/bdev.h
+++ b/include/spdk/bdev.h
@@ -803,7 +803,7 @@ int spdk_bdev_read_blocks(struct spdk_bdev_desc *desc, struct spdk_io_channel *c
  *   * -ENOMEM - spdk_bdev_io buffer cannot be allocated
  */
 int spdk_bdev_read_blocks_with_md(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
-				  void *buf, void *md, int64_t offset_blocks, uint64_t num_blocks,
+				  void *buf, void *md, uint64_t offset_blocks, uint64_t num_blocks,
 				  spdk_bdev_io_completion_cb cb, void *cb_arg);
 
 /**
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 42d82c681..3c82cef97 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -3658,7 +3658,7 @@ _bdev_io_check_md_buf(const struct iovec *iovs, const void *md_buf)
 
 static int
 bdev_read_blocks_with_md(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf,
-			 void *md_buf, int64_t offset_blocks, uint64_t num_blocks,
+			 void *md_buf, uint64_t offset_blocks, uint64_t num_blocks,
 			 spdk_bdev_io_completion_cb cb, void *cb_arg)
 {
 	struct spdk_bdev *bdev = spdk_bdev_desc_get_bdev(desc);
@@ -3715,7 +3715,7 @@ spdk_bdev_read_blocks(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
 
 int
 spdk_bdev_read_blocks_with_md(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
-			      void *buf, void *md_buf, int64_t offset_blocks, uint64_t num_blocks,
+			      void *buf, void *md_buf, uint64_t offset_blocks, uint64_t num_blocks,
 			      spdk_bdev_io_completion_cb cb, void *cb_arg)
 {
 	struct iovec iov = {
-- 
2.26.2


From 43aca60458b48c1e80ec99154b7381b8b06ed9ee Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Tue, 25 May 2021 11:24:48 +0200
Subject: [PATCH 257/342] scripts/fio-wrapper: Move devices sync to
 configure_devices()

This is to make sure we sync devices for both nvmf and iscsi
protocols.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Ifec6cc2d240a5b22b73e9f4087ae328568e4fe4a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8042
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
---
 scripts/fio-wrapper | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/scripts/fio-wrapper b/scripts/fio-wrapper
index 7eaafdb59..8c93f31ba 100755
--- a/scripts/fio-wrapper
+++ b/scripts/fio-wrapper
@@ -60,9 +60,6 @@ get_nvme() {
 		done
 	done
 	blocks=("${blocks[@]##*/}")
-	if [[ -e $rootdir/scripts/sync_dev_uevents.sh ]]; then
-		"$rootdir/scripts/sync_dev_uevents.sh" block/disk "${blocks[@]}"
-	fi > /dev/null
 	printf '%s\n' "${blocks[@]}"
 }
 
@@ -82,6 +79,10 @@ get_devices() {
 configure_devices() {
 	local devs=("$@") dev qd
 
+	if [[ -e $rootdir/scripts/sync_dev_uevents.sh ]]; then
+		"$rootdir/scripts/sync_dev_uevents.sh" block/disk "${devs[@]}"
+	fi > /dev/null
+
 	for dev in "${devs[@]}"; do
 		qd=128
 		# Disable all merge tries"
-- 
2.26.2


From 75a507736b23d54ab834d64ca4320ff3e4fe844b Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Sat, 22 May 2021 00:18:58 +0800
Subject: [PATCH 258/342] vhost-blk: use device name for VIRTIO_BLK_T_GET_ID

Block device product name is same among same type
of the block devices, while Guest VM may use this
value to generate UUID, so here we change it to
block device name instead.

Change-Id: I58c5fb271a6a436c15520616c2065eee9c37300a
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7996
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/vhost/vhost_blk.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/vhost/vhost_blk.c b/lib/vhost/vhost_blk.c
index 60eb8e0f3..031ca6b36 100644
--- a/lib/vhost/vhost_blk.c
+++ b/lib/vhost/vhost_blk.c
@@ -609,7 +609,7 @@ process_blk_request(struct spdk_vhost_blk_task *task,
 			return -1;
 		}
 		task->used_len = spdk_min((size_t)VIRTIO_BLK_ID_BYTES, task->iovs[1].iov_len);
-		spdk_strcpy_pad(task->iovs[1].iov_base, spdk_bdev_get_product_name(bvdev->bdev),
+		spdk_strcpy_pad(task->iovs[1].iov_base, spdk_bdev_get_name(bvdev->bdev),
 				task->used_len, ' ');
 		blk_request_finish(true, task);
 		break;
-- 
2.26.2


From 080118cd830d0a82e483f629ddcb23156548fb0b Mon Sep 17 00:00:00 2001
From: Rui Chang <rui.chang@arm.com>
Date: Thu, 20 May 2021 09:44:00 +0800
Subject: [PATCH 259/342] lib/nvmf: Add current qpair count to poll group
 statistic
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Instruct spdk_nvmf_poll_group_stat, there are statistics of cumulative IO and
admin queue pair counts. But current qpair counts are not reflected. Use
this patch to add current admin and io qpair counts for a poll group.

Signed-off-by: Rui Chang <rui.chang@arm.com>
Change-Id: I7d40aed8b3fb09f9d34e5b5232380d162b97882b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7969
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Eugene Kochetov <evgeniik@nvidia.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: GangCao <gang.cao@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 doc/jsonrpc.md      |  3 +++
 include/spdk/nvmf.h |  6 ++++++
 lib/nvmf/ctrlr.c    |  2 ++
 lib/nvmf/nvmf.c     | 12 ++++++++++++
 4 files changed, 23 insertions(+)

diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index 623997c3c..fc8909242 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -6770,6 +6770,7 @@ tgt_name                    | Optional | string      | Parent NVMe-oF target nam
 ### Response
 
 The response is an object containing NVMf subsystem statistics.
+In the response, `admin_qpairs` and `io_qpairs` are reflecting cumulative queue pair counts while `current_admin_qpairs` and `current_io_qpairs` are showing the current number.
 
 ### Example
 
@@ -6794,6 +6795,8 @@ Example response:
         "name": "app_thread",
         "admin_qpairs": 1,
         "io_qpairs": 4,
+        "current_admin_qpairs": 1,
+        "current_io_qpairs": 2,
         "pending_bdev_io": 1721,
         "transports": [
           {
diff --git a/include/spdk/nvmf.h b/include/spdk/nvmf.h
index cf8b52ad4..5a22b9426 100644
--- a/include/spdk/nvmf.h
+++ b/include/spdk/nvmf.h
@@ -120,8 +120,14 @@ struct spdk_nvmf_listen_opts {
 void spdk_nvmf_listen_opts_init(struct spdk_nvmf_listen_opts *opts, size_t opts_size);
 
 struct spdk_nvmf_poll_group_stat {
+	/* cumulative admin qpair count */
 	uint32_t admin_qpairs;
+	/* cumulative io qpair count */
 	uint32_t io_qpairs;
+	/* current admin qpair count */
+	uint32_t current_admin_qpairs;
+	/* current io qpair count */
+	uint32_t current_io_qpairs;
 	uint64_t pending_bdev_io;
 };
 
diff --git a/lib/nvmf/ctrlr.c b/lib/nvmf/ctrlr.c
index ff684ceec..a0b7a3306 100644
--- a/lib/nvmf/ctrlr.c
+++ b/lib/nvmf/ctrlr.c
@@ -711,8 +711,10 @@ _nvmf_ctrlr_connect(struct spdk_nvmf_request *req)
 
 	if (0 == qpair->qid) {
 		qpair->group->stat.admin_qpairs++;
+		qpair->group->stat.current_admin_qpairs++;
 	} else {
 		qpair->group->stat.io_qpairs++;
+		qpair->group->stat.current_io_qpairs++;
 	}
 
 	if (cmd->qid == 0) {
diff --git a/lib/nvmf/nvmf.c b/lib/nvmf/nvmf.c
index d1ebe2331..eb6ba3935 100644
--- a/lib/nvmf/nvmf.c
+++ b/lib/nvmf/nvmf.c
@@ -999,6 +999,16 @@ _nvmf_qpair_destroy(void *ctx, int status)
 	assert(qpair->state == SPDK_NVMF_QPAIR_DEACTIVATING);
 	qpair_ctx->qid = qpair->qid;
 
+	if (ctrlr) {
+		if (0 == qpair->qid) {
+			assert(qpair->group->stat.current_admin_qpairs > 0);
+			qpair->group->stat.current_admin_qpairs--;
+		} else {
+			assert(qpair->group->stat.current_io_qpairs > 0);
+			qpair->group->stat.current_io_qpairs--;
+		}
+	}
+
 	if (!ctrlr || !ctrlr->thread) {
 		spdk_nvmf_poll_group_remove(qpair);
 		nvmf_transport_qpair_fini(qpair, _nvmf_transport_qpair_fini_complete, qpair_ctx);
@@ -1607,6 +1617,8 @@ spdk_nvmf_poll_group_dump_stat(struct spdk_nvmf_poll_group *group, struct spdk_j
 	spdk_json_write_named_string(w, "name", spdk_thread_get_name(spdk_get_thread()));
 	spdk_json_write_named_uint32(w, "admin_qpairs", group->stat.admin_qpairs);
 	spdk_json_write_named_uint32(w, "io_qpairs", group->stat.io_qpairs);
+	spdk_json_write_named_uint32(w, "current_admin_qpairs", group->stat.current_admin_qpairs);
+	spdk_json_write_named_uint32(w, "current_io_qpairs", group->stat.current_io_qpairs);
 	spdk_json_write_named_uint64(w, "pending_bdev_io", group->stat.pending_bdev_io);
 
 	spdk_json_write_named_array_begin(w, "transports");
-- 
2.26.2


From 8a7f6e71b6c703c70c6de09bdd30b4e158d88b38 Mon Sep 17 00:00:00 2001
From: matthewb <matthew.burbridge@hpe.com>
Date: Tue, 20 Apr 2021 00:46:28 -0400
Subject: [PATCH 260/342] test/bdev/bdevperf : Added check for ZCOPY Support

If the -Z option has been specified bdevperf checks that the bdev
module supports ZCOPY.

Signed-off-by: matthewb <matthew.burbridge@hpe.com>
Change-Id: I0bebad68090f48a1b1250afe4bc4c752c2061bfb
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7352
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: John Kariuki <John.K.Kariuki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Michael Haeuptle <michaelhaeuptle@gmail.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 test/bdev/bdevperf/bdevperf.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/test/bdev/bdevperf/bdevperf.c b/test/bdev/bdevperf/bdevperf.c
index e7ee68b27..df50a11b6 100644
--- a/test/bdev/bdevperf/bdevperf.c
+++ b/test/bdev/bdevperf/bdevperf.c
@@ -1176,6 +1176,14 @@ _bdevperf_construct_job(void *ctx)
 		goto end;
 	}
 
+	if (g_zcopy) {
+		if (!spdk_bdev_io_type_supported(job->bdev, SPDK_BDEV_IO_TYPE_ZCOPY)) {
+			printf("Test requires ZCOPY but bdev module does not support ZCOPY\n");
+			g_run_rc = -ENOTSUP;
+			goto end;
+		}
+	}
+
 	job->ch = spdk_bdev_get_io_channel(job->bdev_desc);
 	if (!job->ch) {
 		SPDK_ERRLOG("Could not get io_channel for device %s, error=%d\n", spdk_bdev_get_name(job->bdev),
-- 
2.26.2


From cfff04aea2c96c74bf203f87b12fbb0456b8dfec Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Thu, 27 May 2021 02:54:37 -0400
Subject: [PATCH 261/342] nvme/cuse: add subsystem reset IOCTL support

Change-Id: Id85989d0ae1246cb60fff4a41e5847a2d84e271f
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8084
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 lib/nvme/nvme_cuse.c                          | 26 +++++++++++++++++--
 test/nvme/cuse/cuse.c                         |  2 ++
 test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c |  2 ++
 3 files changed, 28 insertions(+), 2 deletions(-)

diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index faeaf8faa..b28315f22 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -270,6 +270,21 @@ cuse_nvme_reset_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, void *arg)
 	fuse_reply_ioctl_iov(req, 0, NULL, 0);
 }
 
+static void
+cuse_nvme_subsys_reset_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, void *arg)
+{
+	int rc;
+	fuse_req_t req = arg;
+
+	rc = spdk_nvme_ctrlr_reset_subsystem(ctrlr);
+	if (rc) {
+		fuse_reply_err(req, rc);
+		return;
+	}
+
+	fuse_reply_ioctl_iov(req, 0, NULL, 0);
+}
+
 static void
 cuse_nvme_reset(fuse_req_t req, int cmd, void *arg,
 		struct fuse_file_info *fi, unsigned flags,
@@ -284,7 +299,14 @@ cuse_nvme_reset(fuse_req_t req, int cmd, void *arg,
 		return;
 	}
 
-	rv = nvme_io_msg_send(cuse_device->ctrlr, cuse_device->nsid, cuse_nvme_reset_execute, (void *)req);
+	if (cmd == NVME_IOCTL_SUBSYS_RESET) {
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_SUBSYS_RESET\n");
+		rv = nvme_io_msg_send(cuse_device->ctrlr, cuse_device->nsid, cuse_nvme_subsys_reset_execute,
+				      (void *)req);
+	} else {
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_RESET\n");
+		rv = nvme_io_msg_send(cuse_device->ctrlr, cuse_device->nsid, cuse_nvme_reset_execute, (void *)req);
+	}
 	if (rv) {
 		SPDK_ERRLOG("Cannot send reset\n");
 		fuse_reply_err(req, EINVAL);
@@ -589,7 +611,7 @@ cuse_ctrlr_ioctl(fuse_req_t req, int cmd, void *arg,
 		break;
 
 	case NVME_IOCTL_RESET:
-		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_RESET\n");
+	case NVME_IOCTL_SUBSYS_RESET:
 		cuse_nvme_reset(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
diff --git a/test/nvme/cuse/cuse.c b/test/nvme/cuse/cuse.c
index fe63a0940..f217b9907 100644
--- a/test/nvme/cuse/cuse.c
+++ b/test/nvme/cuse/cuse.c
@@ -64,6 +64,8 @@ spdk_nvme_ctrlr_is_active_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
 
 DEFINE_STUB(spdk_nvme_ctrlr_reset, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
 
+DEFINE_STUB(spdk_nvme_ctrlr_reset_subsystem, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
+
 DEFINE_STUB(spdk_nvme_ns_cmd_read, int, (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		void *payload,
 		uint64_t lba, uint32_t lba_count, spdk_nvme_cmd_cb cb_fn, void *cb_arg,
diff --git a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
index d1a10b767..5079b8799 100644
--- a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
+++ b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
@@ -51,6 +51,8 @@ DEFINE_STUB(spdk_nvme_ctrlr_cmd_io_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
 
 DEFINE_STUB(spdk_nvme_ctrlr_reset, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
 
+DEFINE_STUB(spdk_nvme_ctrlr_reset_subsystem, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
+
 DEFINE_STUB(spdk_nvme_ns_cmd_read, int,
 	    (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 	     void *payload, uint64_t lba, uint32_t lba_count,
-- 
2.26.2


From d172854aa767cf3effe62e58f63106105818a3cc Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Thu, 27 May 2021 23:30:34 +0800
Subject: [PATCH 262/342] configure: Fix the nasm version detection.

I used the nasm with unstable version while compiling SPDK with ISA-L.
And when running nasm -v, it shows:

NASM version 2.16rc0 compiled on May 27 2021

So the version checking in the script is not correct,
it will get "2.16rc0", but not "2.16".  Then the version comparison
will fail.

This patch will fix such issue when users use an unstable nasm and it
also works for the stable version.

Change-Id: I950458f681642d7e1f5fc69acf2ced2e1342c9cf
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8082
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 configure | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure b/configure
index a2d0c5a62..7438b91a6 100755
--- a/configure
+++ b/configure
@@ -166,7 +166,7 @@ fi
 
 #check nasm only on x86
 if [[ $arch == x86_64* ]]; then
-	ver=$(nasm -v 2> /dev/null | awk '{print $3}')
+	ver=$(nasm -v 2> /dev/null | awk '{print $3}' | awk -Fr '{print $1}')
 	if lt "$ver" 2.14; then
 		# ISA-L, compression & crypto require NASM version 2.14 or newer.
 		CONFIG[ISAL]=n
-- 
2.26.2


From a4bf3e1099a4c07b12218a8d3492ed25c1e6cc23 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 18 May 2021 05:20:38 -0400
Subject: [PATCH 263/342] scheduler_dynamic: exit early from _get_thread_load()

_get_thread_load() is function used to determine
the load of a thread based on relation of busy/idle tsc
from previous scheduling period.

In order to avoid division by 0 calculating the percentage,
we can simply exit early determining that thread was not
doing any work.

Having this check here will make sure that no matter
the changes in event framework, scheduler dynamic will work.

Removed the place that updated last_stats if they weren't
yet updated at least once (first scheduling period iteration).
In this case after change to _get_thread_load() will be the same,
as only the latest iteration will be used to calculate thread load.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I75f0f12f024675f2473a26e30596d6eb28093d46
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7917
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 lib/event/scheduler_dynamic.c | 15 ++++-----------
 1 file changed, 4 insertions(+), 11 deletions(-)

diff --git a/lib/event/scheduler_dynamic.c b/lib/event/scheduler_dynamic.c
index 03003a0ab..b864363d8 100644
--- a/lib/event/scheduler_dynamic.c
+++ b/lib/event/scheduler_dynamic.c
@@ -74,6 +74,10 @@ _get_thread_load(struct spdk_lw_thread *lw_thread)
 	lw_thread->last_stats.busy_tsc = lw_thread->snapshot_stats.busy_tsc;
 	lw_thread->last_stats.idle_tsc = lw_thread->snapshot_stats.idle_tsc;
 
+	if (busy == 0) {
+		/* No work was done, exit before possible division by 0. */
+		return 0;
+	}
 	/* return percentage of time thread was busy */
 	return busy  * 100 / (busy + idle);
 }
@@ -157,17 +161,6 @@ balance(struct spdk_scheduler_core_info *cores_info, int cores_count,
 			thread = spdk_thread_get_from_ctx(lw_thread);
 			cpumask = spdk_thread_get_cpumask(thread);
 
-			if (lw_thread->last_stats.busy_tsc + lw_thread->last_stats.idle_tsc == 0) {
-				lw_thread->last_stats.busy_tsc = lw_thread->snapshot_stats.busy_tsc;
-				lw_thread->last_stats.idle_tsc = lw_thread->snapshot_stats.idle_tsc;
-
-				if (i != g_main_lcore) {
-					busy_threads_present = true;
-				}
-
-				continue;
-			}
-
 			thread_busy = lw_thread->snapshot_stats.busy_tsc - lw_thread->last_stats.busy_tsc;
 
 			load = _get_thread_load(lw_thread);
-- 
2.26.2


From 0598e484d7b0e49626a36361da54ecbd493427b4 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 25 May 2021 04:12:59 -0400
Subject: [PATCH 264/342] lib/event: set thread for each event executed

Whenever an event executes, it might change the currently
set thread or reset it to NULL.
To prevent it from affecting other events, set the current
thread each time an event executes.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I6f1e7f8b7acab25353b4782058e87a9e01aab2c8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8045
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/event/reactor.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index b890f6e24..ddfd6d17b 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -605,17 +605,15 @@ event_queue_run_batch(struct spdk_reactor *reactor)
 		thread = NULL;
 	}
 
-	spdk_set_thread(thread);
-
 	for (i = 0; i < count; i++) {
 		struct spdk_event *event = events[i];
 
 		assert(event != NULL);
+		spdk_set_thread(thread);
 		event->fn(event->arg1, event->arg2);
+		spdk_set_thread(NULL);
 	}
 
-	spdk_set_thread(NULL);
-
 	spdk_mempool_put_bulk(g_spdk_event_mempool, events, count);
 
 	return count;
-- 
2.26.2


From e0d448e7f6e304245d7369d9420a42c0506158f7 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 11 May 2021 06:05:55 -0400
Subject: [PATCH 265/342] lib/event: remove snapshot_stats

spdk_thread keeps track of tsc from its whole lifetime,
those can be requested with spdk_thread_get_stats() at any time.

spdk_lw_thread uses stats from above and keeps track of two points in time:
- current_stats reflecting stats at the time of gather_metrics stage
- last_stats reflecting stats from previous gather_metrics stage

1)
Before this patch current_stats were duplicated in snapshot_stats.
There is no need for that so now they are removed.

2)
Removed _spdk_lw_thread_get_current_stats() since it would be copying
current_stats to current_stats, thus not perform any action.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I5e5d4039cd0f7cc10ba150a3d915b90ec96589d7
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7842
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 include/spdk_internal/event.h | 10 ----------
 lib/event/reactor.c           |  8 --------
 lib/event/scheduler_dynamic.c | 10 +++++-----
 3 files changed, 5 insertions(+), 23 deletions(-)

diff --git a/include/spdk_internal/event.h b/include/spdk_internal/event.h
index d900ed82d..e885a4c1a 100644
--- a/include/spdk_internal/event.h
+++ b/include/spdk_internal/event.h
@@ -67,7 +67,6 @@ struct spdk_lw_thread {
 	uint32_t                        new_lcore;
 	bool				resched;
 	struct spdk_thread_stats	current_stats;
-	struct spdk_thread_stats	snapshot_stats;
 	struct spdk_thread_stats	last_stats;
 };
 
@@ -355,15 +354,6 @@ static void __attribute__((constructor)) _spdk_scheduler_register_ ## scheduler
  */
 void _spdk_lw_thread_set_core(struct spdk_lw_thread *thread, uint32_t lcore);
 
-/**
- * Get threads stats
- *
- * \param thread thread that stats regards to.
- * \param stats Output parameter for accumulated TSC counts while the thread was busy.
- */
-void _spdk_lw_thread_get_current_stats(struct spdk_lw_thread *thread,
-				       struct spdk_thread_stats *stats);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index ddfd6d17b..2fc9a758e 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -818,7 +818,6 @@ _reactors_scheduler_gather_metrics(void *arg1, void *arg2)
 		i = 0;
 		TAILQ_FOREACH(lw_thread, &reactor->threads, link) {
 			core_info->threads[i] = lw_thread;
-			_spdk_lw_thread_get_current_stats(lw_thread, &lw_thread->snapshot_stats);
 			i++;
 		}
 	}
@@ -1481,13 +1480,6 @@ _spdk_lw_thread_set_core(struct spdk_lw_thread *thread, uint32_t lcore)
 	thread->resched = true;
 }
 
-void
-_spdk_lw_thread_get_current_stats(struct spdk_lw_thread *thread, struct spdk_thread_stats *stats)
-{
-	assert(thread != NULL);
-	*stats = thread->current_stats;
-}
-
 static int
 _governor_get_capabilities(uint32_t lcore_id, struct spdk_governor_capabilities *capabilities)
 {
diff --git a/lib/event/scheduler_dynamic.c b/lib/event/scheduler_dynamic.c
index b864363d8..ceaaa90dd 100644
--- a/lib/event/scheduler_dynamic.c
+++ b/lib/event/scheduler_dynamic.c
@@ -68,11 +68,11 @@ _get_thread_load(struct spdk_lw_thread *lw_thread)
 {
 	uint64_t busy, idle;
 
-	busy = lw_thread->snapshot_stats.busy_tsc - lw_thread->last_stats.busy_tsc;
-	idle = lw_thread->snapshot_stats.idle_tsc - lw_thread->last_stats.idle_tsc;
+	busy = lw_thread->current_stats.busy_tsc - lw_thread->last_stats.busy_tsc;
+	idle = lw_thread->current_stats.idle_tsc - lw_thread->last_stats.idle_tsc;
 
-	lw_thread->last_stats.busy_tsc = lw_thread->snapshot_stats.busy_tsc;
-	lw_thread->last_stats.idle_tsc = lw_thread->snapshot_stats.idle_tsc;
+	lw_thread->last_stats.busy_tsc = lw_thread->current_stats.busy_tsc;
+	lw_thread->last_stats.idle_tsc = lw_thread->current_stats.idle_tsc;
 
 	if (busy == 0) {
 		/* No work was done, exit before possible division by 0. */
@@ -161,7 +161,7 @@ balance(struct spdk_scheduler_core_info *cores_info, int cores_count,
 			thread = spdk_thread_get_from_ctx(lw_thread);
 			cpumask = spdk_thread_get_cpumask(thread);
 
-			thread_busy = lw_thread->snapshot_stats.busy_tsc - lw_thread->last_stats.busy_tsc;
+			thread_busy = lw_thread->current_stats.busy_tsc - lw_thread->last_stats.busy_tsc;
 
 			load = _get_thread_load(lw_thread);
 
-- 
2.26.2


From 3db73426f2338fc8763319dea910afbb2d502b03 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Tue, 18 May 2021 06:19:40 -0400
Subject: [PATCH 266/342] lib/event: update current_stats at the time of thread
 reschedule

_reactor_schedule_thread() zeroes out the lw_thread on move.

To properly calculate thread stats since the move,
save them right after reschedule.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I44cc3b5907adda35b3117c2dd7268dc813d59853
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7919
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/event/reactor.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index 2fc9a758e..f1d66d1e0 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -1131,6 +1131,7 @@ static void
 _schedule_thread(void *arg1, void *arg2)
 {
 	struct spdk_lw_thread *lw_thread = arg1;
+	struct spdk_thread *thread;
 	struct spdk_reactor *reactor;
 	uint32_t current_core;
 	int efd;
@@ -1139,15 +1140,20 @@ _schedule_thread(void *arg1, void *arg2)
 	reactor = spdk_reactor_get(current_core);
 	assert(reactor != NULL);
 
+	/* Update current_stats to reflect state of thread
+	* at the end of the move. */
+	thread = spdk_thread_get_from_ctx(lw_thread);
+	spdk_set_thread(thread);
+	spdk_thread_get_stats(&lw_thread->current_stats);
+	spdk_set_thread(NULL);
+
 	TAILQ_INSERT_TAIL(&reactor->threads, lw_thread, link);
 	reactor->thread_count++;
 
 	/* Operate thread intr if running with full interrupt ability */
 	if (spdk_interrupt_mode_is_enabled()) {
 		int rc;
-		struct spdk_thread *thread;
 
-		thread = spdk_thread_get_from_ctx(lw_thread);
 		efd = spdk_thread_get_interrupt_fd(thread);
 		rc = spdk_fd_group_add(reactor->fgrp, efd, thread_process_interrupts, thread);
 		if (rc < 0) {
-- 
2.26.2


From a12cf26cdd12bd1c9ff4dec8b2f304e1ba3740d3 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 26 May 2021 21:23:17 +0000
Subject: [PATCH 267/342] nvme: add NVME_CTRLR_STATE_CHECK_EN

We're going to be adding some new states (READ_CAP
and READ_VS) in future patches, that we want to
come before the current "INIT" state.

So we will simply make "INIT" have the same
value as this new NVME_CTRLR_STATE_CHECK_EN state
for now.  That means existing code won't have to
change later once we add new states that come
before CHECK_EN.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I07ca92e28ab1cd8d838cdef5c3ff36ba80a224bf
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8075
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/nvme/nvme_ctrlr.c    | 6 +++---
 lib/nvme/nvme_internal.h | 9 +++++++--
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 7d319bc24..e9a799fa8 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -1134,8 +1134,8 @@ nvme_ctrlr_state_string(enum nvme_ctrlr_state state)
 	switch (state) {
 	case NVME_CTRLR_STATE_INIT_DELAY:
 		return "delay init";
-	case NVME_CTRLR_STATE_INIT:
-		return "init";
+	case NVME_CTRLR_STATE_CHECK_EN:
+		return "check en";
 	case NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_1:
 		return "disable and wait for CSTS.RDY = 1";
 	case NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0:
@@ -3124,7 +3124,7 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 		}
 		break;
 
-	case NVME_CTRLR_STATE_INIT:
+	case NVME_CTRLR_STATE_CHECK_EN: /* synonymous with NVME_CTRLR_STATE_INIT */
 		/* Begin the hardware initialization by making sure the controller is disabled. */
 		if (cc.bits.en) {
 			NVME_CTRLR_DEBUGLOG(ctrlr, "CC.EN = 1\n");
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index 495ff9424..e3b4ed8db 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -518,9 +518,14 @@ enum nvme_ctrlr_state {
 	NVME_CTRLR_STATE_INIT_DELAY,
 
 	/**
-	 * Controller has not been initialized yet.
+	 * Check EN to prepare for controller initialization.
 	 */
-	NVME_CTRLR_STATE_INIT,
+	NVME_CTRLR_STATE_CHECK_EN,
+
+	/**
+	 * Controller has not started initialized yet.
+	 */
+	NVME_CTRLR_STATE_INIT = NVME_CTRLR_STATE_CHECK_EN,
 
 	/**
 	 * Waiting for CSTS.RDY to transition from 0 to 1 so that CC.EN may be set to 0.
-- 
2.26.2


From df01076f70f6f61255e4151ab32216d10bc48e88 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 26 May 2021 21:05:17 +0000
Subject: [PATCH 268/342] nvme: add NVME_CTRLR_STATE_READ_VS

Read VS (Version) register as part of controller
initialization instead of controller construction.

This prepares for upcoming changes to make
controller attach fully asynchronous.  Since reading
fabrics registers is an asynchronous operation, it
will be easier to read the VS register as part of
controller initialization which operates as an
asynchronous state machine.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I771386dbdf5902633e0d9f91b3b20be98f26fdc3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8076
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/nvme/nvme_ctrlr.c                         | 13 ++--
 lib/nvme/nvme_internal.h                      | 14 ++--
 lib/nvme/nvme_pcie.c                          | 10 +--
 lib/nvme/nvme_rdma.c                          |  8 +--
 lib/nvme/nvme_tcp.c                           |  9 +--
 lib/nvme/nvme_vfio_user.c                     |  8 +--
 test/common/lib/nvme/common_stubs.h           |  3 +-
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 70 +++++++++++++++++--
 8 files changed, 89 insertions(+), 46 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index e9a799fa8..20653d6c5 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -1134,6 +1134,8 @@ nvme_ctrlr_state_string(enum nvme_ctrlr_state state)
 	switch (state) {
 	case NVME_CTRLR_STATE_INIT_DELAY:
 		return "delay init";
+	case NVME_CTRLR_STATE_READ_VS:
+		return "read vs";
 	case NVME_CTRLR_STATE_CHECK_EN:
 		return "check en";
 	case NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_1:
@@ -3124,7 +3126,12 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 		}
 		break;
 
-	case NVME_CTRLR_STATE_CHECK_EN: /* synonymous with NVME_CTRLR_STATE_INIT */
+	case NVME_CTRLR_STATE_READ_VS: /* synonymous with NVME_CTRLR_STATE_INIT */
+		nvme_ctrlr_get_vs(ctrlr, &ctrlr->vs);
+		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_CHECK_EN, NVME_TIMEOUT_INFINITE);
+		break;
+
+	case NVME_CTRLR_STATE_CHECK_EN:
 		/* Begin the hardware initialization by making sure the controller is disabled. */
 		if (cc.bits.en) {
 			NVME_CTRLR_DEBUGLOG(ctrlr, "CC.EN = 1\n");
@@ -3405,11 +3412,9 @@ nvme_ctrlr_construct(struct spdk_nvme_ctrlr *ctrlr)
 
 /* This function should be called once at ctrlr initialization to set up constant properties. */
 void
-nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr, const union spdk_nvme_cap_register *cap,
-		    const union spdk_nvme_vs_register *vs)
+nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr, const union spdk_nvme_cap_register *cap)
 {
 	ctrlr->cap = *cap;
-	ctrlr->vs = *vs;
 
 	if (ctrlr->cap.bits.ams & SPDK_NVME_CAP_AMS_WRR) {
 		ctrlr->flags |= SPDK_NVME_CTRLR_WRR_SUPPORTED;
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index e3b4ed8db..d41db35a8 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -518,14 +518,19 @@ enum nvme_ctrlr_state {
 	NVME_CTRLR_STATE_INIT_DELAY,
 
 	/**
-	 * Check EN to prepare for controller initialization.
+	 * Read Version (VS) register.
 	 */
-	NVME_CTRLR_STATE_CHECK_EN,
+	NVME_CTRLR_STATE_READ_VS,
 
 	/**
 	 * Controller has not started initialized yet.
 	 */
-	NVME_CTRLR_STATE_INIT = NVME_CTRLR_STATE_CHECK_EN,
+	NVME_CTRLR_STATE_INIT = NVME_CTRLR_STATE_READ_VS,
+
+	/**
+	 * Check EN to prepare for controller initialization.
+	 */
+	NVME_CTRLR_STATE_CHECK_EN,
 
 	/**
 	 * Waiting for CSTS.RDY to transition from 0 to 1 so that CC.EN may be set to 0.
@@ -1037,8 +1042,7 @@ int	nvme_ctrlr_get_vs(struct spdk_nvme_ctrlr *ctrlr, union spdk_nvme_vs_register
 int	nvme_ctrlr_get_cmbsz(struct spdk_nvme_ctrlr *ctrlr, union spdk_nvme_cmbsz_register *cmbsz);
 int	nvme_ctrlr_get_pmrcap(struct spdk_nvme_ctrlr *ctrlr, union spdk_nvme_pmrcap_register *pmrcap);
 bool	nvme_ctrlr_multi_iocs_enabled(struct spdk_nvme_ctrlr *ctrlr);
-void	nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr, const union spdk_nvme_cap_register *cap,
-			    const union spdk_nvme_vs_register *vs);
+void	nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr, const union spdk_nvme_cap_register *cap);
 void    nvme_ctrlr_process_async_event(struct spdk_nvme_ctrlr *ctrlr,
 				       const struct spdk_nvme_cpl *cpl);
 void nvme_ctrlr_disconnect_qpair(struct spdk_nvme_qpair *qpair);
diff --git a/lib/nvme/nvme_pcie.c b/lib/nvme/nvme_pcie.c
index 2a5a7f72d..d54602eea 100644
--- a/lib/nvme/nvme_pcie.c
+++ b/lib/nvme/nvme_pcie.c
@@ -908,7 +908,6 @@ static struct spdk_nvme_ctrlr *nvme_pcie_ctrlr_construct(const struct spdk_nvme_
 	struct spdk_pci_device *pci_dev = devhandle;
 	struct nvme_pcie_ctrlr *pctrlr;
 	union spdk_nvme_cap_register cap;
-	union spdk_nvme_vs_register vs;
 	uint16_t cmd_reg;
 	int rc;
 	struct spdk_pci_id pci_id;
@@ -960,14 +959,7 @@ static struct spdk_nvme_ctrlr *nvme_pcie_ctrlr_construct(const struct spdk_nvme_
 		return NULL;
 	}
 
-	if (nvme_ctrlr_get_vs(&pctrlr->ctrlr, &vs)) {
-		SPDK_ERRLOG("get_vs() failed\n");
-		spdk_pci_device_unclaim(pci_dev);
-		spdk_free(pctrlr);
-		return NULL;
-	}
-
-	nvme_ctrlr_init_cap(&pctrlr->ctrlr, &cap, &vs);
+	nvme_ctrlr_init_cap(&pctrlr->ctrlr, &cap);
 
 	/* Doorbell stride is 2 ^ (dstrd + 2),
 	 * but we want multiples of 4, so drop the + 2 */
diff --git a/lib/nvme/nvme_rdma.c b/lib/nvme/nvme_rdma.c
index ab0b1d0c5..9061f7438 100644
--- a/lib/nvme/nvme_rdma.c
+++ b/lib/nvme/nvme_rdma.c
@@ -1739,7 +1739,6 @@ static struct spdk_nvme_ctrlr *nvme_rdma_ctrlr_construct(const struct spdk_nvme_
 {
 	struct nvme_rdma_ctrlr *rctrlr;
 	union spdk_nvme_cap_register cap;
-	union spdk_nvme_vs_register vs;
 	struct ibv_context **contexts;
 	struct ibv_device_attr dev_attr;
 	int i, flag, rc;
@@ -1838,17 +1837,12 @@ static struct spdk_nvme_ctrlr *nvme_rdma_ctrlr_construct(const struct spdk_nvme_
 		goto destruct_ctrlr;
 	}
 
-	if (nvme_ctrlr_get_vs(&rctrlr->ctrlr, &vs)) {
-		SPDK_ERRLOG("get_vs() failed\n");
-		goto destruct_ctrlr;
-	}
-
 	if (nvme_ctrlr_add_process(&rctrlr->ctrlr, 0) != 0) {
 		SPDK_ERRLOG("nvme_ctrlr_add_process() failed\n");
 		goto destruct_ctrlr;
 	}
 
-	nvme_ctrlr_init_cap(&rctrlr->ctrlr, &cap, &vs);
+	nvme_ctrlr_init_cap(&rctrlr->ctrlr, &cap);
 
 	SPDK_DEBUGLOG(nvme, "successfully initialized the nvmf ctrlr\n");
 	return &rctrlr->ctrlr;
diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index 19ab9e933..27f3dceb7 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -1935,7 +1935,6 @@ static struct spdk_nvme_ctrlr *nvme_tcp_ctrlr_construct(const struct spdk_nvme_t
 {
 	struct nvme_tcp_ctrlr *tctrlr;
 	union spdk_nvme_cap_register cap;
-	union spdk_nvme_vs_register vs;
 	int rc;
 
 	tctrlr = calloc(1, sizeof(*tctrlr));
@@ -1975,19 +1974,13 @@ static struct spdk_nvme_ctrlr *nvme_tcp_ctrlr_construct(const struct spdk_nvme_t
 		return NULL;
 	}
 
-	if (nvme_ctrlr_get_vs(&tctrlr->ctrlr, &vs)) {
-		SPDK_ERRLOG("get_vs() failed\n");
-		nvme_ctrlr_destruct(&tctrlr->ctrlr);
-		return NULL;
-	}
-
 	if (nvme_ctrlr_add_process(&tctrlr->ctrlr, 0) != 0) {
 		SPDK_ERRLOG("nvme_ctrlr_add_process() failed\n");
 		nvme_ctrlr_destruct(&tctrlr->ctrlr);
 		return NULL;
 	}
 
-	nvme_ctrlr_init_cap(&tctrlr->ctrlr, &cap, &vs);
+	nvme_ctrlr_init_cap(&tctrlr->ctrlr, &cap);
 
 	return &tctrlr->ctrlr;
 }
diff --git a/lib/nvme/nvme_vfio_user.c b/lib/nvme/nvme_vfio_user.c
index c674f9f5e..17a3de833 100644
--- a/lib/nvme/nvme_vfio_user.c
+++ b/lib/nvme/nvme_vfio_user.c
@@ -201,7 +201,6 @@ static struct spdk_nvme_ctrlr *
 	struct nvme_pcie_ctrlr *pctrlr;
 	uint16_t cmd_reg;
 	union spdk_nvme_cap_register cap;
-	union spdk_nvme_vs_register vs;
 	int ret;
 	char ctrlr_path[PATH_MAX];
 	char ctrlr_bar0[PATH_MAX];
@@ -272,12 +271,7 @@ static struct spdk_nvme_ctrlr *
 		goto exit;
 	}
 
-	if (nvme_ctrlr_get_vs(&pctrlr->ctrlr, &vs)) {
-		SPDK_ERRLOG("get_vs() failed\n");
-		goto exit;
-	}
-
-	nvme_ctrlr_init_cap(&pctrlr->ctrlr, &cap, &vs);
+	nvme_ctrlr_init_cap(&pctrlr->ctrlr, &cap);
 	/* Doorbell stride is 2 ^ (dstrd + 2),
 	 * but we want multiples of 4, so drop the + 2 */
 	pctrlr->doorbell_stride_u32 = 1 << cap.bits.dstrd;
diff --git a/test/common/lib/nvme/common_stubs.h b/test/common/lib/nvme/common_stubs.h
index 1dc22a162..5edb12994 100644
--- a/test/common/lib/nvme/common_stubs.h
+++ b/test/common/lib/nvme/common_stubs.h
@@ -74,8 +74,7 @@ DEFINE_STUB_V(nvme_ctrlr_destruct_finish, (struct spdk_nvme_ctrlr *ctrlr));
 DEFINE_STUB(nvme_ctrlr_construct, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
 DEFINE_STUB_V(nvme_ctrlr_destruct, (struct spdk_nvme_ctrlr *ctrlr));
 DEFINE_STUB_V(nvme_ctrlr_init_cap, (struct spdk_nvme_ctrlr *ctrlr,
-				    const union spdk_nvme_cap_register *cap,
-				    const union spdk_nvme_vs_register *vs));
+				    const union spdk_nvme_cap_register *cap));
 DEFINE_STUB(nvme_ctrlr_get_vs, int, (struct spdk_nvme_ctrlr *ctrlr,
 				     union spdk_nvme_vs_register *vs), 0);
 DEFINE_STUB(nvme_ctrlr_get_cap, int, (struct spdk_nvme_ctrlr *ctrlr,
diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index a11dbf000..9fb0bf8ba 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -623,6 +623,9 @@ test_nvme_ctrlr_init_en_1_rdy_0(void)
 	ctrlr.cdata.nn = 1;
 	ctrlr.page_size = 0x1000;
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_1);
 
@@ -685,6 +688,9 @@ test_nvme_ctrlr_init_en_1_rdy_1(void)
 	ctrlr.cdata.nn = 1;
 	ctrlr.page_size = 0x1000;
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(g_ut_nvme_regs.cc.bits.en == 0);
@@ -750,6 +756,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_rr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_RR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -781,6 +790,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_rr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_WRR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -810,6 +822,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_rr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -839,6 +854,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_rr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS + 1;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -868,6 +886,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_rr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_RR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -925,6 +946,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_wrr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_RR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -956,6 +980,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_wrr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_WRR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -987,6 +1014,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_wrr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1016,6 +1046,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_wrr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS + 1;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1045,6 +1078,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_wrr(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_WRR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1101,6 +1137,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_vs(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_RR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1132,6 +1171,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_vs(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_WRR;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1161,6 +1203,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_vs(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1192,6 +1237,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_vs(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS + 1;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1221,6 +1269,9 @@ test_nvme_ctrlr_init_en_0_rdy_0_ams_vs(void)
 	ctrlr.opts.arb_mechanism = SPDK_NVME_CC_AMS_VS;
 
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
@@ -1267,6 +1318,9 @@ test_nvme_ctrlr_init_en_0_rdy_0(void)
 	ctrlr.cdata.nn = 1;
 	ctrlr.page_size = 0x1000;
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 
@@ -1312,6 +1366,9 @@ test_nvme_ctrlr_init_en_0_rdy_1(void)
 	ctrlr.cdata.nn = 1;
 	ctrlr.page_size = 0x1000;
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_INIT);
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 
@@ -2047,6 +2104,9 @@ test_nvme_ctrlr_init_delay(void)
 
 	/* sleep timeout, start to initialize */
 	spdk_delay_us(2 * spdk_get_ticks_hz());
+	while (ctrlr.state != NVME_CTRLR_STATE_CHECK_EN) {
+		CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
+	}
 	CU_ASSERT(nvme_ctrlr_process_init(&ctrlr) == 0);
 	CU_ASSERT(ctrlr.state == NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_0);
 
@@ -2719,9 +2779,10 @@ test_nvme_ctrlr_reset(void)
 
 	SPDK_CU_ASSERT_FATAL(nvme_ctrlr_construct(&ctrlr) == 0);
 
-	ctrlr.vs.bits.mjr = 1;
-	ctrlr.vs.bits.mnr = 2;
-	ctrlr.vs.bits.ter = 0;
+	g_ut_nvme_regs.vs.bits.mjr = 1;
+	g_ut_nvme_regs.vs.bits.mnr = 2;
+	g_ut_nvme_regs.vs.bits.ter = 0;
+	nvme_ctrlr_get_vs(&ctrlr, &ctrlr.vs);
 	ctrlr.cdata.nn = 2048;
 
 	ctrlr.state = NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS;
@@ -2739,7 +2800,8 @@ test_nvme_ctrlr_reset(void)
 	g_active_ns_list = active_ns_list2;
 	g_active_ns_list_length = SPDK_COUNTOF(active_ns_list2);
 	STAILQ_INSERT_HEAD(&adminq.free_req, &req, stailq);
-	memset(&g_ut_nvme_regs, 0, sizeof(g_ut_nvme_regs));
+	g_ut_nvme_regs.cc.raw = 0;
+	g_ut_nvme_regs.csts.raw = 0;
 	g_set_reg_cb = check_en_set_rdy;
 	CU_ASSERT(spdk_nvme_ctrlr_reset(&ctrlr) == 0);
 	g_set_reg_cb = NULL;
-- 
2.26.2


From f5ba8a5ef50485f182c07e1b52fccedc17cbd72d Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 26 May 2021 22:58:18 +0000
Subject: [PATCH 269/342] nvme: add NVME_CTRLR_STATE_READ_CAP

Read CAP (Capabilities) register as part of controller
initialization instead of controller construction.

For now, still read CAP in the pcie and vfio-user
controller construction, since they need the
drstd (doorbell stride) to construct the admin
queue.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I000fe880f2ec0d6de1d565c883d7ea0ae1ac2c81
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8078
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/nvme/nvme_ctrlr.c               | 15 +++++++++++----
 lib/nvme/nvme_internal.h            |  6 +++++-
 lib/nvme/nvme_pcie.c                |  2 --
 lib/nvme/nvme_rdma.c                |  8 --------
 lib/nvme/nvme_tcp.c                 |  9 ---------
 lib/nvme/nvme_vfio_user.c           |  1 -
 test/common/lib/nvme/common_stubs.h |  2 --
 7 files changed, 16 insertions(+), 27 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 20653d6c5..7d1b1b321 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -48,6 +48,7 @@ static void nvme_ctrlr_identify_active_ns_async(struct nvme_active_ns_ctx *ctx);
 static int nvme_ctrlr_identify_ns_async(struct spdk_nvme_ns *ns);
 static int nvme_ctrlr_identify_ns_iocs_specific_async(struct spdk_nvme_ns *ns);
 static int nvme_ctrlr_identify_id_desc_async(struct spdk_nvme_ns *ns);
+static void nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr);
 
 #define CTRLR_STRING(ctrlr) \
 	((ctrlr->trid.trtype == SPDK_NVME_TRANSPORT_TCP || ctrlr->trid.trtype == SPDK_NVME_TRANSPORT_RDMA) ? \
@@ -1136,6 +1137,8 @@ nvme_ctrlr_state_string(enum nvme_ctrlr_state state)
 		return "delay init";
 	case NVME_CTRLR_STATE_READ_VS:
 		return "read vs";
+	case NVME_CTRLR_STATE_READ_CAP:
+		return "read cap";
 	case NVME_CTRLR_STATE_CHECK_EN:
 		return "check en";
 	case NVME_CTRLR_STATE_DISABLE_WAIT_FOR_READY_1:
@@ -3128,6 +3131,11 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 
 	case NVME_CTRLR_STATE_READ_VS: /* synonymous with NVME_CTRLR_STATE_INIT */
 		nvme_ctrlr_get_vs(ctrlr, &ctrlr->vs);
+		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READ_CAP, NVME_TIMEOUT_INFINITE);
+		break;
+
+	case NVME_CTRLR_STATE_READ_CAP:
+		nvme_ctrlr_init_cap(ctrlr);
 		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_CHECK_EN, NVME_TIMEOUT_INFINITE);
 		break;
 
@@ -3410,11 +3418,10 @@ nvme_ctrlr_construct(struct spdk_nvme_ctrlr *ctrlr)
 	return rc;
 }
 
-/* This function should be called once at ctrlr initialization to set up constant properties. */
-void
-nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr, const union spdk_nvme_cap_register *cap)
+static void
+nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr)
 {
-	ctrlr->cap = *cap;
+	nvme_ctrlr_get_cap(ctrlr, &ctrlr->cap);
 
 	if (ctrlr->cap.bits.ams & SPDK_NVME_CAP_AMS_WRR) {
 		ctrlr->flags |= SPDK_NVME_CTRLR_WRR_SUPPORTED;
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index d41db35a8..61ff3201e 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -527,6 +527,11 @@ enum nvme_ctrlr_state {
 	 */
 	NVME_CTRLR_STATE_INIT = NVME_CTRLR_STATE_READ_VS,
 
+	/**
+	 * Read Capabilities (CAP) register.
+	 */
+	NVME_CTRLR_STATE_READ_CAP,
+
 	/**
 	 * Check EN to prepare for controller initialization.
 	 */
@@ -1042,7 +1047,6 @@ int	nvme_ctrlr_get_vs(struct spdk_nvme_ctrlr *ctrlr, union spdk_nvme_vs_register
 int	nvme_ctrlr_get_cmbsz(struct spdk_nvme_ctrlr *ctrlr, union spdk_nvme_cmbsz_register *cmbsz);
 int	nvme_ctrlr_get_pmrcap(struct spdk_nvme_ctrlr *ctrlr, union spdk_nvme_pmrcap_register *pmrcap);
 bool	nvme_ctrlr_multi_iocs_enabled(struct spdk_nvme_ctrlr *ctrlr);
-void	nvme_ctrlr_init_cap(struct spdk_nvme_ctrlr *ctrlr, const union spdk_nvme_cap_register *cap);
 void    nvme_ctrlr_process_async_event(struct spdk_nvme_ctrlr *ctrlr,
 				       const struct spdk_nvme_cpl *cpl);
 void nvme_ctrlr_disconnect_qpair(struct spdk_nvme_qpair *qpair);
diff --git a/lib/nvme/nvme_pcie.c b/lib/nvme/nvme_pcie.c
index d54602eea..b52f0e3f9 100644
--- a/lib/nvme/nvme_pcie.c
+++ b/lib/nvme/nvme_pcie.c
@@ -959,8 +959,6 @@ static struct spdk_nvme_ctrlr *nvme_pcie_ctrlr_construct(const struct spdk_nvme_
 		return NULL;
 	}
 
-	nvme_ctrlr_init_cap(&pctrlr->ctrlr, &cap);
-
 	/* Doorbell stride is 2 ^ (dstrd + 2),
 	 * but we want multiples of 4, so drop the + 2 */
 	pctrlr->doorbell_stride_u32 = 1 << cap.bits.dstrd;
diff --git a/lib/nvme/nvme_rdma.c b/lib/nvme/nvme_rdma.c
index 9061f7438..e52992205 100644
--- a/lib/nvme/nvme_rdma.c
+++ b/lib/nvme/nvme_rdma.c
@@ -1738,7 +1738,6 @@ static struct spdk_nvme_ctrlr *nvme_rdma_ctrlr_construct(const struct spdk_nvme_
 		void *devhandle)
 {
 	struct nvme_rdma_ctrlr *rctrlr;
-	union spdk_nvme_cap_register cap;
 	struct ibv_context **contexts;
 	struct ibv_device_attr dev_attr;
 	int i, flag, rc;
@@ -1832,18 +1831,11 @@ static struct spdk_nvme_ctrlr *nvme_rdma_ctrlr_construct(const struct spdk_nvme_
 		goto destruct_ctrlr;
 	}
 
-	if (nvme_ctrlr_get_cap(&rctrlr->ctrlr, &cap)) {
-		SPDK_ERRLOG("get_cap() failed\n");
-		goto destruct_ctrlr;
-	}
-
 	if (nvme_ctrlr_add_process(&rctrlr->ctrlr, 0) != 0) {
 		SPDK_ERRLOG("nvme_ctrlr_add_process() failed\n");
 		goto destruct_ctrlr;
 	}
 
-	nvme_ctrlr_init_cap(&rctrlr->ctrlr, &cap);
-
 	SPDK_DEBUGLOG(nvme, "successfully initialized the nvmf ctrlr\n");
 	return &rctrlr->ctrlr;
 
diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index 27f3dceb7..ba36d7b67 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -1934,7 +1934,6 @@ static struct spdk_nvme_ctrlr *nvme_tcp_ctrlr_construct(const struct spdk_nvme_t
 		void *devhandle)
 {
 	struct nvme_tcp_ctrlr *tctrlr;
-	union spdk_nvme_cap_register cap;
 	int rc;
 
 	tctrlr = calloc(1, sizeof(*tctrlr));
@@ -1968,20 +1967,12 @@ static struct spdk_nvme_ctrlr *nvme_tcp_ctrlr_construct(const struct spdk_nvme_t
 		return NULL;
 	}
 
-	if (nvme_ctrlr_get_cap(&tctrlr->ctrlr, &cap)) {
-		SPDK_ERRLOG("get_cap() failed\n");
-		nvme_ctrlr_destruct(&tctrlr->ctrlr);
-		return NULL;
-	}
-
 	if (nvme_ctrlr_add_process(&tctrlr->ctrlr, 0) != 0) {
 		SPDK_ERRLOG("nvme_ctrlr_add_process() failed\n");
 		nvme_ctrlr_destruct(&tctrlr->ctrlr);
 		return NULL;
 	}
 
-	nvme_ctrlr_init_cap(&tctrlr->ctrlr, &cap);
-
 	return &tctrlr->ctrlr;
 }
 
diff --git a/lib/nvme/nvme_vfio_user.c b/lib/nvme/nvme_vfio_user.c
index 17a3de833..907ae2aef 100644
--- a/lib/nvme/nvme_vfio_user.c
+++ b/lib/nvme/nvme_vfio_user.c
@@ -271,7 +271,6 @@ static struct spdk_nvme_ctrlr *
 		goto exit;
 	}
 
-	nvme_ctrlr_init_cap(&pctrlr->ctrlr, &cap);
 	/* Doorbell stride is 2 ^ (dstrd + 2),
 	 * but we want multiples of 4, so drop the + 2 */
 	pctrlr->doorbell_stride_u32 = 1 << cap.bits.dstrd;
diff --git a/test/common/lib/nvme/common_stubs.h b/test/common/lib/nvme/common_stubs.h
index 5edb12994..f84923cd0 100644
--- a/test/common/lib/nvme/common_stubs.h
+++ b/test/common/lib/nvme/common_stubs.h
@@ -73,8 +73,6 @@ DEFINE_STUB(nvme_request_check_timeout, int, (struct nvme_request *req, uint16_t
 DEFINE_STUB_V(nvme_ctrlr_destruct_finish, (struct spdk_nvme_ctrlr *ctrlr));
 DEFINE_STUB(nvme_ctrlr_construct, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
 DEFINE_STUB_V(nvme_ctrlr_destruct, (struct spdk_nvme_ctrlr *ctrlr));
-DEFINE_STUB_V(nvme_ctrlr_init_cap, (struct spdk_nvme_ctrlr *ctrlr,
-				    const union spdk_nvme_cap_register *cap));
 DEFINE_STUB(nvme_ctrlr_get_vs, int, (struct spdk_nvme_ctrlr *ctrlr,
 				     union spdk_nvme_vs_register *vs), 0);
 DEFINE_STUB(nvme_ctrlr_get_cap, int, (struct spdk_nvme_ctrlr *ctrlr,
-- 
2.26.2


From a31e319fbb27e439715ecdd3ebf2f075afb2451d Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 27 May 2021 19:22:07 +0000
Subject: [PATCH 270/342] nvme: init discovery ctrlr using
 nvme_ctrlr_process_init

This ensures the discovery ctrlr initialization is
done the same as normal ctrlrs.  This will be
critical as we make the driver fully asynchronous.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I33c4fd7c82d241c30e7adb89abe79b8088c8776a
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8090
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 lib/nvme/nvme_ctrlr.c                         |  7 +++++--
 lib/nvme/nvme_fabric.c                        | 20 ++++++-------------
 .../lib/nvme/nvme_fabric.c/nvme_fabric_ut.c   |  2 ++
 3 files changed, 13 insertions(+), 16 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 7d1b1b321..8dd2b83ef 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -3232,8 +3232,11 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 
 	case NVME_CTRLR_STATE_RESET_ADMIN_QUEUE:
 		nvme_transport_qpair_reset(ctrlr->adminq);
-		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY,
-				     ctrlr->opts.admin_timeout_ms);
+		if (spdk_nvme_ctrlr_is_discovery(ctrlr)) {
+			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READY, NVME_TIMEOUT_INFINITE);
+		} else {
+			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY, ctrlr->opts.admin_timeout_ms);
+		}
 		break;
 
 	case NVME_CTRLR_STATE_IDENTIFY:
diff --git a/lib/nvme/nvme_fabric.c b/lib/nvme/nvme_fabric.c
index 7bf785359..fd4a5cc57 100644
--- a/lib/nvme/nvme_fabric.c
+++ b/lib/nvme/nvme_fabric.c
@@ -265,7 +265,6 @@ nvme_fabric_ctrlr_scan(struct spdk_nvme_probe_ctx *probe_ctx,
 {
 	struct spdk_nvme_ctrlr_opts discovery_opts;
 	struct spdk_nvme_ctrlr *discovery_ctrlr;
-	union spdk_nvme_cc_register cc;
 	int rc;
 	struct nvme_completion_poll_status *status;
 
@@ -283,19 +282,12 @@ nvme_fabric_ctrlr_scan(struct spdk_nvme_probe_ctx *probe_ctx,
 	if (discovery_ctrlr == NULL) {
 		return -1;
 	}
-	nvme_qpair_set_state(discovery_ctrlr->adminq, NVME_QPAIR_ENABLED);
-
-	/* TODO: this should be using the normal NVMe controller initialization process +1 */
-	cc.raw = 0;
-	cc.bits.en = 1;
-	cc.bits.iosqes = 6; /* SQ entry size == 64 == 2^6 */
-	cc.bits.iocqes = 4; /* CQ entry size == 16 == 2^4 */
-	rc = nvme_transport_ctrlr_set_reg_4(discovery_ctrlr, offsetof(struct spdk_nvme_registers, cc.raw),
-					    cc.raw);
-	if (rc < 0) {
-		SPDK_ERRLOG("Failed to set cc\n");
-		nvme_ctrlr_destruct(discovery_ctrlr);
-		return -1;
+
+	while (discovery_ctrlr->state != NVME_CTRLR_STATE_READY) {
+		if (nvme_ctrlr_process_init(discovery_ctrlr) != 0) {
+			nvme_ctrlr_destruct(discovery_ctrlr);
+			return -1;
+		}
 	}
 
 	status = calloc(1, sizeof(*status));
diff --git a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
index fecb4b272..10016acd3 100644
--- a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
+++ b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
@@ -87,6 +87,8 @@ DEFINE_STUB(nvme_wait_for_completion_timeout, int,
 DEFINE_STUB(spdk_nvme_transport_id_adrfam_str, const char *,
 	    (enum spdk_nvmf_adrfam adrfam), NULL);
 
+DEFINE_STUB(nvme_ctrlr_process_init, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
+
 int
 spdk_nvme_transport_id_populate_trstring(struct spdk_nvme_transport_id *trid, const char *trstring)
 {
-- 
2.26.2


From 4e4c2cd8e325652892d0511669744dc3f83080da Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Tue, 25 May 2021 11:09:42 +0200
Subject: [PATCH 271/342] scripts/nvmf_perf: make rate_iops actually optional

Change-Id: Ie46df6e4f52b59941a90eeb786954fe7d5f1d089
Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8040
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 scripts/perf/nvmf/run_nvmf.py | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/scripts/perf/nvmf/run_nvmf.py b/scripts/perf/nvmf/run_nvmf.py
index 01cfd68c0..fc14b35ee 100755
--- a/scripts/perf/nvmf/run_nvmf.py
+++ b/scripts/perf/nvmf/run_nvmf.py
@@ -1344,9 +1344,12 @@ if __name__ == "__main__":
             fio_run_time = data[k]["run_time"]
             fio_ramp_time = data[k]["ramp_time"]
             fio_rw_mix_read = data[k]["rwmixread"]
-            fio_rate_iops = data[k]["rate_iops"]
             fio_run_num = data[k]["run_num"] if "run_num" in data[k].keys() else None
             fio_num_jobs = data[k]["num_jobs"] if "num_jobs" in data[k].keys() else None
+
+            fio_rate_iops = 0
+            if "rate_iops" in data[k]:
+                fio_rate_iops = data[k]["rate_iops"]
         else:
             continue
 
-- 
2.26.2


From 3a53213fb304179bf8372bc70c1a36853bfda032 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 10 Mar 2021 17:34:06 +0100
Subject: [PATCH 272/342] autobuild: Run scan-build under a dedicated test flag

Also, move ocf build outside the autobuild suite to make sure
scanbuild also picks up all the pieces.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I5f0de407cc55b1dc153cc856f68e053a54fc0682
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6841
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 autobuild.sh                   | 15 ++++++++-------
 test/common/autotest_common.sh |  2 ++
 2 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/autobuild.sh b/autobuild.sh
index 28dcc7209..3d88345dc 100755
--- a/autobuild.sh
+++ b/autobuild.sh
@@ -168,6 +168,7 @@ function make_fail_cleanup() {
 
 function scanbuild_make() {
 	pass=true
+	"$rootdir/configure" $config_params --without-shared
 	$scanbuild $MAKE $MAKEFLAGS > $out/build_output.txt && rm -rf $out/scan-build-tmp || make_fail_cleanup
 	xtrace_disable
 
@@ -265,12 +266,9 @@ function build_doc() {
 function autobuild_test_suite() {
 	run_test "autobuild_check_format" ./scripts/check_format.sh
 	run_test "autobuild_external_code" sudo -E --preserve-env=PATH LD_LIBRARY_PATH=$LD_LIBRARY_PATH $rootdir/test/external_code/test_make.sh $rootdir
-	if [ "$SPDK_TEST_OCF" -eq 1 ]; then
-		run_test "autobuild_ocf_precompile" ocf_precompile
-	fi
 	run_test "autobuild_check_so_deps" $rootdir/test/make/check_so_deps.sh $1
 	./configure $config_params --without-shared
-	run_test "scanbuild_make" scanbuild_make
+	$MAKE $MAKEFLAGS
 	run_test "autobuild_generated_files_check" porcelain_check
 	run_test "autobuild_header_dependency_check" header_dependency_check
 	run_test "autobuild_make_install" $MAKE $MAKEFLAGS install DESTDIR="$SPDK_WORKSPACE" prefix=/usr
@@ -306,14 +304,17 @@ $MAKE cc_version
 $MAKE cxx_version
 echo "** END ** Info for Hostname: $HOSTNAME"
 
+if [[ $SPDK_TEST_OCF -eq 1 ]]; then
+	run_test "autobuild_ocf_precompile" ocf_precompile
+fi
+
 if [[ $SPDK_TEST_AUTOBUILD -eq 1 ]]; then
 	run_test "autobuild" autobuild_test_suite $1
 elif [[ $SPDK_TEST_UNITTEST -eq 1 ]]; then
 	run_test "unittest_build" unittest_build
+elif [[ $SPDK_TEST_SCANBUILD -eq 1 ]]; then
+	run_test "scanbuild_make" scanbuild_make
 else
-	if [ "$SPDK_TEST_OCF" -eq 1 ]; then
-		run_test "autobuild_ocf_precompile" ocf_precompile
-	fi
 	# if we aren't testing the unittests, build with shared objects.
 	./configure $config_params --with-shared
 	run_test "make" $MAKE $MAKEFLAGS
diff --git a/test/common/autotest_common.sh b/test/common/autotest_common.sh
index ca247c60c..0180adde1 100755
--- a/test/common/autotest_common.sh
+++ b/test/common/autotest_common.sh
@@ -141,6 +141,8 @@ export SPDK_TEST_URING
 export SPDK_TEST_USE_IGB_UIO
 : ${SPDK_TEST_SCHEDULER:=0}
 export SPDK_TEST_SCHEDULER
+: ${SPDK_TEST_SCANBUILD:=0}
+export SPDK_TEST_SCANBUILD
 
 export DPDK_LIB_DIR="${SPDK_RUN_EXTERNAL_DPDK:-$rootdir/dpdk/build}/lib"
 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$SPDK_LIB_DIR:$DPDK_LIB_DIR
-- 
2.26.2


From 860a61f6eb3750ca65fdc6b9e10bfa904b7da634 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 26 May 2021 10:56:42 +0200
Subject: [PATCH 273/342] autobuild: Export EXTERNAL_MAKE_HUGEMEM if set

EXTERNAL_MAKE_HUGEMEM can be currently used from the external_code
suite.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I4359edc62ebdee91b261133877523c52175cb248
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8059
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 autobuild.sh | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/autobuild.sh b/autobuild.sh
index 3d88345dc..db76f9e7c 100755
--- a/autobuild.sh
+++ b/autobuild.sh
@@ -14,6 +14,10 @@ source "$1"
 source "$rootdir/test/common/autotest_common.sh"
 source "$rootdir/scripts/common.sh"
 
+if [[ -n $EXTERNAL_MAKE_HUGEMEM ]]; then
+	export EXTERNAL_MAKE_HUGEMEM
+fi
+
 out=$output_dir
 if [ -n "$SPDK_TEST_NATIVE_DPDK" ]; then
 	scanbuild_exclude=" --exclude $(dirname $SPDK_RUN_EXTERNAL_DPDK)"
-- 
2.26.2


From 252430a053bb2d6681cc8c99c000c51326c893ad Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 7 May 2021 21:33:40 +0800
Subject: [PATCH 274/342] nvme_tcp: Correctly handle the data digest err

According to NVMe-oF 1.1 spec, it is not a fatal error.
So according to Figure 126 in NVMe Base specification,
we should return "Transient Transport Error".

Change-Id: I601304ae2bb24508882fb1ec8c7e53ec587ab515
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7795
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 CHANGELOG.md             |  3 +++
 include/spdk/nvme_spec.h |  3 +++
 lib/nvme/nvme_tcp.c      | 11 +++++------
 lib/nvmf/tcp.c           | 34 ++++++++++++++++++++++++++--------
 4 files changed, 37 insertions(+), 14 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1d2cdf84c..6b8e0b4fa 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -24,6 +24,9 @@ Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the cont
 
 Added a new function `spdk_nvme_ns_cmd_copy` to submit a Simple Copy Command to a Namespace.
 
+Update the spdk_nvme_generic_command_status_code structure with new status code
+according to the definition in nvme 1.4 spec.
+
 ### rpc
 
 New RPC `bdev_rbd_register_cluster` and `bdev_rbd_unregister_cluster` was added, it allows to create
diff --git a/include/spdk/nvme_spec.h b/include/spdk/nvme_spec.h
index d817a250a..db122a66a 100644
--- a/include/spdk/nvme_spec.h
+++ b/include/spdk/nvme_spec.h
@@ -1401,6 +1401,9 @@ enum spdk_nvme_generic_command_status_code {
 	SPDK_NVME_SC_SANITIZE_IN_PROGRESS		= 0x1d,
 	SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID	= 0x1e,
 	SPDK_NVME_SC_COMMAND_INVALID_IN_CMB		= 0x1f,
+	SPDK_NVME_SC_COMMAND_NAMESPACE_IS_PROTECTED	= 0x20,
+	SPDK_NVME_SC_COMMAND_INTERRUPTED		= 0x21,
+	SPDK_NVME_SC_COMMAND_TRANSIENT_TRANSPORT_ERROR	= 0x22,
 
 	SPDK_NVME_SC_LBA_OUT_OF_RANGE			= 0x80,
 	SPDK_NVME_SC_CAPACITY_EXCEEDED			= 0x81,
diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index ba36d7b67..21e6dba64 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -846,7 +846,6 @@ nvme_tcp_qpair_send_h2c_term_req(struct nvme_tcp_qpair *tqpair, struct nvme_tcp_
 	h2c_term_req->common.plen = h2c_term_req->common.hlen + copy_len;
 	nvme_tcp_qpair_set_recv_state(tqpair, NVME_TCP_PDU_RECV_STATE_ERROR);
 	nvme_tcp_qpair_write_pdu(tqpair, rsp_pdu, nvme_tcp_qpair_send_h2c_term_req_complete, tqpair);
-
 }
 
 static void
@@ -1046,8 +1045,8 @@ nvme_tcp_pdu_payload_handle(struct nvme_tcp_qpair *tqpair,
 {
 	int rc = 0;
 	struct nvme_tcp_pdu *pdu;
-	uint32_t crc32c, error_offset = 0;
-	enum spdk_nvme_tcp_term_req_fes fes;
+	uint32_t crc32c;
+	struct nvme_tcp_req *tcp_req;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD);
 	pdu = tqpair->recv_pdu;
@@ -1060,9 +1059,9 @@ nvme_tcp_pdu_payload_handle(struct nvme_tcp_qpair *tqpair,
 		rc = MATCH_DIGEST_WORD(pdu->data_digest, crc32c);
 		if (rc == 0) {
 			SPDK_ERRLOG("data digest error on tqpair=(%p) with pdu=%p\n", tqpair, pdu);
-			fes = SPDK_NVME_TCP_TERM_REQ_FES_HDGST_ERROR;
-			nvme_tcp_qpair_send_h2c_term_req(tqpair, pdu, fes, error_offset);
-			return;
+			tcp_req = pdu->req;
+			assert(tcp_req != NULL);
+			tcp_req->rsp.status.sc = SPDK_NVME_SC_COMMAND_TRANSIENT_TRANSPORT_ERROR;
 		}
 	}
 
diff --git a/lib/nvmf/tcp.c b/lib/nvmf/tcp.c
index 3dadbaed0..b1694a7c8 100644
--- a/lib/nvmf/tcp.c
+++ b/lib/nvmf/tcp.c
@@ -1360,10 +1360,12 @@ nvmf_tcp_capsule_cmd_payload_handle(struct spdk_nvmf_tcp_transport *ttransport,
 	struct spdk_nvme_tcp_cmd *capsule_cmd;
 	uint32_t error_offset = 0;
 	enum spdk_nvme_tcp_term_req_fes fes;
+	struct spdk_nvme_cpl *rsp;
 
 	capsule_cmd = &pdu->hdr.capsule_cmd;
 	tcp_req = pdu->req;
 	assert(tcp_req != NULL);
+
 	if (capsule_cmd->common.pdo > SPDK_NVME_TCP_PDU_PDO_MAX_OFFSET) {
 		SPDK_ERRLOG("Expected ICReq capsule_cmd pdu offset <= %d, got %c\n",
 			    SPDK_NVME_TCP_PDU_PDO_MAX_OFFSET, capsule_cmd->common.pdo);
@@ -1373,7 +1375,14 @@ nvmf_tcp_capsule_cmd_payload_handle(struct spdk_nvmf_tcp_transport *ttransport,
 	}
 
 	nvmf_tcp_qpair_set_recv_state(tqpair, NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
-	nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_READY_TO_EXECUTE);
+
+	rsp = &tcp_req->req.rsp->nvme_cpl;
+	if (spdk_unlikely(rsp->status.sc == SPDK_NVME_SC_COMMAND_TRANSIENT_TRANSPORT_ERROR)) {
+		nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_READY_TO_COMPLETE);
+	} else {
+		nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_READY_TO_EXECUTE);
+	}
+
 	nvmf_tcp_req_process(ttransport, tcp_req);
 
 	return;
@@ -1582,6 +1591,7 @@ nvmf_tcp_h2c_data_payload_handle(struct spdk_nvmf_tcp_transport *ttransport,
 				 struct nvme_tcp_pdu *pdu)
 {
 	struct spdk_nvmf_tcp_req *tcp_req;
+	struct spdk_nvme_cpl *rsp;
 
 	tcp_req = pdu->req;
 	assert(tcp_req != NULL);
@@ -1596,7 +1606,14 @@ nvmf_tcp_h2c_data_payload_handle(struct spdk_nvmf_tcp_transport *ttransport,
 	 * acknowledged before moving on. */
 	if (tcp_req->h2c_offset == tcp_req->req.length &&
 	    tcp_req->state == TCP_REQUEST_STATE_TRANSFERRING_HOST_TO_CONTROLLER) {
-		nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_READY_TO_EXECUTE);
+		/* After receving all the h2c data, we need to check whether there is
+		 * transient transport error */
+		rsp = &tcp_req->req.rsp->nvme_cpl;
+		if (spdk_unlikely(rsp->status.sc == SPDK_NVME_SC_COMMAND_TRANSIENT_TRANSPORT_ERROR)) {
+			nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_READY_TO_COMPLETE);
+		} else {
+			nvmf_tcp_req_set_state(tcp_req, TCP_REQUEST_STATE_READY_TO_EXECUTE);
+		}
 		nvmf_tcp_req_process(ttransport, tcp_req);
 	}
 }
@@ -1678,8 +1695,9 @@ nvmf_tcp_pdu_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 {
 	int rc = 0;
 	struct nvme_tcp_pdu *pdu;
-	uint32_t crc32c, error_offset = 0;
-	enum spdk_nvme_tcp_term_req_fes fes;
+	uint32_t crc32c;
+	struct spdk_nvmf_tcp_req *tcp_req;
+	struct spdk_nvme_cpl *rsp;
 
 	assert(tqpair->recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD);
 	pdu = tqpair->pdu_in_progress;
@@ -1691,10 +1709,10 @@ nvmf_tcp_pdu_payload_handle(struct spdk_nvmf_tcp_qpair *tqpair,
 		rc = MATCH_DIGEST_WORD(pdu->data_digest, crc32c);
 		if (rc == 0) {
 			SPDK_ERRLOG("Data digest error on tqpair=(%p) with pdu=%p\n", tqpair, pdu);
-			fes = SPDK_NVME_TCP_TERM_REQ_FES_HDGST_ERROR;
-			nvmf_tcp_send_c2h_term_req(tqpair, pdu, fes, error_offset);
-			return;
-
+			tcp_req = pdu->req;
+			assert(tcp_req != NULL);
+			rsp = &tcp_req->req.rsp->nvme_cpl;
+			rsp->status.sc = SPDK_NVME_SC_COMMAND_TRANSIENT_TRANSPORT_ERROR;
 		}
 	}
 
-- 
2.26.2


From 0651ffe3f10022a55f18f5958ee1c669627701c7 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Tue, 25 May 2021 11:26:33 +0800
Subject: [PATCH 275/342] test/nvme_rdma: cases for rdma group connecting qpair

Change-Id: Ia2d76fb364671971d3c78555ab203c3c565ec2f3
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8029
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c | 73 +++++++++++++++++++
 1 file changed, 73 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c b/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c
index b0297d2e6..e550bbe9f 100644
--- a/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c
+++ b/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c
@@ -61,6 +61,11 @@ DEFINE_STUB_V(rdma_destroy_event_channel, (struct rdma_event_channel *channel));
 
 DEFINE_STUB(ibv_dereg_mr, int, (struct ibv_mr *mr), 0);
 
+int ibv_resize_cq(struct ibv_cq *cq, int cqe)
+{
+	return 0;
+}
+
 /* ibv_reg_mr can be a macro, need to undefine it */
 #ifdef ibv_reg_mr
 #undef ibv_reg_mr
@@ -958,6 +963,73 @@ test_nvme_rdma_register_and_unregister_reqs(void)
 	CU_ASSERT(rqpair.cmd_mr.mr == NULL);
 }
 
+static void
+test_nvme_rdma_poll_group_connect_disconnect_qpair(void)
+{
+	int					rc;
+	struct nvme_rdma_poll_group		group = {};
+	struct rdma_cm_id			cm_id = {};
+	struct nvme_rdma_qpair			*rqpair = NULL;
+	struct nvme_rdma_destroyed_qpair	*qpair_tracker = NULL;
+	struct ibv_context			*contexts = (void *)0xDEADBEEF;
+
+	/* Allocate memory for deleting qpair to free */
+	rqpair = calloc(1, sizeof(struct nvme_rdma_qpair));
+	rqpair->cm_id =  &cm_id;
+	rqpair->qpair.trtype = SPDK_NVME_TRANSPORT_RDMA;
+	rqpair->qpair.poll_group = &group.group;
+	rqpair->qpair.state = NVME_QPAIR_DESTROYING;
+	cm_id.verbs = (void *)0xDEADBEEF;
+
+	STAILQ_INIT(&group.destroyed_qpairs);
+	STAILQ_INIT(&group.pollers);
+	rc = nvme_rdma_poller_create(&group, contexts);
+	SPDK_CU_ASSERT_FATAL(rc == 0);
+
+	rc = nvme_rdma_poll_group_connect_qpair(&rqpair->qpair);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(rqpair->cq == (void *)0xFEEDBEEF);
+	CU_ASSERT(rqpair->poller != NULL);
+
+	rc = nvme_rdma_poll_group_disconnect_qpair(&rqpair->qpair);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(rqpair->defer_deletion_to_pg == true);
+	CU_ASSERT(rqpair->poll_group_disconnect_in_progress == false);
+	CU_ASSERT(rqpair->cq == NULL);
+	CU_ASSERT(!STAILQ_EMPTY(&group.destroyed_qpairs));
+
+	qpair_tracker = STAILQ_FIRST(&group.destroyed_qpairs);
+	CU_ASSERT(qpair_tracker->destroyed_qpair_tracker == rqpair);
+	CU_ASSERT(qpair_tracker->completed_cycles == 0);
+
+	nvme_rdma_poll_group_delete_qpair(&group, qpair_tracker);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(STAILQ_EMPTY(&group.destroyed_qpairs));
+
+	nvme_rdma_poll_group_free_pollers(&group);
+	CU_ASSERT(STAILQ_EMPTY(&group.pollers));
+
+	/* No available poller */
+	rqpair = calloc(1, sizeof(struct nvme_rdma_qpair));
+
+	rqpair->cm_id =  &cm_id;
+	rqpair->qpair.trtype = SPDK_NVME_TRANSPORT_RDMA;
+	rqpair->qpair.poll_group = &group.group;
+	rqpair->qpair.state = NVME_QPAIR_DESTROYING;
+	cm_id.verbs = (void *)0xDEADBEEF;
+
+	rc = nvme_rdma_poll_group_connect_qpair(&rqpair->qpair);
+	CU_ASSERT(rc == -EINVAL);
+	CU_ASSERT(rqpair->cq == NULL);
+
+	/* Poll group disconnect in progress */
+	rqpair->poll_group_disconnect_in_progress = true;
+
+	rc = nvme_rdma_poll_group_disconnect_qpair(&rqpair->qpair);
+	CU_ASSERT(rc == -EINPROGRESS);
+	free(rqpair);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -982,6 +1054,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_rdma_req_init);
 	CU_ADD_TEST(suite, test_nvme_rdma_validate_cm_event);
 	CU_ADD_TEST(suite, test_nvme_rdma_register_and_unregister_reqs);
+	CU_ADD_TEST(suite, test_nvme_rdma_poll_group_connect_disconnect_qpair);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From d6f6ffd2741b9ebc12bbeb56dcbd14c6408e31b6 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 27 May 2021 00:04:58 +0000
Subject: [PATCH 276/342] nvme: add NVME_CTRLR_STATE_CONNECT_ADMINQ

Connect the adminq as part of controller initialization
instead of controller construction.

We never actually 'connected' the adminq for
PCIe or vfio-user transports, since its a nop.
But their connect_qpair transport ops function
is also a nop for the adminq, so it's fine to
generically connect the adminq across all transports.

Note that we cannot read registers (cc or csts)
during controller initialization now until after
the adminq has been connected since reading fabrics
registers depends on a connected adminq.  This gets
special cased for now, but eventually reading
cc and csts will need to be part of the state machine
itself to make it asynchronous.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ia5566d7c549d78d24b94ea253df51e697da6237f
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8079
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 lib/nvme/nvme_ctrlr.c    | 25 +++++++++++++++----------
 lib/nvme/nvme_internal.h | 11 ++++++++---
 lib/nvme/nvme_rdma.c     |  6 ------
 lib/nvme/nvme_tcp.c      |  7 -------
 4 files changed, 23 insertions(+), 26 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 8dd2b83ef..96f64798a 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -1135,6 +1135,8 @@ nvme_ctrlr_state_string(enum nvme_ctrlr_state state)
 	switch (state) {
 	case NVME_CTRLR_STATE_INIT_DELAY:
 		return "delay init";
+	case NVME_CTRLR_STATE_CONNECT_ADMINQ:
+		return "connect adminq";
 	case NVME_CTRLR_STATE_READ_VS:
 		return "read vs";
 	case NVME_CTRLR_STATE_READ_CAP:
@@ -1409,11 +1411,6 @@ spdk_nvme_ctrlr_reset(struct spdk_nvme_ctrlr *ctrlr)
 
 	ctrlr->adminq->transport_failure_reason = SPDK_NVME_QPAIR_FAILURE_LOCAL;
 	nvme_transport_ctrlr_disconnect_qpair(ctrlr, ctrlr->adminq);
-	rc = nvme_transport_ctrlr_connect_qpair(ctrlr, ctrlr->adminq);
-	if (rc != 0) {
-		NVME_CTRLR_ERRLOG(ctrlr, "Controller reinitialization failed.\n");
-		goto out;
-	}
 
 	/* Doorbell buffer config is invalid during reset */
 	nvme_ctrlr_free_doorbell_buffer(ctrlr);
@@ -1426,7 +1423,6 @@ spdk_nvme_ctrlr_reset(struct spdk_nvme_ctrlr *ctrlr)
 	/* Set the state back to INIT to cause a full hardware reset. */
 	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_INIT, NVME_TIMEOUT_INFINITE);
 
-	nvme_qpair_set_state(ctrlr->adminq, NVME_QPAIR_ENABLED);
 	while (ctrlr->state != NVME_CTRLR_STATE_READY) {
 		if (nvme_ctrlr_process_init(ctrlr) != 0) {
 			NVME_CTRLR_ERRLOG(ctrlr, "controller reinitialization failed\n");
@@ -1456,7 +1452,6 @@ spdk_nvme_ctrlr_reset(struct spdk_nvme_ctrlr *ctrlr)
 		}
 	}
 
-out:
 	if (rc) {
 		nvme_ctrlr_fail(ctrlr, false);
 	}
@@ -3094,8 +3089,8 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 	}
 	ctrlr->sleep_timeout_tsc = 0;
 
-	if (nvme_ctrlr_get_cc(ctrlr, &cc) ||
-	    nvme_ctrlr_get_csts(ctrlr, &csts)) {
+	if (ctrlr->state > NVME_CTRLR_STATE_CONNECT_ADMINQ &&
+	    (nvme_ctrlr_get_cc(ctrlr, &cc) || nvme_ctrlr_get_csts(ctrlr, &csts))) {
 		if (!ctrlr->is_failed && ctrlr->state_timeout_tsc != NVME_TIMEOUT_INFINITE) {
 			/* While a device is resetting, it may be unable to service MMIO reads
 			 * temporarily. Allow for this case.
@@ -3129,7 +3124,17 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 		}
 		break;
 
-	case NVME_CTRLR_STATE_READ_VS: /* synonymous with NVME_CTRLR_STATE_INIT */
+	case NVME_CTRLR_STATE_CONNECT_ADMINQ: /* synonymous with NVME_CTRLR_STATE_INIT */
+		rc = nvme_transport_ctrlr_connect_qpair(ctrlr, ctrlr->adminq);
+		if (rc == 0) {
+			nvme_qpair_set_state(ctrlr->adminq, NVME_QPAIR_ENABLED);
+			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READ_VS, NVME_TIMEOUT_INFINITE);
+		} else {
+			nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_ERROR, NVME_TIMEOUT_INFINITE);
+		}
+		break;
+
+	case NVME_CTRLR_STATE_READ_VS:
 		nvme_ctrlr_get_vs(ctrlr, &ctrlr->vs);
 		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READ_CAP, NVME_TIMEOUT_INFINITE);
 		break;
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index 61ff3201e..98607a06a 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -518,14 +518,19 @@ enum nvme_ctrlr_state {
 	NVME_CTRLR_STATE_INIT_DELAY,
 
 	/**
-	 * Read Version (VS) register.
+	 * Connect the admin queue.
 	 */
-	NVME_CTRLR_STATE_READ_VS,
+	NVME_CTRLR_STATE_CONNECT_ADMINQ,
 
 	/**
 	 * Controller has not started initialized yet.
 	 */
-	NVME_CTRLR_STATE_INIT = NVME_CTRLR_STATE_READ_VS,
+	NVME_CTRLR_STATE_INIT = NVME_CTRLR_STATE_CONNECT_ADMINQ,
+
+	/**
+	 * Read Version (VS) register.
+	 */
+	NVME_CTRLR_STATE_READ_VS,
 
 	/**
 	 * Read Capabilities (CAP) register.
diff --git a/lib/nvme/nvme_rdma.c b/lib/nvme/nvme_rdma.c
index e52992205..fe2a8d004 100644
--- a/lib/nvme/nvme_rdma.c
+++ b/lib/nvme/nvme_rdma.c
@@ -1825,12 +1825,6 @@ static struct spdk_nvme_ctrlr *nvme_rdma_ctrlr_construct(const struct spdk_nvme_
 		goto destruct_ctrlr;
 	}
 
-	rc = nvme_transport_ctrlr_connect_qpair(&rctrlr->ctrlr, rctrlr->ctrlr.adminq);
-	if (rc < 0) {
-		SPDK_ERRLOG("failed to connect admin qpair\n");
-		goto destruct_ctrlr;
-	}
-
 	if (nvme_ctrlr_add_process(&rctrlr->ctrlr, 0) != 0) {
 		SPDK_ERRLOG("nvme_ctrlr_add_process() failed\n");
 		goto destruct_ctrlr;
diff --git a/lib/nvme/nvme_tcp.c b/lib/nvme/nvme_tcp.c
index 21e6dba64..dacbd5d10 100644
--- a/lib/nvme/nvme_tcp.c
+++ b/lib/nvme/nvme_tcp.c
@@ -1959,13 +1959,6 @@ static struct spdk_nvme_ctrlr *nvme_tcp_ctrlr_construct(const struct spdk_nvme_t
 		return NULL;
 	}
 
-	rc = nvme_transport_ctrlr_connect_qpair(&tctrlr->ctrlr, tctrlr->ctrlr.adminq);
-	if (rc < 0) {
-		SPDK_ERRLOG("failed to connect admin qpair\n");
-		nvme_tcp_ctrlr_destruct(&tctrlr->ctrlr);
-		return NULL;
-	}
-
 	if (nvme_ctrlr_add_process(&tctrlr->ctrlr, 0) != 0) {
 		SPDK_ERRLOG("nvme_ctrlr_add_process() failed\n");
 		nvme_ctrlr_destruct(&tctrlr->ctrlr);
-- 
2.26.2


From 9f5e3c99f25af5d8a4ec973d459ed76ed4b36d8c Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 26 May 2021 23:21:34 +0000
Subject: [PATCH 277/342] nvme: add spdk_nvme_ctrlr_is_fabrics()

We map the SPDK_NVME_TRANSPORT_* values directly to
the NVMe-oF trtype values.  Since PCIe isn't
Fabrics, we choose 256 which is outside of the
8-bit trtype range of values.

So we can just check if trtype >= 256 to determine
if the trid is for fabrics or not.  This is
preferable to checking PCIE || VFIOUSER in case
additional non-fabrics transport types are added
in the future.

I considered taking a trid as the parameter instead,
but went this route since it is consistent with
the existing spdk_nvme_ctrlr_is_discovery().

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: Ib62ff4d30549b2324486c81f2dce67f0f1741e9b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8077
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 include/spdk/nvme.h    |  9 +++++++++
 lib/nvme/nvme_ctrlr.c  | 11 +++++++++++
 lib/nvme/spdk_nvme.map |  1 +
 3 files changed, 21 insertions(+)

diff --git a/include/spdk/nvme.h b/include/spdk/nvme.h
index 372352986..a2d44a2bd 100644
--- a/include/spdk/nvme.h
+++ b/include/spdk/nvme.h
@@ -297,6 +297,15 @@ struct spdk_nvme_accel_fn_table {
  */
 bool spdk_nvme_ctrlr_is_discovery(struct spdk_nvme_ctrlr *ctrlr);
 
+/**
+ * Indicate whether a ctrlr handle is associated with a fabrics controller.
+ *
+ * \param ctrlr Opaque handle to NVMe controller.
+ *
+ * \return true if a fabrics controller, else false.
+ */
+bool spdk_nvme_ctrlr_is_fabrics(struct spdk_nvme_ctrlr *ctrlr);
+
 /**
  * Get the default options for the creation of a specific NVMe controller.
  *
diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 96f64798a..68ea3a072 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -4230,6 +4230,17 @@ spdk_nvme_ctrlr_is_discovery(struct spdk_nvme_ctrlr *ctrlr)
 			strlen(SPDK_NVMF_DISCOVERY_NQN));
 }
 
+bool
+spdk_nvme_ctrlr_is_fabrics(struct spdk_nvme_ctrlr *ctrlr)
+{
+	assert(ctrlr);
+
+	/* We always define non-fabrics trtypes outside of the 8-bit range
+	 * of NVMe-oF trtype.
+	 */
+	return ctrlr->trid.trtype < UINT8_MAX;
+}
+
 int
 spdk_nvme_ctrlr_security_receive(struct spdk_nvme_ctrlr *ctrlr, uint8_t secp,
 				 uint16_t spsp, uint8_t nssf, void *payload, size_t size)
diff --git a/lib/nvme/spdk_nvme.map b/lib/nvme/spdk_nvme.map
index d54dd091b..7df89b050 100644
--- a/lib/nvme/spdk_nvme.map
+++ b/lib/nvme/spdk_nvme.map
@@ -30,6 +30,7 @@
 	spdk_nvme_pcie_set_hotplug_filter;
 
 	spdk_nvme_ctrlr_is_discovery;
+	spdk_nvme_ctrlr_is_fabrics;
 	spdk_nvme_ctrlr_get_default_ctrlr_opts;
 	spdk_nvme_ctrlr_set_trid;
 	spdk_nvme_ctrlr_reset_subsystem;
-- 
2.26.2


From 6a49507c47168890a6d1d0b8960b01fef546bdc8 Mon Sep 17 00:00:00 2001
From: ChengqiangMeng <chengqiangx.meng@intel.com>
Date: Tue, 1 Jun 2021 15:14:56 +0800
Subject: [PATCH 278/342] unittest/nvme_rdma: increase code coverage for
 nvme_rdma.c

nvme_rdma_parse_addr and nvme_rdma_qpair_init code comprehensive coverage.

Signed-off-by: ChengqiangMeng <chengqiangx.meng@intel.com>
Change-Id: I7474281a2b80c092f0ed516e1da3649473eb0fa3
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7337
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 test/common/lib/test_rdma.c                   |  3 +-
 test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c | 46 +++++++++++++++++++
 2 files changed, 48 insertions(+), 1 deletion(-)

diff --git a/test/common/lib/test_rdma.c b/test/common/lib/test_rdma.c
index 62cd934eb..d89f48745 100644
--- a/test/common/lib/test_rdma.c
+++ b/test/common/lib/test_rdma.c
@@ -39,8 +39,9 @@
 #define RDMA_UT_LKEY 123
 #define RDMA_UT_RKEY 312
 
+struct spdk_rdma_qp g_spdk_rdma_qp = {};
 DEFINE_STUB(spdk_rdma_qp_create, struct spdk_rdma_qp *, (struct rdma_cm_id *cm_id,
-		struct spdk_rdma_qp_init_attr *qp_attr), NULL);
+		struct spdk_rdma_qp_init_attr *qp_attr), &g_spdk_rdma_qp);
 DEFINE_STUB(spdk_rdma_qp_accept, int, (struct spdk_rdma_qp *spdk_rdma_qp,
 				       struct rdma_conn_param *conn_param), 0);
 DEFINE_STUB(spdk_rdma_qp_complete_connect, int, (struct spdk_rdma_qp *spdk_rdma_qp), 0);
diff --git a/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c b/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c
index e550bbe9f..b31245630 100644
--- a/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c
+++ b/test/unit/lib/nvme/nvme_rdma.c/nvme_rdma_ut.c
@@ -1030,6 +1030,50 @@ test_nvme_rdma_poll_group_connect_disconnect_qpair(void)
 	free(rqpair);
 }
 
+static void
+test_nvme_rdma_parse_addr(void)
+{
+	struct sockaddr_storage dst_addr;
+	int rc = 0;
+
+	memset(&dst_addr, 0, sizeof(dst_addr));
+	/* case1: getaddrinfo failed */
+	rc = nvme_rdma_parse_addr(&dst_addr, AF_INET, NULL, NULL);
+	CU_ASSERT(rc != 0);
+
+	/* case2: res->ai_addrlen < sizeof(*sa). Expect: Pass. */
+	rc = nvme_rdma_parse_addr(&dst_addr, AF_INET, "12.34.56.78", "23");
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(dst_addr.ss_family == AF_INET);
+}
+
+static void
+test_nvme_rdma_qpair_init(void)
+{
+	struct nvme_rdma_qpair		rqpair = {};
+	struct rdma_cm_id		 cm_id = {};
+	struct ibv_qp			    qp = {};
+	struct nvme_rdma_ctrlr	rctrlr = {};
+	int rc = 0;
+
+	rctrlr.ctrlr.trid.trtype = SPDK_NVME_TRANSPORT_RDMA;
+	rqpair.cm_id = &cm_id;
+	g_nvme_hooks.get_ibv_pd = NULL;
+	rqpair.qpair.poll_group = NULL;
+	rqpair.qpair.ctrlr = &rctrlr.ctrlr;
+	g_spdk_rdma_qp.qp = &qp;
+
+	rc = nvme_rdma_qpair_init(&rqpair);
+	CU_ASSERT(rc == 0);
+
+	CU_ASSERT(rqpair.cm_id->context == &rqpair.qpair);
+	CU_ASSERT(rqpair.max_send_sge == NVME_RDMA_DEFAULT_TX_SGE);
+	CU_ASSERT(rqpair.max_recv_sge == NVME_RDMA_DEFAULT_RX_SGE);
+	CU_ASSERT(rqpair.current_num_sends == 0);
+	CU_ASSERT(rqpair.current_num_recvs == 0);
+	CU_ASSERT(rqpair.cq == (struct ibv_cq *)0xFEEDBEEF);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -1055,6 +1099,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_rdma_validate_cm_event);
 	CU_ADD_TEST(suite, test_nvme_rdma_register_and_unregister_reqs);
 	CU_ADD_TEST(suite, test_nvme_rdma_poll_group_connect_disconnect_qpair);
+	CU_ADD_TEST(suite, test_nvme_rdma_parse_addr);
+	CU_ADD_TEST(suite, test_nvme_rdma_qpair_init);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From ee8f6dd1d51a1ec8ba7f640dd4054f089442392c Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Tue, 1 Jun 2021 23:18:08 +0800
Subject: [PATCH 279/342] sgl.h: Add a new internal header file.

The purpose is to reduce the duplicated code in nvmf and iscsi
layer.

Change-Id: I7e96f0d5bb1ba4b81378addca3cdd929056384e9
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8132
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: <dongx.yi@intel.com>
---
 include/spdk_internal/nvme_tcp.h |  93 +++++-----------------
 include/spdk_internal/sgl.h      | 127 +++++++++++++++++++++++++++++++
 lib/iscsi/iscsi.c                |  56 +++-----------
 3 files changed, 158 insertions(+), 118 deletions(-)
 create mode 100644 include/spdk_internal/sgl.h

diff --git a/include/spdk_internal/nvme_tcp.h b/include/spdk_internal/nvme_tcp.h
index 3345880c1..01f0ad8a1 100644
--- a/include/spdk_internal/nvme_tcp.h
+++ b/include/spdk_internal/nvme_tcp.h
@@ -38,6 +38,8 @@
 #include "spdk/sock.h"
 #include "spdk/dif.h"
 
+#include "sgl.h"
+
 #define SPDK_CRC32C_XOR				0xffffffffUL
 #define SPDK_NVME_TCP_DIGEST_LEN		4
 #define SPDK_NVME_TCP_DIGEST_ALIGNMENT		4
@@ -76,13 +78,6 @@
 
 typedef void (*nvme_tcp_qpair_xfer_complete_cb)(void *cb_arg);
 
-struct _nvme_tcp_sgl {
-	struct iovec	*iov;
-	int		iovcnt;
-	uint32_t	iov_offset;
-	uint32_t	total_size;
-};
-
 struct nvme_tcp_pdu {
 	union {
 		/* to hold error pdu data */
@@ -125,7 +120,7 @@ struct nvme_tcp_pdu {
 	TAILQ_ENTRY(nvme_tcp_pdu)			tailq;
 	uint32_t					remaining;
 	uint32_t					padding_len;
-	struct _nvme_tcp_sgl				sgl;
+	struct spdk_iov_sgl				sgl;
 
 	struct spdk_dif_ctx				*dif_ctx;
 
@@ -248,32 +243,7 @@ nvme_tcp_pdu_calc_data_digest(struct nvme_tcp_pdu *pdu)
 }
 
 static inline void
-_nvme_tcp_sgl_init(struct _nvme_tcp_sgl *s, struct iovec *iov, int iovcnt,
-		   uint32_t iov_offset)
-{
-	s->iov = iov;
-	s->iovcnt = iovcnt;
-	s->iov_offset = iov_offset;
-	s->total_size = 0;
-}
-
-static inline void
-_nvme_tcp_sgl_advance(struct _nvme_tcp_sgl *s, uint32_t step)
-{
-	s->iov_offset += step;
-	while (s->iovcnt > 0) {
-		if (s->iov_offset < s->iov->iov_len) {
-			break;
-		}
-
-		s->iov_offset -= s->iov->iov_len;
-		s->iov++;
-		s->iovcnt--;
-	}
-}
-
-static inline void
-_nvme_tcp_sgl_get_buf(struct _nvme_tcp_sgl *s, void **_buf, uint32_t *_buf_len)
+_nvme_tcp_sgl_get_buf(struct spdk_iov_sgl *s, void **_buf, uint32_t *_buf_len)
 {
 	if (_buf != NULL) {
 		*_buf = s->iov->iov_base + s->iov_offset;
@@ -284,33 +254,12 @@ _nvme_tcp_sgl_get_buf(struct _nvme_tcp_sgl *s, void **_buf, uint32_t *_buf_len)
 }
 
 static inline bool
-_nvme_tcp_sgl_append(struct _nvme_tcp_sgl *s, uint8_t *data, uint32_t data_len)
-{
-	if (s->iov_offset >= data_len) {
-		s->iov_offset -= data_len;
-	} else {
-		assert(s->iovcnt > 0);
-		s->iov->iov_base = data + s->iov_offset;
-		s->iov->iov_len = data_len - s->iov_offset;
-		s->total_size += data_len - s->iov_offset;
-		s->iov_offset = 0;
-		s->iov++;
-		s->iovcnt--;
-		if (s->iovcnt == 0) {
-			return false;
-		}
-	}
-
-	return true;
-}
-
-static inline bool
-_nvme_tcp_sgl_append_multi(struct _nvme_tcp_sgl *s, struct iovec *iov, int iovcnt)
+_nvme_tcp_sgl_append_multi(struct spdk_iov_sgl *s, struct iovec *iov, int iovcnt)
 {
 	int i;
 
 	for (i = 0; i < iovcnt; i++) {
-		if (!_nvme_tcp_sgl_append(s, iov[i].iov_base, iov[i].iov_len)) {
+		if (!spdk_iov_sgl_append(s, iov[i].iov_base, iov[i].iov_len)) {
 			return false;
 		}
 	}
@@ -332,7 +281,7 @@ _get_iov_array_size(struct iovec *iov, int iovcnt)
 }
 
 static inline bool
-_nvme_tcp_sgl_append_multi_with_md(struct _nvme_tcp_sgl *s, struct iovec *iov, int iovcnt,
+_nvme_tcp_sgl_append_multi_with_md(struct spdk_iov_sgl *s, struct iovec *iov, int iovcnt,
 				   uint32_t data_len, const struct spdk_dif_ctx *dif_ctx)
 {
 	int rc;
@@ -368,14 +317,14 @@ nvme_tcp_build_iovs(struct iovec *iov, int iovcnt, struct nvme_tcp_pdu *pdu,
 		    bool hdgst_enable, bool ddgst_enable, uint32_t *_mapped_length)
 {
 	uint32_t hlen, plen;
-	struct _nvme_tcp_sgl *sgl;
+	struct spdk_iov_sgl *sgl;
 
 	if (iovcnt == 0) {
 		return 0;
 	}
 
 	sgl = &pdu->sgl;
-	_nvme_tcp_sgl_init(sgl, iov, iovcnt, 0);
+	spdk_iov_sgl_init(sgl, iov, iovcnt, 0);
 	hlen = pdu->hdr.common.hlen;
 
 	/* Header Digest */
@@ -386,7 +335,7 @@ nvme_tcp_build_iovs(struct iovec *iov, int iovcnt, struct nvme_tcp_pdu *pdu,
 	plen = hlen;
 	if (!pdu->data_len) {
 		/* PDU header + possible header digest */
-		_nvme_tcp_sgl_append(sgl, (uint8_t *)&pdu->hdr.raw, hlen);
+		spdk_iov_sgl_append(sgl, (uint8_t *)&pdu->hdr.raw, hlen);
 		goto end;
 	}
 
@@ -396,7 +345,7 @@ nvme_tcp_build_iovs(struct iovec *iov, int iovcnt, struct nvme_tcp_pdu *pdu,
 		plen = hlen;
 	}
 
-	if (!_nvme_tcp_sgl_append(sgl, (uint8_t *)&pdu->hdr.raw, hlen)) {
+	if (!spdk_iov_sgl_append(sgl, (uint8_t *)&pdu->hdr.raw, hlen)) {
 		goto end;
 	}
 
@@ -416,7 +365,7 @@ nvme_tcp_build_iovs(struct iovec *iov, int iovcnt, struct nvme_tcp_pdu *pdu,
 	/* Data Digest */
 	if (g_nvme_tcp_ddgst[pdu->hdr.common.pdu_type] && ddgst_enable) {
 		plen += SPDK_NVME_TCP_DIGEST_LEN;
-		_nvme_tcp_sgl_append(sgl, pdu->data_digest, SPDK_NVME_TCP_DIGEST_LEN);
+		spdk_iov_sgl_append(sgl, pdu->data_digest, SPDK_NVME_TCP_DIGEST_LEN);
 	}
 
 	assert(plen == pdu->hdr.common.plen);
@@ -433,14 +382,14 @@ static int
 nvme_tcp_build_payload_iovs(struct iovec *iov, int iovcnt, struct nvme_tcp_pdu *pdu,
 			    bool ddgst_enable, uint32_t *_mapped_length)
 {
-	struct _nvme_tcp_sgl *sgl;
+	struct spdk_iov_sgl *sgl;
 
 	if (iovcnt == 0) {
 		return 0;
 	}
 
 	sgl = &pdu->sgl;
-	_nvme_tcp_sgl_init(sgl, iov, iovcnt, pdu->rw_offset);
+	spdk_iov_sgl_init(sgl, iov, iovcnt, pdu->rw_offset);
 
 	if (spdk_likely(!pdu->dif_ctx)) {
 		if (!_nvme_tcp_sgl_append_multi(sgl, pdu->data_iov, pdu->data_iovcnt)) {
@@ -455,7 +404,7 @@ nvme_tcp_build_payload_iovs(struct iovec *iov, int iovcnt, struct nvme_tcp_pdu *
 
 	/* Data Digest */
 	if (ddgst_enable) {
-		_nvme_tcp_sgl_append(sgl, pdu->data_digest, SPDK_NVME_TCP_DIGEST_LEN);
+		spdk_iov_sgl_append(sgl, pdu->data_digest, SPDK_NVME_TCP_DIGEST_LEN);
 	}
 
 end:
@@ -565,7 +514,7 @@ nvme_tcp_pdu_set_data_buf(struct nvme_tcp_pdu *pdu,
 {
 	uint32_t buf_offset, buf_len, remain_len, len;
 	uint8_t *buf;
-	struct _nvme_tcp_sgl *pdu_sgl, buf_sgl;
+	struct spdk_iov_sgl *pdu_sgl, buf_sgl;
 
 	pdu->data_len = data_len;
 
@@ -583,20 +532,20 @@ nvme_tcp_pdu_set_data_buf(struct nvme_tcp_pdu *pdu,
 	} else {
 		pdu_sgl = &pdu->sgl;
 
-		_nvme_tcp_sgl_init(pdu_sgl, pdu->data_iov, NVME_TCP_MAX_SGL_DESCRIPTORS, 0);
-		_nvme_tcp_sgl_init(&buf_sgl, iov, iovcnt, 0);
+		spdk_iov_sgl_init(pdu_sgl, pdu->data_iov, NVME_TCP_MAX_SGL_DESCRIPTORS, 0);
+		spdk_iov_sgl_init(&buf_sgl, iov, iovcnt, 0);
 
-		_nvme_tcp_sgl_advance(&buf_sgl, buf_offset);
+		spdk_iov_sgl_advance(&buf_sgl, buf_offset);
 		remain_len = buf_len;
 
 		while (remain_len > 0) {
 			_nvme_tcp_sgl_get_buf(&buf_sgl, (void *)&buf, &len);
 			len = spdk_min(len, remain_len);
 
-			_nvme_tcp_sgl_advance(&buf_sgl, len);
+			spdk_iov_sgl_advance(&buf_sgl, len);
 			remain_len -= len;
 
-			if (!_nvme_tcp_sgl_append(pdu_sgl, buf, len)) {
+			if (!spdk_iov_sgl_append(pdu_sgl, buf, len)) {
 				break;
 			}
 		}
diff --git a/include/spdk_internal/sgl.h b/include/spdk_internal/sgl.h
new file mode 100644
index 000000000..9fee65d42
--- /dev/null
+++ b/include/spdk_internal/sgl.h
@@ -0,0 +1,127 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SGL_INTERNAL_H__
+#define __SGL_INTERNAL_H__
+
+#include "spdk/stdinc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct spdk_iov_sgl {
+	struct iovec    *iov;
+	int             iovcnt;
+	uint32_t        iov_offset;
+	uint32_t        total_size;
+};
+
+/**
+ * Initialize struct spdk_iov_sgl with iov, iovcnt and iov_offset.
+ *
+ * \param s the spdk_iov_sgl to be filled.
+ * \param iov the io vector to fill the s
+ * \param iovcnt the size the iov
+ * \param iov_offset the current filled iov_offset for s.
+ */
+
+static inline void
+spdk_iov_sgl_init(struct spdk_iov_sgl *s, struct iovec *iov, int iovcnt,
+		  uint32_t iov_offset)
+{
+	s->iov = iov;
+	s->iovcnt = iovcnt;
+	s->iov_offset = iov_offset;
+	s->total_size = 0;
+}
+
+/**
+ * Consume the iovs in spdk_iov_sgl with passed bytes
+ *
+ * \param s the spdk_iov_sgl which contains the iov
+ * \param step the bytes_size consumed.
+ */
+
+static inline void
+spdk_iov_sgl_advance(struct spdk_iov_sgl *s, uint32_t step)
+{
+	s->iov_offset += step;
+	while (s->iovcnt > 0) {
+		assert(s->iov != NULL);
+		if (s->iov_offset < s->iov->iov_len) {
+			break;
+		}
+
+		s->iov_offset -= s->iov->iov_len;
+		s->iov++;
+		s->iovcnt--;
+	}
+}
+
+/**
+ * Append the data to the struct spdk_iov_sgl pointed by s
+ *
+ * \param s the address of the struct spdk_iov_sgl
+ * \param data the data buffer to be appended
+ * \param data_len the length of the data.
+ *
+ * \return true if all the data is appended.
+ */
+
+static inline bool
+spdk_iov_sgl_append(struct spdk_iov_sgl *s, uint8_t *data, uint32_t data_len)
+{
+	if (s->iov_offset >= data_len) {
+		s->iov_offset -= data_len;
+	} else {
+		assert(s->iovcnt > 0);
+		s->iov->iov_base = data + s->iov_offset;
+		s->iov->iov_len = data_len - s->iov_offset;
+		s->total_size += data_len - s->iov_offset;
+		s->iov_offset = 0;
+		s->iov++;
+		s->iovcnt--;
+		if (s->iovcnt == 0) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SGL_INTERNAL_H__ */
diff --git a/lib/iscsi/iscsi.c b/lib/iscsi/iscsi.c
index dcd2aa395..842e167d7 100644
--- a/lib/iscsi/iscsi.c
+++ b/lib/iscsi/iscsi.c
@@ -57,6 +57,8 @@
 
 #include "spdk/log.h"
 
+#include "spdk_internal/sgl.h"
+
 #define MAX_TMPBUF 1024
 
 #ifdef __FreeBSD__
@@ -387,49 +389,11 @@ iscsi_conn_read_data_segment(struct spdk_iscsi_conn *conn,
 	}
 }
 
-struct _iscsi_sgl {
-	struct iovec	*iov;
-	int		iovcnt;
-	uint32_t	iov_offset;
-	uint32_t	total_size;
-};
-
-static inline void
-_iscsi_sgl_init(struct _iscsi_sgl *s, struct iovec *iovs, int iovcnt,
-		uint32_t iov_offset)
-{
-	s->iov = iovs;
-	s->iovcnt = iovcnt;
-	s->iov_offset = iov_offset;
-	s->total_size = 0;
-}
-
-static inline bool
-_iscsi_sgl_append(struct _iscsi_sgl *s, uint8_t *data, uint32_t data_len)
-{
-	if (s->iov_offset >= data_len) {
-		s->iov_offset -= data_len;
-	} else {
-		assert(s->iovcnt > 0);
-		s->iov->iov_base = data + s->iov_offset;
-		s->iov->iov_len = data_len - s->iov_offset;
-		s->total_size += data_len - s->iov_offset;
-		s->iov_offset = 0;
-		s->iov++;
-		s->iovcnt--;
-		if (s->iovcnt == 0) {
-			return false;
-		}
-	}
-
-	return true;
-}
-
 /* Build iovec array to leave metadata space for every data block
  * when reading data segment from socket.
  */
 static inline bool
-_iscsi_sgl_append_with_md(struct _iscsi_sgl *s,
+_iscsi_sgl_append_with_md(struct spdk_iov_sgl *s,
 			  void *buf, uint32_t buf_len, uint32_t data_len,
 			  struct spdk_dif_ctx *dif_ctx)
 {
@@ -468,7 +432,7 @@ int
 iscsi_build_iovs(struct spdk_iscsi_conn *conn, struct iovec *iovs, int iovcnt,
 		 struct spdk_iscsi_pdu *pdu, uint32_t *_mapped_length)
 {
-	struct _iscsi_sgl sgl;
+	struct spdk_iov_sgl sgl;
 	int enable_digest;
 	uint32_t total_ahs_len;
 	uint32_t data_len;
@@ -487,22 +451,22 @@ iscsi_build_iovs(struct spdk_iscsi_conn *conn, struct iovec *iovs, int iovcnt,
 		enable_digest = 0;
 	}
 
-	_iscsi_sgl_init(&sgl, iovs, iovcnt, pdu->writev_offset);
+	spdk_iov_sgl_init(&sgl, iovs, iovcnt, pdu->writev_offset);
 
 	/* BHS */
-	if (!_iscsi_sgl_append(&sgl, (uint8_t *)&pdu->bhs, ISCSI_BHS_LEN)) {
+	if (!spdk_iov_sgl_append(&sgl, (uint8_t *)&pdu->bhs, ISCSI_BHS_LEN)) {
 		goto end;
 	}
 	/* AHS */
 	if (total_ahs_len > 0) {
-		if (!_iscsi_sgl_append(&sgl, pdu->ahs, 4 * total_ahs_len)) {
+		if (!spdk_iov_sgl_append(&sgl, pdu->ahs, 4 * total_ahs_len)) {
 			goto end;
 		}
 	}
 
 	/* Header Digest */
 	if (enable_digest && conn->header_digest) {
-		if (!_iscsi_sgl_append(&sgl, pdu->header_digest, ISCSI_DIGEST_LEN)) {
+		if (!spdk_iov_sgl_append(&sgl, pdu->header_digest, ISCSI_DIGEST_LEN)) {
 			goto end;
 		}
 	}
@@ -510,7 +474,7 @@ iscsi_build_iovs(struct spdk_iscsi_conn *conn, struct iovec *iovs, int iovcnt,
 	/* Data Segment */
 	if (data_len > 0) {
 		if (!pdu->dif_insert_or_strip) {
-			if (!_iscsi_sgl_append(&sgl, pdu->data, data_len)) {
+			if (!spdk_iov_sgl_append(&sgl, pdu->data, data_len)) {
 				goto end;
 			}
 		} else {
@@ -523,7 +487,7 @@ iscsi_build_iovs(struct spdk_iscsi_conn *conn, struct iovec *iovs, int iovcnt,
 
 	/* Data Digest */
 	if (enable_digest && conn->data_digest && data_len != 0) {
-		_iscsi_sgl_append(&sgl, pdu->data_digest, ISCSI_DIGEST_LEN);
+		spdk_iov_sgl_append(&sgl, pdu->data_digest, ISCSI_DIGEST_LEN);
 	}
 
 end:
-- 
2.26.2


From b85127cc6f8566e7e2b388ee9892e2ebc46c8882 Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 28 May 2021 19:25:59 +0800
Subject: [PATCH 280/342] util/crc32c: Add spdk_crc32c_iov_update.

Purpose: To support caculating crc32c for iovs.

Change-Id: I7ea6d8b71ea2cf6e8b81903439787870923b9bef
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8093
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 CHANGELOG.md                            |  5 +++++
 examples/accel/perf/accel_perf.c        | 16 +---------------
 include/spdk/crc32.h                    | 10 ++++++++++
 include/spdk_internal/nvme_tcp.h        | 16 +---------------
 lib/util/crc32c.c                       | 18 ++++++++++++++++++
 lib/util/spdk_util.map                  |  1 +
 test/unit/lib/util/crc32c.c/crc32c_ut.c | 23 ++++++++++++++++++++++-
 7 files changed, 58 insertions(+), 31 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6b8e0b4fa..cbb545611 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -14,6 +14,11 @@ Updated DPDK submodule to DPDK 21.02.
 Remove the probe_cb parameter in spdk_idxd_probe function. And remove the definition
 of spdk_idxd_probe_cb function pointer. It should be implemented in idxd_user.c.
 
+### util
+
+`spdk_crc32c_iov_update` function was added to support calculating the crc32c of the
+iovs.
+
 ### nvmf
 
 Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the controller ID range.
diff --git a/examples/accel/perf/accel_perf.c b/examples/accel/perf/accel_perf.c
index 0dce1af4e..d2c52b8a6 100644
--- a/examples/accel/perf/accel_perf.c
+++ b/examples/accel/perf/accel_perf.c
@@ -559,20 +559,6 @@ batch_done(void *cb_arg, int status)
 	spdk_thread_send_msg(worker_batch->worker->thread, _batch_done, worker_batch);
 }
 
-static uint32_t
-_update_crc32c_iov(struct iovec *iov, int iovcnt, uint32_t crc32c)
-{
-	int i;
-
-	for (i = 0; i < iovcnt; i++) {
-		assert(iov[i].iov_base != NULL);
-		assert(iov[i].iov_len != 0);
-		crc32c = spdk_crc32c_update(iov[i].iov_base, iov[i].iov_len, crc32c);
-
-	}
-	return crc32c;
-}
-
 static void
 _accel_done(void *arg1)
 {
@@ -586,7 +572,7 @@ _accel_done(void *arg1)
 	if (g_verify && task->status == 0) {
 		switch (g_workload_selection) {
 		case ACCEL_CRC32C:
-			sw_crc32c = _update_crc32c_iov(task->iovs, task->iov_cnt, ~g_crc32c_seed);
+			sw_crc32c = spdk_crc32c_iov_update(task->iovs, task->iov_cnt, ~g_crc32c_seed);
 			if (*(uint32_t *)task->dst != sw_crc32c) {
 				SPDK_NOTICELOG("CRC-32C miscompare\n");
 				worker->xfer_failed++;
diff --git a/include/spdk/crc32.h b/include/spdk/crc32.h
index a2032a25e..5b6dbb4b7 100644
--- a/include/spdk/crc32.h
+++ b/include/spdk/crc32.h
@@ -66,6 +66,16 @@ uint32_t spdk_crc32_ieee_update(const void *buf, size_t len, uint32_t crc);
  */
 uint32_t spdk_crc32c_update(const void *buf, size_t len, uint32_t crc);
 
+/**
+ * Calculate a partial CRC-32C checksum.
+ *
+ * \param iov Data buffer vectors to checksum.
+ * \param iovcnt size of iov parameter.
+ * \param crc32c Previous CRC-32C value.
+ * \return Updated CRC-32C value.
+ */
+uint32_t spdk_crc32c_iov_update(struct iovec *iov, int iovcnt, uint32_t crc32c);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/spdk_internal/nvme_tcp.h b/include/spdk_internal/nvme_tcp.h
index 01f0ad8a1..bdd68c094 100644
--- a/include/spdk_internal/nvme_tcp.h
+++ b/include/spdk_internal/nvme_tcp.h
@@ -200,20 +200,6 @@ nvme_tcp_pdu_calc_header_digest(struct nvme_tcp_pdu *pdu)
 	return crc32c;
 }
 
-static uint32_t
-_update_crc32c_iov(struct iovec *iov, int iovcnt, uint32_t crc32c)
-{
-	int i;
-
-	for (i = 0; i < iovcnt; i++) {
-		assert(iov[i].iov_base != NULL);
-		assert(iov[i].iov_len != 0);
-		crc32c = spdk_crc32c_update(iov[i].iov_base, iov[i].iov_len, crc32c);
-	}
-
-	return crc32c;
-}
-
 static uint32_t
 nvme_tcp_pdu_calc_data_digest(struct nvme_tcp_pdu *pdu)
 {
@@ -223,7 +209,7 @@ nvme_tcp_pdu_calc_data_digest(struct nvme_tcp_pdu *pdu)
 	assert(pdu->data_len != 0);
 
 	if (spdk_likely(!pdu->dif_ctx)) {
-		crc32c = _update_crc32c_iov(pdu->data_iov, pdu->data_iovcnt, crc32c);
+		crc32c = spdk_crc32c_iov_update(pdu->data_iov, pdu->data_iovcnt, crc32c);
 	} else {
 		spdk_dif_update_crc32c_stream(pdu->data_iov, pdu->data_iovcnt,
 					      0, pdu->data_len, &crc32c, pdu->dif_ctx);
diff --git a/lib/util/crc32c.c b/lib/util/crc32c.c
index 9acd8d80f..685905229 100644
--- a/lib/util/crc32c.c
+++ b/lib/util/crc32c.c
@@ -131,3 +131,21 @@ spdk_crc32c_update(const void *buf, size_t len, uint32_t crc)
 }
 
 #endif
+
+uint32_t
+spdk_crc32c_iov_update(struct iovec *iov, int iovcnt, uint32_t crc32c)
+{
+	int i;
+
+	if (iov == NULL) {
+		return crc32c;
+	}
+
+	for (i = 0; i < iovcnt; i++) {
+		assert(iov[i].iov_base != NULL);
+		assert(iov[i].iov_len != 0);
+		crc32c = spdk_crc32c_update(iov[i].iov_base, iov[i].iov_len, crc32c);
+	}
+
+	return crc32c;
+}
diff --git a/lib/util/spdk_util.map b/lib/util/spdk_util.map
index f182f423f..88705e416 100644
--- a/lib/util/spdk_util.map
+++ b/lib/util/spdk_util.map
@@ -61,6 +61,7 @@
 	# public functions in crc32.h
 	spdk_crc32_ieee_update;
 	spdk_crc32c_update;
+	spdk_crc32c_iov_update;
 
 	# public functions in dif.h
 	spdk_dif_ctx_init;
diff --git a/test/unit/lib/util/crc32c.c/crc32c_ut.c b/test/unit/lib/util/crc32c.c/crc32c_ut.c
index 6313d7bf6..3b857bab2 100644
--- a/test/unit/lib/util/crc32c.c/crc32c_ut.c
+++ b/test/unit/lib/util/crc32c.c/crc32c_ut.c
@@ -42,7 +42,8 @@ static void
 test_crc32c(void)
 {
 	uint32_t crc;
-	char buf[1024];
+	char buf[1024], buf1[1024];
+	struct iovec iov[2] = {};
 
 	/* Verify a string's CRC32-C value against the known correct result. */
 	snprintf(buf, sizeof(buf), "%s", "Hello world!");
@@ -51,6 +52,26 @@ test_crc32c(void)
 	crc ^= 0xFFFFFFFFu;
 	CU_ASSERT(crc == 0x7b98e751);
 
+	crc = 0xFFFFFFFFu;
+	iov[0].iov_base = buf;
+	iov[0].iov_len = strlen(buf);
+	crc = spdk_crc32c_iov_update(iov, 1, crc);
+	crc ^= 0xFFFFFFFFu;
+	CU_ASSERT(crc == 0x7b98e751);
+
+	crc = 0xFFFFFFFFu;
+	snprintf(buf, sizeof(buf), "%s", "Hello");
+	iov[0].iov_base = buf;
+	iov[0].iov_len = strlen(buf);
+
+	snprintf(buf1, sizeof(buf1), "%s", " world!");
+	iov[1].iov_base = buf1;
+	iov[1].iov_len = strlen(buf1);
+
+	crc = spdk_crc32c_iov_update(iov, 2, crc);
+	crc ^= 0xFFFFFFFFu;
+	CU_ASSERT(crc == 0x7b98e751);
+
 	/*
 	 * The main loop of the optimized CRC32-C implementation processes data in 8-byte blocks,
 	 * followed by a loop to handle the 0-7 trailing bytes.
-- 
2.26.2


From f70180d50da3589e45cbfbd24304151bd273e927 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Thu, 20 May 2021 16:08:39 +0800
Subject: [PATCH 281/342] test/nvme_cuse: cases for cuse submitting io

Change-Id: I21f640c1d633884543961b382c400449caba241b
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6935
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c | 118 +++++++++++++++++-
 1 file changed, 112 insertions(+), 6 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
index 5079b8799..086b7f157 100644
--- a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
+++ b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
@@ -66,14 +66,8 @@ DEFINE_STUB(spdk_nvme_ns_cmd_write, int,
 DEFINE_STUB(spdk_nvme_ns_get_num_sectors, uint64_t,
 	    (struct spdk_nvme_ns *ns), 0);
 
-DEFINE_STUB(spdk_nvme_ns_get_sector_size, uint32_t,
-	    (struct spdk_nvme_ns *ns), 0);
-
 DEFINE_STUB_V(spdk_unaffinitize_thread, (void));
 
-DEFINE_STUB(spdk_nvme_ctrlr_get_ns, struct spdk_nvme_ns *,
-	    (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid), NULL);
-
 DEFINE_STUB(nvme_io_msg_ctrlr_register, int,
 	    (struct spdk_nvme_ctrlr *ctrlr,
 	     struct nvme_io_msg_producer *io_msg_producer), 0);
@@ -88,6 +82,8 @@ DEFINE_STUB(spdk_nvme_ctrlr_is_active_ns, bool,
 DEFINE_STUB(fuse_reply_err, int, (fuse_req_t req, int err), 0);
 
 struct cuse_io_ctx *g_ut_ctx;
+struct spdk_nvme_ctrlr *g_ut_ctrlr;
+uint32_t g_ut_nsid;
 
 uint32_t
 spdk_nvme_ctrlr_get_num_ns(struct spdk_nvme_ctrlr *ctrlr)
@@ -101,11 +97,29 @@ nvme_io_msg_send(struct spdk_nvme_ctrlr *ctrlr,
 		 uint32_t nsid, spdk_nvme_io_msg_fn fn, void *arg)
 {
 	g_ut_ctx = arg;
+	g_ut_nsid = nsid;
+	g_ut_ctrlr = ctrlr;
 
 	HANDLE_RETURN_MOCK(nvme_io_msg_send);
 	return 0;
 }
 
+uint32_t
+spdk_nvme_ns_get_sector_size(struct spdk_nvme_ns *ns)
+{
+	return ns->sector_size;
+}
+
+struct spdk_nvme_ns *
+spdk_nvme_ctrlr_get_ns(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)
+{
+	if (nsid < 1 || nsid > ctrlr->num_ns) {
+		return NULL;
+	}
+
+	return &ctrlr->ns[nsid - 1];
+}
+
 struct cuse_device *g_cuse_device;
 DEFINE_RETURN_MOCK(fuse_req_userdata, void *);
 void *
@@ -207,6 +221,7 @@ test_cuse_nvme_submit_passthru_cmd(void)
 
 	cuse_io_ctx_free(g_ut_ctx);
 	free(passthru_cmd);
+	free(g_cuse_device);
 }
 
 static void
@@ -240,6 +255,95 @@ test_nvme_cuse_get_cuse_ns_device(void)
 	TAILQ_REMOVE(&g_ctrlr_ctx_head, &ctrlr_device, tailq);
 }
 
+static void
+test_cuse_nvme_submit_io(void)
+{
+	struct cuse_device cuse_device = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct fuse_file_info fi = {};
+	struct spdk_nvme_ns ns = {};
+	struct nvme_user_io *user_io = NULL;
+	char arg[1024] = {};
+	fuse_req_t req = (void *)0xDEEACDFF;
+
+	/* Allocate memory to avoid stack buffer overflow */
+	user_io = calloc(3, 4096);
+	SPDK_CU_ASSERT_FATAL(user_io != NULL);
+
+	cuse_device.ctrlr = &ctrlr;
+	ctrlr.ns = &ns;
+	ctrlr.num_ns = 1;
+	ns.sector_size = 4096;
+	ns.id = 1;
+	user_io->slba = 1024;
+	user_io->nblocks = 1;
+	cuse_device.nsid = 1;
+	g_cuse_device = &cuse_device;
+
+	/* Read */
+	user_io->opcode = SPDK_NVME_OPC_READ;
+	g_ut_ctx = NULL;
+
+	cuse_nvme_submit_io(req, 0, arg, &fi, FUSE_IOCTL_DIR, user_io, 4096, 4096);
+	SPDK_CU_ASSERT_FATAL(g_ut_ctx != NULL);
+	CU_ASSERT(g_ut_nsid == 1);
+	CU_ASSERT(g_ut_ctx->req == (void *)0xDEEACDFF);
+	CU_ASSERT(g_ut_ctx->lba = 1024);
+	CU_ASSERT(g_ut_ctx->lba_count == 2);
+	CU_ASSERT(g_ut_ctx->data_len == 2 * 4096);
+	CU_ASSERT(g_ut_ctx->data != NULL);
+	cuse_io_ctx_free(g_ut_ctx);
+
+	/* Write */
+	user_io->opcode = SPDK_NVME_OPC_WRITE;
+	g_ut_ctx = NULL;
+
+	cuse_nvme_submit_io(req, 0, arg, &fi, FUSE_IOCTL_DIR, user_io, 4096, 4096);
+	SPDK_CU_ASSERT_FATAL(g_ut_ctx != NULL);
+	CU_ASSERT(g_ut_nsid == 1);
+	CU_ASSERT(g_ut_ctx->req == req);
+	CU_ASSERT(g_ut_ctx->lba = 1024);
+	CU_ASSERT(g_ut_ctx->lba_count == 2);
+	CU_ASSERT(g_ut_ctx->data_len == 2 * 4096);
+	CU_ASSERT(g_ut_ctx->data != NULL);
+	cuse_io_ctx_free(g_ut_ctx);
+
+	/* Invalid */
+	g_ut_ctx = NULL;
+	user_io->opcode = SPDK_NVME_OPC_FLUSH;
+
+	cuse_nvme_submit_io(req, 0, arg, &fi, FUSE_IOCTL_DIR, user_io, 4096, 4096);
+	SPDK_CU_ASSERT_FATAL(g_ut_ctx == NULL);
+
+	free(user_io);
+}
+
+static void
+test_cuse_nvme_reset(void)
+{
+	struct cuse_device cuse_device = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	fuse_req_t req = (void *)0xDEADBEEF;
+
+	cuse_device.ctrlr = &ctrlr;
+	g_cuse_device = &cuse_device;
+
+	/* Invalid nsid  */
+	cuse_device.nsid = 1;
+	g_ut_ctx = NULL;
+
+	cuse_nvme_reset(req, 0, NULL, NULL, 0, NULL, 4096, 4096);
+	CU_ASSERT(g_ut_ctx == NULL);
+
+	/* Valid nsid, check IO message sent value */
+	cuse_device.nsid = 0;
+
+	cuse_nvme_reset(req, 0, NULL, NULL, 0, NULL, 4096, 4096);
+	CU_ASSERT(g_ut_ctx == (void *)0xDEADBEEF);
+	CU_ASSERT(g_ut_ctrlr == &ctrlr);
+	CU_ASSERT(g_ut_nsid == 0);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -252,6 +356,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_cuse_nvme_submit_io_read_write);
 	CU_ADD_TEST(suite, test_cuse_nvme_submit_passthru_cmd);
 	CU_ADD_TEST(suite, test_nvme_cuse_get_cuse_ns_device);
+	CU_ADD_TEST(suite, test_cuse_nvme_submit_io);
+	CU_ADD_TEST(suite, test_cuse_nvme_reset);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From d4558c613214f04ad3ddaadfdb92d0dcb2e2a6d9 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Fri, 28 May 2021 10:49:18 +0900
Subject: [PATCH 282/342] bdev/nvme: Reduce conversion between spdk_bdev_io and
 nvme_bdev_io

We can hold bdev_io directly in nvme_bdev_ctrlr as an outstanding reset.

We can put spdk_bdev_io_from_ctx(bio) into a parameter for a few
functions because it is used only once in a function.

Passing not spdk_bdev_io but nvme_bdev_io to bdev_nvme_verify_pi_error()
remove unnecessary substitution.

This is a little more efficient and simplifies the implementation.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: If49ad9fa42abf27decf3afcd8c994f55faa3bc70
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8094
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/nvme/bdev_nvme.c                  | 48 ++++++++-----------
 module/bdev/nvme/common.h                     |  2 +-
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  | 11 ++---
 3 files changed, 26 insertions(+), 35 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index ef6b3415e..ba2f424c0 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -187,7 +187,7 @@ static int bdev_nvme_io_passthru_md(struct spdk_nvme_ns *ns, struct spdk_nvme_qp
 				    struct spdk_nvme_cmd *cmd, void *buf, size_t nbytes, void *md_buf, size_t md_len);
 static int bdev_nvme_abort(struct nvme_io_channel *nvme_ch,
 			   struct nvme_bdev_io *bio, struct nvme_bdev_io *bio_to_abort);
-static int bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio);
+static int bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct spdk_bdev_io *bdev_io);
 static int bdev_nvme_failover(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, bool remove);
 static void remove_cb(void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr);
 
@@ -255,16 +255,13 @@ static inline void
 bdev_nvme_io_complete_nvme_status(struct nvme_bdev_io *bio,
 				  const struct spdk_nvme_cpl *cpl)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
-
-	spdk_bdev_io_complete_nvme_status(bdev_io, cpl->cdw0, cpl->status.sct,
-					  cpl->status.sc);
+	spdk_bdev_io_complete_nvme_status(spdk_bdev_io_from_ctx(bio), cpl->cdw0,
+					  cpl->status.sct, cpl->status.sc);
 }
 
 static inline void
 bdev_nvme_io_complete(struct nvme_bdev_io *bio, int rc)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 	enum spdk_bdev_io_status io_status;
 
 	if (rc == 0) {
@@ -275,7 +272,7 @@ bdev_nvme_io_complete(struct nvme_bdev_io *bio, int rc)
 		io_status = SPDK_BDEV_IO_STATUS_FAILED;
 	}
 
-	spdk_bdev_io_complete(bdev_io, io_status);
+	spdk_bdev_io_complete(spdk_bdev_io_from_ctx(bio), io_status);
 }
 
 static void
@@ -489,7 +486,7 @@ bdev_nvme_abort_pending_resets(struct spdk_io_channel_iter *i)
 
 static void
 bdev_nvme_reset_io_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
-			    struct nvme_bdev_io *bio, int rc)
+			    struct spdk_bdev_io *bdev_io, int rc)
 {
 	enum spdk_bdev_io_status io_status = SPDK_BDEV_IO_STATUS_SUCCESS;
 
@@ -497,7 +494,7 @@ bdev_nvme_reset_io_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 		io_status = SPDK_BDEV_IO_STATUS_FAILED;
 	}
 
-	spdk_bdev_io_complete(spdk_bdev_io_from_ctx(bio), io_status);
+	spdk_bdev_io_complete(bdev_io, io_status);
 
 	/* Make sure we clear any pending resets before returning. */
 	spdk_for_each_channel(nvme_bdev_ctrlr,
@@ -511,9 +508,9 @@ static void
 _bdev_nvme_reset_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, int rc)
 {
 	struct nvme_bdev_ctrlr_trid *curr_trid;
-	struct nvme_bdev_io *bio = nvme_bdev_ctrlr->reset_bio;
+	struct spdk_bdev_io *bdev_io = nvme_bdev_ctrlr->reset_bdev_io;
 
-	nvme_bdev_ctrlr->reset_bio = NULL;
+	nvme_bdev_ctrlr->reset_bdev_io = NULL;
 
 	if (rc) {
 		SPDK_ERRLOG("Resetting controller failed.\n");
@@ -538,8 +535,8 @@ _bdev_nvme_reset_complete(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, int rc)
 
 	pthread_mutex_unlock(&nvme_bdev_ctrlr->mutex);
 
-	if (bio) {
-		bdev_nvme_reset_io_complete(nvme_bdev_ctrlr, bio, rc);
+	if (bdev_io) {
+		bdev_nvme_reset_io_complete(nvme_bdev_ctrlr, bdev_io, rc);
 	} else {
 		/* Make sure we clear any pending resets before returning. */
 		spdk_for_each_channel(nvme_bdev_ctrlr,
@@ -637,15 +634,14 @@ _bdev_nvme_reset(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr)
 }
 
 static int
-bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio)
+bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct spdk_bdev_io *bdev_io)
 {
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 	int rc;
 
 	rc = _bdev_nvme_reset(nvme_ch->ctrlr);
 	if (rc == 0) {
-		assert(nvme_ch->ctrlr->reset_bio == NULL);
-		nvme_ch->ctrlr->reset_bio = bio;
+		assert(nvme_ch->ctrlr->reset_bdev_io == NULL);
+		nvme_ch->ctrlr->reset_bdev_io = bdev_io;
 	} else if (rc == -EAGAIN) {
 		/*
 		 * Reset call is queued only if it is from the app framework. This is on purpose so that
@@ -767,7 +763,7 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 
 	ret = bdev_nvme_readv(nvme_ns->ns,
 			      qpair,
-			      (struct nvme_bdev_io *)bdev_io->driver_ctx,
+			      bio,
 			      bdev_io->u.bdev.iovs,
 			      bdev_io->u.bdev.iovcnt,
 			      bdev_io->u.bdev.md_buf,
@@ -859,7 +855,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 				     bdev_io->u.bdev.num_blocks);
 		break;
 	case SPDK_BDEV_IO_TYPE_RESET:
-		rc = bdev_nvme_reset(nvme_ch, nbdev_io);
+		rc = bdev_nvme_reset(nvme_ch, bdev_io);
 		break;
 	case SPDK_BDEV_IO_TYPE_FLUSH:
 		rc = bdev_nvme_flush(nvme_ns->ns,
@@ -2508,8 +2504,9 @@ bdev_nvme_library_fini(void)
 }
 
 static void
-bdev_nvme_verify_pi_error(struct spdk_bdev_io *bdev_io)
+bdev_nvme_verify_pi_error(struct nvme_bdev_io *bio)
 {
+	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 	struct spdk_bdev *bdev = bdev_io->bdev;
 	struct spdk_dif_ctx dif_ctx;
 	struct spdk_dif_error err_blk = {};
@@ -2549,11 +2546,10 @@ static void
 bdev_nvme_no_pi_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
 	struct nvme_bdev_io *bio = ref;
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	if (spdk_nvme_cpl_is_success(cpl)) {
 		/* Run PI verification for read data buffer. */
-		bdev_nvme_verify_pi_error(bdev_io);
+		bdev_nvme_verify_pi_error(bio);
 	}
 
 	/* Return original completion status */
@@ -2603,13 +2599,12 @@ static void
 bdev_nvme_writev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
 	struct nvme_bdev_io *bio = ref;
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	if (spdk_nvme_cpl_is_pi_error(cpl)) {
 		SPDK_ERRLOG("writev completed with PI error (sct=%d, sc=%d)\n",
 			    cpl->status.sct, cpl->status.sc);
 		/* Run PI verification for write data buffer if PI error is detected. */
-		bdev_nvme_verify_pi_error(bdev_io);
+		bdev_nvme_verify_pi_error(bio);
 	}
 
 	bdev_nvme_io_complete_nvme_status(bio, cpl);
@@ -2630,7 +2625,7 @@ bdev_nvme_zone_appendv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		SPDK_ERRLOG("zone append completed with PI error (sct=%d, sc=%d)\n",
 			    cpl->status.sct, cpl->status.sc);
 		/* Run PI verification for zone append data buffer if PI error is detected. */
-		bdev_nvme_verify_pi_error(bdev_io);
+		bdev_nvme_verify_pi_error(bio);
 	}
 
 	bdev_nvme_io_complete_nvme_status(bio, cpl);
@@ -2640,13 +2635,12 @@ static void
 bdev_nvme_comparev_done(void *ref, const struct spdk_nvme_cpl *cpl)
 {
 	struct nvme_bdev_io *bio = ref;
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 
 	if (spdk_nvme_cpl_is_pi_error(cpl)) {
 		SPDK_ERRLOG("comparev completed with PI error (sct=%d, sc=%d)\n",
 			    cpl->status.sct, cpl->status.sc);
 		/* Run PI verification for compare data buffer if PI error is detected. */
-		bdev_nvme_verify_pi_error(bdev_io);
+		bdev_nvme_verify_pi_error(bio);
 	}
 
 	bdev_nvme_io_complete_nvme_status(bio, cpl);
diff --git a/module/bdev/nvme/common.h b/module/bdev/nvme/common.h
index d5e306c9d..1128bccf3 100644
--- a/module/bdev/nvme/common.h
+++ b/module/bdev/nvme/common.h
@@ -107,7 +107,7 @@ struct nvme_bdev_ctrlr {
 
 	struct ocssd_bdev_ctrlr			*ocssd_ctrlr;
 
-	struct nvme_bdev_io			*reset_bio;
+	struct spdk_bdev_io			*reset_bdev_io;
 
 	/** linked list pointer for device list */
 	TAILQ_ENTRY(nvme_bdev_ctrlr)		tailq;
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index 271ad4bcf..32f2c5942 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -1343,7 +1343,6 @@ test_pending_reset(void)
 	const int STRING_SIZE = 32;
 	const char *attached_names[STRING_SIZE];
 	struct spdk_bdev_io *first_bdev_io, *second_bdev_io;
-	struct nvme_bdev_io *first_bio, *second_bio;
 	struct spdk_io_channel *ch1, *ch2;
 	struct nvme_io_channel *nvme_ch1, *nvme_ch2;
 	int rc;
@@ -1354,12 +1353,10 @@ test_pending_reset(void)
 	first_bdev_io = calloc(1, sizeof(struct spdk_bdev_io) + sizeof(struct nvme_bdev_io));
 	SPDK_CU_ASSERT_FATAL(first_bdev_io != NULL);
 	first_bdev_io->internal.status = SPDK_BDEV_IO_STATUS_FAILED;
-	first_bio = (struct nvme_bdev_io *)first_bdev_io->driver_ctx;
 
 	second_bdev_io = calloc(1, sizeof(struct spdk_bdev_io) + sizeof(struct nvme_bdev_io));
 	SPDK_CU_ASSERT_FATAL(second_bdev_io != NULL);
 	second_bdev_io->internal.status = SPDK_BDEV_IO_STATUS_FAILED;
-	second_bio = (struct nvme_bdev_io *)second_bdev_io->driver_ctx;
 
 	set_thread(0);
 
@@ -1394,14 +1391,14 @@ test_pending_reset(void)
 	/* The first reset request is submitted on thread 1, and the second reset request
 	 * is submitted on thread 0 while processing the first request.
 	 */
-	rc = bdev_nvme_reset(nvme_ch2, first_bio);
+	rc = bdev_nvme_reset(nvme_ch2, first_bdev_io);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(nvme_bdev_ctrlr->resetting == true);
 	CU_ASSERT(TAILQ_EMPTY(&nvme_ch2->pending_resets));
 
 	set_thread(0);
 
-	rc = bdev_nvme_reset(nvme_ch1, second_bio);
+	rc = bdev_nvme_reset(nvme_ch1, second_bdev_io);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(TAILQ_FIRST(&nvme_ch1->pending_resets) == second_bdev_io);
 
@@ -1419,14 +1416,14 @@ test_pending_reset(void)
 	 */
 	set_thread(1);
 
-	rc = bdev_nvme_reset(nvme_ch2, first_bio);
+	rc = bdev_nvme_reset(nvme_ch2, first_bdev_io);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(nvme_bdev_ctrlr->resetting == true);
 	CU_ASSERT(TAILQ_EMPTY(&nvme_ch2->pending_resets));
 
 	set_thread(0);
 
-	rc = bdev_nvme_reset(nvme_ch1, second_bio);
+	rc = bdev_nvme_reset(nvme_ch1, second_bdev_io);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(TAILQ_FIRST(&nvme_ch1->pending_resets) == second_bdev_io);
 
-- 
2.26.2


From a3f581e83b2c8239f85b8ad98019b28f1555a90a Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Sat, 29 May 2021 08:22:36 +0900
Subject: [PATCH 283/342] bdev/nvme: Inline nvme_bdev_to_bdev_ns() and remove
 it

It is unlikely that managing namespaces by nvme_bdev is complicated.
Hence we do not need the helper function nvme_bdev_to_bdev_ns().

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I77b4dcd12b2f2a219f58e5bc7b7e51dd10635da4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8118
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/nvme/bdev_nvme.c | 4 ++--
 module/bdev/nvme/common.h    | 6 ------
 2 files changed, 2 insertions(+), 8 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index ba2f424c0..8194efd3f 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -941,7 +941,7 @@ bdev_nvme_io_type_supported(void *ctx, enum spdk_bdev_io_type io_type)
 	struct spdk_nvme_ctrlr *ctrlr;
 	const struct spdk_nvme_ctrlr_data *cdata;
 
-	nvme_ns = nvme_bdev_to_bdev_ns(nbdev);
+	nvme_ns = nbdev->nvme_ns;
 	assert(nvme_ns != NULL);
 	ns = nvme_ns->ns;
 	ctrlr = spdk_nvme_ns_get_ctrlr(ns);
@@ -1179,7 +1179,7 @@ bdev_nvme_dump_info_json(void *ctx, struct spdk_json_write_ctx *w)
 	union spdk_nvme_csts_register csts;
 	char buf[128];
 
-	nvme_ns = nvme_bdev_to_bdev_ns(nvme_bdev);
+	nvme_ns = nvme_bdev->nvme_ns;
 	assert(nvme_ns != NULL);
 	ns = nvme_ns->ns;
 	ctrlr = spdk_nvme_ns_get_ctrlr(ns);
diff --git a/module/bdev/nvme/common.h b/module/bdev/nvme/common.h
index 1128bccf3..90e8e06df 100644
--- a/module/bdev/nvme/common.h
+++ b/module/bdev/nvme/common.h
@@ -199,10 +199,4 @@ bdev_nvme_find_admin_path(struct nvme_io_channel *nvme_ch,
 	return true;
 }
 
-static inline struct nvme_bdev_ns *
-nvme_bdev_to_bdev_ns(struct nvme_bdev *nbdev)
-{
-	return nbdev->nvme_ns;
-}
-
 #endif /* SPDK_COMMON_BDEV_NVME_H */
-- 
2.26.2


From a4f96d93a8a40af62816f6af629d63eaa88dba09 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 17 May 2021 13:43:20 +0900
Subject: [PATCH 284/342] nvme: Initialize ANA state to optimized if ANA
 reporting is not supported

Initialize ANA state of each namespace to optimized regardless of
whether ANA is supported or not. This will simplify the code to get
the optimal I/O path because we do not have to care if the namespace
supports ANA.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I24dfe08674af398671de6528b884e9d82409eeae
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7890
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/nvme/nvme_ctrlr.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 68ea3a072..dea7daa0a 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -800,6 +800,12 @@ nvme_ctrlr_set_supported_log_pages(struct spdk_nvme_ctrlr *ctrlr)
 			nvme_ctrlr_parse_ana_log_page(ctrlr, nvme_ctrlr_update_ns_ana_states,
 						      ctrlr);
 		}
+	} else {
+		uint32_t i;
+
+		for (i = 0; i < ctrlr->num_ns; i++) {
+			ctrlr->ns[i].ana_state = SPDK_NVME_ANA_OPTIMIZED_STATE;
+		}
 	}
 
 out:
-- 
2.26.2


From 5863f95ae4154eeaa4d599bd8cb94d7306ad22eb Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 31 May 2021 16:11:13 +0900
Subject: [PATCH 285/342] bdev/nvme: Submit abort command for admin command on
 the current thread

Previously only a single thread could submit abort commands for admin
commands and it was the thread of the corresponding controller.

When we support multipath, we need to traverse the list of controllers
to which the target admin command is submitted. Threads of controllers
may be different.

On the other hand, the previous implementation made the I/O flow very
clean, but the I/O flow will not be clean if there are many controllers
and the subsystem does not have its thread.

This patch changes the policy so that any SPDK thread can submit abort
commands for admin commands.

Then when multipath is supported, we will be able to traverse the
list of controllers simply on the current thread to abort either I/O
command or admin command.

We already are able to submit any admin command on any thread anytime
including abort command. Hence this will not cause any issue.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ib69de33f2e84b03861c7d95ce060035bdb589e4b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8121
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 module/bdev/nvme/bdev_nvme.c                  | 47 +++++---------
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  | 61 ++++++++++++-------
 2 files changed, 53 insertions(+), 55 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 8194efd3f..7d3c0dbd8 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -3326,34 +3326,6 @@ bdev_nvme_io_passthru_md(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 			(uint32_t)nbytes, md_buf, bdev_nvme_queued_done, bio);
 }
 
-static void
-bdev_nvme_abort_admin_cmd(void *ctx)
-{
-	struct nvme_bdev_io *bio = ctx;
-	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
-	struct nvme_io_channel *nvme_ch;
-	struct nvme_bdev_io *bio_to_abort;
-	int rc;
-
-	nvme_ch = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
-	bio_to_abort = (struct nvme_bdev_io *)bdev_io->u.abort.bio_to_abort->driver_ctx;
-
-	rc = spdk_nvme_ctrlr_cmd_abort_ext(nvme_ch->ctrlr->ctrlr,
-					   NULL,
-					   bio_to_abort,
-					   bdev_nvme_abort_done, bio);
-	if (rc == -ENOENT) {
-		/* If no admin command was found in admin qpair, complete the abort
-		 * request with failure.
-		 */
-		bio->cpl.cdw0 |= 1U;
-		bio->cpl.status.sc = SPDK_NVME_SC_SUCCESS;
-		bio->cpl.status.sct = SPDK_NVME_SCT_GENERIC;
-
-		spdk_thread_send_msg(bio->orig_thread, bdev_nvme_abort_completion, bio);
-	}
-}
-
 static int
 bdev_nvme_abort(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio,
 		struct nvme_bdev_io *bio_to_abort)
@@ -3368,11 +3340,22 @@ bdev_nvme_abort(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio,
 					   bdev_nvme_abort_done, bio);
 	if (rc == -ENOENT) {
 		/* If no command was found in I/O qpair, the target command may be
-		 * admin command. Only a single thread tries aborting admin command
-		 * to clean I/O flow.
+		 * admin command.
 		 */
-		spdk_thread_send_msg(nvme_ch->ctrlr->thread,
-				     bdev_nvme_abort_admin_cmd, bio);
+		rc = spdk_nvme_ctrlr_cmd_abort_ext(nvme_ch->ctrlr->ctrlr,
+						   NULL,
+						   bio_to_abort,
+						   bdev_nvme_abort_done, bio);
+	}
+
+	if (rc == -ENOENT) {
+		/* If no command was found, complete the abort request with failure. */
+		bio->cpl.cdw0 |= 1U;
+		bio->cpl.status.sc = SPDK_NVME_SC_SUCCESS;
+		bio->cpl.status.sct = SPDK_NVME_SCT_GENERIC;
+
+		bdev_nvme_abort_completion(bio);
+
 		rc = 0;
 	}
 
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index 32f2c5942..9ee358b17 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -1995,13 +1995,13 @@ test_abort(void)
 	const char *attached_names[STRING_SIZE];
 	struct nvme_bdev *bdev;
 	struct spdk_bdev_io *write_io, *admin_io, *abort_io;
-	struct spdk_io_channel *ch;
-	struct nvme_io_channel *nvme_ch;
+	struct spdk_io_channel *ch1, *ch2;
+	struct nvme_io_channel *nvme_ch1;
 	int rc;
 
 	/* Create ctrlr on thread 1 and submit I/O and admin requests to be aborted on
-	 * thread 0. Abort requests are submitted on thread 0. Aborting I/O requests are
-	 * done on thread 0 but aborting admin requests are done on thread 1.
+	 * thread 0. Aborting I/O requests are submitted on thread 0. Aborting admin requests
+	 * are submitted on thread 1. Both should succeed.
 	 */
 
 	ut_init_trid(&trid);
@@ -2027,8 +2027,6 @@ test_abort(void)
 	bdev = nvme_bdev_ctrlr->namespaces[0]->bdev;
 	SPDK_CU_ASSERT_FATAL(bdev != NULL);
 
-	set_thread(0);
-
 	write_io = calloc(1, sizeof(struct spdk_bdev_io) + sizeof(struct nvme_bdev_io));
 	SPDK_CU_ASSERT_FATAL(write_io != NULL);
 	write_io->bdev = &bdev->disk;
@@ -2046,17 +2044,23 @@ test_abort(void)
 	abort_io->bdev = &bdev->disk;
 	abort_io->type = SPDK_BDEV_IO_TYPE_ABORT;
 
-	ch = spdk_get_io_channel(nvme_bdev_ctrlr);
-	SPDK_CU_ASSERT_FATAL(ch != NULL);
-	nvme_ch = spdk_io_channel_get_ctx(ch);
+	set_thread(0);
 
-	write_io->internal.ch = (struct spdk_bdev_channel *)ch;
-	admin_io->internal.ch = (struct spdk_bdev_channel *)ch;
-	abort_io->internal.ch = (struct spdk_bdev_channel *)ch;
+	ch1 = spdk_get_io_channel(nvme_bdev_ctrlr);
+	SPDK_CU_ASSERT_FATAL(ch1 != NULL);
+	nvme_ch1 = spdk_io_channel_get_ctx(ch1);
+
+	set_thread(1);
+
+	ch2 = spdk_get_io_channel(nvme_bdev_ctrlr);
+	SPDK_CU_ASSERT_FATAL(ch2 != NULL);
+
+	write_io->internal.ch = (struct spdk_bdev_channel *)ch1;
+	abort_io->internal.ch = (struct spdk_bdev_channel *)ch1;
 
 	/* Aborting the already completed request should fail. */
 	write_io->internal.in_submit_request = true;
-	bdev_nvme_submit_request(ch, write_io);
+	bdev_nvme_submit_request(ch1, write_io);
 	poll_threads();
 
 	CU_ASSERT(write_io->internal.in_submit_request == false);
@@ -2064,7 +2068,7 @@ test_abort(void)
 	abort_io->u.abort.bio_to_abort = write_io;
 	abort_io->internal.in_submit_request = true;
 
-	bdev_nvme_submit_request(ch, abort_io);
+	bdev_nvme_submit_request(ch1, abort_io);
 
 	poll_threads();
 
@@ -2072,8 +2076,11 @@ test_abort(void)
 	CU_ASSERT(abort_io->internal.status == SPDK_BDEV_IO_STATUS_FAILED);
 	CU_ASSERT(ctrlr->adminq.num_outstanding_reqs == 0);
 
+	admin_io->internal.ch = (struct spdk_bdev_channel *)ch1;
+	abort_io->internal.ch = (struct spdk_bdev_channel *)ch2;
+
 	admin_io->internal.in_submit_request = true;
-	bdev_nvme_submit_request(ch, admin_io);
+	bdev_nvme_submit_request(ch1, admin_io);
 	spdk_delay_us(10000);
 	poll_threads();
 
@@ -2082,7 +2089,7 @@ test_abort(void)
 	abort_io->u.abort.bio_to_abort = admin_io;
 	abort_io->internal.in_submit_request = true;
 
-	bdev_nvme_submit_request(ch, abort_io);
+	bdev_nvme_submit_request(ch2, abort_io);
 
 	poll_threads();
 
@@ -2092,15 +2099,16 @@ test_abort(void)
 
 	/* Aborting the write request should succeed. */
 	write_io->internal.in_submit_request = true;
-	bdev_nvme_submit_request(ch, write_io);
+	bdev_nvme_submit_request(ch1, write_io);
 
 	CU_ASSERT(write_io->internal.in_submit_request == true);
-	CU_ASSERT(nvme_ch->qpair->num_outstanding_reqs == 1);
+	CU_ASSERT(nvme_ch1->qpair->num_outstanding_reqs == 1);
 
+	abort_io->internal.ch = (struct spdk_bdev_channel *)ch1;
 	abort_io->u.abort.bio_to_abort = write_io;
 	abort_io->internal.in_submit_request = true;
 
-	bdev_nvme_submit_request(ch, abort_io);
+	bdev_nvme_submit_request(ch1, abort_io);
 
 	spdk_delay_us(10000);
 	poll_threads();
@@ -2110,19 +2118,20 @@ test_abort(void)
 	CU_ASSERT(ctrlr->adminq.num_outstanding_reqs == 0);
 	CU_ASSERT(write_io->internal.in_submit_request == false);
 	CU_ASSERT(write_io->internal.status == SPDK_BDEV_IO_STATUS_ABORTED);
-	CU_ASSERT(nvme_ch->qpair->num_outstanding_reqs == 0);
+	CU_ASSERT(nvme_ch1->qpair->num_outstanding_reqs == 0);
 
 	/* Aborting the admin request should succeed. */
 	admin_io->internal.in_submit_request = true;
-	bdev_nvme_submit_request(ch, admin_io);
+	bdev_nvme_submit_request(ch1, admin_io);
 
 	CU_ASSERT(admin_io->internal.in_submit_request == true);
 	CU_ASSERT(ctrlr->adminq.num_outstanding_reqs == 1);
 
+	abort_io->internal.ch = (struct spdk_bdev_channel *)ch2;
 	abort_io->u.abort.bio_to_abort = admin_io;
 	abort_io->internal.in_submit_request = true;
 
-	bdev_nvme_submit_request(ch, abort_io);
+	bdev_nvme_submit_request(ch2, abort_io);
 
 	spdk_delay_us(10000);
 	poll_threads();
@@ -2134,7 +2143,13 @@ test_abort(void)
 	CU_ASSERT(admin_io->internal.status == SPDK_BDEV_IO_STATUS_ABORTED);
 	CU_ASSERT(ctrlr->adminq.num_outstanding_reqs == 0);
 
-	spdk_put_io_channel(ch);
+	set_thread(0);
+
+	spdk_put_io_channel(ch1);
+
+	set_thread(1);
+
+	spdk_put_io_channel(ch2);
 
 	poll_threads();
 
-- 
2.26.2


From fdc4c13e9e4249e1657736c3b7d64bcbf0cc27a4 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Mon, 31 May 2021 16:25:10 +0900
Subject: [PATCH 286/342] bdev/nvme: Rename nvme_io_channel by nvme_io_path

By the next patch, nvme_io_channel will be used as an I/O channel
to a single nvme_bdev. This channel is created to a single
nvme_bdev_ctrlr and has a corresponding I/O qpair. nvme_io_path
will be a better name especially when we support multipath.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ic34162f3c383676c5249396a09173329fc6febce
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8095
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/nvme/bdev_nvme.c                  | 150 +++++++++---------
 module/bdev/nvme/bdev_nvme.h                  |   2 +-
 module/bdev/nvme/bdev_ocssd.c                 |  34 ++--
 module/bdev/nvme/bdev_ocssd.h                 |   4 +-
 module/bdev/nvme/common.h                     |  12 +-
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  | 106 ++++++-------
 .../bdev/nvme/bdev_ocssd.c/bdev_ocssd_ut.c    |  10 +-
 7 files changed, 160 insertions(+), 158 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 7d3c0dbd8..67319ecbb 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -176,7 +176,7 @@ static int bdev_nvme_get_zone_info(struct spdk_nvme_ns *ns, struct spdk_nvme_qpa
 static int bdev_nvme_zone_management(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 				     struct nvme_bdev_io *bio, uint64_t zone_id,
 				     enum spdk_bdev_zone_action action);
-static int bdev_nvme_admin_passthru(struct nvme_io_channel *nvme_ch,
+static int bdev_nvme_admin_passthru(struct nvme_io_path *io_path,
 				    struct nvme_bdev_io *bio,
 				    struct spdk_nvme_cmd *cmd, void *buf, size_t nbytes);
 static int bdev_nvme_io_passthru(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
@@ -185,9 +185,9 @@ static int bdev_nvme_io_passthru(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair
 static int bdev_nvme_io_passthru_md(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 				    struct nvme_bdev_io *bio,
 				    struct spdk_nvme_cmd *cmd, void *buf, size_t nbytes, void *md_buf, size_t md_len);
-static int bdev_nvme_abort(struct nvme_io_channel *nvme_ch,
+static int bdev_nvme_abort(struct nvme_io_path *io_path,
 			   struct nvme_bdev_io *bio, struct nvme_bdev_io *bio_to_abort);
-static int bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct spdk_bdev_io *bdev_io);
+static int bdev_nvme_reset(struct nvme_io_path *io_path, struct spdk_bdev_io *bdev_io);
 static int bdev_nvme_failover(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr, bool remove);
 static void remove_cb(void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr);
 
@@ -223,15 +223,15 @@ static config_json_namespace_fn g_config_json_namespace_fn[] = {
 };
 
 struct spdk_nvme_qpair *
-bdev_nvme_get_io_qpair(struct spdk_io_channel *ctrlr_io_ch)
+bdev_nvme_get_io_qpair(struct spdk_io_channel *io_path_ch)
 {
-	struct nvme_io_channel *nvme_ch;
+	struct nvme_io_path *io_path;
 
-	assert(ctrlr_io_ch != NULL);
+	assert(io_path_ch != NULL);
 
-	nvme_ch = spdk_io_channel_get_ctx(ctrlr_io_ch);
+	io_path = spdk_io_channel_get_ctx(io_path_ch);
 
-	return nvme_ch->qpair;
+	return io_path->qpair;
 }
 
 static int
@@ -368,9 +368,9 @@ bdev_nvme_flush(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 }
 
 static int
-bdev_nvme_create_qpair(struct nvme_io_channel *nvme_ch)
+bdev_nvme_create_qpair(struct nvme_io_path *io_path)
 {
-	struct spdk_nvme_ctrlr *ctrlr = nvme_ch->ctrlr->ctrlr;
+	struct spdk_nvme_ctrlr *ctrlr = io_path->ctrlr->ctrlr;
 	struct spdk_nvme_io_qpair_opts opts;
 	struct spdk_nvme_qpair *qpair;
 	int rc;
@@ -386,9 +386,9 @@ bdev_nvme_create_qpair(struct nvme_io_channel *nvme_ch)
 		return -1;
 	}
 
-	assert(nvme_ch->group != NULL);
+	assert(io_path->group != NULL);
 
-	rc = spdk_nvme_poll_group_add(nvme_ch->group->group, qpair);
+	rc = spdk_nvme_poll_group_add(io_path->group->group, qpair);
 	if (rc != 0) {
 		SPDK_ERRLOG("Unable to begin polling on NVMe Channel.\n");
 		goto err;
@@ -400,7 +400,7 @@ bdev_nvme_create_qpair(struct nvme_io_channel *nvme_ch)
 		goto err;
 	}
 
-	nvme_ch->qpair = qpair;
+	io_path->qpair = qpair;
 
 	return 0;
 
@@ -411,17 +411,17 @@ err:
 }
 
 static int
-bdev_nvme_destroy_qpair(struct nvme_io_channel *nvme_ch)
+bdev_nvme_destroy_qpair(struct nvme_io_path *io_path)
 {
 	int rc;
 
-	if (nvme_ch->qpair == NULL) {
+	if (io_path->qpair == NULL) {
 		return 0;
 	}
 
-	rc = spdk_nvme_ctrlr_free_io_qpair(nvme_ch->qpair);
+	rc = spdk_nvme_ctrlr_free_io_qpair(io_path->qpair);
 	if (!rc) {
-		nvme_ch->qpair = NULL;
+		io_path->qpair = NULL;
 	}
 	return rc;
 }
@@ -450,14 +450,14 @@ bdev_nvme_check_pending_destruct(struct spdk_io_channel_iter *i, int status)
 }
 
 static void
-_bdev_nvme_complete_pending_resets(struct nvme_io_channel *nvme_ch,
+_bdev_nvme_complete_pending_resets(struct nvme_io_path *io_path,
 				   enum spdk_bdev_io_status status)
 {
 	struct spdk_bdev_io *bdev_io;
 
-	while (!TAILQ_EMPTY(&nvme_ch->pending_resets)) {
-		bdev_io = TAILQ_FIRST(&nvme_ch->pending_resets);
-		TAILQ_REMOVE(&nvme_ch->pending_resets, bdev_io, module_link);
+	while (!TAILQ_EMPTY(&io_path->pending_resets)) {
+		bdev_io = TAILQ_FIRST(&io_path->pending_resets);
+		TAILQ_REMOVE(&io_path->pending_resets, bdev_io, module_link);
 		spdk_bdev_io_complete(bdev_io, status);
 	}
 }
@@ -466,9 +466,9 @@ static void
 bdev_nvme_complete_pending_resets(struct spdk_io_channel_iter *i)
 {
 	struct spdk_io_channel *_ch = spdk_io_channel_iter_get_channel(i);
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(_ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(_ch);
 
-	_bdev_nvme_complete_pending_resets(nvme_ch, SPDK_BDEV_IO_STATUS_SUCCESS);
+	_bdev_nvme_complete_pending_resets(io_path, SPDK_BDEV_IO_STATUS_SUCCESS);
 
 	spdk_for_each_channel_continue(i, 0);
 }
@@ -477,9 +477,9 @@ static void
 bdev_nvme_abort_pending_resets(struct spdk_io_channel_iter *i)
 {
 	struct spdk_io_channel *_ch = spdk_io_channel_iter_get_channel(i);
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(_ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(_ch);
 
-	_bdev_nvme_complete_pending_resets(nvme_ch, SPDK_BDEV_IO_STATUS_FAILED);
+	_bdev_nvme_complete_pending_resets(io_path, SPDK_BDEV_IO_STATUS_FAILED);
 
 	spdk_for_each_channel_continue(i, 0);
 }
@@ -559,10 +559,10 @@ static void
 _bdev_nvme_reset_create_qpair(struct spdk_io_channel_iter *i)
 {
 	struct spdk_io_channel *_ch = spdk_io_channel_iter_get_channel(i);
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(_ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(_ch);
 	int rc;
 
-	rc = bdev_nvme_create_qpair(nvme_ch);
+	rc = bdev_nvme_create_qpair(io_path);
 
 	spdk_for_each_channel_continue(i, rc);
 }
@@ -598,10 +598,10 @@ static void
 _bdev_nvme_reset_destroy_qpair(struct spdk_io_channel_iter *i)
 {
 	struct spdk_io_channel *ch = spdk_io_channel_iter_get_channel(i);
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	int rc;
 
-	rc = bdev_nvme_destroy_qpair(nvme_ch);
+	rc = bdev_nvme_destroy_qpair(io_path);
 
 	spdk_for_each_channel_continue(i, rc);
 }
@@ -634,21 +634,21 @@ _bdev_nvme_reset(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr)
 }
 
 static int
-bdev_nvme_reset(struct nvme_io_channel *nvme_ch, struct spdk_bdev_io *bdev_io)
+bdev_nvme_reset(struct nvme_io_path *io_path, struct spdk_bdev_io *bdev_io)
 {
 	int rc;
 
-	rc = _bdev_nvme_reset(nvme_ch->ctrlr);
+	rc = _bdev_nvme_reset(io_path->ctrlr);
 	if (rc == 0) {
-		assert(nvme_ch->ctrlr->reset_bdev_io == NULL);
-		nvme_ch->ctrlr->reset_bdev_io = bdev_io;
+		assert(io_path->ctrlr->reset_bdev_io == NULL);
+		io_path->ctrlr->reset_bdev_io = bdev_io;
 	} else if (rc == -EAGAIN) {
 		/*
 		 * Reset call is queued only if it is from the app framework. This is on purpose so that
 		 * we don't interfere with the app framework reset strategy. i.e. we are deferring to the
 		 * upper level. If they are in the middle of a reset, we won't try to schedule another one.
 		 */
-		TAILQ_INSERT_TAIL(&nvme_ch->pending_resets, bdev_io, module_link);
+		TAILQ_INSERT_TAIL(&io_path->pending_resets, bdev_io, module_link);
 	} else {
 		return rc;
 	}
@@ -746,7 +746,7 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 	struct nvme_bdev_io *bio = (struct nvme_bdev_io *)bdev_io->driver_ctx;
 	struct spdk_bdev *bdev = bdev_io->bdev;
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev->ctxt;
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
 	int ret;
@@ -756,7 +756,7 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 		goto exit;
 	}
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair))) {
 		ret = -ENXIO;
 		goto exit;
 	}
@@ -780,7 +780,7 @@ exit:
 static void
 bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct spdk_bdev *bdev = bdev_io->bdev;
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev->ctxt;
 	struct nvme_bdev_io *nbdev_io = (struct nvme_bdev_io *)bdev_io->driver_ctx;
@@ -789,7 +789,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 	struct spdk_nvme_qpair *qpair;
 	int rc = 0;
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair))) {
 		rc = -ENXIO;
 		goto exit;
 	}
@@ -855,7 +855,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 				     bdev_io->u.bdev.num_blocks);
 		break;
 	case SPDK_BDEV_IO_TYPE_RESET:
-		rc = bdev_nvme_reset(nvme_ch, bdev_io);
+		rc = bdev_nvme_reset(io_path, bdev_io);
 		break;
 	case SPDK_BDEV_IO_TYPE_FLUSH:
 		rc = bdev_nvme_flush(nvme_ns->ns,
@@ -891,7 +891,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 					       bdev_io->u.zone_mgmt.zone_action);
 		break;
 	case SPDK_BDEV_IO_TYPE_NVME_ADMIN:
-		rc = bdev_nvme_admin_passthru(nvme_ch,
+		rc = bdev_nvme_admin_passthru(io_path,
 					      nbdev_io,
 					      &bdev_io->u.nvme_passthru.cmd,
 					      bdev_io->u.nvme_passthru.buf,
@@ -917,7 +917,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 		break;
 	case SPDK_BDEV_IO_TYPE_ABORT:
 		nbdev_io_to_abort = (struct nvme_bdev_io *)bdev_io->u.abort.bio_to_abort->driver_ctx;
-		rc = bdev_nvme_abort(nvme_ch,
+		rc = bdev_nvme_abort(io_path,
 				     nbdev_io,
 				     nbdev_io_to_abort);
 		break;
@@ -996,10 +996,10 @@ bdev_nvme_io_type_supported(void *ctx, enum spdk_bdev_io_type io_type)
 }
 
 static int
-bdev_nvme_create_cb(void *io_device, void *ctx_buf)
+bdev_nvme_create_path_cb(void *io_device, void *ctx_buf)
 {
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = io_device;
-	struct nvme_io_channel *nvme_ch = ctx_buf;
+	struct nvme_io_path *io_path = ctx_buf;
 	struct spdk_io_channel *pg_ch;
 	int rc;
 
@@ -1008,26 +1008,26 @@ bdev_nvme_create_cb(void *io_device, void *ctx_buf)
 		return -1;
 	}
 
-	nvme_ch->group = spdk_io_channel_get_ctx(pg_ch);
+	io_path->group = spdk_io_channel_get_ctx(pg_ch);
 
 #ifdef SPDK_CONFIG_VTUNE
-	nvme_ch->group->collect_spin_stat = true;
+	io_path->group->collect_spin_stat = true;
 #else
-	nvme_ch->group->collect_spin_stat = false;
+	io_path->group->collect_spin_stat = false;
 #endif
 
-	TAILQ_INIT(&nvme_ch->pending_resets);
+	TAILQ_INIT(&io_path->pending_resets);
 
 	if (spdk_nvme_ctrlr_is_ocssd_supported(nvme_bdev_ctrlr->ctrlr)) {
-		rc = bdev_ocssd_create_io_channel(nvme_ch);
+		rc = bdev_ocssd_create_io_channel(io_path);
 		if (rc != 0) {
 			goto err_ocssd_ch;
 		}
 	}
 
-	nvme_ch->ctrlr = nvme_bdev_ctrlr;
+	io_path->ctrlr = nvme_bdev_ctrlr;
 
-	rc = bdev_nvme_create_qpair(nvme_ch);
+	rc = bdev_nvme_create_qpair(io_path);
 	if (rc != 0) {
 		goto err_qpair;
 	}
@@ -1035,8 +1035,8 @@ bdev_nvme_create_cb(void *io_device, void *ctx_buf)
 	return 0;
 
 err_qpair:
-	if (nvme_ch->ocssd_ch) {
-		bdev_ocssd_destroy_io_channel(nvme_ch);
+	if (io_path->ocssd_ch) {
+		bdev_ocssd_destroy_io_channel(io_path);
 	}
 err_ocssd_ch:
 	spdk_put_io_channel(pg_ch);
@@ -1045,19 +1045,19 @@ err_ocssd_ch:
 }
 
 static void
-bdev_nvme_destroy_cb(void *io_device, void *ctx_buf)
+bdev_nvme_destroy_path_cb(void *io_device, void *ctx_buf)
 {
-	struct nvme_io_channel *nvme_ch = ctx_buf;
+	struct nvme_io_path *io_path = ctx_buf;
 
-	assert(nvme_ch->group != NULL);
+	assert(io_path->group != NULL);
 
-	if (nvme_ch->ocssd_ch != NULL) {
-		bdev_ocssd_destroy_io_channel(nvme_ch);
+	if (io_path->ocssd_ch != NULL) {
+		bdev_ocssd_destroy_io_channel(io_path);
 	}
 
-	bdev_nvme_destroy_qpair(nvme_ch);
+	bdev_nvme_destroy_qpair(io_path);
 
-	spdk_put_io_channel(spdk_io_channel_from_ctx(nvme_ch->group));
+	spdk_put_io_channel(spdk_io_channel_from_ctx(io_path->group));
 }
 
 static void
@@ -1294,8 +1294,8 @@ bdev_nvme_write_config_json(struct spdk_bdev *bdev, struct spdk_json_write_ctx *
 static uint64_t
 bdev_nvme_get_spin_time(struct spdk_io_channel *ch)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
-	struct nvme_bdev_poll_group *group = nvme_ch->group;
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
+	struct nvme_bdev_poll_group *group = io_path->group;
 	uint64_t spin_time;
 
 	if (!group || !group->collect_spin_stat) {
@@ -1832,8 +1832,10 @@ _nvme_bdev_ctrlr_create(struct spdk_nvme_ctrlr *ctrlr,
 
 	nvme_bdev_ctrlr->prchk_flags = prchk_flags;
 
-	spdk_io_device_register(nvme_bdev_ctrlr, bdev_nvme_create_cb, bdev_nvme_destroy_cb,
-				sizeof(struct nvme_io_channel),
+	spdk_io_device_register(nvme_bdev_ctrlr,
+				bdev_nvme_create_path_cb,
+				bdev_nvme_destroy_path_cb,
+				sizeof(struct nvme_io_path),
 				name);
 
 	nvme_bdev_ctrlr->adminq_timer_poller = SPDK_POLLER_REGISTER(bdev_nvme_poll_adminq, nvme_bdev_ctrlr,
@@ -2562,7 +2564,7 @@ bdev_nvme_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	struct nvme_bdev_io *bio = ref;
 	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
-	struct nvme_io_channel *nvme_ch;
+	struct nvme_io_path *io_path;
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
 	int ret;
@@ -2574,9 +2576,9 @@ bdev_nvme_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		/* Save completion status to use after verifying PI error. */
 		bio->cpl = *cpl;
 
-		nvme_ch = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
+		io_path = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
 
-		if (spdk_likely(bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair))) {
+		if (spdk_likely(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair))) {
 			/* Read without PI checking to verify PI error. */
 			ret = bdev_nvme_no_pi_readv(nvme_ns->ns,
 						    qpair,
@@ -2725,7 +2727,7 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
 	struct spdk_io_channel *ch = spdk_bdev_io_get_io_channel(bdev_io);
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	uint64_t zone_id = bdev_io->u.zone_mgmt.zone_id;
 	uint32_t zones_to_copy = bdev_io->u.zone_mgmt.num_zones;
 	struct spdk_bdev_zone_info *info = bdev_io->u.zone_mgmt.buf;
@@ -2739,7 +2741,7 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		goto out_complete_io_nvme_cpl;
 	}
 
-	if (!bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair)) {
+	if (!bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair)) {
 		ret = -ENXIO;
 		goto out_complete_io_ret;
 	}
@@ -3251,13 +3253,13 @@ bdev_nvme_zone_management(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair
 }
 
 static int
-bdev_nvme_admin_passthru(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio,
+bdev_nvme_admin_passthru(struct nvme_io_path *io_path, struct nvme_bdev_io *bio,
 			 struct spdk_nvme_cmd *cmd, void *buf, size_t nbytes)
 {
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr;
 	uint32_t max_xfer_size;
 
-	if (!bdev_nvme_find_admin_path(nvme_ch, &nvme_bdev_ctrlr)) {
+	if (!bdev_nvme_find_admin_path(io_path, &nvme_bdev_ctrlr)) {
 		return -EINVAL;
 	}
 
@@ -3327,22 +3329,22 @@ bdev_nvme_io_passthru_md(struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 }
 
 static int
-bdev_nvme_abort(struct nvme_io_channel *nvme_ch, struct nvme_bdev_io *bio,
+bdev_nvme_abort(struct nvme_io_path *io_path, struct nvme_bdev_io *bio,
 		struct nvme_bdev_io *bio_to_abort)
 {
 	int rc;
 
 	bio->orig_thread = spdk_get_thread();
 
-	rc = spdk_nvme_ctrlr_cmd_abort_ext(nvme_ch->ctrlr->ctrlr,
-					   nvme_ch->qpair,
+	rc = spdk_nvme_ctrlr_cmd_abort_ext(io_path->ctrlr->ctrlr,
+					   io_path->qpair,
 					   bio_to_abort,
 					   bdev_nvme_abort_done, bio);
 	if (rc == -ENOENT) {
 		/* If no command was found in I/O qpair, the target command may be
 		 * admin command.
 		 */
-		rc = spdk_nvme_ctrlr_cmd_abort_ext(nvme_ch->ctrlr->ctrlr,
+		rc = spdk_nvme_ctrlr_cmd_abort_ext(io_path->ctrlr->ctrlr,
 						   NULL,
 						   bio_to_abort,
 						   bdev_nvme_abort_done, bio);
diff --git a/module/bdev/nvme/bdev_nvme.h b/module/bdev/nvme/bdev_nvme.h
index 98a311a0a..5bfe1b545 100644
--- a/module/bdev/nvme/bdev_nvme.h
+++ b/module/bdev/nvme/bdev_nvme.h
@@ -63,7 +63,7 @@ struct spdk_bdev_nvme_opts {
 	bool delay_cmd_submit;
 };
 
-struct spdk_nvme_qpair *bdev_nvme_get_io_qpair(struct spdk_io_channel *ctrlr_io_ch);
+struct spdk_nvme_qpair *bdev_nvme_get_io_qpair(struct spdk_io_channel *io_path_ch);
 void bdev_nvme_get_opts(struct spdk_bdev_nvme_opts *opts);
 int bdev_nvme_set_opts(const struct spdk_bdev_nvme_opts *opts);
 int bdev_nvme_set_hotplug(bool enabled, uint64_t period_us, spdk_msg_fn cb, void *cb_ctx);
diff --git a/module/bdev/nvme/bdev_ocssd.c b/module/bdev/nvme/bdev_ocssd.c
index c2df83ad6..b28df317c 100644
--- a/module/bdev/nvme/bdev_ocssd.c
+++ b/module/bdev/nvme/bdev_ocssd.c
@@ -514,7 +514,7 @@ static void
 bdev_ocssd_io_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io, bool success)
 {
 	struct ocssd_bdev *ocssd_bdev = (struct ocssd_bdev *)bdev_io->bdev->ctxt;
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
 	int rc;
@@ -524,7 +524,7 @@ bdev_ocssd_io_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 		return;
 	}
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, nvme_ch,
+	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
 			  &nvme_ns, &qpair))) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
@@ -639,7 +639,7 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 	struct spdk_ocssd_chunk_information_entry *chunk_info = &ocdev_io->zone_info.chunk_info;
 	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(ctx);
 	struct ocssd_bdev *ocssd_bdev = bdev_io->bdev->ctxt;
-	struct nvme_io_channel *nvme_ch;
+	struct nvme_io_path *io_path;
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
 	struct bdev_ocssd_ns *ocssd_ns;
@@ -651,9 +651,9 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 		return;
 	}
 
-	nvme_ch = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
+	io_path = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, nvme_ch, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, io_path, &nvme_ns, &qpair))) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
 	}
@@ -741,14 +741,14 @@ static void bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bd
 static int
 bdev_ocssd_poll_pending(void *ctx)
 {
-	struct nvme_io_channel *nvme_ch = ctx;
+	struct nvme_io_path *io_path = ctx;
 	struct ocssd_io_channel *ocssd_ch;
 	struct spdk_bdev_io *bdev_io;
 	struct spdk_io_channel *ch;
 	TAILQ_HEAD(, spdk_bdev_io) pending_requests;
 	int num_requests = 0;
 
-	ocssd_ch = nvme_ch->ocssd_ch;
+	ocssd_ch = io_path->ocssd_ch;
 
 	TAILQ_INIT(&pending_requests);
 	TAILQ_SWAP(&ocssd_ch->pending_requests, &pending_requests, spdk_bdev_io, module_link);
@@ -770,8 +770,8 @@ bdev_ocssd_poll_pending(void *ctx)
 static void
 bdev_ocssd_delay_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
-	struct ocssd_io_channel *ocssd_ch = nvme_ch->ocssd_ch;
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
+	struct ocssd_io_channel *ocssd_ch = io_path->ocssd_ch;
 
 	TAILQ_INSERT_TAIL(&ocssd_ch->pending_requests, bdev_io, module_link);
 	spdk_poller_resume(ocssd_ch->pending_poller);
@@ -780,13 +780,13 @@ bdev_ocssd_delay_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 static int
 _bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct ocssd_bdev *ocssd_bdev = (struct ocssd_bdev *)bdev_io->bdev->ctxt;
 	struct bdev_ocssd_io *ocdev_io = (struct bdev_ocssd_io *)bdev_io->driver_ctx;
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, nvme_ch,
+	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
 			  &nvme_ns, &qpair))) {
 		return -1;
 	}
@@ -1496,7 +1496,7 @@ bdev_ocssd_depopulate_namespace(struct nvme_bdev_ns *nvme_ns)
 }
 
 int
-bdev_ocssd_create_io_channel(struct nvme_io_channel *nvme_ch)
+bdev_ocssd_create_io_channel(struct nvme_io_path *io_path)
 {
 	struct ocssd_io_channel *ocssd_ch;
 
@@ -1505,7 +1505,7 @@ bdev_ocssd_create_io_channel(struct nvme_io_channel *nvme_ch)
 		return -ENOMEM;
 	}
 
-	ocssd_ch->pending_poller = SPDK_POLLER_REGISTER(bdev_ocssd_poll_pending, nvme_ch, 0);
+	ocssd_ch->pending_poller = SPDK_POLLER_REGISTER(bdev_ocssd_poll_pending, io_path, 0);
 	if (ocssd_ch->pending_poller == NULL) {
 		SPDK_ERRLOG("Failed to register pending requests poller\n");
 		free(ocssd_ch);
@@ -1516,16 +1516,16 @@ bdev_ocssd_create_io_channel(struct nvme_io_channel *nvme_ch)
 	spdk_poller_pause(ocssd_ch->pending_poller);
 
 	TAILQ_INIT(&ocssd_ch->pending_requests);
-	nvme_ch->ocssd_ch = ocssd_ch;
+	io_path->ocssd_ch = ocssd_ch;
 
 	return 0;
 }
 
 void
-bdev_ocssd_destroy_io_channel(struct nvme_io_channel *nvme_ch)
+bdev_ocssd_destroy_io_channel(struct nvme_io_path *io_path)
 {
-	spdk_poller_unregister(&nvme_ch->ocssd_ch->pending_poller);
-	free(nvme_ch->ocssd_ch);
+	spdk_poller_unregister(&io_path->ocssd_ch->pending_poller);
+	free(io_path->ocssd_ch);
 }
 
 int
diff --git a/module/bdev/nvme/bdev_ocssd.h b/module/bdev/nvme/bdev_ocssd.h
index 81de06596..33783c34f 100644
--- a/module/bdev/nvme/bdev_ocssd.h
+++ b/module/bdev/nvme/bdev_ocssd.h
@@ -50,8 +50,8 @@ void bdev_ocssd_populate_namespace(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr,
 void bdev_ocssd_depopulate_namespace(struct nvme_bdev_ns *nvme_ns);
 void bdev_ocssd_namespace_config_json(struct spdk_json_write_ctx *w, struct nvme_bdev_ns *nvme_ns);
 
-int bdev_ocssd_create_io_channel(struct nvme_io_channel *ioch);
-void bdev_ocssd_destroy_io_channel(struct nvme_io_channel *ioch);
+int bdev_ocssd_create_io_channel(struct nvme_io_path *ioch);
+void bdev_ocssd_destroy_io_channel(struct nvme_io_path *ioch);
 
 int bdev_ocssd_init_ctrlr(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr);
 void bdev_ocssd_fini_ctrlr(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr);
diff --git a/module/bdev/nvme/common.h b/module/bdev/nvme/common.h
index 90e8e06df..7ac7089c4 100644
--- a/module/bdev/nvme/common.h
+++ b/module/bdev/nvme/common.h
@@ -154,7 +154,7 @@ struct nvme_async_probe_ctx {
 
 struct ocssd_io_channel;
 
-struct nvme_io_channel {
+struct nvme_io_path {
 	struct nvme_bdev_ctrlr		*ctrlr;
 	struct spdk_nvme_qpair		*qpair;
 	struct nvme_bdev_poll_group	*group;
@@ -178,24 +178,24 @@ void nvme_bdev_ctrlr_destruct(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr);
 void nvme_bdev_ctrlr_unregister(void *ctx);
 
 static inline bool
-bdev_nvme_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_channel *nvme_ch,
+bdev_nvme_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_path *io_path,
 		       struct nvme_bdev_ns **_nvme_ns, struct spdk_nvme_qpair **_qpair)
 {
-	if (spdk_unlikely(nvme_ch->qpair == NULL)) {
+	if (spdk_unlikely(io_path->qpair == NULL)) {
 		/* The device is currently resetting. */
 		return false;
 	}
 
 	*_nvme_ns = nbdev->nvme_ns;
-	*_qpair = nvme_ch->qpair;
+	*_qpair = io_path->qpair;
 	return true;
 }
 
 static inline bool
-bdev_nvme_find_admin_path(struct nvme_io_channel *nvme_ch,
+bdev_nvme_find_admin_path(struct nvme_io_path *io_path,
 			  struct nvme_bdev_ctrlr **_nvme_bdev_ctrlr)
 {
-	*_nvme_bdev_ctrlr = nvme_ch->ctrlr;
+	*_nvme_bdev_ctrlr = io_path->ctrlr;
 	return true;
 }
 
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index 9ee358b17..d2a0174b8 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -204,9 +204,9 @@ DEFINE_STUB_V(bdev_ocssd_depopulate_namespace, (struct nvme_bdev_ns *nvme_ns));
 DEFINE_STUB_V(bdev_ocssd_namespace_config_json, (struct spdk_json_write_ctx *w,
 		struct nvme_bdev_ns *nvme_ns));
 
-DEFINE_STUB(bdev_ocssd_create_io_channel, int, (struct nvme_io_channel *ioch), 0);
+DEFINE_STUB(bdev_ocssd_create_io_channel, int, (struct nvme_io_path *ioch), 0);
 
-DEFINE_STUB_V(bdev_ocssd_destroy_io_channel, (struct nvme_io_channel *ioch));
+DEFINE_STUB_V(bdev_ocssd_destroy_io_channel, (struct nvme_io_path *ioch));
 
 DEFINE_STUB(bdev_ocssd_init_ctrlr, int, (struct nvme_bdev_ctrlr *nvme_bdev_ctrlr), 0);
 
@@ -1016,7 +1016,7 @@ test_reset_ctrlr(void)
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = NULL;
 	struct nvme_bdev_ctrlr_trid *curr_trid;
 	struct spdk_io_channel *ch1, *ch2;
-	struct nvme_io_channel *nvme_ch1, *nvme_ch2;
+	struct nvme_io_path *io_path1, *io_path2;
 	int rc;
 
 	ut_init_trid(&trid);
@@ -1035,16 +1035,16 @@ test_reset_ctrlr(void)
 	ch1 = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch1 != NULL);
 
-	nvme_ch1 = spdk_io_channel_get_ctx(ch1);
-	CU_ASSERT(nvme_ch1->qpair != NULL);
+	io_path1 = spdk_io_channel_get_ctx(ch1);
+	CU_ASSERT(io_path1->qpair != NULL);
 
 	set_thread(1);
 
 	ch2 = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch2 != NULL);
 
-	nvme_ch2 = spdk_io_channel_get_ctx(ch2);
-	CU_ASSERT(nvme_ch2->qpair != NULL);
+	io_path2 = spdk_io_channel_get_ctx(ch2);
+	CU_ASSERT(io_path2->qpair != NULL);
 
 	/* Reset starts from thread 1. */
 	set_thread(1);
@@ -1070,28 +1070,28 @@ test_reset_ctrlr(void)
 	rc = _bdev_nvme_reset(nvme_bdev_ctrlr);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(nvme_bdev_ctrlr->resetting == true);
-	CU_ASSERT(nvme_ch1->qpair != NULL);
-	CU_ASSERT(nvme_ch2->qpair != NULL);
+	CU_ASSERT(io_path1->qpair != NULL);
+	CU_ASSERT(io_path2->qpair != NULL);
 
 	poll_thread_times(0, 1);
-	CU_ASSERT(nvme_ch1->qpair == NULL);
-	CU_ASSERT(nvme_ch2->qpair != NULL);
+	CU_ASSERT(io_path1->qpair == NULL);
+	CU_ASSERT(io_path2->qpair != NULL);
 
 	poll_thread_times(1, 1);
-	CU_ASSERT(nvme_ch1->qpair == NULL);
-	CU_ASSERT(nvme_ch2->qpair == NULL);
+	CU_ASSERT(io_path1->qpair == NULL);
+	CU_ASSERT(io_path2->qpair == NULL);
 	CU_ASSERT(ctrlr.is_failed == true);
 
 	poll_thread_times(1, 1);
 	CU_ASSERT(ctrlr.is_failed == false);
 
 	poll_thread_times(0, 1);
-	CU_ASSERT(nvme_ch1->qpair != NULL);
-	CU_ASSERT(nvme_ch2->qpair == NULL);
+	CU_ASSERT(io_path1->qpair != NULL);
+	CU_ASSERT(io_path2->qpair == NULL);
 
 	poll_thread_times(1, 1);
-	CU_ASSERT(nvme_ch1->qpair != NULL);
-	CU_ASSERT(nvme_ch2->qpair != NULL);
+	CU_ASSERT(io_path1->qpair != NULL);
+	CU_ASSERT(io_path2->qpair != NULL);
 	CU_ASSERT(nvme_bdev_ctrlr->resetting == true);
 	CU_ASSERT(curr_trid->is_failed == true);
 
@@ -1344,7 +1344,7 @@ test_pending_reset(void)
 	const char *attached_names[STRING_SIZE];
 	struct spdk_bdev_io *first_bdev_io, *second_bdev_io;
 	struct spdk_io_channel *ch1, *ch2;
-	struct nvme_io_channel *nvme_ch1, *nvme_ch2;
+	struct nvme_io_path *io_path1, *io_path2;
 	int rc;
 
 	memset(attached_names, 0, sizeof(char *) * STRING_SIZE);
@@ -1379,28 +1379,28 @@ test_pending_reset(void)
 	ch1 = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch1 != NULL);
 
-	nvme_ch1 = spdk_io_channel_get_ctx(ch1);
+	io_path1 = spdk_io_channel_get_ctx(ch1);
 
 	set_thread(1);
 
 	ch2 = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch2 != NULL);
 
-	nvme_ch2 = spdk_io_channel_get_ctx(ch2);
+	io_path2 = spdk_io_channel_get_ctx(ch2);
 
 	/* The first reset request is submitted on thread 1, and the second reset request
 	 * is submitted on thread 0 while processing the first request.
 	 */
-	rc = bdev_nvme_reset(nvme_ch2, first_bdev_io);
+	rc = bdev_nvme_reset(io_path2, first_bdev_io);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(nvme_bdev_ctrlr->resetting == true);
-	CU_ASSERT(TAILQ_EMPTY(&nvme_ch2->pending_resets));
+	CU_ASSERT(TAILQ_EMPTY(&io_path2->pending_resets));
 
 	set_thread(0);
 
-	rc = bdev_nvme_reset(nvme_ch1, second_bdev_io);
+	rc = bdev_nvme_reset(io_path1, second_bdev_io);
 	CU_ASSERT(rc == 0);
-	CU_ASSERT(TAILQ_FIRST(&nvme_ch1->pending_resets) == second_bdev_io);
+	CU_ASSERT(TAILQ_FIRST(&io_path1->pending_resets) == second_bdev_io);
 
 	poll_threads();
 
@@ -1416,16 +1416,16 @@ test_pending_reset(void)
 	 */
 	set_thread(1);
 
-	rc = bdev_nvme_reset(nvme_ch2, first_bdev_io);
+	rc = bdev_nvme_reset(io_path2, first_bdev_io);
 	CU_ASSERT(rc == 0);
 	CU_ASSERT(nvme_bdev_ctrlr->resetting == true);
-	CU_ASSERT(TAILQ_EMPTY(&nvme_ch2->pending_resets));
+	CU_ASSERT(TAILQ_EMPTY(&io_path2->pending_resets));
 
 	set_thread(0);
 
-	rc = bdev_nvme_reset(nvme_ch1, second_bdev_io);
+	rc = bdev_nvme_reset(io_path1, second_bdev_io);
 	CU_ASSERT(rc == 0);
-	CU_ASSERT(TAILQ_FIRST(&nvme_ch1->pending_resets) == second_bdev_io);
+	CU_ASSERT(TAILQ_FIRST(&io_path1->pending_resets) == second_bdev_io);
 
 	ctrlr->fail_reset = true;
 
@@ -1591,7 +1591,7 @@ test_reconnect_qpair(void)
 	struct spdk_nvme_ctrlr ctrlr = {};
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = NULL;
 	struct spdk_io_channel *ch;
-	struct nvme_io_channel *nvme_ch;
+	struct nvme_io_path *io_path;
 	int rc;
 
 	set_thread(0);
@@ -1607,26 +1607,26 @@ test_reconnect_qpair(void)
 	ch = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch != NULL);
 
-	nvme_ch = spdk_io_channel_get_ctx(ch);
-	CU_ASSERT(nvme_ch->qpair != NULL);
-	CU_ASSERT(nvme_ch->group != NULL);
-	CU_ASSERT(nvme_ch->group->group != NULL);
-	CU_ASSERT(nvme_ch->group->poller != NULL);
+	io_path = spdk_io_channel_get_ctx(ch);
+	CU_ASSERT(io_path->qpair != NULL);
+	CU_ASSERT(io_path->group != NULL);
+	CU_ASSERT(io_path->group->group != NULL);
+	CU_ASSERT(io_path->group->poller != NULL);
 
 	/* Test if the disconnected qpair is reconnected. */
-	nvme_ch->qpair->is_connected = false;
+	io_path->qpair->is_connected = false;
 
 	poll_threads();
 
-	CU_ASSERT(nvme_ch->qpair->is_connected == true);
+	CU_ASSERT(io_path->qpair->is_connected == true);
 
 	/* If the ctrlr is failed, reconnecting qpair should fail too. */
-	nvme_ch->qpair->is_connected = false;
+	io_path->qpair->is_connected = false;
 	ctrlr.is_failed = true;
 
 	poll_threads();
 
-	CU_ASSERT(nvme_ch->qpair->is_connected == false);
+	CU_ASSERT(io_path->qpair->is_connected == false);
 
 	spdk_put_io_channel(ch);
 
@@ -1721,12 +1721,12 @@ static void
 ut_test_submit_nvme_cmd(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 			enum spdk_bdev_io_type io_type)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
 	struct nvme_bdev_ns *nvme_ns = NULL;
 	struct spdk_nvme_qpair *qpair = NULL;
 
-	CU_ASSERT(bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair));
+	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair));
 
 	bdev_io->type = io_type;
 	bdev_io->internal.in_submit_request = true;
@@ -1747,12 +1747,12 @@ static void
 ut_test_submit_nop(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 		   enum spdk_bdev_io_type io_type)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
 	struct nvme_bdev_ns *nvme_ns = NULL;
 	struct spdk_nvme_qpair *qpair = NULL;
 
-	CU_ASSERT(bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair));
+	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair));
 
 	bdev_io->type = io_type;
 	bdev_io->internal.in_submit_request = true;
@@ -1767,14 +1767,14 @@ ut_test_submit_nop(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 static void
 ut_test_submit_fused_nvme_cmd(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
 {
-	struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
+	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev_io *bio = (struct nvme_bdev_io *)bdev_io->driver_ctx;
 	struct ut_nvme_req *req;
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
 	struct nvme_bdev_ns *nvme_ns = NULL;
 	struct spdk_nvme_qpair *qpair = NULL;
 
-	CU_ASSERT(bdev_nvme_find_io_path(nbdev, nvme_ch, &nvme_ns, &qpair));
+	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair));
 
 	/* Only compare and write now. */
 	bdev_io->type = SPDK_BDEV_IO_TYPE_COMPARE_AND_WRITE;
@@ -1787,7 +1787,7 @@ ut_test_submit_fused_nvme_cmd(struct spdk_io_channel *ch, struct spdk_bdev_io *b
 	CU_ASSERT(bio->first_fused_submitted == true);
 
 	/* First outstanding request is compare operation. */
-	req = TAILQ_FIRST(&nvme_ch->qpair->outstanding_reqs);
+	req = TAILQ_FIRST(&io_path->qpair->outstanding_reqs);
 	SPDK_CU_ASSERT_FATAL(req != NULL);
 	CU_ASSERT(req->opc == SPDK_NVME_OPC_COMPARE);
 	req->cpl.cdw0 = SPDK_NVME_OPC_COMPARE;
@@ -1996,7 +1996,7 @@ test_abort(void)
 	struct nvme_bdev *bdev;
 	struct spdk_bdev_io *write_io, *admin_io, *abort_io;
 	struct spdk_io_channel *ch1, *ch2;
-	struct nvme_io_channel *nvme_ch1;
+	struct nvme_io_path *io_path1;
 	int rc;
 
 	/* Create ctrlr on thread 1 and submit I/O and admin requests to be aborted on
@@ -2048,7 +2048,7 @@ test_abort(void)
 
 	ch1 = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch1 != NULL);
-	nvme_ch1 = spdk_io_channel_get_ctx(ch1);
+	io_path1 = spdk_io_channel_get_ctx(ch1);
 
 	set_thread(1);
 
@@ -2102,7 +2102,7 @@ test_abort(void)
 	bdev_nvme_submit_request(ch1, write_io);
 
 	CU_ASSERT(write_io->internal.in_submit_request == true);
-	CU_ASSERT(nvme_ch1->qpair->num_outstanding_reqs == 1);
+	CU_ASSERT(io_path1->qpair->num_outstanding_reqs == 1);
 
 	abort_io->internal.ch = (struct spdk_bdev_channel *)ch1;
 	abort_io->u.abort.bio_to_abort = write_io;
@@ -2118,7 +2118,7 @@ test_abort(void)
 	CU_ASSERT(ctrlr->adminq.num_outstanding_reqs == 0);
 	CU_ASSERT(write_io->internal.in_submit_request == false);
 	CU_ASSERT(write_io->internal.status == SPDK_BDEV_IO_STATUS_ABORTED);
-	CU_ASSERT(nvme_ch1->qpair->num_outstanding_reqs == 0);
+	CU_ASSERT(io_path1->qpair->num_outstanding_reqs == 0);
 
 	/* Aborting the admin request should succeed. */
 	admin_io->internal.in_submit_request = true;
@@ -2174,7 +2174,7 @@ test_get_io_qpair(void)
 	struct spdk_nvme_ctrlr ctrlr = {};
 	struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = NULL;
 	struct spdk_io_channel *ch;
-	struct nvme_io_channel *nvme_ch;
+	struct nvme_io_path *io_path;
 	struct spdk_nvme_qpair *qpair;
 	int rc;
 
@@ -2190,11 +2190,11 @@ test_get_io_qpair(void)
 
 	ch = spdk_get_io_channel(nvme_bdev_ctrlr);
 	SPDK_CU_ASSERT_FATAL(ch != NULL);
-	nvme_ch = spdk_io_channel_get_ctx(ch);
-	CU_ASSERT(nvme_ch->qpair != NULL);
+	io_path = spdk_io_channel_get_ctx(ch);
+	CU_ASSERT(io_path->qpair != NULL);
 
 	qpair = bdev_nvme_get_io_qpair(ch);
-	CU_ASSERT(qpair == nvme_ch->qpair);
+	CU_ASSERT(qpair == io_path->qpair);
 
 	spdk_put_io_channel(ch);
 
diff --git a/test/unit/lib/bdev/nvme/bdev_ocssd.c/bdev_ocssd_ut.c b/test/unit/lib/bdev/nvme/bdev_ocssd.c/bdev_ocssd_ut.c
index 91a573ace..9937fa6ea 100644
--- a/test/unit/lib/bdev/nvme/bdev_ocssd.c/bdev_ocssd_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_ocssd.c/bdev_ocssd_ut.c
@@ -885,7 +885,7 @@ test_get_zone_info(void)
 	struct spdk_bdev *bdev;
 	struct spdk_bdev_io *bdev_io;
 	struct spdk_io_channel *ch;
-	struct nvme_io_channel *nvme_ch;
+	struct nvme_io_path *io_path;
 #define MAX_ZONE_INFO_COUNT 64
 	struct spdk_bdev_zone_info zone_info[MAX_ZONE_INFO_COUNT];
 	struct spdk_ocssd_chunk_information_entry *chunk_info;
@@ -915,12 +915,12 @@ test_get_zone_info(void)
 	bdev = spdk_bdev_get_by_name(bdev_name);
 	SPDK_CU_ASSERT_FATAL(bdev != NULL);
 
-	ch = calloc(1, sizeof(*ch) + sizeof(*nvme_ch));
+	ch = calloc(1, sizeof(*ch) + sizeof(*io_path));
 	SPDK_CU_ASSERT_FATAL(ch != NULL);
 
-	nvme_ch = spdk_io_channel_get_ctx(ch);
-	nvme_ch->ctrlr = nvme_bdev_ctrlr;
-	nvme_ch->qpair = (struct spdk_nvme_qpair *)0x1;
+	io_path = spdk_io_channel_get_ctx(ch);
+	io_path->ctrlr = nvme_bdev_ctrlr;
+	io_path->qpair = (struct spdk_nvme_qpair *)0x1;
 
 	bdev_io = alloc_ocssd_io();
 	bdev_io->internal.cb = get_zone_info_cb;
-- 
2.26.2


From b70b16acba89013c07cc95f97f52b12364a34340 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 1 Jun 2021 20:02:25 +0800
Subject: [PATCH 287/342] nvmf: don't use request internal variable after
 req_complete callback

vfio-user transport `req_complete` callback will zero the internal
NVMe command and response fields, the common NVMf library should
not use them after the callback, so here we use stack variables
to save them before the `req_complete` callback.

Fix issue #1965.

Change-Id: Iff2342b6095d9496cdf112d657a0a99ce1fb5d12
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8129
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 lib/nvmf/ctrlr.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/lib/nvmf/ctrlr.c b/lib/nvmf/ctrlr.c
index a0b7a3306..4b98fe091 100644
--- a/lib/nvmf/ctrlr.c
+++ b/lib/nvmf/ctrlr.c
@@ -3579,10 +3579,13 @@ _nvmf_request_complete(void *ctx)
 	bool is_aer = false;
 	uint32_t nsid;
 	bool paused;
+	uint8_t opcode;
 
 	rsp->sqid = 0;
 	rsp->status.p = 0;
 	rsp->cid = req->cmd->nvme_cmd.cid;
+	nsid = req->cmd->nvme_cmd.nsid;
+	opcode = req->cmd->nvmf_cmd.opcode;
 
 	qpair = req->qpair;
 	if (qpair->ctrlr) {
@@ -3615,13 +3618,11 @@ _nvmf_request_complete(void *ctx)
 
 	/* AER cmd is an exception */
 	if (sgroup && !is_aer) {
-		if (spdk_unlikely(req->cmd->nvmf_cmd.opcode == SPDK_NVME_OPC_FABRIC ||
+		if (spdk_unlikely(opcode == SPDK_NVME_OPC_FABRIC ||
 				  nvmf_qpair_is_admin_queue(qpair))) {
 			assert(sgroup->mgmt_io_outstanding > 0);
 			sgroup->mgmt_io_outstanding--;
 		} else {
-			nsid = req->cmd->nvme_cmd.nsid;
-
 			/* NOTE: This implicitly also checks for 0, since 0 - 1 wraps around to UINT32_MAX. */
 			if (spdk_likely(nsid - 1 < sgroup->num_ns)) {
 				sgroup->ns_info[nsid - 1].io_outstanding--;
-- 
2.26.2


From 5b532e80c8f775a431762eceb7bc267e237ebe41 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Mon, 31 May 2021 22:00:14 +0800
Subject: [PATCH 288/342] test/vfio-user: add `subnqn` for all vfio-user tests

After commit a31e319f "nvme: init discovery ctrlr using nvme_ctrlr_process_init"
SPDK will not initialize vfio-user subsystem if we didn't specify it
in the command line, so add this parameter as other transports already use it.

Change-Id: I5331459e9a88d8d94fa8b6ce693e086516b9f0bc
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8120
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 test/nvmf/target/nvmf_vfio_user.sh | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/test/nvmf/target/nvmf_vfio_user.sh b/test/nvmf/target/nvmf_vfio_user.sh
index f74274236..2cd87079f 100755
--- a/test/nvmf/target/nvmf_vfio_user.sh
+++ b/test/nvmf/target/nvmf_vfio_user.sh
@@ -39,13 +39,13 @@ for i in $(seq 1 $NUM_DEVICES); do
 done
 
 for i in $(seq 1 $NUM_DEVICES); do
-	$SPDK_EXAMPLE_DIR/identify -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i" -g -L nvme -L nvme_vfio -L vfio_pci
+	$SPDK_EXAMPLE_DIR/identify -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i subnqn:nqn.2019-07.io.spdk:cnode$i" -g -L nvme -L nvme_vfio -L vfio_pci
 	sleep 1
-	$SPDK_EXAMPLE_DIR/perf -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i" -s 256 -g -q 128 -o 4096 -w read -t 5 -c 0x2
+	$SPDK_EXAMPLE_DIR/perf -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i subnqn:nqn.2019-07.io.spdk:cnode$i" -s 256 -g -q 128 -o 4096 -w read -t 5 -c 0x2
 	sleep 1
-	$SPDK_EXAMPLE_DIR/perf -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i" -s 256 -g -q 128 -o 4096 -w write -t 5 -c 0x2
+	$SPDK_EXAMPLE_DIR/perf -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i subnqn:nqn.2019-07.io.spdk:cnode$i" -s 256 -g -q 128 -o 4096 -w write -t 5 -c 0x2
 	sleep 1
-	$SPDK_EXAMPLE_DIR/reconnect -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i" -g -q 32 -o 4096 -w randrw -M 50 -t 5 -c 0xE
+	$SPDK_EXAMPLE_DIR/reconnect -r "trtype:VFIOUSER traddr:/var/run/muser/domain/muser$i/$i subnqn:nqn.2019-07.io.spdk:cnode$i" -g -q 32 -o 4096 -w randrw -M 50 -t 5 -c 0xE
 	sleep 1
 done
 
-- 
2.26.2


From c52e7007748b7f555a8ac42e02111abdd0f780f2 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Fri, 28 May 2021 22:53:39 +0800
Subject: [PATCH 289/342] libvfio-user: update submodule

1. struct pxdcap.per is changed to struct pxdcap.rer
Which matches the name in the nvme spec.
2. use new API return value.
3. update specification changes.

Signed-off-by: Swapnil Ingle <swapnil.ingle@nutanix.com>
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Change-Id: Ida421c4cffd1c65d550e83011ab123b321ea9dff
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8088
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 include/spdk/vfio_user_spec.h | 91 +++++++++++++++++++++++++----------
 lib/nvmf/vfio_user.c          |  4 +-
 lib/vfio_user/vfio_user.c     | 26 ++++++----
 libvfio-user                  |  2 +-
 4 files changed, 86 insertions(+), 37 deletions(-)

diff --git a/include/spdk/vfio_user_spec.h b/include/spdk/vfio_user_spec.h
index 9c2ee4bef..f59b72a57 100644
--- a/include/spdk/vfio_user_spec.h
+++ b/include/spdk/vfio_user_spec.h
@@ -36,30 +36,34 @@
 
 #include "spdk/stdinc.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 enum vfio_user_command {
 	VFIO_USER_VERSION			= 1,
 	VFIO_USER_DMA_MAP			= 2,
 	VFIO_USER_DMA_UNMAP			= 3,
 	VFIO_USER_DEVICE_GET_INFO		= 4,
 	VFIO_USER_DEVICE_GET_REGION_INFO	= 5,
-	VFIO_USER_DEVICE_GET_IRQ_INFO		= 6,
-	VFIO_USER_DEVICE_SET_IRQS		= 7,
-	VFIO_USER_REGION_READ			= 8,
-	VFIO_USER_REGION_WRITE			= 9,
-	VFIO_USER_DMA_READ			= 10,
-	VFIO_USER_DMA_WRITE			= 11,
-	VFIO_USER_VM_INTERRUPT			= 12,
+	VFIO_USER_DEVICE_GET_REGION_IO_FDS	= 6,
+	VFIO_USER_DEVICE_GET_IRQ_INFO		= 7,
+	VFIO_USER_DEVICE_SET_IRQS		= 8,
+	VFIO_USER_REGION_READ			= 9,
+	VFIO_USER_REGION_WRITE			= 10,
+	VFIO_USER_DMA_READ			= 11,
+	VFIO_USER_DMA_WRITE			= 12,
 	VFIO_USER_DEVICE_RESET			= 13,
 	VFIO_USER_DIRTY_PAGES			= 14,
 	VFIO_USER_MAX,
 };
 
 enum vfio_user_message_type {
-	VFIO_USER_MESSAGE_COMMAND		= 0,
-	VFIO_USER_MESSAGE_REPLY			= 1,
+	VFIO_USER_MESSAGE_COMMAND	= 0,
+	VFIO_USER_MESSAGE_REPLY		= 1,
 };
 
-#define VFIO_USER_FLAGS_NO_REPLY		(0x1)
+#define VFIO_USER_FLAGS_NO_REPLY	(0x1)
 
 struct vfio_user_header {
 	uint16_t	msg_id;
@@ -67,8 +71,8 @@ struct vfio_user_header {
 	uint32_t	msg_size;
 	struct {
 		uint32_t	type     : 4;
-#define VFIO_USER_F_TYPE_COMMAND    0
-#define VFIO_USER_F_TYPE_REPLY      1
+#define VFIO_USER_F_TYPE_COMMAND	0
+#define VFIO_USER_F_TYPE_REPLY		1
 		uint32_t	no_reply : 1;
 		uint32_t	error    : 1;
 		uint32_t	resvd    : 26;
@@ -82,23 +86,48 @@ struct vfio_user_version {
 	uint8_t		data[];
 } __attribute__((packed));
 
+/*
+ * Similar to vfio_device_info, but without caps (yet).
+ */
 struct vfio_user_device_info {
-	uint32_t    argsz;
+	uint32_t	argsz;
 	/* VFIO_DEVICE_FLAGS_* */
-	uint32_t    flags;
-	uint32_t    num_regions;
-	uint32_t    num_irqs;
+	uint32_t	flags;
+	uint32_t	num_regions;
+	uint32_t	num_irqs;
 } __attribute__((packed));
 
-struct vfio_user_dma_region {
-	uint64_t	addr;
+/* based on struct vfio_bitmap */
+struct vfio_user_bitmap {
+	uint64_t	pgsize;
 	uint64_t	size;
-	uint64_t	offset;
-	uint32_t	prot;
+	char		data[];
+} __attribute__((packed));
+
+/* based on struct vfio_iommu_type1_dma_map */
+struct vfio_user_dma_map {
+	uint32_t	argsz;
+#define VFIO_USER_F_DMA_REGION_READ	(1 << 0)
+#define VFIO_USER_F_DMA_REGION_WRITE	(1 << 1)
+#define VFIO_USER_F_DMA_REGION_MAPPABLE	(1 << 2)
 	uint32_t	flags;
-#define VFIO_USER_F_DMA_REGION_MAPPABLE (1 << 0)
+	uint64_t	offset;
+	uint64_t	addr;
+	uint64_t	size;
 } __attribute__((packed));
 
+/* based on struct vfio_iommu_type1_dma_unmap */
+struct vfio_user_dma_unmap {
+	uint32_t	argsz;
+#ifndef VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP
+#define VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP	(1 << 0)
+#endif
+	uint32_t	flags;
+	uint64_t	addr;
+	uint64_t	size;
+	struct vfio_user_bitmap	bitmap[];
+};
+
 struct vfio_user_region_access {
 	uint64_t	offset;
 	uint32_t	region;
@@ -107,13 +136,25 @@ struct vfio_user_region_access {
 } __attribute__((packed));
 
 struct vfio_user_dma_region_access {
-	uint64_t    addr;
-	uint64_t    count;
-	uint8_t     data[];
+	uint64_t	addr;
+	uint64_t	count;
+	uint8_t		data[];
 } __attribute__((packed));
 
 struct vfio_user_irq_info {
-	uint32_t    subindex;
+	uint32_t	subindex;
 } __attribute__((packed));
 
+/* based on struct vfio_iommu_type1_dirty_bitmap_get */
+struct vfio_user_bitmap_range {
+	uint64_t	iova;
+	uint64_t	size;
+	struct vfio_user_bitmap	bitmap;
+} __attribute__((packed));
+
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif
diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index e0a9aeaba..fdf518b1a 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -398,7 +398,7 @@ map_one(vfu_ctx_t *ctx, uint64_t addr, uint64_t len, dma_sg_t *sg, struct iovec
 	assert(iov != NULL);
 
 	ret = vfu_addr_to_sg(ctx, (void *)(uintptr_t)addr, len, sg, 1, PROT_READ | PROT_WRITE);
-	if (ret != 1) {
+	if (ret < 0) {
 		return NULL;
 	}
 
@@ -1478,7 +1478,7 @@ vfio_user_dev_info_fill(struct nvmf_vfio_user_transport *vu_transport,
 	struct pxcap pxcap = {
 		.hdr.id = PCI_CAP_ID_EXP,
 		.pxcaps.ver = 0x2,
-		.pxdcap = {.per = 0x1, .flrc = 0x1},
+		.pxdcap = {.rer = 0x1, .flrc = 0x1},
 		.pxdcap2.ctds = 0x1
 	};
 
diff --git a/lib/vfio_user/vfio_user.c b/lib/vfio_user/vfio_user.c
index eed6c1576..0a691535e 100644
--- a/lib/vfio_user/vfio_user.c
+++ b/lib/vfio_user/vfio_user.c
@@ -296,18 +296,26 @@ vfio_user_get_dev_info(struct vfio_device *dev, struct vfio_user_device_info *de
 int
 vfio_user_dev_dma_map_unmap(struct vfio_device *dev, struct vfio_memory_region *mr, bool map)
 {
-	struct vfio_user_dma_region region = { 0 };
+	struct vfio_user_dma_map dma_map = { 0 };
+	struct vfio_user_dma_unmap dma_unmap = { 0 };
 
-	region.addr = mr->iova;
-	region.size = mr->size;
-	region.offset = mr->offset;
 	if (map) {
-		region.flags = VFIO_USER_F_DMA_REGION_MAPPABLE;
-		region.prot = PROT_READ | PROT_WRITE;
+		dma_map.argsz = sizeof(struct vfio_user_dma_map);
+		dma_map.addr = mr->iova;
+		dma_map.size = mr->size;
+		dma_map.offset = mr->offset;
+		dma_map.flags = VFIO_USER_F_DMA_REGION_READ | VFIO_USER_F_DMA_REGION_WRITE |
+				VFIO_USER_F_DMA_REGION_MAPPABLE;
+
+		return vfio_user_dev_send_request(dev, VFIO_USER_DMA_MAP,
+						  &dma_map, sizeof(dma_map), sizeof(dma_map), &mr->fd, 1);
+	} else {
+		dma_unmap.argsz = sizeof(struct vfio_user_dma_unmap);
+		dma_unmap.addr = mr->iova;
+		dma_unmap.size = mr->size;
+		return vfio_user_dev_send_request(dev, VFIO_USER_DMA_UNMAP,
+						  &dma_unmap, sizeof(dma_unmap), sizeof(dma_unmap), &mr->fd, 1);
 	}
-
-	return vfio_user_dev_send_request(dev, map ? VFIO_USER_DMA_MAP : VFIO_USER_DMA_UNMAP,
-					  &region, sizeof(region), sizeof(region), &mr->fd, 1);
 }
 
 int
diff --git a/libvfio-user b/libvfio-user
index 7443fbedd..8ac2360a8 160000
--- a/libvfio-user
+++ b/libvfio-user
@@ -1 +1 @@
-Subproject commit 7443fbedd1f94288fbe0d3563b72c4938aa9ff2f
+Subproject commit 8ac2360a8aefbd2dd11c65f2b2e21565c36c0ee6
-- 
2.26.2


From 2e8ae7294ab41d477986430731f8bc21b8fc7605 Mon Sep 17 00:00:00 2001
From: paul luse <paul.e.luse@intel.com>
Date: Wed, 2 Jun 2021 13:23:57 -0400
Subject: [PATCH 290/342] lib/idxd: stop polling on the first uncompleted
 location

We already keep a list of outstanding completion locations to
poll and were previously polling all of them.  New ones are
added at the tail and we poll the oldest first from the head
so if we break when we find a slot that hasn't completed we
can get more work done while the HW finishes. This is a proven
performance improvement in limited testing.

Signed-off-by: paul luse <paul.e.luse@intel.com>
Change-Id: Icc15041605586f9a31435d447d253c381c00b1f8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8161
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
---
 lib/idxd/idxd.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/lib/idxd/idxd.c b/lib/idxd/idxd.c
index 1b58955d2..9d85a4518 100644
--- a/lib/idxd/idxd.c
+++ b/lib/idxd/idxd.c
@@ -1070,6 +1070,13 @@ spdk_idxd_process_events(struct spdk_idxd_io_channel *chan)
 					_free_batch(comp_ctx->batch, chan);
 				}
 			}
+		} else {
+			/*
+			 * oldest locations are at the head of the list so if
+			 * we've polled a location that hasn't completed, bail
+			 * now as there are unlikely to be any more completions.
+			 */
+			break;
 		}
 	}
 	return rc;
-- 
2.26.2


From 3e2e2a57659d268679b128fd64e214397830a7fa Mon Sep 17 00:00:00 2001
From: paul luse <paul.e.luse@intel.com>
Date: Wed, 2 Jun 2021 13:29:52 -0400
Subject: [PATCH 291/342] examples/accel_perf: don't schedule final callback
 when using HW

This results in a significant performance improvement when using
HW offload engines.

Signed-off-by: paul luse <paul.e.luse@intel.com>
Change-Id: I54d3e39f186c9f878fcf8bed8e9242e29d1e1bf1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8162
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
---
 examples/accel/perf/accel_perf.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/examples/accel/perf/accel_perf.c b/examples/accel/perf/accel_perf.c
index d2c52b8a6..c276d4078 100644
--- a/examples/accel/perf/accel_perf.c
+++ b/examples/accel/perf/accel_perf.c
@@ -44,6 +44,7 @@
 #define DATA_PATTERN 0x5a
 #define ALIGN_4K 0x1000
 
+static bool g_using_sw_engine = false;
 static uint64_t	g_tsc_rate;
 static uint64_t g_tsc_end;
 static int g_rc;
@@ -894,7 +895,11 @@ accel_done(void *cb_arg, int status)
 	assert(worker);
 
 	task->status = status;
-	spdk_thread_send_msg(worker->thread, _accel_done, task);
+	if (g_using_sw_engine == false) {
+		_accel_done(task);
+	} else {
+		spdk_thread_send_msg(worker->thread, _accel_done, task);
+	}
 }
 
 static void
@@ -913,6 +918,7 @@ accel_perf_start(void *arg1)
 	spdk_put_io_channel(accel_ch);
 
 	if ((g_capabilites & g_workload_selection) != g_workload_selection) {
+		g_using_sw_engine = true;
 		SPDK_WARNLOG("The selected workload is not natively supported by the current engine\n");
 		SPDK_WARNLOG("The software engine will be used instead.\n\n");
 	}
-- 
2.26.2


From f31ad9b6f1feecea83102e5bf04d086c5fb6be32 Mon Sep 17 00:00:00 2001
From: paul luse <paul.e.luse@intel.com>
Date: Thu, 3 Jun 2021 09:25:43 -0400
Subject: [PATCH 292/342] lib/idxd: add cache control flag to op codes that
 support it

Perf improvement, directs DSA to write to cache as opposed to
mem.

Signed-off-by: paul luse <paul.e.luse@intel.com>
Change-Id: I0d6ba157af8f1b54f8aae3b8e54a6f7754e4a9de
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8169
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/idxd/idxd.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/lib/idxd/idxd.c b/lib/idxd/idxd.c
index 9d85a4518..7af6564ad 100644
--- a/lib/idxd/idxd.c
+++ b/lib/idxd/idxd.c
@@ -473,6 +473,7 @@ spdk_idxd_submit_copy(struct spdk_idxd_io_channel *chan, void *dst, const void *
 	desc->src_addr = src_addr;
 	desc->dst_addr = dst_addr;
 	desc->xfer_size = nbytes;
+	desc->flags |= IDXD_FLAG_CACHE_CONTROL; /* direct IO to CPU cache instead of mem */
 
 	/* Submit operation. */
 	movdir64b(chan->portal, desc);
@@ -522,6 +523,7 @@ spdk_idxd_submit_dualcast(struct spdk_idxd_io_channel *chan, void *dst1, void *d
 	desc->dst_addr = dst1_addr;
 	desc->dest2 = dst2_addr;
 	desc->xfer_size = nbytes;
+	desc->flags |= IDXD_FLAG_CACHE_CONTROL; /* direct IO to CPU cache instead of mem */
 
 	/* Submit operation. */
 	movdir64b(chan->portal, desc);
@@ -591,6 +593,7 @@ spdk_idxd_submit_fill(struct spdk_idxd_io_channel *chan, void *dst, uint64_t fil
 	desc->pattern = fill_pattern;
 	desc->dst_addr = dst_addr;
 	desc->xfer_size = nbytes;
+	desc->flags |= IDXD_FLAG_CACHE_CONTROL; /* direct IO to CPU cache instead of mem */
 
 	/* Submit operation. */
 	movdir64b(chan->portal, desc);
-- 
2.26.2


From 475fadf365b3378b3ec8702dd076c78e84f4ae86 Mon Sep 17 00:00:00 2001
From: paul luse <paul.e.luse@intel.com>
Date: Thu, 3 Jun 2021 11:54:17 -0400
Subject: [PATCH 293/342] examples/accel_perf: don't allocate channel just to
 get engine caps

Getting/putting the channel races with getting real IO channels
causing issues with an upcoming design. Avoid it entirely by using
the first worker channel to get the capabilties.

Signed-off-by: paul luse <paul.e.luse@intel.com>
Change-Id: I750a8d59e294f4cda9f71f3327afc03e15342768
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8170
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 examples/accel/perf/accel_perf.c | 22 ++++++++++------------
 1 file changed, 10 insertions(+), 12 deletions(-)

diff --git a/examples/accel/perf/accel_perf.c b/examples/accel/perf/accel_perf.c
index c276d4078..7ffae8fe2 100644
--- a/examples/accel/perf/accel_perf.c
+++ b/examples/accel/perf/accel_perf.c
@@ -63,7 +63,6 @@ static enum accel_capability g_workload_selection;
 static struct worker_thread *g_workers = NULL;
 static int g_num_workers = 0;
 static pthread_mutex_t g_workers_lock = PTHREAD_MUTEX_INITIALIZER;
-uint64_t g_capabilites;
 
 struct worker_thread;
 static void accel_done(void *ref, int status);
@@ -731,6 +730,7 @@ _init_thread(void *arg1)
 	struct accel_batch *tmp;
 	struct accel_batch *worker_batch = NULL;
 	struct display_info *display = arg1;
+	uint64_t capabilities;
 
 	worker = calloc(1, sizeof(*worker));
 	if (worker == NULL) {
@@ -751,6 +751,15 @@ _init_thread(void *arg1)
 	pthread_mutex_unlock(&g_workers_lock);
 	worker->ch = spdk_accel_engine_get_io_channel();
 
+	if (g_num_workers == 1) {
+		capabilities = spdk_accel_get_capabilities(worker->ch);
+		if ((capabilities & g_workload_selection) != g_workload_selection) {
+			g_using_sw_engine = true;
+			SPDK_WARNLOG("The selected workload is not natively supported by the current engine\n");
+			SPDK_WARNLOG("The software engine will be used instead.\n\n");
+		}
+	}
+
 	TAILQ_INIT(&worker->tasks_pool);
 
 	if (g_ops_per_batch > 0) {
@@ -905,7 +914,6 @@ accel_done(void *cb_arg, int status)
 static void
 accel_perf_start(void *arg1)
 {
-	struct spdk_io_channel *accel_ch;
 	struct spdk_cpuset tmp_cpumask = {};
 	char thread_name[32];
 	uint32_t i;
@@ -913,16 +921,6 @@ accel_perf_start(void *arg1)
 	struct spdk_thread *thread;
 	struct display_info *display;
 
-	accel_ch = spdk_accel_engine_get_io_channel();
-	g_capabilites = spdk_accel_get_capabilities(accel_ch);
-	spdk_put_io_channel(accel_ch);
-
-	if ((g_capabilites & g_workload_selection) != g_workload_selection) {
-		g_using_sw_engine = true;
-		SPDK_WARNLOG("The selected workload is not natively supported by the current engine\n");
-		SPDK_WARNLOG("The software engine will be used instead.\n\n");
-	}
-
 	g_tsc_rate = spdk_get_ticks_hz();
 	g_tsc_end = spdk_get_ticks() + g_time_in_sec * g_tsc_rate;
 
-- 
2.26.2


From 1136107e21a11a697b96f5aad5aaf4497781e4fd Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Wed, 26 May 2021 17:30:15 +0800
Subject: [PATCH 294/342] nvme: optimize the error log when OPAL isn't
 supported

We will print a notice log if the drive can support SECURITY
SEND/RECEIVE commands but not OPAL, so remove the error logs.

Change-Id: Ib26aa727ad1e703d53c387af8507b920606ea9c6
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8055
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Niklas Cassel <niklas.cassel@wdc.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 module/bdev/nvme/bdev_nvme.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 67319ecbb..db78e56e6 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -1854,9 +1854,6 @@ _nvme_bdev_ctrlr_create(struct spdk_nvme_ctrlr *ctrlr,
 	if (spdk_nvme_ctrlr_get_flags(nvme_bdev_ctrlr->ctrlr) &
 	    SPDK_NVME_CTRLR_SECURITY_SEND_RECV_SUPPORTED) {
 		nvme_bdev_ctrlr->opal_dev = spdk_opal_dev_construct(nvme_bdev_ctrlr->ctrlr);
-		if (nvme_bdev_ctrlr->opal_dev == NULL) {
-			SPDK_ERRLOG("Failed to initialize Opal\n");
-		}
 	}
 
 	TAILQ_INSERT_HEAD(&nvme_bdev_ctrlr->trids, trid_entry, link);
-- 
2.26.2


From a7f526ba1a4eb62f41d952dadd52a966f7b9c4eb Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Thu, 27 May 2021 01:37:18 -0400
Subject: [PATCH 295/342] nvme/opal: check Security Protocol 00h before sending
 TCG SP

A Security Receive command with the Security Protocol field cleared to
00h shall return information about the security protocols supported by
the controller, so we can check the TCG security protocol is supported
or not before sending it.

Fix issue #1961.

Change-Id: Id061defe45db981b276e2794fd0b59f8db70b7f4
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8083
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Niklas Cassel <niklas.cassel@wdc.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvme/nvme_opal.c | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/lib/nvme/nvme_opal.c b/lib/nvme/nvme_opal.c
index 8bd2ccf02..9f26a9046 100644
--- a/lib/nvme/nvme_opal.c
+++ b/lib/nvme/nvme_opal.c
@@ -841,7 +841,37 @@ static int
 opal_discovery0(struct spdk_opal_dev *dev, void *payload, uint32_t payload_size)
 {
 	int ret;
+	uint16_t i, sp_list_len;
+	uint8_t *sp_list;
+	bool sp_tcg_supported = false;
 
+	/* NVMe 1.4 chapter 5.25.2 Security Protocol 00h */
+	ret = spdk_nvme_ctrlr_security_receive(dev->ctrlr, SPDK_SCSI_SECP_INFO, 0,
+					       0, payload, payload_size);
+	if (ret) {
+		return ret;
+	}
+
+	/* spc4r31 chapter 7.7.1.3 Supported security protocols list description */
+	sp_list_len = from_be16(payload + 6);
+	sp_list = (uint8_t *)payload + 8;
+
+	if (sp_list_len + 8 > (int)payload_size) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < sp_list_len; i++) {
+		if (sp_list[i] == SPDK_SCSI_SECP_TCG) {
+			sp_tcg_supported = true;
+			break;
+		}
+	}
+
+	if (!sp_tcg_supported) {
+		return -ENOTSUP;
+	}
+
+	memset(payload, 0, payload_size);
 	ret = spdk_nvme_ctrlr_security_receive(dev->ctrlr, SPDK_SCSI_SECP_TCG, LV0_DISCOVERY_COMID,
 					       0, payload, payload_size);
 	if (ret) {
-- 
2.26.2


From dd743a3285c52ec6d3ec1b95aac0c61c213970e8 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 24 May 2021 09:30:23 -0400
Subject: [PATCH 296/342] ut/event: verify tsc stats in test_scheduler

At no point in the UT thread and reactor stats
were verified. This patch makes sure that those are
checked and points out a glaring issue fixed in the
next patch.

Please note that spdk_get_ticks() and spdk_delay_us()
increase a single global value, which does not play
well with tests simulating multiple reactors.
As such each round through reactors resets the
global timer and verifies it at the end.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I27878fe35c1606ec20c548fe3bb5ede0102c8a63
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8020
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 test/unit/lib/event/reactor.c/reactor_ut.c | 52 +++++++++++++++++++---
 1 file changed, 46 insertions(+), 6 deletions(-)

diff --git a/test/unit/lib/event/reactor.c/reactor_ut.c b/test/unit/lib/event/reactor.c/reactor_ut.c
index aaa138744..d8fb31483 100644
--- a/test/unit/lib/event/reactor.c/reactor_ut.c
+++ b/test/unit/lib/event/reactor.c/reactor_ut.c
@@ -525,6 +525,8 @@ test_scheduler(void)
 	struct spdk_lw_thread *lw_thread;
 	struct spdk_reactor *reactor;
 	struct spdk_poller *busy, *idle;
+	uint64_t current_time;
+	struct spdk_thread_stats stats;
 	int i;
 
 	MOCK_SET(spdk_env_get_current_core, 0);
@@ -560,22 +562,39 @@ test_scheduler(void)
 	MOCK_SET(spdk_env_get_current_core, 0);
 
 	/* Init threads stats (low load) */
+	/* Each reactor starts at 100 tsc,
+	 * ends at 100 + 10 + 90 = 200 tsc. */
+	current_time = 100;
 	for (i = 0; i < 3; i++) {
 		spdk_set_thread(thread[i]);
+		/* FIXME: A single _reactor_run() iterates over all active pollers.
+		 * If at least one returns busy, so does the thread. Load here is not
+		 * 'low', but 100% busy. */
 		busy = spdk_poller_register(poller_run_busy, (void *)10, 0);
 		idle = spdk_poller_register(poller_run_idle, (void *)90, 0);
 		reactor = spdk_reactor_get(i);
 		CU_ASSERT(reactor != NULL);
-		reactor->tsc_last = 100;
+		MOCK_SET(spdk_get_ticks, current_time);
+		reactor->tsc_last = spdk_get_ticks();
 		_reactor_run(reactor);
+		CU_ASSERT(reactor->tsc_last == 200);
 		spdk_poller_unregister(&busy);
 		spdk_poller_unregister(&idle);
 
+		CU_ASSERT(spdk_thread_get_last_tsc(thread[i]) == 200);
+		CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+		CU_ASSERT(stats.busy_tsc == 100);
+		CU_ASSERT(stats.idle_tsc == 0);
+		CU_ASSERT(reactor->busy_tsc == 100);
+		CU_ASSERT(reactor->idle_tsc == 0);
+
 		/* Update last stats so that we don't have to call scheduler twice */
 		lw_thread = spdk_thread_get_ctx(thread[i]);
 		lw_thread->last_stats.busy_tsc = UINT32_MAX;
 		lw_thread->last_stats.idle_tsc = UINT32_MAX;
 	}
+	CU_ASSERT(spdk_get_ticks() == 200);
+	current_time = 200;
 
 	reactor = spdk_reactor_get(0);
 	CU_ASSERT(reactor != NULL);
@@ -596,12 +615,23 @@ test_scheduler(void)
 	MOCK_SET(spdk_env_get_current_core, 0);
 	CU_ASSERT(event_queue_run_batch(reactor) == 1);
 
-	/* Threads were idle, so all of them should be placed on core 0 */
+	/* Threads were idle, so all of them should be placed on core 0.
+	 * All reactors start and end at 200 tsc, since threads are idle. */
 	for (i = 0; i < 3; i++) {
 		reactor = spdk_reactor_get(i);
 		CU_ASSERT(reactor != NULL);
+		MOCK_SET(spdk_get_ticks, current_time);
 		_reactor_run(reactor);
+		CU_ASSERT(reactor->tsc_last == current_time);
+		CU_ASSERT(reactor->busy_tsc == 100);
+		CU_ASSERT(reactor->idle_tsc == 0);
+		spdk_set_thread(thread[i]);
+		CU_ASSERT(spdk_thread_get_last_tsc(thread[i]) == current_time);
+		CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+		CU_ASSERT(stats.busy_tsc == 100);
+		CU_ASSERT(stats.idle_tsc == 0);
 	}
+	CU_ASSERT(spdk_get_ticks() == current_time);
 
 	/* 2 threads should be scheduled to core 0 */
 	reactor = spdk_reactor_get(0);
@@ -622,17 +652,27 @@ test_scheduler(void)
 	/* Make threads busy */
 	reactor = spdk_reactor_get(0);
 	CU_ASSERT(reactor != NULL);
-	reactor->tsc_last = 100;
 
+	/* All threads run on single reactor,
+	 * reactor 0 starts at 200 tsc,
+	 * ending at 200 + (100 * 3) = 500 tsc. */
+	MOCK_SET(spdk_get_ticks, current_time);
 	for (i = 0; i < 3; i++) {
 		spdk_set_thread(thread[i]);
 		busy = spdk_poller_register(poller_run_busy, (void *)100, 0);
 		_reactor_run(reactor);
 		spdk_poller_unregister(&busy);
-	}
 
-	reactor->busy_tsc = 0;
-	reactor->idle_tsc = UINT32_MAX;
+		CU_ASSERT(reactor->tsc_last == (current_time + 100 * (i + 1)));
+		CU_ASSERT(spdk_thread_get_last_tsc(thread[i]) == (current_time + 100 * (i + 1)));
+		CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
+		CU_ASSERT(stats.busy_tsc == 200);
+		CU_ASSERT(stats.idle_tsc == 0);
+	}
+	CU_ASSERT(reactor->busy_tsc == 400);
+	CU_ASSERT(reactor->idle_tsc == 0);
+	CU_ASSERT(spdk_get_ticks() == 500);
+	current_time = 500;
 
 	/* Run scheduler again, this time all threads are busy */
 	_reactors_scheduler_gather_metrics(NULL, NULL);
-- 
2.26.2


From 005b22d299c290a2736f489b38dda3188c606c26 Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Mon, 24 May 2021 11:44:08 -0400
Subject: [PATCH 297/342] ut/event: fix test_scheduler UT

This UT was not working as intended, and was covered by
scheduler implementation and direct modification
of the lw_thread stats in UT.

A single _reactor_run() iterates over all active pollers.
If at least one returns busy, so does the thread.
Thread load at the begining of UT is not 'low', but 100% busy.

To emulate loads outside of the 100% busy/idle, multiple
spdk_thread_polls need to be exectued.

As such to keep this case simple, the busy poller is removed.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: I21b4c607977ed5926e0bb2743c33636cfc49f328
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8021
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 test/unit/lib/event/reactor.c/reactor_ut.c | 39 ++++++++--------------
 1 file changed, 14 insertions(+), 25 deletions(-)

diff --git a/test/unit/lib/event/reactor.c/reactor_ut.c b/test/unit/lib/event/reactor.c/reactor_ut.c
index d8fb31483..37e9a7b6f 100644
--- a/test/unit/lib/event/reactor.c/reactor_ut.c
+++ b/test/unit/lib/event/reactor.c/reactor_ut.c
@@ -522,7 +522,6 @@ test_scheduler(void)
 {
 	struct spdk_cpuset cpuset = {};
 	struct spdk_thread *thread[3];
-	struct spdk_lw_thread *lw_thread;
 	struct spdk_reactor *reactor;
 	struct spdk_poller *busy, *idle;
 	uint64_t current_time;
@@ -563,35 +562,25 @@ test_scheduler(void)
 
 	/* Init threads stats (low load) */
 	/* Each reactor starts at 100 tsc,
-	 * ends at 100 + 10 + 90 = 200 tsc. */
+	 * ends at 100 + 100 = 200 tsc. */
 	current_time = 100;
 	for (i = 0; i < 3; i++) {
 		spdk_set_thread(thread[i]);
-		/* FIXME: A single _reactor_run() iterates over all active pollers.
-		 * If at least one returns busy, so does the thread. Load here is not
-		 * 'low', but 100% busy. */
-		busy = spdk_poller_register(poller_run_busy, (void *)10, 0);
-		idle = spdk_poller_register(poller_run_idle, (void *)90, 0);
+		idle = spdk_poller_register(poller_run_idle, (void *)100, 0);
 		reactor = spdk_reactor_get(i);
 		CU_ASSERT(reactor != NULL);
 		MOCK_SET(spdk_get_ticks, current_time);
 		reactor->tsc_last = spdk_get_ticks();
 		_reactor_run(reactor);
 		CU_ASSERT(reactor->tsc_last == 200);
-		spdk_poller_unregister(&busy);
 		spdk_poller_unregister(&idle);
 
 		CU_ASSERT(spdk_thread_get_last_tsc(thread[i]) == 200);
 		CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
-		CU_ASSERT(stats.busy_tsc == 100);
-		CU_ASSERT(stats.idle_tsc == 0);
-		CU_ASSERT(reactor->busy_tsc == 100);
-		CU_ASSERT(reactor->idle_tsc == 0);
-
-		/* Update last stats so that we don't have to call scheduler twice */
-		lw_thread = spdk_thread_get_ctx(thread[i]);
-		lw_thread->last_stats.busy_tsc = UINT32_MAX;
-		lw_thread->last_stats.idle_tsc = UINT32_MAX;
+		CU_ASSERT(stats.busy_tsc == 0);
+		CU_ASSERT(stats.idle_tsc == 100);
+		CU_ASSERT(reactor->busy_tsc == 0);
+		CU_ASSERT(reactor->idle_tsc == 100);
 	}
 	CU_ASSERT(spdk_get_ticks() == 200);
 	current_time = 200;
@@ -623,13 +612,13 @@ test_scheduler(void)
 		MOCK_SET(spdk_get_ticks, current_time);
 		_reactor_run(reactor);
 		CU_ASSERT(reactor->tsc_last == current_time);
-		CU_ASSERT(reactor->busy_tsc == 100);
-		CU_ASSERT(reactor->idle_tsc == 0);
+		CU_ASSERT(reactor->busy_tsc == 0);
+		CU_ASSERT(reactor->idle_tsc == 100);
 		spdk_set_thread(thread[i]);
 		CU_ASSERT(spdk_thread_get_last_tsc(thread[i]) == current_time);
 		CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
-		CU_ASSERT(stats.busy_tsc == 100);
-		CU_ASSERT(stats.idle_tsc == 0);
+		CU_ASSERT(stats.busy_tsc == 0);
+		CU_ASSERT(stats.idle_tsc == 100);
 	}
 	CU_ASSERT(spdk_get_ticks() == current_time);
 
@@ -666,11 +655,11 @@ test_scheduler(void)
 		CU_ASSERT(reactor->tsc_last == (current_time + 100 * (i + 1)));
 		CU_ASSERT(spdk_thread_get_last_tsc(thread[i]) == (current_time + 100 * (i + 1)));
 		CU_ASSERT(spdk_thread_get_stats(&stats) == 0);
-		CU_ASSERT(stats.busy_tsc == 200);
-		CU_ASSERT(stats.idle_tsc == 0);
+		CU_ASSERT(stats.busy_tsc == 100);
+		CU_ASSERT(stats.idle_tsc == 100);
 	}
-	CU_ASSERT(reactor->busy_tsc == 400);
-	CU_ASSERT(reactor->idle_tsc == 0);
+	CU_ASSERT(reactor->busy_tsc == 300);
+	CU_ASSERT(reactor->idle_tsc == 100);
 	CU_ASSERT(spdk_get_ticks() == 500);
 	current_time = 500;
 
-- 
2.26.2


From 47a6578ee55c47dc84d168ac83eb730a4c7f293a Mon Sep 17 00:00:00 2001
From: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Date: Wed, 19 May 2021 05:47:34 -0400
Subject: [PATCH 298/342] lib/event: calculate last_stats in event framework

Rather than to rely on schedulers to access and modify
last_stats values over multiple scheduling periods, move that
operation to event framework.

Providing this to the schedulers in generic manner is better
than enforcing that each scheduler has to keep track of this
data on their own.

Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Change-Id: Icaf3b4af80d86fafaddf328fd230db9743d21ab5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7971
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 lib/event/reactor.c           | 10 +++++++---
 lib/event/scheduler_dynamic.c |  3 ---
 2 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/lib/event/reactor.c b/lib/event/reactor.c
index f1d66d1e0..3242d92e2 100644
--- a/lib/event/reactor.c
+++ b/lib/event/reactor.c
@@ -674,11 +674,18 @@ static void
 _init_thread_stats(struct spdk_reactor *reactor, struct spdk_lw_thread *lw_thread)
 {
 	struct spdk_thread *thread = spdk_thread_get_from_ctx(lw_thread);
+	struct spdk_thread_stats last_stats;
+
+	/* Save last stats before replacing them. */
+	last_stats = lw_thread->current_stats;
 
 	lw_thread->lcore = reactor->lcore;
 
 	spdk_set_thread(thread);
 	spdk_thread_get_stats(&lw_thread->current_stats);
+	spdk_set_thread(NULL);
+
+	lw_thread->last_stats = last_stats;
 }
 
 static void
@@ -1170,7 +1177,6 @@ _reactor_schedule_thread(struct spdk_thread *thread)
 {
 	uint32_t core;
 	struct spdk_lw_thread *lw_thread;
-	struct spdk_thread_stats last_stats;
 	struct spdk_event *evt = NULL;
 	struct spdk_cpuset *cpumask;
 	uint32_t i;
@@ -1184,9 +1190,7 @@ _reactor_schedule_thread(struct spdk_thread *thread)
 	lw_thread = spdk_thread_get_ctx(thread);
 	assert(lw_thread != NULL);
 	core = lw_thread->lcore;
-	last_stats = lw_thread->last_stats;
 	memset(lw_thread, 0, sizeof(*lw_thread));
-	lw_thread->last_stats = last_stats;
 
 	if (current_lcore != SPDK_ENV_LCORE_ID_ANY) {
 		local_reactor = spdk_reactor_get(current_lcore);
diff --git a/lib/event/scheduler_dynamic.c b/lib/event/scheduler_dynamic.c
index ceaaa90dd..063da396c 100644
--- a/lib/event/scheduler_dynamic.c
+++ b/lib/event/scheduler_dynamic.c
@@ -71,9 +71,6 @@ _get_thread_load(struct spdk_lw_thread *lw_thread)
 	busy = lw_thread->current_stats.busy_tsc - lw_thread->last_stats.busy_tsc;
 	idle = lw_thread->current_stats.idle_tsc - lw_thread->last_stats.idle_tsc;
 
-	lw_thread->last_stats.busy_tsc = lw_thread->current_stats.busy_tsc;
-	lw_thread->last_stats.idle_tsc = lw_thread->current_stats.idle_tsc;
-
 	if (busy == 0) {
 		/* No work was done, exit before possible division by 0. */
 		return 0;
-- 
2.26.2


From 522faef3e21661b28ff93845a266a3af1eedc59b Mon Sep 17 00:00:00 2001
From: Curt Bruns <curt.e.bruns@gmail.com>
Date: Tue, 1 Jun 2021 18:40:00 -0400
Subject: [PATCH 299/342] nvme: add cuse support for RESCAN IOCTL

Nvme-cli submits a RESCAN IOCTL after a format command to
update any information that may have changed during the
format, such as LBA Format.  This patch adds support
for RESCAN by executing nvme_ctrlr_update_namespaces to
update the controller information.

Fixes: #1964

Change-Id: I9f03e00a7f39339947ff02390f69ce806e1cfa0e
Signed-off-by: Curt Bruns <curt.e.bruns@gmail.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8146
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvme/nvme_ctrlr.c                         |  2 +-
 lib/nvme/nvme_cuse.c                          | 35 +++++++++++++++++++
 lib/nvme/nvme_internal.h                      |  1 +
 test/nvme/cuse/cuse.c                         |  2 ++
 test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c |  2 ++
 5 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index dea7daa0a..705d02c59 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -2533,7 +2533,7 @@ nvme_ctrlr_destruct_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 	}
 }
 
-static void
+void
 nvme_ctrlr_update_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 {
 	uint32_t i, nn = ctrlr->cdata.nn;
diff --git a/lib/nvme/nvme_cuse.c b/lib/nvme/nvme_cuse.c
index b28315f22..2a38ba4d2 100644
--- a/lib/nvme/nvme_cuse.c
+++ b/lib/nvme/nvme_cuse.c
@@ -313,6 +313,36 @@ cuse_nvme_reset(fuse_req_t req, int cmd, void *arg,
 	}
 }
 
+static void
+cuse_nvme_rescan_execute(struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, void *arg)
+{
+	fuse_req_t req = arg;
+
+	nvme_ctrlr_update_namespaces(ctrlr);
+	fuse_reply_ioctl_iov(req, 0, NULL, 0);
+}
+
+static void
+cuse_nvme_rescan(fuse_req_t req, int cmd, void *arg,
+		 struct fuse_file_info *fi, unsigned flags,
+		 const void *in_buf, size_t in_bufsz, size_t out_bufsz)
+{
+	int rv;
+	struct cuse_device *cuse_device = fuse_req_userdata(req);
+
+	if (cuse_device->nsid) {
+		SPDK_ERRLOG("Namespace rescan not supported\n");
+		fuse_reply_err(req, EINVAL);
+		return;
+	}
+
+	rv = nvme_io_msg_send(cuse_device->ctrlr, cuse_device->nsid, cuse_nvme_rescan_execute, (void *)req);
+	if (rv) {
+		SPDK_ERRLOG("Cannot send rescan\n");
+		fuse_reply_err(req, EINVAL);
+	}
+}
+
 /*****************************************************************************
  * Namespace IO requests
  */
@@ -615,6 +645,11 @@ cuse_ctrlr_ioctl(fuse_req_t req, int cmd, void *arg,
 		cuse_nvme_reset(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
 		break;
 
+	case NVME_IOCTL_RESCAN:
+		SPDK_DEBUGLOG(nvme_cuse, "NVME_IOCTL_RESCAN\n");
+		cuse_nvme_rescan(req, cmd, arg, fi, flags, in_buf, in_bufsz, out_bufsz);
+		break;
+
 	default:
 		SPDK_ERRLOG("Unsupported IOCTL 0x%X.\n", cmd);
 		fuse_reply_err(req, EINVAL);
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index 98607a06a..b23a9fc91 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -1318,6 +1318,7 @@ const struct spdk_nvme_transport *nvme_get_transport(const char *transport_name)
 const struct spdk_nvme_transport *nvme_get_first_transport(void);
 const struct spdk_nvme_transport *nvme_get_next_transport(const struct spdk_nvme_transport
 		*transport);
+void  nvme_ctrlr_update_namespaces(struct spdk_nvme_ctrlr *ctrlr);
 
 /* Transport specific functions */
 struct spdk_nvme_ctrlr *nvme_transport_ctrlr_construct(const struct spdk_nvme_transport_id *trid,
diff --git a/test/nvme/cuse/cuse.c b/test/nvme/cuse/cuse.c
index f217b9907..9999c51c2 100644
--- a/test/nvme/cuse/cuse.c
+++ b/test/nvme/cuse/cuse.c
@@ -91,6 +91,8 @@ DEFINE_STUB(nvme_io_msg_ctrlr_register, int,
 DEFINE_STUB_V(nvme_io_msg_ctrlr_unregister,
 	      (struct spdk_nvme_ctrlr *ctrlr, struct nvme_io_msg_producer *io_msg_producer));
 
+DEFINE_STUB_V(nvme_ctrlr_update_namespaces, (struct spdk_nvme_ctrlr *ctrlr));
+
 static bool
 wait_for_file(char *filename, bool exists)
 {
diff --git a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
index 086b7f157..20fb266ed 100644
--- a/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
+++ b/test/unit/lib/nvme/nvme_cuse.c/nvme_cuse_ut.c
@@ -81,6 +81,8 @@ DEFINE_STUB(spdk_nvme_ctrlr_is_active_ns, bool,
 
 DEFINE_STUB(fuse_reply_err, int, (fuse_req_t req, int err), 0);
 
+DEFINE_STUB_V(nvme_ctrlr_update_namespaces, (struct spdk_nvme_ctrlr *ctrlr));
+
 struct cuse_io_ctx *g_ut_ctx;
 struct spdk_nvme_ctrlr *g_ut_ctrlr;
 uint32_t g_ut_nsid;
-- 
2.26.2


From 70f7ea3e3049ebf2dd15daefe0134192facf2617 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 2 Jun 2021 10:12:04 +0200
Subject: [PATCH 300/342] test/nvmf: Simplify get_nvme_devs()

This function was unintentionally including trace lines in its output
by playing with stderr (where -x is redirecting its output by default).
Avoid that by simply listing the devices and doing proper checks from
within the actual test.

Spotted in https://github.com/spdk/spdk/issues/1973

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: If15375aca152aaa49267c9cc51e70fd859685ea1
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8156
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 test/nvmf/common.sh          | 12 +++---------
 test/nvmf/target/nvme_cli.sh |  9 +++++----
 2 files changed, 8 insertions(+), 13 deletions(-)

diff --git a/test/nvmf/common.sh b/test/nvmf/common.sh
index 252681850..db7113a80 100644
--- a/test/nvmf/common.sh
+++ b/test/nvmf/common.sh
@@ -507,19 +507,13 @@ function nvme_connect() {
 }
 
 function get_nvme_devs() {
-	local dev rest
+	local dev _
 
-	nvmes=()
-	while read -r dev rest; do
+	while read -r dev _; do
 		if [[ $dev == /dev/nvme* ]]; then
-			nvmes+=("$dev")
-		fi
-		if [[ $1 == print ]]; then
-			echo "$dev $rest"
+			echo "$dev"
 		fi
 	done < <(nvme list)
-	((${#nvmes[@]})) || return 1
-	echo "${#nvmes[@]}" >&2
 }
 
 function gen_nvmf_target_json() {
diff --git a/test/nvmf/target/nvme_cli.sh b/test/nvmf/target/nvme_cli.sh
index ab0b13b08..9c6559e12 100755
--- a/test/nvmf/target/nvme_cli.sh
+++ b/test/nvmf/target/nvme_cli.sh
@@ -14,6 +14,7 @@ MALLOC_BDEV_SIZE=64
 MALLOC_BLOCK_SIZE=512
 
 rpc_py="$rootdir/scripts/rpc.py"
+devs=()
 
 nvmftestinit
 nvmfappstart -m 0xF
@@ -29,11 +30,11 @@ $rpc_py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 Malloc1
 $rpc_py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t $TEST_TRANSPORT -a $NVMF_FIRST_TARGET_IP -s $NVMF_PORT
 
 nvme discover -t $TEST_TRANSPORT -a $NVMF_FIRST_TARGET_IP -s "$NVMF_PORT"
-nvme_num_before_connection=$(get_nvme_devs 2>&1 || echo 0)
+devs=($(get_nvme_devs)) nvme_num_before_connection=${#devs[@]}
 nvme connect -t $TEST_TRANSPORT -n "nqn.2016-06.io.spdk:cnode1" -a "$NVMF_FIRST_TARGET_IP" -s "$NVMF_PORT"
 
 waitforserial $NVMF_SERIAL 2
-if ! get_nvme_devs print 2> /dev/null; then
+if [[ -z $(get_nvme_devs) ]]; then
 	echo "Could not find any nvme devices to work with, aborting the test" >&2
 	exit 1
 fi
@@ -57,9 +58,9 @@ for ns in "${nvmes[@]}"; do
 	nvme id-ns $ns
 done
 
-nvme_num=$(get_nvme_devs 2>&1)
+devs=($(get_nvme_devs)) nvme_num=${#devs[@]}
 nvme disconnect -n "nqn.2016-06.io.spdk:cnode1"
-if [ $nvme_num -le $nvme_num_before_connection ]; then
+if ((nvme_num <= nvme_num_before_connection)); then
 	echo "nvme-cli connect target devices failed"
 	exit 1
 fi
-- 
2.26.2


From c2feee4fefa600e761d64e13a5ca5fe7cdb81f41 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 2 Jun 2021 10:40:46 +0200
Subject: [PATCH 301/342] test/common: Free stderr fd from tracing

Consider this:

foo() { echo bar >&2 ; }
set -x
foobar=$(foo 2>&1)
[[ $foobar == "bar" ]]

The above test will fail since $foobar will also include tracing
strings as stderr is where set -x redirects the output. Since in
some cases this may troublesome, replace stderr with a dedicated
fd allocated dynamically.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Ia6609e4463b371c07fab42d2bd291c9e43742df5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8158
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 test/common/autotest_common.sh | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/test/common/autotest_common.sh b/test/common/autotest_common.sh
index 0180adde1..30f5832e6 100755
--- a/test/common/autotest_common.sh
+++ b/test/common/autotest_common.sh
@@ -1,5 +1,16 @@
 #!/usr/bin/env bash
 
+function xtrace_fd() {
+	if [[ -n $BASH_XTRACEFD && -e /proc/self/fd/$BASH_XTRACEFD ]]; then
+		# Close it first to make sure it's sane
+		exec {BASH_XTRACEFD}>&-
+	fi
+	exec {BASH_XTRACEFD}>&2
+
+	set -x
+	echo "Tracing to $BASH_XTRACEFD FD"
+}
+
 function xtrace_disable() {
 	if [ "$XTRACE_DISABLED" != "yes" ]; then
 		PREV_BASH_OPTS="$-"
@@ -1388,7 +1399,7 @@ if $SPDK_AUTOTEST_X; then
 	# explicitly enable xtraces, overriding any tracking information.
 	unset XTRACE_DISABLED
 	unset XTRACE_NESTING_LEVEL
-	set -x
+	xtrace_fd
 	xtrace_enable
 else
 	xtrace_restore
-- 
2.26.2


From 26004a40fbed3af214e08329094adb44be95764e Mon Sep 17 00:00:00 2001
From: Ziye Yang <ziye.yang@intel.com>
Date: Fri, 4 Jun 2021 19:30:45 +0800
Subject: [PATCH 302/342] accel_engine: Use the vector based crc32c function.

Purpose: Use the new function in order to reduce duplicated code.

Change-Id: Ie848c7586575b3f0bb617d7e767cf459b43d4783
Signed-off-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8174
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/accel/accel_engine.c | 10 +---------
 1 file changed, 1 insertion(+), 9 deletions(-)

diff --git a/lib/accel/accel_engine.c b/lib/accel/accel_engine.c
index eac01219a..89868dce0 100644
--- a/lib/accel/accel_engine.c
+++ b/lib/accel/accel_engine.c
@@ -968,15 +968,7 @@ _sw_accel_crc32c(uint32_t *dst, void *src, uint32_t seed, uint64_t nbytes)
 static void
 _sw_accel_crc32cv(uint32_t *dst, struct iovec *iov, uint32_t iovcnt, uint32_t seed)
 {
-	uint32_t i, crc32c = ~seed;
-
-	for (i = 0; i < iovcnt; i++) {
-		assert(iov[i].iov_base != NULL);
-		assert(iov[i].iov_len != 0);
-		crc32c = spdk_crc32c_update(iov[i].iov_base, iov[i].iov_len, crc32c);
-	}
-
-	*dst = crc32c;
+	*dst = spdk_crc32c_iov_update(iov, iovcnt, ~seed);
 }
 
 static struct spdk_io_channel *sw_accel_get_io_channel(void);
-- 
2.26.2


From b832f99f881ed374508651c5a6c9d1b33adbb7ba Mon Sep 17 00:00:00 2001
From: yupeng <yupeng0921@gmail.com>
Date: Mon, 24 May 2021 04:22:43 +0000
Subject: [PATCH 303/342] nvmf: Add nvmf_set_crdt RPC

Set the three CRDT values at SPDK_RPC_STARTUP time.

Signed-off-by: Peng Yu <yupeng0921@gmail.com>
Change-Id: I2fb4c4a3e367a4888cfec4658e6bf6899c7ae1f4
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8007
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 CHANGELOG.md                              |  2 ++
 doc/jsonrpc.md                            | 16 +++++++++
 include/spdk/nvmf.h                       |  1 +
 lib/nvmf/ctrlr.c                          | 12 +++----
 lib/nvmf/nvmf.c                           | 19 +++++++++++
 lib/nvmf/nvmf_internal.h                  |  2 ++
 module/event/subsystems/nvmf/event_nvmf.h |  1 +
 module/event/subsystems/nvmf/nvmf_rpc.c   | 40 +++++++++++++++++++++++
 module/event/subsystems/nvmf/nvmf_tgt.c   |  4 +++
 scripts/rpc.py                            | 12 +++++++
 scripts/rpc/nvmf.py                       | 22 +++++++++++++
 test/json_config/config_filter.py         |  1 +
 test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c     |  4 ++-
 13 files changed, 128 insertions(+), 8 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index cbb545611..fbf53d836 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -25,6 +25,8 @@ Added `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the cont
 
 `spdk_nvmf_request_get_buffers_multi` API is removed.
 
+Added the `nvmf_set_crdt` RPC for setting command retry delay times.
+
 ### nvme
 
 Added a new function `spdk_nvme_ns_cmd_copy` to submit a Simple Copy Command to a Namespace.
diff --git a/doc/jsonrpc.md b/doc/jsonrpc.md
index fc8909242..47b496804 100644
--- a/doc/jsonrpc.md
+++ b/doc/jsonrpc.md
@@ -6840,6 +6840,22 @@ Example response:
 }
 ~~~
 
+
+## nvmf_set_crdt {#rpc_nvmf_set_crdt}
+
+Set the 3 CRDT (Command Retry Delay Time) values. For details about
+CRDT, please refer to the NVMe specification. Currently all the
+SPDK nvmf subsystems share the same CRDT values. The default values
+are 0. This rpc can only be invoked in STARTUP stage. All values are
+in units of 100 milliseconds (same as the NVMe specification).
+
+### Parameters
+Name                    | Optional | Type        | Description
+----------------------- | -------- | ----------- | -----------
+crdt1                   | Optional | number      | Command Retry Delay Time 1
+crdt2                   | Optional | number      | Command Retry Delay Time 2
+crdt3                   | Optional | number      | Command Retry Delay Time 3
+
 # Vhost Target {#jsonrpc_components_vhost_tgt}
 
 The following common preconditions need to be met in all target types.
diff --git a/include/spdk/nvmf.h b/include/spdk/nvmf.h
index 5a22b9426..06ca5d9f7 100644
--- a/include/spdk/nvmf.h
+++ b/include/spdk/nvmf.h
@@ -70,6 +70,7 @@ struct spdk_nvmf_target_opts {
 	char		name[NVMF_TGT_NAME_MAX_LENGTH];
 	uint32_t	max_subsystems;
 	uint32_t	acceptor_poll_rate;
+	uint16_t	crdt[3];
 };
 
 struct spdk_nvmf_transport_opts {
diff --git a/lib/nvmf/ctrlr.c b/lib/nvmf/ctrlr.c
index 4b98fe091..633008af9 100644
--- a/lib/nvmf/ctrlr.c
+++ b/lib/nvmf/ctrlr.c
@@ -88,6 +88,7 @@ nvmf_invalid_connect_response(struct spdk_nvmf_fabric_connect_rsp *rsp,
 #define SPDK_NVMF_INVALID_CONNECT_DATA(rsp, field)	\
 	nvmf_invalid_connect_response(rsp, 1, offsetof(struct spdk_nvmf_fabric_connect_data, field))
 
+
 static void
 nvmf_ctrlr_stop_keep_alive_timer(struct spdk_nvmf_ctrlr *ctrlr)
 {
@@ -2338,13 +2339,10 @@ spdk_nvmf_ctrlr_identify_ctrlr(struct spdk_nvmf_ctrlr *ctrlr, struct spdk_nvme_c
 
 		nvmf_ctrlr_populate_oacs(ctrlr, cdata);
 
-		/*
-		 * FIXME: Set all crdt to 0 currently,
-		 * will provide an API to customize them later.
-		 */
-		cdata->crdt[0] = 0;
-		cdata->crdt[1] = 0;
-		cdata->crdt[2] = 0;
+		assert(subsystem->tgt != NULL);
+		cdata->crdt[0] = subsystem->tgt->crdt[0];
+		cdata->crdt[1] = subsystem->tgt->crdt[1];
+		cdata->crdt[2] = subsystem->tgt->crdt[2];
 
 		SPDK_DEBUGLOG(nvmf, "ext ctrlr data: ioccsz 0x%x\n",
 			      cdata->nvmf_specific.ioccsz);
diff --git a/lib/nvmf/nvmf.c b/lib/nvmf/nvmf.c
index eb6ba3935..1cb9a7487 100644
--- a/lib/nvmf/nvmf.c
+++ b/lib/nvmf/nvmf.c
@@ -283,6 +283,16 @@ spdk_nvmf_tgt_create(struct spdk_nvmf_target_opts *opts)
 		acceptor_poll_rate = opts->acceptor_poll_rate;
 	}
 
+	if (!opts) {
+		tgt->crdt[0] = 0;
+		tgt->crdt[1] = 0;
+		tgt->crdt[2] = 0;
+	} else {
+		tgt->crdt[0] = opts->crdt[0];
+		tgt->crdt[1] = opts->crdt[1];
+		tgt->crdt[2] = opts->crdt[2];
+	}
+
 	tgt->discovery_genctr = 0;
 	TAILQ_INIT(&tgt->transports);
 	TAILQ_INIT(&tgt->poll_groups);
@@ -572,6 +582,15 @@ spdk_nvmf_tgt_write_config_json(struct spdk_json_write_ctx *w, struct spdk_nvmf_
 
 	spdk_json_write_object_end(w);
 
+	spdk_json_write_object_begin(w);
+	spdk_json_write_named_string(w, "method", "nvmf_set_crdt");
+	spdk_json_write_named_object_begin(w, "params");
+	spdk_json_write_named_uint32(w, "crdt1", tgt->crdt[0]);
+	spdk_json_write_named_uint32(w, "crdt2", tgt->crdt[1]);
+	spdk_json_write_named_uint32(w, "crdt3", tgt->crdt[2]);
+	spdk_json_write_object_end(w);
+	spdk_json_write_object_end(w);
+
 	/* write transports */
 	TAILQ_FOREACH(transport, &tgt->transports, link) {
 		spdk_json_write_object_begin(w);
diff --git a/lib/nvmf/nvmf_internal.h b/lib/nvmf/nvmf_internal.h
index 8e300429a..bfa2dc1c8 100644
--- a/lib/nvmf/nvmf_internal.h
+++ b/lib/nvmf/nvmf_internal.h
@@ -87,6 +87,8 @@ struct spdk_nvmf_tgt {
 	spdk_nvmf_tgt_destroy_done_fn		*destroy_cb_fn;
 	void					*destroy_cb_arg;
 
+	uint16_t				crdt[3];
+
 	TAILQ_ENTRY(spdk_nvmf_tgt)		link;
 };
 
diff --git a/module/event/subsystems/nvmf/event_nvmf.h b/module/event/subsystems/nvmf/event_nvmf.h
index 59a884e3f..72b52d2ec 100644
--- a/module/event/subsystems/nvmf/event_nvmf.h
+++ b/module/event/subsystems/nvmf/event_nvmf.h
@@ -57,6 +57,7 @@ struct spdk_nvmf_tgt_conf {
 extern struct spdk_nvmf_tgt_conf g_spdk_nvmf_tgt_conf;
 
 extern uint32_t g_spdk_nvmf_tgt_max_subsystems;
+extern uint16_t g_spdk_nvmf_tgt_crdt[3];
 
 extern struct spdk_nvmf_tgt *g_spdk_nvmf_tgt;
 
diff --git a/module/event/subsystems/nvmf/nvmf_rpc.c b/module/event/subsystems/nvmf/nvmf_rpc.c
index 87c11e393..84705a63c 100644
--- a/module/event/subsystems/nvmf/nvmf_rpc.c
+++ b/module/event/subsystems/nvmf/nvmf_rpc.c
@@ -128,3 +128,43 @@ rpc_nvmf_set_config(struct spdk_jsonrpc_request *request,
 }
 SPDK_RPC_REGISTER("nvmf_set_config", rpc_nvmf_set_config, SPDK_RPC_STARTUP)
 SPDK_RPC_REGISTER_ALIAS_DEPRECATED(nvmf_set_config, set_nvmf_target_config)
+
+struct nvmf_rpc_set_crdt {
+	uint16_t crdt1;
+	uint16_t crdt2;
+	uint16_t crdt3;
+};
+
+static const struct spdk_json_object_decoder rpc_set_crdt_opts_decoders[] = {
+	{"crdt1", offsetof(struct nvmf_rpc_set_crdt, crdt1), spdk_json_decode_uint16, true},
+	{"crdt2", offsetof(struct nvmf_rpc_set_crdt, crdt2), spdk_json_decode_uint16, true},
+	{"crdt3", offsetof(struct nvmf_rpc_set_crdt, crdt3), spdk_json_decode_uint16, true},
+};
+
+static void
+rpc_nvmf_set_crdt(struct spdk_jsonrpc_request *request,
+		  const struct spdk_json_val *params)
+{
+	struct nvmf_rpc_set_crdt rpc_set_crdt;
+
+	rpc_set_crdt.crdt1 = 0;
+	rpc_set_crdt.crdt2 = 0;
+	rpc_set_crdt.crdt3 = 0;
+
+	if (params != NULL) {
+		if (spdk_json_decode_object(params, rpc_set_crdt_opts_decoders,
+					    SPDK_COUNTOF(rpc_set_crdt_opts_decoders), &rpc_set_crdt)) {
+			SPDK_ERRLOG("spdk_json_decode_object() failed\n");
+			spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
+							 "Invalid parameters");
+			return;
+		}
+	}
+
+	g_spdk_nvmf_tgt_crdt[0] = rpc_set_crdt.crdt1;
+	g_spdk_nvmf_tgt_crdt[1] = rpc_set_crdt.crdt2;
+	g_spdk_nvmf_tgt_crdt[2] = rpc_set_crdt.crdt3;
+
+	spdk_jsonrpc_send_bool_response(request, true);
+}
+SPDK_RPC_REGISTER("nvmf_set_crdt", rpc_nvmf_set_crdt, SPDK_RPC_STARTUP)
diff --git a/module/event/subsystems/nvmf/nvmf_tgt.c b/module/event/subsystems/nvmf/nvmf_tgt.c
index 4ac81f3e5..4df1f3060 100644
--- a/module/event/subsystems/nvmf/nvmf_tgt.c
+++ b/module/event/subsystems/nvmf/nvmf_tgt.c
@@ -65,6 +65,7 @@ struct spdk_nvmf_tgt_conf g_spdk_nvmf_tgt_conf = {
 
 struct spdk_nvmf_tgt *g_spdk_nvmf_tgt = NULL;
 uint32_t g_spdk_nvmf_tgt_max_subsystems = 0;
+uint16_t g_spdk_nvmf_tgt_crdt[3] = {0, 0, 0};
 
 static enum nvmf_tgt_state g_tgt_state;
 
@@ -277,6 +278,9 @@ nvmf_tgt_create_target(void)
 
 	opts.max_subsystems = g_spdk_nvmf_tgt_max_subsystems;
 	opts.acceptor_poll_rate = g_spdk_nvmf_tgt_conf.acceptor_poll_rate;
+	opts.crdt[0] = g_spdk_nvmf_tgt_crdt[0];
+	opts.crdt[1] = g_spdk_nvmf_tgt_crdt[1];
+	opts.crdt[2] = g_spdk_nvmf_tgt_crdt[2];
 	g_spdk_nvmf_tgt = spdk_nvmf_tgt_create(&opts);
 	if (!g_spdk_nvmf_tgt) {
 		SPDK_ERRLOG("spdk_nvmf_tgt_create() failed\n");
diff --git a/scripts/rpc.py b/scripts/rpc.py
index 174f0cff4..7857b0760 100755
--- a/scripts/rpc.py
+++ b/scripts/rpc.py
@@ -2155,6 +2155,18 @@ Format: 'user:u1 secret:s1 muser:mu1 msecret:ms1,user:u2 secret:s2 muser:mu2 mse
     p.add_argument('-t', '--tgt_name', help='The name of the parent NVMe-oF target (optional)', type=str)
     p.set_defaults(func=nvmf_get_stats)
 
+    def nvmf_set_crdt(args):
+        print_dict(rpc.nvmf.nvmf_set_crdt(args.client, args.crdt1, args.crdt2, args.crdt3))
+
+    p = subparsers.add_parser(
+        'nvmf_set_crdt',
+        help="""Set the 3 crdt (Command Retry Delay Time) values for NVMf subsystem. All
+        values are in units of 100 milliseconds (same as the NVM Express specification).""")
+    p.add_argument('-t1', '--crdt1', help='Command Retry Delay Time 1, in units of 100 milliseconds', type=int)
+    p.add_argument('-t2', '--crdt2', help='Command Retry Delay Time 2, in units of 100 milliseconds', type=int)
+    p.add_argument('-t3', '--crdt3', help='Command Retry Delay Time 3, in units of 100 milliseconds', type=int)
+    p.set_defaults(func=nvmf_set_crdt)
+
     # pmem
     def bdev_pmem_create_pool(args):
         num_blocks = int((args.total_size * 1024 * 1024) / args.block_size)
diff --git a/scripts/rpc/nvmf.py b/scripts/rpc/nvmf.py
index 8848b430b..96164c0f2 100644
--- a/scripts/rpc/nvmf.py
+++ b/scripts/rpc/nvmf.py
@@ -540,3 +540,25 @@ def nvmf_get_stats(client, tgt_name=None):
         }
 
     return client.call('nvmf_get_stats', params)
+
+
+def nvmf_set_crdt(client, crdt1=None, crdt2=None, crdt3=None):
+    """Set the 3 crdt (Command Retry Delay Time) values
+
+    Args:
+        crdt1: Command Retry Delay Time 1
+        crdt2: Command Retry Delay Time 2
+        crdt3: Command Retry Delay Time 3
+
+    Returns:
+        True or False
+    """
+    params = {}
+    if crdt1 is not None:
+        params['crdt1'] = crdt1
+    if crdt2 is not None:
+        params['crdt2'] = crdt2
+    if crdt3 is not None:
+        params['crdt3'] = crdt3
+
+    return client.call('nvmf_set_crdt', params)
diff --git a/test/json_config/config_filter.py b/test/json_config/config_filter.py
index d19a3165b..59ed539b9 100755
--- a/test/json_config/config_filter.py
+++ b/test/json_config/config_filter.py
@@ -28,6 +28,7 @@ def filter_methods(do_remove_global_rpcs):
         'nvmf_set_config',
         'nvmf_set_max_subsystems',
         'nvmf_create_transport',
+        'nvmf_set_crdt',
         'bdev_set_options',
         'bdev_wait_for_examine',
         'bdev_nvme_set_options',
diff --git a/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c b/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
index 5cf4295d5..bd3f7e5d4 100644
--- a/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
+++ b/test/unit/lib/nvmf/ctrlr.c/ctrlr_ut.c
@@ -1499,8 +1499,10 @@ test_get_dif_ctx(void)
 static void
 test_identify_ctrlr(void)
 {
+	struct spdk_nvmf_tgt tgt = {};
 	struct spdk_nvmf_subsystem subsystem = {
-		.subtype = SPDK_NVMF_SUBTYPE_NVME
+		.subtype = SPDK_NVMF_SUBTYPE_NVME,
+		.tgt = &tgt,
 	};
 	struct spdk_nvmf_transport_ops tops = {};
 	struct spdk_nvmf_transport transport = {
-- 
2.26.2


From 43b4883217bfb6eef1292f3b33c83b568ecb7197 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 27 May 2021 18:21:33 +0000
Subject: [PATCH 304/342] nvme: don't reinit qpairs for vfio-user during reset

Previously we were only checking trtype==PCIE to
determine whether a controller was fabrics.  This
skipped the vfio-user case.  So use the new
spdk_nvme_transport_id_is_fabrics() API instead.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I81f26853f44b1c47522ce6354e5aa4a905796bd0
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8089
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvme/nvme_ctrlr.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 705d02c59..28cafdff8 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -1438,13 +1438,13 @@ spdk_nvme_ctrlr_reset(struct spdk_nvme_ctrlr *ctrlr)
 	}
 
 	/*
-	 * For PCIe controllers, the memory locations of the transport qpair
+	 * For non-fabrics controllers, the memory locations of the transport qpair
 	 * don't change when the controller is reset. They simply need to be
 	 * re-enabled with admin commands to the controller. For fabric
 	 * controllers we need to disconnect and reconnect the qpair on its
 	 * own thread outside of the context of the reset.
 	 */
-	if (rc == 0 && ctrlr->trid.trtype == SPDK_NVME_TRANSPORT_PCIE) {
+	if (rc == 0 && !spdk_nvme_ctrlr_is_fabrics(ctrlr)) {
 		/* Reinitialize qpairs */
 		TAILQ_FOREACH(qpair, &ctrlr->active_io_qpairs, tailq) {
 			assert(spdk_bit_array_get(ctrlr->free_io_qids, qpair->id));
-- 
2.26.2


From b333f00627d3344695c8ad3ec03978a8504f96aa Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Fri, 28 May 2021 06:26:24 +0000
Subject: [PATCH 305/342] nvme: save last transport_failure_reason in transport

If a reconnect fails, we restore the original
transport_failure_reason after we're done with
the failed reconnect.  Save the original reason
in the qpair itself rather than a local variable,
to facilitate upcoming changes where connect will
be asynchronous.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I20ff43fc687a379aa5c930e17cf3ff8d730320be
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8116
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvme/nvme_internal.h  | 1 +
 lib/nvme/nvme_transport.c | 5 ++---
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index b23a9fc91..ebedac38f 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -455,6 +455,7 @@ struct spdk_nvme_qpair {
 	const struct spdk_nvme_transport	*transport;
 
 	uint8_t					transport_failure_reason: 2;
+	uint8_t					last_transport_failure_reason: 2;
 };
 
 struct spdk_nvme_poll_group {
diff --git a/lib/nvme/nvme_transport.c b/lib/nvme/nvme_transport.c
index 7037d4191..f2bb19d9d 100644
--- a/lib/nvme/nvme_transport.c
+++ b/lib/nvme/nvme_transport.c
@@ -347,7 +347,6 @@ int
 nvme_transport_ctrlr_connect_qpair(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair)
 {
 	const struct spdk_nvme_transport *transport = nvme_get_transport(ctrlr->trid.trstring);
-	uint8_t transport_failure_reason;
 	int rc;
 
 	assert(transport != NULL);
@@ -355,7 +354,7 @@ nvme_transport_ctrlr_connect_qpair(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nv
 		qpair->transport = transport;
 	}
 
-	transport_failure_reason = qpair->transport_failure_reason;
+	qpair->last_transport_failure_reason = qpair->transport_failure_reason;
 	qpair->transport_failure_reason = SPDK_NVME_QPAIR_FAILURE_NONE;
 
 	nvme_qpair_set_state(qpair, NVME_QPAIR_CONNECTING);
@@ -376,7 +375,7 @@ nvme_transport_ctrlr_connect_qpair(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nv
 
 err:
 	/* If the qpair was unable to reconnect, restore the original failure reason. */
-	qpair->transport_failure_reason = transport_failure_reason;
+	qpair->transport_failure_reason = qpair->last_transport_failure_reason;
 	nvme_transport_ctrlr_disconnect_qpair(ctrlr, qpair);
 	nvme_qpair_set_state(qpair, NVME_QPAIR_DISCONNECTED);
 	return rc;
-- 
2.26.2


From 51d7f9b13f7cf6452d8fe091db749c9af3c9d4d5 Mon Sep 17 00:00:00 2001
From: matthewb <matthew.burbridge@hpe.com>
Date: Mon, 12 Apr 2021 06:45:22 -0400
Subject: [PATCH 306/342] lib/bdev: Removed ZCOPY emulation

ZCOPY emulation is not required. Modules can check if the bdev module
supports ZCOPY.  If not supported the module uses the existing
READ and WRITE operations.

Signed-off-by: matthewb <matthew.burbridge@hpe.com>
Change-Id: Idac0a4d27a79a6c7e567c420e15637e826c347c8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6815
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Michael Haeuptle <michaelhaeuptle@gmail.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Community-CI: Mellanox Build Bot
---
 CHANGELOG.md    |  5 +++++
 lib/bdev/bdev.c | 59 +------------------------------------------------
 2 files changed, 6 insertions(+), 58 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index fbf53d836..ad8c161bb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -46,6 +46,11 @@ to create a rbd bdev with  an already registered Rados Cluster Object.
 New RPC `bdev_rbd_get_clusters_info` was added, it allows to get the info of the registered
 Rados Cluster names.
 
+### bdev
+
+Removed ZCOPY emulation: The bdev module can be checked to see if it supports ZCOPY
+and if not supported then use existing READ/WRITE commands.
+
 ## v21.04:
 
 ### accel
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index 3c82cef97..ac6bc014a 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -2574,11 +2574,6 @@ spdk_bdev_io_type_supported(struct spdk_bdev *bdev, enum spdk_bdev_io_type io_ty
 			/* The bdev layer will emulate write zeroes as long as write is supported. */
 			supported = bdev_io_type_supported(bdev, SPDK_BDEV_IO_TYPE_WRITE);
 			break;
-		case SPDK_BDEV_IO_TYPE_ZCOPY:
-			/* Zero copy can be emulated with regular read and write */
-			supported = bdev_io_type_supported(bdev, SPDK_BDEV_IO_TYPE_READ) &&
-				    bdev_io_type_supported(bdev, SPDK_BDEV_IO_TYPE_WRITE);
-			break;
 		default:
 			break;
 		}
@@ -4318,29 +4313,6 @@ spdk_bdev_comparev_and_writev_blocks(struct spdk_bdev_desc *desc, struct spdk_io
 				   bdev_comparev_and_writev_blocks_locked, bdev_io);
 }
 
-static void
-bdev_zcopy_get_buf(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io, bool success)
-{
-	if (!success) {
-		/* Don't use spdk_bdev_io_complete here - this bdev_io was never actually submitted. */
-		bdev_io->internal.status = SPDK_BDEV_IO_STATUS_NOMEM;
-		bdev_io->internal.cb(bdev_io, success, bdev_io->internal.caller_ctx);
-		return;
-	}
-
-	if (bdev_io->u.bdev.zcopy.populate) {
-		/* Read the real data into the buffer */
-		bdev_io->type = SPDK_BDEV_IO_TYPE_READ;
-		bdev_io->internal.status = SPDK_BDEV_IO_STATUS_PENDING;
-		bdev_io_submit(bdev_io);
-		return;
-	}
-
-	/* Don't use spdk_bdev_io_complete here - this bdev_io was never actually submitted. */
-	bdev_io->internal.status = SPDK_BDEV_IO_STATUS_SUCCESS;
-	bdev_io->internal.cb(bdev_io, success, bdev_io->internal.caller_ctx);
-}
-
 int
 spdk_bdev_zcopy_start(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
 		      uint64_t offset_blocks, uint64_t num_blocks,
@@ -4381,13 +4353,7 @@ spdk_bdev_zcopy_start(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
 	bdev_io->u.bdev.zcopy.start = 1;
 	bdev_io_init(bdev_io, bdev, cb_arg, cb);
 
-	if (bdev_io_type_supported(bdev, SPDK_BDEV_IO_TYPE_ZCOPY)) {
-		bdev_io_submit(bdev_io);
-	} else {
-		/* Emulate zcopy by allocating a buffer */
-		spdk_bdev_io_get_buf(bdev_io, bdev_zcopy_get_buf,
-				     bdev_io->u.bdev.num_blocks * bdev->blocklen);
-	}
+	bdev_io_submit(bdev_io);
 
 	return 0;
 }
@@ -4396,16 +4362,6 @@ int
 spdk_bdev_zcopy_end(struct spdk_bdev_io *bdev_io, bool commit,
 		    spdk_bdev_io_completion_cb cb, void *cb_arg)
 {
-	struct spdk_bdev *bdev = bdev_io->bdev;
-
-	if (bdev_io->type == SPDK_BDEV_IO_TYPE_READ) {
-		/* This can happen if the zcopy was emulated in start */
-		if (bdev_io->u.bdev.zcopy.start != 1) {
-			return -EINVAL;
-		}
-		bdev_io->type = SPDK_BDEV_IO_TYPE_ZCOPY;
-	}
-
 	if (bdev_io->type != SPDK_BDEV_IO_TYPE_ZCOPY) {
 		return -EINVAL;
 	}
@@ -4416,19 +4372,6 @@ spdk_bdev_zcopy_end(struct spdk_bdev_io *bdev_io, bool commit,
 	bdev_io->internal.cb = cb;
 	bdev_io->internal.status = SPDK_BDEV_IO_STATUS_PENDING;
 
-	if (bdev_io_type_supported(bdev, SPDK_BDEV_IO_TYPE_ZCOPY)) {
-		bdev_io_submit(bdev_io);
-		return 0;
-	}
-
-	if (!bdev_io->u.bdev.zcopy.commit) {
-		/* Don't use spdk_bdev_io_complete here - this bdev_io was never actually submitted. */
-		bdev_io->internal.status = SPDK_BDEV_IO_STATUS_SUCCESS;
-		bdev_io->internal.cb(bdev_io, true, bdev_io->internal.caller_ctx);
-		return 0;
-	}
-
-	bdev_io->type = SPDK_BDEV_IO_TYPE_WRITE;
 	bdev_io_submit(bdev_io);
 
 	return 0;
-- 
2.26.2


From 6127461c934a16e6935990be76433926b6321c8b Mon Sep 17 00:00:00 2001
From: matthewb <matthew.burbridge@hpe.com>
Date: Mon, 12 Apr 2021 08:03:51 -0400
Subject: [PATCH 307/342] lib/bdev: Added iov to spdk_bdev_zcopy_start

Adding iov to the spdk_bdev_zcopy_start function enable spdk_bdev_zcopy_start to
be used by transport layers as the iov is owned by the transport command

Signed-off-by: matthewb <matthew.burbridge@hpe.com>
Change-Id: I6d2be7f49566048bf25b7711ada8d2fb49fea6ee
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6816
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Michael Haeuptle <michaelhaeuptle@gmail.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 CHANGELOG.md                                 |   2 +
 include/spdk/bdev.h                          |   4 +-
 lib/bdev/bdev.c                              |   5 +-
 lib/bdev/part.c                              |   2 +-
 module/bdev/passthru/vbdev_passthru.c        |   3 +-
 test/bdev/bdevperf/bdevperf.c                |   4 +-
 test/external_code/passthru/vbdev_passthru.c |   3 +-
 test/unit/lib/bdev/bdev.c/bdev_ut.c          | 220 ++++++++++++++++++-
 8 files changed, 234 insertions(+), 9 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index ad8c161bb..cc4929eed 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -51,6 +51,8 @@ Rados Cluster names.
 Removed ZCOPY emulation: The bdev module can be checked to see if it supports ZCOPY
 and if not supported then use existing READ/WRITE commands.
 
+Added iov to spdk_bdev_zcopy_start
+
 ## v21.04:
 
 ### accel
diff --git a/include/spdk/bdev.h b/include/spdk/bdev.h
index 36cdb02a3..a7fabc790 100644
--- a/include/spdk/bdev.h
+++ b/include/spdk/bdev.h
@@ -1226,6 +1226,8 @@ int spdk_bdev_comparev_and_writev_blocks(struct spdk_bdev_desc *desc, struct spd
  *
  * \param desc Block device descriptor
  * \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
+ * \param iov A scatter gather list to be populated with the buffers
+ * \param iovcnt The maximum number of elements in iov.
  * \param offset_blocks The offset, in blocks, from the start of the block device.
  * \param num_blocks The number of blocks.
  * \param populate Whether the data buffer should be populated with the
@@ -1239,11 +1241,11 @@ int spdk_bdev_comparev_and_writev_blocks(struct spdk_bdev_desc *desc, struct spd
  * negated errno on failure, in which case the callback will not be called.
  */
 int spdk_bdev_zcopy_start(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
+			  struct iovec *iov, int iovcnt,
 			  uint64_t offset_blocks, uint64_t num_blocks,
 			  bool populate,
 			  spdk_bdev_io_completion_cb cb, void *cb_arg);
 
-
 /**
  * Submit a request to release a data buffer representing a range of blocks.
  *
diff --git a/lib/bdev/bdev.c b/lib/bdev/bdev.c
index ac6bc014a..4a4a4573d 100644
--- a/lib/bdev/bdev.c
+++ b/lib/bdev/bdev.c
@@ -4315,6 +4315,7 @@ spdk_bdev_comparev_and_writev_blocks(struct spdk_bdev_desc *desc, struct spdk_io
 
 int
 spdk_bdev_zcopy_start(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
+		      struct iovec *iov, int iovcnt,
 		      uint64_t offset_blocks, uint64_t num_blocks,
 		      bool populate,
 		      spdk_bdev_io_completion_cb cb, void *cb_arg)
@@ -4345,8 +4346,8 @@ spdk_bdev_zcopy_start(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
 	bdev_io->type = SPDK_BDEV_IO_TYPE_ZCOPY;
 	bdev_io->u.bdev.num_blocks = num_blocks;
 	bdev_io->u.bdev.offset_blocks = offset_blocks;
-	bdev_io->u.bdev.iovs = NULL;
-	bdev_io->u.bdev.iovcnt = 0;
+	bdev_io->u.bdev.iovs = iov;
+	bdev_io->u.bdev.iovcnt = iovcnt;
 	bdev_io->u.bdev.md_buf = NULL;
 	bdev_io->u.bdev.zcopy.populate = populate ? 1 : 0;
 	bdev_io->u.bdev.zcopy.commit = 0;
diff --git a/lib/bdev/part.c b/lib/bdev/part.c
index 917874e12..1922e89e0 100644
--- a/lib/bdev/part.c
+++ b/lib/bdev/part.c
@@ -374,7 +374,7 @@ spdk_bdev_part_submit_request(struct spdk_bdev_part_channel *ch, struct spdk_bde
 				     bdev_part_complete_io, bdev_io);
 		break;
 	case SPDK_BDEV_IO_TYPE_ZCOPY:
-		rc = spdk_bdev_zcopy_start(base_desc, base_ch, remapped_offset,
+		rc = spdk_bdev_zcopy_start(base_desc, base_ch, NULL, 0, remapped_offset,
 					   bdev_io->u.bdev.num_blocks, bdev_io->u.bdev.zcopy.populate,
 					   bdev_part_complete_zcopy_io, bdev_io);
 		break;
diff --git a/module/bdev/passthru/vbdev_passthru.c b/module/bdev/passthru/vbdev_passthru.c
index 5d72bce46..06d245b63 100644
--- a/module/bdev/passthru/vbdev_passthru.c
+++ b/module/bdev/passthru/vbdev_passthru.c
@@ -347,7 +347,8 @@ vbdev_passthru_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *b
 				     _pt_complete_io, bdev_io);
 		break;
 	case SPDK_BDEV_IO_TYPE_ZCOPY:
-		rc = spdk_bdev_zcopy_start(pt_node->base_desc, pt_ch->base_ch, bdev_io->u.bdev.offset_blocks,
+		rc = spdk_bdev_zcopy_start(pt_node->base_desc, pt_ch->base_ch, NULL, 0,
+					   bdev_io->u.bdev.offset_blocks,
 					   bdev_io->u.bdev.num_blocks, bdev_io->u.bdev.zcopy.populate,
 					   _pt_complete_zcopy_io, bdev_io);
 		break;
diff --git a/test/bdev/bdevperf/bdevperf.c b/test/bdev/bdevperf/bdevperf.c
index df50a11b6..c07d7b684 100644
--- a/test/bdev/bdevperf/bdevperf.c
+++ b/test/bdev/bdevperf/bdevperf.c
@@ -716,7 +716,7 @@ bdevperf_submit_task(void *arg)
 		break;
 	case SPDK_BDEV_IO_TYPE_READ:
 		if (g_zcopy) {
-			rc = spdk_bdev_zcopy_start(desc, ch, task->offset_blocks, job->io_size_blocks,
+			rc = spdk_bdev_zcopy_start(desc, ch, NULL, 0, task->offset_blocks, job->io_size_blocks,
 						   true, bdevperf_zcopy_populate_complete, task);
 		} else {
 			if (spdk_bdev_is_md_separate(job->bdev)) {
@@ -803,7 +803,7 @@ bdevperf_prep_zcopy_write_task(void *arg)
 	struct bdevperf_job	*job = task->job;
 	int			rc;
 
-	rc = spdk_bdev_zcopy_start(job->bdev_desc, job->ch,
+	rc = spdk_bdev_zcopy_start(job->bdev_desc, job->ch, NULL, 0,
 				   task->offset_blocks, job->io_size_blocks,
 				   false, bdevperf_zcopy_get_buf_complete, task);
 	if (rc != 0) {
diff --git a/test/external_code/passthru/vbdev_passthru.c b/test/external_code/passthru/vbdev_passthru.c
index 80e41162c..54e010142 100644
--- a/test/external_code/passthru/vbdev_passthru.c
+++ b/test/external_code/passthru/vbdev_passthru.c
@@ -347,7 +347,8 @@ vbdev_passthru_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *b
 				     _pt_complete_io, bdev_io);
 		break;
 	case SPDK_BDEV_IO_TYPE_ZCOPY:
-		rc = spdk_bdev_zcopy_start(pt_node->base_desc, pt_ch->base_ch, bdev_io->u.bdev.offset_blocks,
+		rc = spdk_bdev_zcopy_start(pt_node->base_desc, pt_ch->base_ch, bdev_io->u.bdev.iovs,
+					   bdev_io->u.bdev.iovcnt, bdev_io->u.bdev.offset_blocks,
 					   bdev_io->u.bdev.num_blocks, bdev_io->u.bdev.zcopy.populate,
 					   _pt_complete_zcopy_io, bdev_io);
 		break;
diff --git a/test/unit/lib/bdev/bdev.c/bdev_ut.c b/test/unit/lib/bdev/bdev.c/bdev_ut.c
index 54c555f7b..a0350bafa 100644
--- a/test/unit/lib/bdev/bdev.c/bdev_ut.c
+++ b/test/unit/lib/bdev/bdev.c/bdev_ut.c
@@ -116,6 +116,11 @@ static void *g_compare_write_buf;
 static uint32_t g_compare_write_buf_len;
 static bool g_abort_done;
 static enum spdk_bdev_io_status g_abort_status;
+static void *g_zcopy_read_buf;
+static uint32_t g_zcopy_read_buf_len;
+static void *g_zcopy_write_buf;
+static uint32_t g_zcopy_write_buf_len;
+static struct spdk_bdev_io *g_zcopy_bdev_io;
 
 static struct ut_expected_io *
 ut_alloc_expected_io(uint8_t type, uint64_t offset, uint64_t length, int iovcnt)
@@ -190,6 +195,43 @@ stub_submit_request(struct spdk_io_channel *_ch, struct spdk_bdev_io *bdev_io)
 		}
 	}
 
+	if (bdev_io->type == SPDK_BDEV_IO_TYPE_ZCOPY) {
+		if (bdev_io->u.bdev.zcopy.start) {
+			g_zcopy_bdev_io = bdev_io;
+			if (bdev_io->u.bdev.zcopy.populate) {
+				/* Start of a read */
+				CU_ASSERT(g_zcopy_read_buf != NULL);
+				CU_ASSERT(g_zcopy_read_buf_len > 0);
+				bdev_io->u.bdev.iovs[0].iov_base = g_zcopy_read_buf;
+				bdev_io->u.bdev.iovs[0].iov_len = g_zcopy_read_buf_len;
+				bdev_io->u.bdev.iovcnt = 1;
+			} else {
+				/* Start of a write */
+				CU_ASSERT(g_zcopy_write_buf != NULL);
+				CU_ASSERT(g_zcopy_write_buf_len > 0);
+				bdev_io->u.bdev.iovs[0].iov_base = g_zcopy_write_buf;
+				bdev_io->u.bdev.iovs[0].iov_len = g_zcopy_write_buf_len;
+				bdev_io->u.bdev.iovcnt = 1;
+			}
+		} else {
+			if (bdev_io->u.bdev.zcopy.commit) {
+				/* End of write */
+				CU_ASSERT(bdev_io->u.bdev.iovs[0].iov_base == g_zcopy_write_buf);
+				CU_ASSERT(bdev_io->u.bdev.iovs[0].iov_len == g_zcopy_write_buf_len);
+				CU_ASSERT(bdev_io->u.bdev.iovcnt == 1);
+				g_zcopy_write_buf = NULL;
+				g_zcopy_write_buf_len = 0;
+			} else {
+				/* End of read */
+				CU_ASSERT(bdev_io->u.bdev.iovs[0].iov_base == g_zcopy_read_buf);
+				CU_ASSERT(bdev_io->u.bdev.iovs[0].iov_len == g_zcopy_read_buf_len);
+				CU_ASSERT(bdev_io->u.bdev.iovcnt == 1);
+				g_zcopy_read_buf = NULL;
+				g_zcopy_read_buf_len = 0;
+			}
+		}
+	}
+
 	TAILQ_INSERT_TAIL(&ch->outstanding_io, bdev_io, module_link);
 	ch->outstanding_io_count++;
 
@@ -856,7 +898,13 @@ io_done(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)
 {
 	g_io_done = true;
 	g_io_status = bdev_io->internal.status;
-	spdk_bdev_free_io(bdev_io);
+	if ((bdev_io->type == SPDK_BDEV_IO_TYPE_ZCOPY) &&
+	    (bdev_io->u.bdev.zcopy.start)) {
+		g_zcopy_bdev_io = bdev_io;
+	} else {
+		spdk_bdev_free_io(bdev_io);
+		g_zcopy_bdev_io = NULL;
+	}
 }
 
 static void
@@ -3442,6 +3490,174 @@ bdev_write_zeroes(void)
 	poll_threads();
 }
 
+static void
+bdev_zcopy_write(void)
+{
+	struct spdk_bdev *bdev;
+	struct spdk_bdev_desc *desc = NULL;
+	struct spdk_io_channel *ioch;
+	struct ut_expected_io *expected_io;
+	uint64_t offset, num_blocks;
+	uint32_t num_completed;
+	char aa_buf[512];
+	struct iovec iov;
+	int rc;
+	const bool populate = false;
+	const bool commit = true;
+
+	memset(aa_buf, 0xaa, sizeof(aa_buf));
+
+	spdk_bdev_initialize(bdev_init_cb, NULL);
+	bdev = allocate_bdev("bdev");
+
+	rc = spdk_bdev_open_ext("bdev", true, bdev_ut_event_cb, NULL, &desc);
+	CU_ASSERT_EQUAL(rc, 0);
+	SPDK_CU_ASSERT_FATAL(desc != NULL);
+	CU_ASSERT(bdev == spdk_bdev_desc_get_bdev(desc));
+	ioch = spdk_bdev_get_io_channel(desc);
+	SPDK_CU_ASSERT_FATAL(ioch != NULL);
+
+	g_io_exp_status = SPDK_BDEV_IO_STATUS_SUCCESS;
+
+	offset = 50;
+	num_blocks = 1;
+	iov.iov_base = NULL;
+	iov.iov_len = 0;
+
+	g_zcopy_read_buf = (void *) 0x1122334455667788UL;
+	g_zcopy_read_buf_len = (uint32_t) -1;
+	/* Do a zcopy start for a write (populate=false) */
+	expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_ZCOPY, offset, num_blocks, 0);
+	TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+	g_io_done = false;
+	g_zcopy_write_buf = aa_buf;
+	g_zcopy_write_buf_len = sizeof(aa_buf);
+	g_zcopy_bdev_io = NULL;
+	rc = spdk_bdev_zcopy_start(desc, ioch, &iov, 1, offset, num_blocks, populate, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	num_completed = stub_complete_io(1);
+	CU_ASSERT_EQUAL(num_completed, 1);
+	CU_ASSERT(g_io_done == true);
+	CU_ASSERT(g_io_status == SPDK_BDEV_IO_STATUS_SUCCESS);
+	/* Check that the iov has been set up */
+	CU_ASSERT(iov.iov_base == g_zcopy_write_buf);
+	CU_ASSERT(iov.iov_len == g_zcopy_write_buf_len);
+	/* Check that the bdev_io has been saved */
+	CU_ASSERT(g_zcopy_bdev_io != NULL);
+	/* Now do the zcopy end for a write (commit=true) */
+	g_io_done = false;
+	expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_ZCOPY, offset, num_blocks, 0);
+	TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+	rc = spdk_bdev_zcopy_end(g_zcopy_bdev_io, commit, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	num_completed = stub_complete_io(1);
+	CU_ASSERT_EQUAL(num_completed, 1);
+	CU_ASSERT(g_io_done == true);
+	CU_ASSERT(g_io_status == SPDK_BDEV_IO_STATUS_SUCCESS);
+	/* Check the g_zcopy are reset by io_done */
+	CU_ASSERT(g_zcopy_write_buf == NULL);
+	CU_ASSERT(g_zcopy_write_buf_len == 0);
+	/* Check that io_done has freed the g_zcopy_bdev_io */
+	CU_ASSERT(g_zcopy_bdev_io == NULL);
+
+	/* Check the zcopy read buffer has not been touched which
+	 * ensures that the correct buffers were used.
+	 */
+	CU_ASSERT(g_zcopy_read_buf == (void *) 0x1122334455667788UL);
+	CU_ASSERT(g_zcopy_read_buf_len == (uint32_t) -1);
+
+	spdk_put_io_channel(ioch);
+	spdk_bdev_close(desc);
+	free_bdev(bdev);
+	spdk_bdev_finish(bdev_fini_cb, NULL);
+	poll_threads();
+}
+
+static void
+bdev_zcopy_read(void)
+{
+	struct spdk_bdev *bdev;
+	struct spdk_bdev_desc *desc = NULL;
+	struct spdk_io_channel *ioch;
+	struct ut_expected_io *expected_io;
+	uint64_t offset, num_blocks;
+	uint32_t num_completed;
+	char aa_buf[512];
+	struct iovec iov;
+	int rc;
+	const bool populate = true;
+	const bool commit = false;
+
+	memset(aa_buf, 0xaa, sizeof(aa_buf));
+
+	spdk_bdev_initialize(bdev_init_cb, NULL);
+	bdev = allocate_bdev("bdev");
+
+	rc = spdk_bdev_open_ext("bdev", true, bdev_ut_event_cb, NULL, &desc);
+	CU_ASSERT_EQUAL(rc, 0);
+	SPDK_CU_ASSERT_FATAL(desc != NULL);
+	CU_ASSERT(bdev == spdk_bdev_desc_get_bdev(desc));
+	ioch = spdk_bdev_get_io_channel(desc);
+	SPDK_CU_ASSERT_FATAL(ioch != NULL);
+
+	g_io_exp_status = SPDK_BDEV_IO_STATUS_SUCCESS;
+
+	offset = 50;
+	num_blocks = 1;
+	iov.iov_base = NULL;
+	iov.iov_len = 0;
+
+	g_zcopy_write_buf = (void *) 0x1122334455667788UL;
+	g_zcopy_write_buf_len = (uint32_t) -1;
+
+	/* Do a zcopy start for a read (populate=true) */
+	expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_ZCOPY, offset, num_blocks, 0);
+	TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+	g_io_done = false;
+	g_zcopy_read_buf = aa_buf;
+	g_zcopy_read_buf_len = sizeof(aa_buf);
+	g_zcopy_bdev_io = NULL;
+	rc = spdk_bdev_zcopy_start(desc, ioch, &iov, 1, offset, num_blocks, populate, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	num_completed = stub_complete_io(1);
+	CU_ASSERT_EQUAL(num_completed, 1);
+	CU_ASSERT(g_io_done == true);
+	CU_ASSERT(g_io_status == SPDK_BDEV_IO_STATUS_SUCCESS);
+	/* Check that the iov has been set up */
+	CU_ASSERT(iov.iov_base == g_zcopy_read_buf);
+	CU_ASSERT(iov.iov_len == g_zcopy_read_buf_len);
+	/* Check that the bdev_io has been saved */
+	CU_ASSERT(g_zcopy_bdev_io != NULL);
+
+	/* Now do the zcopy end for a read (commit=false) */
+	g_io_done = false;
+	expected_io = ut_alloc_expected_io(SPDK_BDEV_IO_TYPE_ZCOPY, offset, num_blocks, 0);
+	TAILQ_INSERT_TAIL(&g_bdev_ut_channel->expected_io, expected_io, link);
+	rc = spdk_bdev_zcopy_end(g_zcopy_bdev_io, commit, io_done, NULL);
+	CU_ASSERT_EQUAL(rc, 0);
+	num_completed = stub_complete_io(1);
+	CU_ASSERT_EQUAL(num_completed, 1);
+	CU_ASSERT(g_io_done == true);
+	CU_ASSERT(g_io_status == SPDK_BDEV_IO_STATUS_SUCCESS);
+	/* Check the g_zcopy are reset by io_done */
+	CU_ASSERT(g_zcopy_read_buf == NULL);
+	CU_ASSERT(g_zcopy_read_buf_len == 0);
+	/* Check that io_done has freed the g_zcopy_bdev_io */
+	CU_ASSERT(g_zcopy_bdev_io == NULL);
+
+	/* Check the zcopy write buffer has not been touched which
+	 * ensures that the correct buffers were used.
+	 */
+	CU_ASSERT(g_zcopy_write_buf == (void *) 0x1122334455667788UL);
+	CU_ASSERT(g_zcopy_write_buf_len == (uint32_t) -1);
+
+	spdk_put_io_channel(ioch);
+	spdk_bdev_close(desc);
+	free_bdev(bdev);
+	spdk_bdev_finish(bdev_fini_cb, NULL);
+	poll_threads();
+}
+
 static void
 bdev_open_while_hotremove(void)
 {
@@ -4495,6 +4711,8 @@ main(int argc, char **argv)
 	CU_ADD_TEST(suite, bdev_write_zeroes);
 	CU_ADD_TEST(suite, bdev_compare_and_write);
 	CU_ADD_TEST(suite, bdev_compare);
+	CU_ADD_TEST(suite, bdev_zcopy_write);
+	CU_ADD_TEST(suite, bdev_zcopy_read);
 	CU_ADD_TEST(suite, bdev_open_while_hotremove);
 	CU_ADD_TEST(suite, bdev_close_while_hotremove);
 	CU_ADD_TEST(suite, bdev_open_ext);
-- 
2.26.2


From 980b501c9879c94fca64782bc4b718d1c6e8e948 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 2 Jun 2021 02:10:38 +0900
Subject: [PATCH 308/342] bdev/nvme: Separate helper function find_io_path()
 between nvme and ocssd

This enables us to optimize nvme_bdev for multipath.

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I09dcc6b34b4529fe1f90dbe0fddcbee807cf217e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8148
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 module/bdev/nvme/bdev_nvme.c  | 22 ++++++++++++++++++++++
 module/bdev/nvme/bdev_ocssd.c | 20 +++++++++++++++++---
 module/bdev/nvme/common.h     | 22 ----------------------
 3 files changed, 39 insertions(+), 25 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index db78e56e6..4422a4938 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -251,6 +251,28 @@ static struct spdk_bdev_module nvme_if = {
 };
 SPDK_BDEV_MODULE_REGISTER(nvme, &nvme_if)
 
+static inline bool
+bdev_nvme_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_path *io_path,
+		       struct nvme_bdev_ns **_nvme_ns, struct spdk_nvme_qpair **_qpair)
+{
+	if (spdk_unlikely(io_path->qpair == NULL)) {
+		/* The device is currently resetting. */
+		return false;
+	}
+
+	*_nvme_ns = nbdev->nvme_ns;
+	*_qpair = io_path->qpair;
+	return true;
+}
+
+static inline bool
+bdev_nvme_find_admin_path(struct nvme_io_path *io_path,
+			  struct nvme_bdev_ctrlr **_nvme_bdev_ctrlr)
+{
+	*_nvme_bdev_ctrlr = io_path->ctrlr;
+	return true;
+}
+
 static inline void
 bdev_nvme_io_complete_nvme_status(struct nvme_bdev_io *bio,
 				  const struct spdk_nvme_cpl *cpl)
diff --git a/module/bdev/nvme/bdev_ocssd.c b/module/bdev/nvme/bdev_ocssd.c
index b28df317c..c0c503f77 100644
--- a/module/bdev/nvme/bdev_ocssd.c
+++ b/module/bdev/nvme/bdev_ocssd.c
@@ -105,6 +105,20 @@ bdev_ocssd_get_ns_from_nvme(struct nvme_bdev_ns *nvme_ns)
 	return nvme_ns->type_ctx;
 }
 
+static inline bool
+bdev_ocssd_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_path *io_path,
+			struct nvme_bdev_ns **_nvme_ns, struct spdk_nvme_qpair **_qpair)
+{
+	if (spdk_unlikely(io_path->qpair == NULL)) {
+		/* The device is currently resetting. */
+		return false;
+	}
+
+	*_nvme_ns = nbdev->nvme_ns;
+	*_qpair = io_path->qpair;
+	return true;
+}
+
 static int
 bdev_ocssd_library_init(void)
 {
@@ -524,7 +538,7 @@ bdev_ocssd_io_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 		return;
 	}
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
+	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
 			  &nvme_ns, &qpair))) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
@@ -653,7 +667,7 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 
 	io_path = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, io_path, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path, &nvme_ns, &qpair))) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
 	}
@@ -786,7 +800,7 @@ _bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev
 	struct nvme_bdev_ns *nvme_ns;
 	struct spdk_nvme_qpair *qpair;
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
+	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
 			  &nvme_ns, &qpair))) {
 		return -1;
 	}
diff --git a/module/bdev/nvme/common.h b/module/bdev/nvme/common.h
index 7ac7089c4..b1bdf8d35 100644
--- a/module/bdev/nvme/common.h
+++ b/module/bdev/nvme/common.h
@@ -177,26 +177,4 @@ void nvme_bdev_dump_trid_json(const struct spdk_nvme_transport_id *trid,
 void nvme_bdev_ctrlr_destruct(struct nvme_bdev_ctrlr *nvme_bdev_ctrlr);
 void nvme_bdev_ctrlr_unregister(void *ctx);
 
-static inline bool
-bdev_nvme_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_path *io_path,
-		       struct nvme_bdev_ns **_nvme_ns, struct spdk_nvme_qpair **_qpair)
-{
-	if (spdk_unlikely(io_path->qpair == NULL)) {
-		/* The device is currently resetting. */
-		return false;
-	}
-
-	*_nvme_ns = nbdev->nvme_ns;
-	*_qpair = io_path->qpair;
-	return true;
-}
-
-static inline bool
-bdev_nvme_find_admin_path(struct nvme_io_path *io_path,
-			  struct nvme_bdev_ctrlr **_nvme_bdev_ctrlr)
-{
-	*_nvme_bdev_ctrlr = io_path->ctrlr;
-	return true;
-}
-
 #endif /* SPDK_COMMON_BDEV_NVME_H */
-- 
2.26.2


From 55e4be3432e30b7790a2ff667463cf7760d29784 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 2 Jun 2021 02:49:43 +0900
Subject: [PATCH 309/342] bdev/nvme: find_io_path() returns spdk_nvme_ns
 pointer directly

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I3f2b047c162c7d9cab69c273ca8ac5c2236314fa
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8149
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 module/bdev/nvme/bdev_nvme.c                  | 52 +++++++++----------
 .../lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c  | 12 ++---
 2 files changed, 32 insertions(+), 32 deletions(-)

diff --git a/module/bdev/nvme/bdev_nvme.c b/module/bdev/nvme/bdev_nvme.c
index 4422a4938..cd9086586 100644
--- a/module/bdev/nvme/bdev_nvme.c
+++ b/module/bdev/nvme/bdev_nvme.c
@@ -253,14 +253,14 @@ SPDK_BDEV_MODULE_REGISTER(nvme, &nvme_if)
 
 static inline bool
 bdev_nvme_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_path *io_path,
-		       struct nvme_bdev_ns **_nvme_ns, struct spdk_nvme_qpair **_qpair)
+		       struct spdk_nvme_ns **_ns, struct spdk_nvme_qpair **_qpair)
 {
 	if (spdk_unlikely(io_path->qpair == NULL)) {
 		/* The device is currently resetting. */
 		return false;
 	}
 
-	*_nvme_ns = nbdev->nvme_ns;
+	*_ns = nbdev->nvme_ns->ns;
 	*_qpair = io_path->qpair;
 	return true;
 }
@@ -769,7 +769,7 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 	struct spdk_bdev *bdev = bdev_io->bdev;
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev->ctxt;
 	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
-	struct nvme_bdev_ns *nvme_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 	int ret;
 
@@ -778,12 +778,12 @@ bdev_nvme_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 		goto exit;
 	}
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair))) {
 		ret = -ENXIO;
 		goto exit;
 	}
 
-	ret = bdev_nvme_readv(nvme_ns->ns,
+	ret = bdev_nvme_readv(ns,
 			      qpair,
 			      bio,
 			      bdev_io->u.bdev.iovs,
@@ -807,11 +807,11 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev->ctxt;
 	struct nvme_bdev_io *nbdev_io = (struct nvme_bdev_io *)bdev_io->driver_ctx;
 	struct nvme_bdev_io *nbdev_io_to_abort;
-	struct nvme_bdev_ns *nvme_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 	int rc = 0;
 
-	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair))) {
 		rc = -ENXIO;
 		goto exit;
 	}
@@ -819,7 +819,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 	switch (bdev_io->type) {
 	case SPDK_BDEV_IO_TYPE_READ:
 		if (bdev_io->u.bdev.iovs && bdev_io->u.bdev.iovs[0].iov_base) {
-			rc = bdev_nvme_readv(nvme_ns->ns,
+			rc = bdev_nvme_readv(ns,
 					     qpair,
 					     nbdev_io,
 					     bdev_io->u.bdev.iovs,
@@ -835,7 +835,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 		}
 		break;
 	case SPDK_BDEV_IO_TYPE_WRITE:
-		rc = bdev_nvme_writev(nvme_ns->ns,
+		rc = bdev_nvme_writev(ns,
 				      qpair,
 				      nbdev_io,
 				      bdev_io->u.bdev.iovs,
@@ -846,7 +846,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 				      bdev->dif_check_flags);
 		break;
 	case SPDK_BDEV_IO_TYPE_COMPARE:
-		rc = bdev_nvme_comparev(nvme_ns->ns,
+		rc = bdev_nvme_comparev(ns,
 					qpair,
 					nbdev_io,
 					bdev_io->u.bdev.iovs,
@@ -857,7 +857,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 					bdev->dif_check_flags);
 		break;
 	case SPDK_BDEV_IO_TYPE_COMPARE_AND_WRITE:
-		rc = bdev_nvme_comparev_and_writev(nvme_ns->ns,
+		rc = bdev_nvme_comparev_and_writev(ns,
 						   qpair,
 						   nbdev_io,
 						   bdev_io->u.bdev.iovs,
@@ -870,7 +870,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 						   bdev->dif_check_flags);
 		break;
 	case SPDK_BDEV_IO_TYPE_UNMAP:
-		rc = bdev_nvme_unmap(nvme_ns->ns,
+		rc = bdev_nvme_unmap(ns,
 				     qpair,
 				     nbdev_io,
 				     bdev_io->u.bdev.offset_blocks,
@@ -880,14 +880,14 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 		rc = bdev_nvme_reset(io_path, bdev_io);
 		break;
 	case SPDK_BDEV_IO_TYPE_FLUSH:
-		rc = bdev_nvme_flush(nvme_ns->ns,
+		rc = bdev_nvme_flush(ns,
 				     qpair,
 				     nbdev_io,
 				     bdev_io->u.bdev.offset_blocks,
 				     bdev_io->u.bdev.num_blocks);
 		break;
 	case SPDK_BDEV_IO_TYPE_ZONE_APPEND:
-		rc = bdev_nvme_zone_appendv(nvme_ns->ns,
+		rc = bdev_nvme_zone_appendv(ns,
 					    qpair,
 					    nbdev_io,
 					    bdev_io->u.bdev.iovs,
@@ -898,7 +898,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 					    bdev->dif_check_flags);
 		break;
 	case SPDK_BDEV_IO_TYPE_GET_ZONE_INFO:
-		rc = bdev_nvme_get_zone_info(nvme_ns->ns,
+		rc = bdev_nvme_get_zone_info(ns,
 					     qpair,
 					     nbdev_io,
 					     bdev_io->u.zone_mgmt.zone_id,
@@ -906,7 +906,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 					     bdev_io->u.zone_mgmt.buf);
 		break;
 	case SPDK_BDEV_IO_TYPE_ZONE_MANAGEMENT:
-		rc = bdev_nvme_zone_management(nvme_ns->ns,
+		rc = bdev_nvme_zone_management(ns,
 					       qpair,
 					       nbdev_io,
 					       bdev_io->u.zone_mgmt.zone_id,
@@ -920,7 +920,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 					      bdev_io->u.nvme_passthru.nbytes);
 		break;
 	case SPDK_BDEV_IO_TYPE_NVME_IO:
-		rc = bdev_nvme_io_passthru(nvme_ns->ns,
+		rc = bdev_nvme_io_passthru(ns,
 					   qpair,
 					   nbdev_io,
 					   &bdev_io->u.nvme_passthru.cmd,
@@ -928,7 +928,7 @@ bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 					   bdev_io->u.nvme_passthru.nbytes);
 		break;
 	case SPDK_BDEV_IO_TYPE_NVME_IO_MD:
-		rc = bdev_nvme_io_passthru_md(nvme_ns->ns,
+		rc = bdev_nvme_io_passthru_md(ns,
 					      qpair,
 					      nbdev_io,
 					      &bdev_io->u.nvme_passthru.cmd,
@@ -2584,7 +2584,7 @@ bdev_nvme_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(bio);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
 	struct nvme_io_path *io_path;
-	struct nvme_bdev_ns *nvme_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 	int ret;
 
@@ -2597,9 +2597,9 @@ bdev_nvme_readv_done(void *ref, const struct spdk_nvme_cpl *cpl)
 
 		io_path = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
 
-		if (spdk_likely(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair))) {
+		if (spdk_likely(bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair))) {
 			/* Read without PI checking to verify PI error. */
-			ret = bdev_nvme_no_pi_readv(nvme_ns->ns,
+			ret = bdev_nvme_no_pi_readv(ns,
 						    qpair,
 						    bio,
 						    bdev_io->u.bdev.iovs,
@@ -2752,7 +2752,7 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	struct spdk_bdev_zone_info *info = bdev_io->u.zone_mgmt.buf;
 	uint64_t max_zones_per_buf, i;
 	uint32_t zone_report_bufsize;
-	struct nvme_bdev_ns *nvme_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 	int ret;
 
@@ -2760,12 +2760,12 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 		goto out_complete_io_nvme_cpl;
 	}
 
-	if (!bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair)) {
+	if (!bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair)) {
 		ret = -ENXIO;
 		goto out_complete_io_ret;
 	}
 
-	zone_report_bufsize = spdk_nvme_ns_get_max_io_xfer_size(nvme_ns->ns);
+	zone_report_bufsize = spdk_nvme_ns_get_max_io_xfer_size(ns);
 	max_zones_per_buf = (zone_report_bufsize - sizeof(*bio->zone_report_buf)) /
 			    sizeof(bio->zone_report_buf->descs[0]);
 
@@ -2789,11 +2789,11 @@ bdev_nvme_get_zone_info_done(void *ref, const struct spdk_nvme_cpl *cpl)
 	}
 
 	if (bio->handled_zones < zones_to_copy) {
-		uint64_t zone_size_lba = spdk_nvme_zns_ns_get_zone_size_sectors(nvme_ns->ns);
+		uint64_t zone_size_lba = spdk_nvme_zns_ns_get_zone_size_sectors(ns);
 		uint64_t slba = zone_id + (zone_size_lba * bio->handled_zones);
 
 		memset(bio->zone_report_buf, 0, zone_report_bufsize);
-		ret = spdk_nvme_zns_report_zones(nvme_ns->ns, qpair,
+		ret = spdk_nvme_zns_report_zones(ns, qpair,
 						 bio->zone_report_buf, zone_report_bufsize,
 						 slba, SPDK_NVME_ZRA_LIST_ALL, true,
 						 bdev_nvme_get_zone_info_done, bio);
diff --git a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
index d2a0174b8..f25f2f098 100644
--- a/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
+++ b/test/unit/lib/bdev/nvme/bdev_nvme.c/bdev_nvme_ut.c
@@ -1723,10 +1723,10 @@ ut_test_submit_nvme_cmd(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io
 {
 	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
-	struct nvme_bdev_ns *nvme_ns = NULL;
+	struct spdk_nvme_ns *ns = NULL;
 	struct spdk_nvme_qpair *qpair = NULL;
 
-	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair));
+	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair));
 
 	bdev_io->type = io_type;
 	bdev_io->internal.in_submit_request = true;
@@ -1749,10 +1749,10 @@ ut_test_submit_nop(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io,
 {
 	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
-	struct nvme_bdev_ns *nvme_ns = NULL;
+	struct spdk_nvme_ns *ns = NULL;
 	struct spdk_nvme_qpair *qpair = NULL;
 
-	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair));
+	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair));
 
 	bdev_io->type = io_type;
 	bdev_io->internal.in_submit_request = true;
@@ -1771,10 +1771,10 @@ ut_test_submit_fused_nvme_cmd(struct spdk_io_channel *ch, struct spdk_bdev_io *b
 	struct nvme_bdev_io *bio = (struct nvme_bdev_io *)bdev_io->driver_ctx;
 	struct ut_nvme_req *req;
 	struct nvme_bdev *nbdev = (struct nvme_bdev *)bdev_io->bdev->ctxt;
-	struct nvme_bdev_ns *nvme_ns = NULL;
+	struct spdk_nvme_ns *ns = NULL;
 	struct spdk_nvme_qpair *qpair = NULL;
 
-	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &nvme_ns, &qpair));
+	CU_ASSERT(bdev_nvme_find_io_path(nbdev, io_path, &ns, &qpair));
 
 	/* Only compare and write now. */
 	bdev_io->type = SPDK_BDEV_IO_TYPE_COMPARE_AND_WRITE;
-- 
2.26.2


From b7cc001a04c329e5e9464b42e647042b3bfb72bc Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Wed, 2 Jun 2021 03:13:58 +0900
Subject: [PATCH 310/342] bdev/ocssd: find_io_path() returns bdev_ocssd_ns and
 spdk_nvme_ns pointers directly

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: Ifd5a3f5ab2e87d383da1c3b94949fa2ffd916ecc
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8150
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 module/bdev/nvme/bdev_ocssd.c | 95 +++++++++++++++++++----------------
 1 file changed, 51 insertions(+), 44 deletions(-)

diff --git a/module/bdev/nvme/bdev_ocssd.c b/module/bdev/nvme/bdev_ocssd.c
index c0c503f77..62e628006 100644
--- a/module/bdev/nvme/bdev_ocssd.c
+++ b/module/bdev/nvme/bdev_ocssd.c
@@ -107,14 +107,16 @@ bdev_ocssd_get_ns_from_nvme(struct nvme_bdev_ns *nvme_ns)
 
 static inline bool
 bdev_ocssd_find_io_path(struct nvme_bdev *nbdev, struct nvme_io_path *io_path,
-			struct nvme_bdev_ns **_nvme_ns, struct spdk_nvme_qpair **_qpair)
+			struct bdev_ocssd_ns **_ocssd_ns,
+			struct spdk_nvme_ns **_ns, struct spdk_nvme_qpair **_qpair)
 {
 	if (spdk_unlikely(io_path->qpair == NULL)) {
 		/* The device is currently resetting. */
 		return false;
 	}
 
-	*_nvme_ns = nbdev->nvme_ns;
+	*_ocssd_ns = bdev_ocssd_get_ns_from_nvme(nbdev->nvme_ns);
+	*_ns = nbdev->nvme_ns->ns;
 	*_qpair = io_path->qpair;
 	return true;
 }
@@ -383,12 +385,11 @@ bdev_ocssd_read_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-bdev_ocssd_read(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
-		struct spdk_nvme_qpair *qpair,
+bdev_ocssd_read(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+		struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		struct bdev_ocssd_io *ocdev_io, struct iovec *iov, int iovcnt,
 		void *md, uint64_t lba_count, uint64_t lba)
 {
-	struct bdev_ocssd_ns *ocssd_ns = bdev_ocssd_get_ns_from_nvme(nvme_ns);
 	const size_t zone_size = bdev_ocssd_get_zone_size(ocssd_bdev);
 
 	if ((lba % zone_size) + lba_count > zone_size) {
@@ -403,7 +404,7 @@ bdev_ocssd_read(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
 
 	lba = bdev_ocssd_to_disk_lba(ocssd_ns, lba);
 
-	return spdk_nvme_ns_cmd_readv_with_md(nvme_ns->ns, qpair, lba,
+	return spdk_nvme_ns_cmd_readv_with_md(ns, qpair, lba,
 					      lba_count, bdev_ocssd_read_cb,
 					      ocdev_io, 0, bdev_ocssd_reset_sgl,
 					      bdev_ocssd_next_sge, md, 0, 0);
@@ -424,12 +425,11 @@ bdev_ocssd_write_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-bdev_ocssd_write(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
-		 struct spdk_nvme_qpair *qpair,
+bdev_ocssd_write(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+		 struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		 struct bdev_ocssd_io *ocdev_io, struct iovec *iov, int iovcnt,
 		 void *md, uint64_t lba_count, uint64_t lba)
 {
-	struct bdev_ocssd_ns *ocssd_ns = bdev_ocssd_get_ns_from_nvme(nvme_ns);
 	const size_t zone_size = bdev_ocssd_get_zone_size(ocssd_bdev);
 	struct bdev_ocssd_zone *zone;
 	int rc;
@@ -452,7 +452,7 @@ bdev_ocssd_write(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
 
 	lba = bdev_ocssd_to_disk_lba(ocssd_ns, lba);
 
-	rc = spdk_nvme_ns_cmd_writev_with_md(nvme_ns->ns, qpair, lba,
+	rc = spdk_nvme_ns_cmd_writev_with_md(ns, qpair, lba,
 					     lba_count, bdev_ocssd_write_cb,
 					     ocdev_io, 0, bdev_ocssd_reset_sgl,
 					     bdev_ocssd_next_sge, md, 0, 0);
@@ -479,12 +479,11 @@ bdev_ocssd_append_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-bdev_ocssd_zone_append(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
-		       struct spdk_nvme_qpair *qpair,
+bdev_ocssd_zone_append(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+		       struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		       struct bdev_ocssd_io *ocdev_io, struct iovec *iov, int iovcnt,
 		       void *md, uint64_t lba_count, uint64_t lba)
 {
-	struct bdev_ocssd_ns *ocssd_ns = bdev_ocssd_get_ns_from_nvme(nvme_ns);
 	struct bdev_ocssd_zone *zone;
 	int rc = 0;
 
@@ -512,7 +511,7 @@ bdev_ocssd_zone_append(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_
 
 	lba = bdev_ocssd_to_disk_lba(ocssd_ns, zone->write_pointer);
 
-	rc = spdk_nvme_ns_cmd_writev_with_md(nvme_ns->ns, qpair, lba,
+	rc = spdk_nvme_ns_cmd_writev_with_md(ns, qpair, lba,
 					     lba_count, bdev_ocssd_append_cb,
 					     ocdev_io, 0, bdev_ocssd_reset_sgl,
 					     bdev_ocssd_next_sge, md, 0, 0);
@@ -529,7 +528,8 @@ bdev_ocssd_io_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 {
 	struct ocssd_bdev *ocssd_bdev = (struct ocssd_bdev *)bdev_io->bdev->ctxt;
 	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
-	struct nvme_bdev_ns *nvme_ns;
+	struct bdev_ocssd_ns *ocssd_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 	int rc;
 
@@ -539,13 +539,14 @@ bdev_ocssd_io_get_buf_cb(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_i
 	}
 
 	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
-			  &nvme_ns, &qpair))) {
+			  &ocssd_ns, &ns, &qpair))) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
 	}
 
 	rc = bdev_ocssd_read(ocssd_bdev,
-			     nvme_ns,
+			     ocssd_ns,
+			     ns,
 			     qpair,
 			     (struct bdev_ocssd_io *)bdev_io->driver_ctx,
 			     bdev_io->u.bdev.iovs,
@@ -575,11 +576,10 @@ bdev_ocssd_reset_zone_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-bdev_ocssd_reset_zone(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
-		      struct spdk_nvme_qpair *qpair,
+bdev_ocssd_reset_zone(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+		      struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
 		      struct bdev_ocssd_io *ocdev_io, uint64_t slba, size_t num_zones)
 {
-	struct bdev_ocssd_ns *ocssd_ns = bdev_ocssd_get_ns_from_nvme(nvme_ns);
 	uint64_t offset, zone_size = bdev_ocssd_get_zone_size(ocssd_bdev);
 	struct bdev_ocssd_zone *zone;
 	int rc;
@@ -601,7 +601,7 @@ bdev_ocssd_reset_zone(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_n
 
 	ocdev_io->io.zone = zone;
 
-	rc = spdk_nvme_ocssd_ns_cmd_vector_reset(nvme_ns->ns, qpair,
+	rc = spdk_nvme_ocssd_ns_cmd_vector_reset(ns, qpair,
 			ocdev_io->io.lba, num_zones, NULL,
 			bdev_ocssd_reset_zone_cb, ocdev_io);
 	if (spdk_unlikely(rc != 0)) {
@@ -611,8 +611,8 @@ bdev_ocssd_reset_zone(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_n
 	return rc;
 }
 
-static int _bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev,
-				     struct nvme_bdev_ns *nvme_ns,
+static int _bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+				     struct spdk_nvme_ns *ns,
 				     struct bdev_ocssd_io *ocdev_io, uint64_t zone_id);
 
 static void
@@ -654,7 +654,7 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 	struct spdk_bdev_io *bdev_io = spdk_bdev_io_from_ctx(ctx);
 	struct ocssd_bdev *ocssd_bdev = bdev_io->bdev->ctxt;
 	struct nvme_io_path *io_path;
-	struct nvme_bdev_ns *nvme_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 	struct bdev_ocssd_ns *ocssd_ns;
 	struct spdk_bdev_zone_info *zone_info;
@@ -667,13 +667,12 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 
 	io_path = spdk_io_channel_get_ctx(spdk_bdev_io_get_io_channel(bdev_io));
 
-	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path, &nvme_ns, &qpair))) {
+	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path, &ocssd_ns, &ns,
+			  &qpair))) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
 		return;
 	}
 
-	ocssd_ns = bdev_ocssd_get_ns_from_nvme(nvme_ns);
-
 	zone_info = ((struct spdk_bdev_zone_info *)bdev_io->u.zone_mgmt.buf) +
 		    ocdev_io->zone_info.chunk_offset;
 	bdev_ocssd_fill_zone_info(ocssd_bdev, ocssd_ns, zone_info, chunk_info);
@@ -681,7 +680,7 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 	if (++ocdev_io->zone_info.chunk_offset == bdev_io->u.zone_mgmt.num_zones) {
 		spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_SUCCESS);
 	} else {
-		rc = _bdev_ocssd_get_zone_info(ocssd_bdev, nvme_ns, ocdev_io,
+		rc = _bdev_ocssd_get_zone_info(ocssd_bdev, ocssd_ns, ns, ocdev_io,
 					       bdev_io->u.zone_mgmt.zone_id);
 		if (spdk_unlikely(rc != 0)) {
 			if (rc == -ENOMEM) {
@@ -694,18 +693,18 @@ bdev_ocssd_zone_info_cb(void *ctx, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-_bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
+_bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+			  struct spdk_nvme_ns *ns,
 			  struct bdev_ocssd_io *ocdev_io, uint64_t zone_id)
 {
-	struct bdev_ocssd_ns *ocssd_ns = bdev_ocssd_get_ns_from_nvme(nvme_ns);
 	uint64_t lba, offset, zone_size = bdev_ocssd_get_zone_size(ocssd_bdev);
 
 	lba = zone_id + ocdev_io->zone_info.chunk_offset * zone_size;
 	offset = bdev_ocssd_to_chunk_info_offset(ocssd_ns, lba);
 
-	return spdk_nvme_ctrlr_cmd_get_log_page(spdk_nvme_ns_get_ctrlr(nvme_ns->ns),
+	return spdk_nvme_ctrlr_cmd_get_log_page(spdk_nvme_ns_get_ctrlr(ns),
 						SPDK_OCSSD_LOG_CHUNK_INFO,
-						spdk_nvme_ns_get_id(nvme_ns->ns),
+						spdk_nvme_ns_get_id(ns),
 						&ocdev_io->zone_info.chunk_info,
 						sizeof(ocdev_io->zone_info.chunk_info),
 						offset * sizeof(ocdev_io->zone_info.chunk_info),
@@ -713,7 +712,8 @@ _bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nv
 }
 
 static int
-bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
+bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+			 struct spdk_nvme_ns *ns,
 			 struct bdev_ocssd_io *ocdev_io, uint64_t zone_id, uint32_t num_zones)
 {
 	uint64_t zone_size = bdev_ocssd_get_zone_size(ocssd_bdev);
@@ -730,17 +730,19 @@ bdev_ocssd_get_zone_info(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvm
 
 	ocdev_io->zone_info.chunk_offset = 0;
 
-	return _bdev_ocssd_get_zone_info(ocssd_bdev, nvme_ns, ocdev_io, zone_id);
+	return _bdev_ocssd_get_zone_info(ocssd_bdev, ocssd_ns, ns, ocdev_io, zone_id);
 }
 
 static int
-bdev_ocssd_zone_management(struct ocssd_bdev *ocssd_bdev, struct nvme_bdev_ns *nvme_ns,
-			   struct spdk_nvme_qpair *qpair, struct spdk_bdev_io *bdev_io)
+bdev_ocssd_zone_management(struct ocssd_bdev *ocssd_bdev, struct bdev_ocssd_ns *ocssd_ns,
+			   struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair,
+			   struct spdk_bdev_io *bdev_io)
 {
 	switch (bdev_io->u.zone_mgmt.zone_action) {
 	case SPDK_BDEV_ZONE_RESET:
 		return bdev_ocssd_reset_zone(ocssd_bdev,
-					     nvme_ns,
+					     ocssd_ns,
+					     ns,
 					     qpair,
 					     (struct bdev_ocssd_io *)bdev_io->driver_ctx,
 					     bdev_io->u.zone_mgmt.zone_id,
@@ -797,11 +799,12 @@ _bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev
 	struct nvme_io_path *io_path = spdk_io_channel_get_ctx(ch);
 	struct ocssd_bdev *ocssd_bdev = (struct ocssd_bdev *)bdev_io->bdev->ctxt;
 	struct bdev_ocssd_io *ocdev_io = (struct bdev_ocssd_io *)bdev_io->driver_ctx;
-	struct nvme_bdev_ns *nvme_ns;
+	struct bdev_ocssd_ns *ocssd_ns;
+	struct spdk_nvme_ns *ns;
 	struct spdk_nvme_qpair *qpair;
 
 	if (spdk_unlikely(!bdev_ocssd_find_io_path(&ocssd_bdev->nvme_bdev, io_path,
-			  &nvme_ns, &qpair))) {
+			  &ocssd_ns, &ns, &qpair))) {
 		return -1;
 	}
 
@@ -809,7 +812,8 @@ _bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev
 	case SPDK_BDEV_IO_TYPE_READ:
 		if (bdev_io->u.bdev.iovs && bdev_io->u.bdev.iovs[0].iov_base) {
 			return bdev_ocssd_read(ocssd_bdev,
-					       nvme_ns,
+					       ocssd_ns,
+					       ns,
 					       qpair,
 					       ocdev_io,
 					       bdev_io->u.bdev.iovs,
@@ -825,7 +829,8 @@ _bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev
 
 	case SPDK_BDEV_IO_TYPE_WRITE:
 		return bdev_ocssd_write(ocssd_bdev,
-					nvme_ns,
+					ocssd_ns,
+					ns,
 					qpair,
 					ocdev_io,
 					bdev_io->u.bdev.iovs,
@@ -835,18 +840,20 @@ _bdev_ocssd_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev
 					bdev_io->u.bdev.offset_blocks);
 
 	case SPDK_BDEV_IO_TYPE_ZONE_MANAGEMENT:
-		return bdev_ocssd_zone_management(ocssd_bdev, nvme_ns, qpair, bdev_io);
+		return bdev_ocssd_zone_management(ocssd_bdev, ocssd_ns, ns, qpair, bdev_io);
 
 	case SPDK_BDEV_IO_TYPE_GET_ZONE_INFO:
 		return bdev_ocssd_get_zone_info(ocssd_bdev,
-						nvme_ns,
+						ocssd_ns,
+						ns,
 						ocdev_io,
 						bdev_io->u.zone_mgmt.zone_id,
 						bdev_io->u.zone_mgmt.num_zones);
 
 	case SPDK_BDEV_IO_TYPE_ZONE_APPEND:
 		return bdev_ocssd_zone_append(ocssd_bdev,
-					      nvme_ns,
+					      ocssd_ns,
+					      ns,
 					      qpair,
 					      ocdev_io,
 					      bdev_io->u.bdev.iovs,
-- 
2.26.2


From e9a4350381aa642b474f6774c33f2f12ad0c0105 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Tue, 25 May 2021 11:15:15 +0200
Subject: [PATCH 311/342] pkgdep/git: Patch QAT driver for changes in crypto
 API

Details here:

git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0eb76ba29d16df2951d37c54ca279c4e5630b071

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Ica523bc4ec6b68fab2549a02476872b4d250a8f0
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8041
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 test/common/config/pkgdep/git                 |  6 ++++
 .../pkgdep/patches/qat/0001-cipher-ns.patch   | 28 +++++++++++++++++++
 2 files changed, 34 insertions(+)
 create mode 100644 test/common/config/pkgdep/patches/qat/0001-cipher-ns.patch

diff --git a/test/common/config/pkgdep/git b/test/common/config/pkgdep/git
index b5c8d1d8e..b0684fd9e 100644
--- a/test/common/config/pkgdep/git
+++ b/test/common/config/pkgdep/git
@@ -158,6 +158,12 @@ function install_qat() {
 		# qat_algs_ablkcipher.c doesn't exist in older versions of the driver so simply force the patch
 		patch --force --dir="$GIT_REPOS/QAT" -p1
 	fi < "$rootdir/test/common/config/pkgdep/patches/qat/0001-sha.patch" || :
+
+	# cipher routines were moved from crypto.h to crypto/internal/cipher.h in kernels >= 5.12
+	if ((kernel_ver >= 0x050c00)); then
+		patch --dir="$GIT_REPOS/QAT" -p1
+	fi < "$rootdir/test/common/config/pkgdep/patches/qat/0001-cipher-ns.patch"
+
 	(cd "$GIT_REPOS/QAT" && sudo ./configure --enable-icp-sriov=host && sudo make install)
 
 	if ! sudo service qat_service start; then
diff --git a/test/common/config/pkgdep/patches/qat/0001-cipher-ns.patch b/test/common/config/pkgdep/patches/qat/0001-cipher-ns.patch
new file mode 100644
index 000000000..8c9f29c5a
--- /dev/null
+++ b/test/common/config/pkgdep/patches/qat/0001-cipher-ns.patch
@@ -0,0 +1,28 @@
+Cipher routines were moved to their own header file and the symbol exports
+are now available under a new namespace, CRYPTO_INTERNAL.
+
+Details: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0eb76ba29d16df2951d37c54ca279c4e5630b071
+---
+
+diff --git a/quickassist/lookaside/access_layer/src/linux/icp_qa_module.c b/quickassist/lookaside/access_layer/src/linux/icp_qa_module.c
+index 413eb07..f7d09bd 100644
+--- a/quickassist/lookaside/access_layer/src/linux/icp_qa_module.c
++++ b/quickassist/lookaside/access_layer/src/linux/icp_qa_module.c
+@@ -120,3 +120,4 @@ module_exit(kapi_mod_exit);
+ MODULE_DESCRIPTION("Intel(R) Quickassist Technology Acceleration Driver");
+ MODULE_AUTHOR("Intel");
+ MODULE_LICENSE("Dual BSD/GPL");
++MODULE_IMPORT_NS(CRYPTO_INTERNAL);
+diff --git a/quickassist/utilities/osal/src/linux/kernel_space/OsalCryptoInterface.c b/quickassist/utilities/osal/src/linux/kernel_space/OsalCryptoInterface.c
+index 9d2e85c..f265422 100644
+--- a/quickassist/utilities/osal/src/linux/kernel_space/OsalCryptoInterface.c
++++ b/quickassist/utilities/osal/src/linux/kernel_space/OsalCryptoInterface.c
+@@ -65,7 +65,7 @@
+  */
+ 
+ #include "Osal.h"
+-#include <linux/crypto.h>
++#include <crypto/internal/cipher.h>
+ #include <linux/version.h>
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+ #include <crypto/internal/hash.h>
-- 
2.26.2


From 12de3673f07e1ec16b3e37609566eaf79dbe7aca Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 27 Apr 2021 20:44:08 +0800
Subject: [PATCH 312/342] nvmf/vfio-user: remove controller ready field

The controller concept in NVMf is like a session, for any
new connection in nvmf_vfio_user_accept() with the endpoint,
we treat it as a new controller, we don't need the `ready`
field in controller to indicate the connection state, we
need the connection state in endpoint, so here just use
endpoint->ctrlr point to indicate the socket connection
is valid or not.

Change-Id: I588dbba7973cb61a1d79d81324a43e052f7dafb0
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7621
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/nvmf/vfio_user.c | 9 ++-------
 1 file changed, 2 insertions(+), 7 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index fdf518b1a..963ee7fec 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -157,8 +157,6 @@ struct nvmf_vfio_user_ctrlr {
 	struct nvmf_vfio_user_endpoint		*endpoint;
 	struct nvmf_vfio_user_transport		*transport;
 
-	/* True when the socket connection is active */
-	bool					ready;
 	/* Number of connected queue pairs */
 	uint32_t				num_connected_qps;
 
@@ -268,7 +266,6 @@ fail_ctrlr(struct nvmf_vfio_user_ctrlr *ctrlr)
 		SPDK_ERRLOG(":%s failing controller\n", ctrlr_id(ctrlr));
 	}
 
-	ctrlr->ready = false;
 	ctrlr->cfs = 1U;
 }
 
@@ -1655,7 +1652,6 @@ nvmf_vfio_user_create_ctrlr(struct nvmf_vfio_user_transport *transport,
 		goto out;
 	}
 	endpoint->ctrlr = ctrlr;
-	ctrlr->ready = true;
 
 	/* Notify the generic layer about the new admin queue pair */
 	TAILQ_INSERT_TAIL(&ctrlr->transport->new_qps, ctrlr->qp[0], link);
@@ -1852,8 +1848,8 @@ nvmf_vfio_user_accept(struct spdk_nvmf_transport *transport)
 	pthread_mutex_lock(&vu_transport->lock);
 
 	TAILQ_FOREACH(endpoint, &vu_transport->endpoints, link) {
-		/* we need try to attach the controller again after reset or shutdown */
-		if (endpoint->ctrlr != NULL && endpoint->ctrlr->ready) {
+		/* try to attach a new controller  */
+		if (endpoint->ctrlr != NULL) {
 			continue;
 		}
 
@@ -1948,7 +1944,6 @@ vfio_user_stop_ctrlr(struct nvmf_vfio_user_ctrlr *ctrlr)
 
 	SPDK_DEBUGLOG(nvmf_vfio, "%s stop processing\n", ctrlr_id(ctrlr));
 
-	ctrlr->ready = false;
 	endpoint = ctrlr->endpoint;
 	assert(endpoint != NULL);
 
-- 
2.26.2


From 3d4b9ba0d49a613385dbb5b7744064a1d85d2b57 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 27 Apr 2021 21:02:31 +0800
Subject: [PATCH 313/342] nvmf/vfio-user: rename destroy_qp to free_qp

The original destroy_qp() only release the queue pair
related memory, and free_qp() will be called inside
destroy_ctrlr() function, so also remove one duplicated
line here.

Change-Id: I2a06a6704b514361685068acda4e65ed5d502f0d
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7622
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/nvmf/vfio_user.c | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index 963ee7fec..1b663b092 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -727,12 +727,8 @@ unmap_qp(struct nvmf_vfio_user_qpair *qp)
 	}
 }
 
-/*
- * TODO we can immediately remove the QP from the list because this function
- * is now executed by the SPDK thread.
- */
 static void
-destroy_qp(struct nvmf_vfio_user_ctrlr *ctrlr, uint16_t qid)
+free_qp(struct nvmf_vfio_user_ctrlr *ctrlr, uint16_t qid)
 {
 	struct nvmf_vfio_user_qpair *qpair;
 
@@ -1601,7 +1597,7 @@ _destroy_ctrlr(void *ctx)
 	int i;
 
 	for (i = 0; i < NVMF_VFIO_USER_DEFAULT_MAX_QPAIRS_PER_CTRLR; i++) {
-		destroy_qp(ctrlr, i);
+		free_qp(ctrlr, i);
 	}
 
 	if (ctrlr->endpoint) {
@@ -2002,7 +1998,6 @@ handle_queue_connect_rsp(struct nvmf_vfio_user_req *req, void *cb_arg)
 
 	if (spdk_nvme_cpl_is_error(&req->req.rsp->nvme_cpl)) {
 		SPDK_ERRLOG("SC %u, SCT %u\n", req->req.rsp->nvme_cpl.status.sc, req->req.rsp->nvme_cpl.status.sct);
-		destroy_qp(ctrlr, qpair->qpair.qid);
 		destroy_ctrlr(ctrlr);
 		return -1;
 	}
@@ -2172,7 +2167,7 @@ nvmf_vfio_user_close_qpair(struct spdk_nvmf_qpair *qpair,
 
 	assert(qpair != NULL);
 	vu_qpair = SPDK_CONTAINEROF(qpair, struct nvmf_vfio_user_qpair, qpair);
-	destroy_qp(vu_qpair->ctrlr, qpair->qid);
+	free_qp(vu_qpair->ctrlr, qpair->qid);
 
 	if (cb_fn) {
 		cb_fn(cb_arg);
-- 
2.26.2


From 0cc8bcf508407bfeafb6e1b0ecde633c36990bfb Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 27 Apr 2021 21:10:50 +0800
Subject: [PATCH 314/342] nvmf/vfio-user: rename destroy_ctrlr() to
 free_ctrlr()

The coming destroy_ctrlr() function will disconnect
queue pairs and free controller at last, so here
rename the original destroy_ctrlr() to free_ctrlr().

Change-Id: I527b2742142d60b0383be5a12391c77dd50d47a7
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7623
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/nvmf/vfio_user.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index 1b663b092..845b57db4 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -1591,7 +1591,7 @@ vfio_user_dev_info_fill(struct nvmf_vfio_user_transport *vu_transport,
 }
 
 static void
-_destroy_ctrlr(void *ctx)
+_free_ctrlr(void *ctx)
 {
 	struct nvmf_vfio_user_ctrlr *ctrlr = ctx;
 	int i;
@@ -1609,16 +1609,16 @@ _destroy_ctrlr(void *ctx)
 }
 
 static int
-destroy_ctrlr(struct nvmf_vfio_user_ctrlr *ctrlr)
+free_ctrlr(struct nvmf_vfio_user_ctrlr *ctrlr)
 {
 	assert(ctrlr != NULL);
 
-	SPDK_DEBUGLOG(nvmf_vfio, "destroy %s\n", ctrlr_id(ctrlr));
+	SPDK_DEBUGLOG(nvmf_vfio, "free %s\n", ctrlr_id(ctrlr));
 
 	if (ctrlr->thread == spdk_get_thread()) {
-		_destroy_ctrlr(ctrlr);
+		_free_ctrlr(ctrlr);
 	} else {
-		spdk_thread_send_msg(ctrlr->thread, _destroy_ctrlr, ctrlr);
+		spdk_thread_send_msg(ctrlr->thread, _free_ctrlr, ctrlr);
 	}
 
 	return 0;
@@ -1656,7 +1656,7 @@ out:
 	if (err != 0) {
 		SPDK_ERRLOG("%s: failed to create vfio-user controller: %s\n",
 			    endpoint_id(endpoint), strerror(-err));
-		if (destroy_ctrlr(ctrlr) != 0) {
+		if (free_ctrlr(ctrlr) != 0) {
 			SPDK_ERRLOG("%s: failed to clean up\n",
 				    endpoint_id(endpoint));
 		}
@@ -1774,7 +1774,7 @@ nvmf_vfio_user_stop_listen(struct spdk_nvmf_transport *transport,
 		if (strcmp(trid->traddr, endpoint->trid.traddr) == 0) {
 			TAILQ_REMOVE(&vu_transport->endpoints, endpoint, link);
 			if (endpoint->ctrlr) {
-				err = destroy_ctrlr(endpoint->ctrlr);
+				err = free_ctrlr(endpoint->ctrlr);
 				if (err != 0) {
 					SPDK_ERRLOG("%s: failed destroy controller: %s\n",
 						    endpoint_id(endpoint), strerror(-err));
@@ -1924,7 +1924,7 @@ vfio_user_qpair_disconnect_cb(void *ctx)
 	}
 
 	if (!ctrlr->num_connected_qps) {
-		destroy_ctrlr(ctrlr);
+		free_ctrlr(ctrlr);
 		pthread_mutex_unlock(&endpoint->lock);
 		return;
 	}
@@ -1998,7 +1998,7 @@ handle_queue_connect_rsp(struct nvmf_vfio_user_req *req, void *cb_arg)
 
 	if (spdk_nvme_cpl_is_error(&req->req.rsp->nvme_cpl)) {
 		SPDK_ERRLOG("SC %u, SCT %u\n", req->req.rsp->nvme_cpl.status.sc, req->req.rsp->nvme_cpl.status.sct);
-		destroy_ctrlr(ctrlr);
+		free_ctrlr(ctrlr);
 		return -1;
 	}
 
-- 
2.26.2


From 45b567673814fcb7e5fa5cada1d44ebf092bc005 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Tue, 27 Apr 2021 21:16:03 +0800
Subject: [PATCH 315/342] nvmf/vfio-user: rename vfio_user_stop_ctrlr() to
 vfio_user_destroy_ctrlr()

The original function will disconnect queue pairs first and then free
controller memory finally, so rename it to vfio_user_destroy_ctrlr().

Change-Id: Idc235e4186bd4164be712fc9d4cda4991efc6248
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7624
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: <dongx.yi@intel.com>
---
 lib/nvmf/vfio_user.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/nvmf/vfio_user.c b/lib/nvmf/vfio_user.c
index 845b57db4..ac8ae9081 100644
--- a/lib/nvmf/vfio_user.c
+++ b/lib/nvmf/vfio_user.c
@@ -1932,7 +1932,7 @@ vfio_user_qpair_disconnect_cb(void *ctx)
 }
 
 static int
-vfio_user_stop_ctrlr(struct nvmf_vfio_user_ctrlr *ctrlr)
+vfio_user_destroy_ctrlr(struct nvmf_vfio_user_ctrlr *ctrlr)
 {
 	uint32_t i;
 	struct nvmf_vfio_user_qpair *qpair;
@@ -1970,7 +1970,7 @@ vfio_user_poll_mmio(void *ctx)
 
 		/* initiator shutdown or reset, waiting for another re-connect */
 		if (errno == ENOTCONN) {
-			vfio_user_stop_ctrlr(ctrlr);
+			vfio_user_destroy_ctrlr(ctrlr);
 			return SPDK_POLLER_BUSY;
 		}
 
-- 
2.26.2


From 7cccf5c5f42663e28d338f7d50df0a8935a483f7 Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Wed, 19 May 2021 08:21:33 +0200
Subject: [PATCH 316/342] test/common: update irdma driver version to 1.5.2

Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Change-Id: I696870dbdc9fa654e270d9fe76f12b7044455527
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7946
Reviewed-by: Maciej Wawryk <maciejx.wawryk@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 test/common/config/pkgdep/git | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/test/common/config/pkgdep/git b/test/common/config/pkgdep/git
index b0684fd9e..78e00c74a 100644
--- a/test/common/config/pkgdep/git
+++ b/test/common/config/pkgdep/git
@@ -532,7 +532,7 @@ function install_sources() {
 }
 
 GIT_VERSION=2.25.1
-IRDMA_VERSION=1.2.21
+IRDMA_VERSION=1.5.2
 ICE_VERSION=1.4.11
 : ${GIT_REPO_SPDK=https://github.com/spdk/spdk.git}
 export GIT_REPO_SPDK
@@ -560,7 +560,7 @@ export DRIVER_LOCATION_QAT
 export GIT_REPO_GIT
 : ${GIT_REPO_DPDK_KMODS=http://dpdk.org/git/dpdk-kmods}
 export GIT_REPO_DPDK_KMODS
-: ${IRDMA_DRIVER=https://downloadmirror.intel.com/30238/eng/irdma-$IRDMA_VERSION.tgz}
+: ${IRDMA_DRIVER=https://downloadmirror.intel.com/29751/eng/irdma-$IRDMA_VERSION.tgz}
 export IRDMA_DRIVER
 : ${ICE_DRIVER="https://sourceforge.net/projects/e1000/files/ice stable/$ICE_VERSION/ice-$ICE_VERSION.tar.gz"}
 export ICE_DRIVER
-- 
2.26.2


From 661825cfc9f96bbc29b054fc4a8b4d4d7a94963a Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Wed, 24 Mar 2021 16:53:27 +0800
Subject: [PATCH 317/342] test/nvme_ns_cmd: cases for namespace command reading
 and setup

Change-Id: I774c386480bc5fb20ce40a58ce9b72798f280e6d
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7029
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c   | 66 +++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c b/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c
index 7c85e4438..5899579dc 100644
--- a/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c
+++ b/test/unit/lib/nvme/nvme_ns_cmd.c/nvme_ns_cmd_ut.c
@@ -2025,6 +2025,70 @@ test_nvme_ns_cmd_compare_with_md(void)
 	free(metadata);
 }
 
+static void
+test_nvme_ns_cmd_setup_request(void)
+{
+	struct spdk_nvme_ns ns = {};
+	struct nvme_request req = {};
+
+	ns.id = 1;
+	ns.pi_type = SPDK_NVME_FMT_NVM_PROTECTION_TYPE1;
+	ns.flags = SPDK_NVME_NS_DPS_PI_SUPPORTED;
+
+	_nvme_ns_cmd_setup_request(&ns, &req, SPDK_NVME_OPC_READ,
+				   1024, 256, SPDK_NVME_IO_FLAGS_PRACT, 1, 1);
+	CU_ASSERT(req.cmd.cdw10 == 1024);
+	CU_ASSERT(req.cmd.opc == SPDK_NVME_OPC_READ);
+	CU_ASSERT(req.cmd.nsid == 1);
+	CU_ASSERT(req.cmd.cdw14  == 1024);
+	CU_ASSERT(req.cmd.fuse == 0);
+	CU_ASSERT(req.cmd.cdw12 == (255 | SPDK_NVME_IO_FLAGS_PRACT));
+	CU_ASSERT(req.cmd.cdw15 == (1 << 16 | 1));
+}
+
+static void
+test_spdk_nvme_ns_cmd_readv_with_md(void)
+{
+	struct spdk_nvme_ns		ns;
+	struct spdk_nvme_ctrlr		ctrlr;
+	struct spdk_nvme_qpair		qpair;
+	int				rc = 0;
+	char				*metadata = NULL;
+	uint32_t			lba_count = 256;
+	uint32_t			sector_size = 512;
+	uint32_t			md_size = 128;
+	uint64_t			sge_length = lba_count * sector_size;
+
+	metadata = (void *)0xDEADBEEF;
+	prepare_for_test(&ns, &ctrlr, &qpair, sector_size,
+			 md_size, 128 * 1024, 0, false);
+
+	rc = spdk_nvme_ns_cmd_readv_with_md(&ns, &qpair, 0x1000, lba_count, NULL,
+					    &sge_length, 0, nvme_request_reset_sgl,
+					    nvme_request_next_sge, metadata, 0, 0);
+	CU_ASSERT(rc == 0);
+	SPDK_CU_ASSERT_FATAL(g_request != NULL);
+	CU_ASSERT(g_request->cmd.opc == SPDK_NVME_OPC_READ);
+	CU_ASSERT(nvme_payload_type(&g_request->payload) == NVME_PAYLOAD_TYPE_SGL);
+	CU_ASSERT(g_request->payload.reset_sgl_fn == nvme_request_reset_sgl);
+	CU_ASSERT(g_request->payload.next_sge_fn == nvme_request_next_sge);
+	CU_ASSERT(g_request->payload.contig_or_cb_arg == &sge_length);
+	CU_ASSERT(g_request->payload.md == (void *)0xDEADBEEF);
+	CU_ASSERT(g_request->cmd.nsid == ns.id);
+	CU_ASSERT(g_request->payload_size == 256 * 512);
+	CU_ASSERT(g_request->qpair == &qpair);
+	CU_ASSERT(g_request->md_offset == 0);
+	CU_ASSERT(g_request->payload_offset == 0);
+
+	rc = spdk_nvme_ns_cmd_readv_with_md(&ns, &qpair, 0x1000, lba_count, NULL,
+					    NULL, 0, nvme_request_reset_sgl, NULL,
+					    metadata, 0, 0);
+	CU_ASSERT(rc == -EINVAL);
+
+	nvme_free_request(g_request);
+	cleanup_after_test(&qpair);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -2060,6 +2124,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_compare_and_write);
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_compare_with_md);
 	CU_ADD_TEST(suite, test_nvme_ns_cmd_comparev_with_md);
+	CU_ADD_TEST(suite, test_nvme_ns_cmd_setup_request);
+	CU_ADD_TEST(suite, test_spdk_nvme_ns_cmd_readv_with_md);
 
 	g_spdk_nvme_driver = &_g_nvme_driver;
 
-- 
2.26.2


From 2246a9371809c30333b1844afbf9772c4b06db79 Mon Sep 17 00:00:00 2001
From: Jiewei Ke <jiewei@smartx.com>
Date: Mon, 17 May 2021 04:08:30 -0400
Subject: [PATCH 318/342] thread: speed up io_device lookup by using rbtree

Use the macros for red black tree provided by Free BSD to speed up
io_device lookup.

Signed-off-by: Jiewei Ke <jiewei@smartx.com>
Change-Id: Ib3bd382bbeb610503194e7d7bfd569f60a0d0121
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7894
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 lib/thread/thread.c                       | 54 +++++++++++++----------
 test/unit/lib/thread/thread.c/thread_ut.c | 42 ++++++------------
 2 files changed, 44 insertions(+), 52 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 3cee7de00..39a9839db 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -177,14 +177,22 @@ struct io_device {
 	struct spdk_thread		*unregister_thread;
 	uint32_t			ctx_size;
 	uint32_t			for_each_count;
-	TAILQ_ENTRY(io_device)		tailq;
+	RB_ENTRY(io_device)		node;
 
 	uint32_t			refcnt;
 
 	bool				unregistered;
 };
 
-static TAILQ_HEAD(, io_device) g_io_devices = TAILQ_HEAD_INITIALIZER(g_io_devices);
+static RB_HEAD(io_device_tree, io_device) g_io_devices = RB_INITIALIZER(g_io_devices);
+
+static int
+io_device_cmp(struct io_device *dev1, struct io_device *dev2)
+{
+	return dev1->io_device - dev2->io_device;
+}
+
+RB_GENERATE_STATIC(io_device_tree, io_device, node, io_device_cmp);
 
 struct spdk_msg {
 	spdk_msg_fn		fn;
@@ -296,7 +304,7 @@ spdk_thread_lib_fini(void)
 {
 	struct io_device *dev;
 
-	TAILQ_FOREACH(dev, &g_io_devices, tailq) {
+	RB_FOREACH(dev, io_device_tree, &g_io_devices) {
 		SPDK_ERRLOG("io_device %s not unregistered\n", dev->name);
 	}
 
@@ -1842,6 +1850,15 @@ spdk_thread_set_interrupt_mode(bool enable_interrupt)
 	return;
 }
 
+static struct io_device *
+io_device_get(void *io_device)
+{
+	struct io_device find = {};
+
+	find.io_device = io_device;
+	return RB_FIND(io_device_tree, &g_io_devices, &find);
+}
+
 void
 spdk_io_device_register(void *io_device, spdk_io_channel_create_cb create_cb,
 			spdk_io_channel_destroy_cb destroy_cb, uint32_t ctx_size,
@@ -1885,16 +1902,14 @@ spdk_io_device_register(void *io_device, spdk_io_channel_create_cb create_cb,
 		      dev->name, dev->io_device, thread->name);
 
 	pthread_mutex_lock(&g_devlist_mutex);
-	TAILQ_FOREACH(tmp, &g_io_devices, tailq) {
-		if (tmp->io_device == io_device) {
-			SPDK_ERRLOG("io_device %p already registered (old:%s new:%s)\n",
-				    io_device, tmp->name, dev->name);
-			free(dev);
-			pthread_mutex_unlock(&g_devlist_mutex);
-			return;
-		}
+	tmp = RB_INSERT(io_device_tree, &g_io_devices, dev);
+	if (tmp != NULL) {
+		SPDK_ERRLOG("io_device %p already registered (old:%s new:%s)\n",
+			    io_device, tmp->name, dev->name);
+		free(dev);
+		pthread_mutex_unlock(&g_devlist_mutex);
+		return;
 	}
-	TAILQ_INSERT_TAIL(&g_io_devices, dev, tailq);
 	pthread_mutex_unlock(&g_devlist_mutex);
 }
 
@@ -1948,12 +1963,7 @@ spdk_io_device_unregister(void *io_device, spdk_io_device_unregister_cb unregist
 	}
 
 	pthread_mutex_lock(&g_devlist_mutex);
-	TAILQ_FOREACH(dev, &g_io_devices, tailq) {
-		if (dev->io_device == io_device) {
-			break;
-		}
-	}
-
+	dev = io_device_get(io_device);
 	if (!dev) {
 		SPDK_ERRLOG("io_device %p not found\n", io_device);
 		assert(false);
@@ -1970,7 +1980,7 @@ spdk_io_device_unregister(void *io_device, spdk_io_device_unregister_cb unregist
 
 	dev->unregister_cb = unregister_cb;
 	dev->unregistered = true;
-	TAILQ_REMOVE(&g_io_devices, dev, tailq);
+	RB_REMOVE(io_device_tree, &g_io_devices, dev);
 	refcnt = dev->refcnt;
 	dev->unregister_thread = thread;
 	pthread_mutex_unlock(&g_devlist_mutex);
@@ -2005,11 +2015,7 @@ spdk_get_io_channel(void *io_device)
 	int rc;
 
 	pthread_mutex_lock(&g_devlist_mutex);
-	TAILQ_FOREACH(dev, &g_io_devices, tailq) {
-		if (dev->io_device == io_device) {
-			break;
-		}
-	}
+	dev = io_device_get(io_device);
 	if (dev == NULL) {
 		SPDK_ERRLOG("could not find io_device %p\n", io_device);
 		pthread_mutex_unlock(&g_devlist_mutex);
diff --git a/test/unit/lib/thread/thread.c/thread_ut.c b/test/unit/lib/thread/thread.c/thread_ut.c
index 150aaed84..a3d57c2fb 100644
--- a/test/unit/lib/thread/thread.c/thread_ut.c
+++ b/test/unit/lib/thread/thread.c/thread_ut.c
@@ -644,12 +644,12 @@ for_each_channel_unreg(void)
 
 	allocate_threads(1);
 	set_thread(0);
-	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
+	CU_ASSERT(RB_EMPTY(&g_io_devices));
 	spdk_io_device_register(&io_target, channel_create, channel_destroy, sizeof(int), NULL);
-	CU_ASSERT(!TAILQ_EMPTY(&g_io_devices));
-	dev = TAILQ_FIRST(&g_io_devices);
+	CU_ASSERT(!RB_EMPTY(&g_io_devices));
+	dev = RB_MIN(io_device_tree, &g_io_devices);
 	SPDK_CU_ASSERT_FATAL(dev != NULL);
-	CU_ASSERT(TAILQ_NEXT(dev, tailq) == NULL);
+	CU_ASSERT(RB_NEXT(io_device_tree, &g_io_devices, dev) == NULL);
 	ch0 = spdk_get_io_channel(&io_target);
 	spdk_for_each_channel(&io_target, unreg_ch_done, &ctx, unreg_foreach_done);
 
@@ -658,14 +658,14 @@ for_each_channel_unreg(void)
 	 * There is an outstanding foreach call on the io_device, so the unregister should not
 	 *  have removed the device.
 	 */
-	CU_ASSERT(dev == TAILQ_FIRST(&g_io_devices));
+	CU_ASSERT(dev == RB_MIN(io_device_tree, &g_io_devices));
 	spdk_io_device_register(&io_target, channel_create, channel_destroy, sizeof(int), NULL);
 	/*
 	 * There is already a device registered at &io_target, so a new io_device should not
 	 *  have been added to g_io_devices.
 	 */
-	CU_ASSERT(dev == TAILQ_FIRST(&g_io_devices));
-	CU_ASSERT(TAILQ_NEXT(dev, tailq) == NULL);
+	CU_ASSERT(dev == RB_MIN(io_device_tree, &g_io_devices));
+	CU_ASSERT(RB_NEXT(io_device_tree, &g_io_devices, dev) == NULL);
 
 	poll_thread(0);
 	CU_ASSERT(ctx.ch_done == true);
@@ -675,7 +675,7 @@ for_each_channel_unreg(void)
 	 *  even though a channel still exists for the device.
 	 */
 	spdk_io_device_unregister(&io_target, NULL);
-	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
+	CU_ASSERT(RB_EMPTY(&g_io_devices));
 
 	set_thread(0);
 	spdk_put_io_channel(ch0);
@@ -824,7 +824,7 @@ channel(void)
 	poll_threads();
 	spdk_io_device_unregister(&g_device2, NULL);
 	poll_threads();
-	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
+	CU_ASSERT(RB_EMPTY(&g_io_devices));
 	free_threads();
 	CU_ASSERT(TAILQ_EMPTY(&g_threads));
 }
@@ -879,7 +879,7 @@ channel_destroy_races(void)
 	spdk_io_device_unregister(&device, NULL);
 	poll_threads();
 
-	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
+	CU_ASSERT(RB_EMPTY(&g_io_devices));
 	free_threads();
 	CU_ASSERT(TAILQ_EMPTY(&g_threads));
 }
@@ -1135,20 +1135,6 @@ struct ut_nested_dev {
 	struct ut_nested_dev *child;
 };
 
-static struct io_device *
-ut_get_io_device(void *dev)
-{
-	struct io_device *tmp;
-
-	TAILQ_FOREACH(tmp, &g_io_devices, tailq) {
-		if (tmp->io_device == dev) {
-			return tmp;
-		}
-	}
-
-	return NULL;
-}
-
 static int
 ut_null_poll(void *ctx)
 {
@@ -1246,11 +1232,11 @@ nested_channel(void)
 	spdk_io_device_register(&_dev3, ut_nested_ch_create_cb, ut_nested_ch_destroy_cb,
 				sizeof(struct ut_nested_ch), "dev3");
 
-	dev1 = ut_get_io_device(&_dev1);
+	dev1 = io_device_get(&_dev1);
 	SPDK_CU_ASSERT_FATAL(dev1 != NULL);
-	dev2 = ut_get_io_device(&_dev2);
+	dev2 = io_device_get(&_dev2);
 	SPDK_CU_ASSERT_FATAL(dev2 != NULL);
-	dev3 = ut_get_io_device(&_dev3);
+	dev3 = io_device_get(&_dev3);
 	SPDK_CU_ASSERT_FATAL(dev3 != NULL);
 
 	/* A single call spdk_get_io_channel() to dev1 will also create channels
@@ -1315,7 +1301,7 @@ nested_channel(void)
 	spdk_io_device_unregister(&_dev1, NULL);
 	spdk_io_device_unregister(&_dev2, NULL);
 	spdk_io_device_unregister(&_dev3, NULL);
-	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
+	CU_ASSERT(RB_EMPTY(&g_io_devices));
 
 	free_threads();
 	CU_ASSERT(TAILQ_EMPTY(&g_threads));
-- 
2.26.2


From 84588b3ba898ff86c485a811cf4d381a08bc57c2 Mon Sep 17 00:00:00 2001
From: Jiewei Ke <jiewei@smartx.com>
Date: Tue, 25 May 2021 05:51:13 -0400
Subject: [PATCH 319/342] util: rename RB_ROOT into _RB_ROOT

In examples/bdev/fio_plugin/fio_plugin, it will include fio.h which
defines the RB_ROOT macro. To workaround the RB_ROOT redefined error,
rename RB_ROOT to _RB_ROOT.

Signed-off-by: Jiewei Ke <jiewei@smartx.com>
Change-Id: Ied4f835e4d1657ca5a0a80c13c72845c774618d8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8044
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 include/spdk/tree.h | 21 +++++++++++++--------
 1 file changed, 13 insertions(+), 8 deletions(-)

diff --git a/include/spdk/tree.h b/include/spdk/tree.h
index 958185cee..6da45995a 100644
--- a/include/spdk/tree.h
+++ b/include/spdk/tree.h
@@ -340,8 +340,13 @@ struct {								\
 #define RB_RED_RIGHT(elm, field)	((RB_BITS(elm, field) & RB_RED_R) != 0)
 #define RB_PARENT(elm, field)		((__typeof(RB_UP(elm, field)))	\
 					 (RB_BITS(elm, field) & ~RB_RED_MASK))
-#define RB_ROOT(head)			(head)->rbh_root
-#define RB_EMPTY(head)			(RB_ROOT(head) == NULL)
+/*
+ * _RB_ROOT starts with an underscore. This is a workaround for the issue that
+ * RB_ROOT() had a name conflict with the SPDK FIO plugin. The SPDK FIO plugin
+ * includes FIO and FIO defines RB_ROOT() itself.
+ */
+#define _RB_ROOT(head)			(head)->rbh_root
+#define RB_EMPTY(head)			(_RB_ROOT(head) == NULL)
 
 #define RB_SET_PARENT(dst, src, field) do {				\
 	RB_BITS(dst, field) &= RB_RED_MASK;				\
@@ -368,7 +373,7 @@ struct {								\
 
 #define RB_SWAP_CHILD(head, out, in, field) do {			\
 	if (RB_PARENT(out, field) == NULL)				\
-		RB_ROOT(head) = (in);					\
+		_RB_ROOT(head) = (in);					\
 	else if ((out) == RB_LEFT(RB_PARENT(out, field), field))	\
 		RB_LEFT(RB_PARENT(out, field), field) = (in);		\
 	else								\
@@ -638,7 +643,7 @@ name##_RB_INSERT(struct name *head, struct type *elm)			\
 	struct type *tmp;						\
 	struct type *parent = NULL;					\
 	int comp = 0;							\
-	tmp = RB_ROOT(head);						\
+	tmp = _RB_ROOT(head);						\
 	while (tmp) {							\
 		parent = tmp;						\
 		comp = (cmp)(elm, parent);				\
@@ -651,7 +656,7 @@ name##_RB_INSERT(struct name *head, struct type *elm)			\
 	}								\
 	RB_SET(elm, parent, field);					\
 	if (parent == NULL)						\
-		RB_ROOT(head) = elm;					\
+		_RB_ROOT(head) = elm;					\
 	else if (comp < 0)						\
 		RB_LEFT(parent, field) = elm;				\
 	else								\
@@ -669,7 +674,7 @@ name##_RB_INSERT(struct name *head, struct type *elm)			\
 attr struct type *							\
 name##_RB_FIND(struct name *head, struct type *elm)			\
 {									\
-	struct type *tmp = RB_ROOT(head);				\
+	struct type *tmp = _RB_ROOT(head);				\
 	int comp;							\
 	while (tmp) {							\
 		comp = cmp(elm, tmp);					\
@@ -688,7 +693,7 @@ name##_RB_FIND(struct name *head, struct type *elm)			\
 attr struct type *							\
 name##_RB_NFIND(struct name *head, struct type *elm)			\
 {									\
-	struct type *tmp = RB_ROOT(head);				\
+	struct type *tmp = _RB_ROOT(head);				\
 	struct type *res = NULL;					\
 	int comp;							\
 	while (tmp) {							\
@@ -755,7 +760,7 @@ name##_RB_PREV(struct type *elm)					\
 attr struct type *							\
 name##_RB_MINMAX(struct name *head, int val)				\
 {									\
-	struct type *tmp = RB_ROOT(head);				\
+	struct type *tmp = _RB_ROOT(head);				\
 	struct type *parent = NULL;					\
 	while (tmp) {							\
 		parent = tmp;						\
-- 
2.26.2


From 81a8bc670c698301381c2ea4843967bbdefdc02f Mon Sep 17 00:00:00 2001
From: jiaqizho <jiaqi.zhou@intel.com>
Date: Fri, 23 Oct 2020 10:23:02 +0800
Subject: [PATCH 320/342] iostat : add -x to display extended statistics

Signed-off-by: jiaqizho <jiaqi.zhou@intel.com>
Change-Id: Ia25257093a13987c40a682c9b5ace4daa15ac607
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/4847
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 scripts/iostat.py | 117 ++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 104 insertions(+), 13 deletions(-)

diff --git a/scripts/iostat.py b/scripts/iostat.py
index f683ce865..cb9ebe596 100755
--- a/scripts/iostat.py
+++ b/scripts/iostat.py
@@ -16,6 +16,8 @@ SPDK_BDEV_KB_STAT_HEAD = ['Device', 'tps', 'KB_read/s',
                           'KB_wrtn/s', 'KB_dscd/s', 'KB_read', 'KB_wrtn', 'KB_dscd']
 SPDK_BDEV_MB_STAT_HEAD = ['Device', 'tps', 'MB_read/s',
                           'MB_wrtn/s', 'MB_dscd/s', 'MB_read', 'MB_wrtn', 'MB_dscd']
+SPDK_BDEV_EXT_STAT_HEAD = ['qu-sz', 'aqu-sz', 'wareq-sz', 'rareq-sz', 'w_await(us)', 'r_await(us)', 'util']
+
 
 SPDK_MAX_SECTORS = 0xffffffff
 
@@ -25,6 +27,7 @@ class BdevStat:
     def __init__(self, dictionary):
         if dictionary is None:
             return
+        self.qd_period = 0
         for k, value in dictionary.items():
             if k == 'name':
                 self.bdev_name = value
@@ -46,16 +49,14 @@ class BdevStat:
                 self.wr_ticks = value
             elif k == 'unmap_latency_ticks':
                 self.dc_ticks = value
+            elif k == 'queue_depth_polling_period':
+                self.qd_period = value
             elif k == 'queue_depth':
-                self.ios_pgr = value
+                self.queue_depth = value
             elif k == 'io_time':
-                self.tot_ticks = value
+                self.io_time = value
             elif k == 'weighted_io_time':
-                self.rq_ticks = value
-
-        self.rd_merges = 0
-        self.wr_merges = 0
-        self.dc_merges = 0
+                self.weighted_io_time = value
         self.upt = 0.0
 
     def __getattr__(self, name):
@@ -159,12 +160,13 @@ def get_cpu_stat():
     return cpu_dump_info
 
 
-def read_bdev_stat(last_stat, stat, mb, use_upt):
+def read_bdev_stat(last_stat, stat, mb, use_upt, ext_info):
     if use_upt:
         upt_cur = uptime()
     else:
         upt_cur = stat['ticks']
-        upt_rate = stat['tick_rate']
+
+    upt_rate = stat['tick_rate']
 
     info_stats = []
     unit = 2048 if mb else 2
@@ -215,6 +217,48 @@ def read_bdev_stat(last_stat, stat, mb, use_upt):
                 "{:.2f}".format(wr_sec / unit),
                 "{:.2f}".format(dc_sec / unit),
             ]
+            if ext_info:
+                if _stat.qd_period > 0:
+                    tot_sampling_time = upt * 1000000 / _stat.qd_period
+                    busy_times = (_stat.io_time - _last_stat.io_time) / _stat.qd_period
+
+                    wr_ios = _stat.wr_ios - _last_stat.wr_ios
+                    rd_ios = _stat.rd_ios - _last_stat.rd_ios
+                    if busy_times != 0:
+                        aqu_sz = (_stat.weighted_io_time - _last_stat.weighted_io_time) / _stat.qd_period / busy_times
+                    else:
+                        aqu_sz = 0
+
+                    if wr_ios != 0:
+                        wareq_sz = wr_sec / wr_ios
+                        w_await = (_stat.wr_ticks * 1000000 / upt_rate -
+                                   _last_stat.wr_ticks * 1000000 / upt_rate) / wr_ios
+                    else:
+                        wareq_sz = 0
+                        w_await = 0
+
+                    if rd_ios != 0:
+                        rareq_sz = rd_sec / rd_ios
+                        r_await = (_stat.rd_ticks * 1000000 / upt_rate -
+                                   _last_stat.rd_ticks * 1000000 / upt_rate) / rd_ios
+                    else:
+                        rareq_sz = 0
+                        r_await = 0
+
+                    util = busy_times / tot_sampling_time
+
+                    info_stat += [
+                        "{:.2f}".format(_stat.queue_depth),
+                        "{:.2f}".format(aqu_sz),
+                        "{:.2f}".format(wareq_sz),
+                        "{:.2f}".format(rareq_sz),
+                        "{:.2f}".format(w_await),
+                        "{:.2f}".format(r_await),
+                        "{:.2f}".format(util),
+                    ]
+                else:
+                    info_stat += ["N/A"] * len(SPDK_BDEV_EXT_STAT_HEAD)
+
             info_stats.append(info_stat)
     else:
         for bdev in stat['bdevs']:
@@ -238,10 +282,53 @@ def read_bdev_stat(last_stat, stat, mb, use_upt):
                 "{:.2f}".format(_stat.wr_sectors / unit),
                 "{:.2f}".format(_stat.dc_sectors / unit),
             ]
+
+            # add extended statistics
+            if ext_info:
+                if _stat.qd_period > 0:
+                    tot_sampling_time = upt * 1000000 / _stat.qd_period
+                    busy_times = _stat.io_time / _stat.qd_period
+                    if busy_times != 0:
+                        aqu_sz = _stat.weighted_io_time / _stat.qd_period / busy_times
+                    else:
+                        aqu_sz = 0
+
+                    if _stat.wr_ios != 0:
+                        wareq_sz = _stat.wr_sectors / _stat.wr_ios
+                        w_await = _stat.wr_ticks * 1000000 / upt_rate / _stat.wr_ios
+                    else:
+                        wareq_sz = 0
+                        w_await = 0
+
+                    if _stat.rd_ios != 0:
+                        rareq_sz = _stat.rd_sectors / _stat.rd_ios
+                        r_await = _stat.rd_ticks * 1000000 / upt_rate / _stat.rd_ios
+                    else:
+                        rareq_sz = 0
+                        r_await = 0
+
+                    util = busy_times / tot_sampling_time
+
+                    info_stat += [
+                        "{:.2f}".format(_stat.queue_depth),
+                        "{:.2f}".format(aqu_sz),
+                        "{:.2f}".format(wareq_sz),
+                        "{:.2f}".format(rareq_sz),
+                        "{:.2f}".format(w_await),
+                        "{:.2f}".format(r_await),
+                        "{:.2f}".format(util),
+                    ]
+                else:
+                    info_stat += ["N/A"] * len(SPDK_BDEV_EXT_STAT_HEAD)
+
             info_stats.append(info_stat)
 
-    _stat_format(
-        info_stats, SPDK_BDEV_MB_STAT_HEAD if mb else SPDK_BDEV_KB_STAT_HEAD)
+    head = []
+    head += SPDK_BDEV_MB_STAT_HEAD if mb else SPDK_BDEV_KB_STAT_HEAD
+    if ext_info:
+        head += SPDK_BDEV_EXT_STAT_HEAD
+
+    _stat_format(info_stats, head)
     return bdev_stats
 
 
@@ -258,14 +345,14 @@ def io_stat_display(args, cpu_info, stat):
     if args.bdev_stat and not args.cpu_stat:
         _stat = get_bdev_stat(args.client, args.name)
         bdev_stats = read_bdev_stat(
-            stat, _stat, args.mb_display, args.use_uptime)
+            stat, _stat, args.mb_display, args.use_uptime, args.extended_display)
         return None, bdev_stats
 
     _cpu_info = get_cpu_stat()
     read_cpu_stat(cpu_info, _cpu_info)
 
     _stat = get_bdev_stat(args.client, args.name)
-    bdev_stats = read_bdev_stat(stat, _stat, args.mb_display, args.use_uptime)
+    bdev_stats = read_bdev_stat(stat, _stat, args.mb_display, args.use_uptime, args.extended_display)
     return _cpu_info, bdev_stats
 
 
@@ -343,6 +430,10 @@ if __name__ == "__main__":
     parser.add_argument('-v', dest='verbose', action='store_const', const="INFO",
                         help='Set verbose mode to INFO', default="ERROR")
 
+    parser.add_argument('-x', '--extended', dest='extended_display',
+                        action='store_true', help="Display extended statistics.",
+                        required=False, default=False)
+
     args = parser.parse_args()
     if ((args.interval == 0 and args.time_in_second != 0) or
             (args.interval != 0 and args.time_in_second == 0)):
-- 
2.26.2


From 9c3ba11a2904dde3a710bc73c5fdacd2e2cc0006 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Fri, 26 Feb 2021 12:22:24 +0100
Subject: [PATCH 321/342] test/vhost: Commonize some of the environment

Also, remove the unecessary FIXME.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I3feda936cff62d79e921247dd40613c389ac3a3c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6586
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 test/vhost/common.sh         | 4 ++++
 test/vhost/lvol/lvol_test.sh | 1 -
 test/vhost/manual.sh         | 5 -----
 test/vhost/vhost.sh          | 5 -----
 4 files changed, 4 insertions(+), 11 deletions(-)

diff --git a/test/vhost/common.sh b/test/vhost/common.sh
index 68303726d..3c5c600f5 100644
--- a/test/vhost/common.sh
+++ b/test/vhost/common.sh
@@ -9,6 +9,10 @@ TARGET_DIR=$VHOST_DIR/vhost
 VM_PASSWORD="root"
 
 VM_IMAGE=${VM_IMAGE:-"$DEPENDENCY_DIR/spdk_test_image.qcow2"}
+DEFAULT_FIO_BIN=${DEFAULT_FIO_BIN:-"$DEPENDENCY_DIR/fio"}
+FIO_BIN=${FIO_BIN:-"$DEFAULT_FIO_BIN"}
+
+WORKDIR=$(readlink -f "$(dirname "$0")")
 
 if ! hash $QEMU_IMG_BIN $QEMU_BIN; then
 	error 'QEMU is not installed on this system. Unable to run vhost tests.'
diff --git a/test/vhost/lvol/lvol_test.sh b/test/vhost/lvol/lvol_test.sh
index 6920eff87..fda77acc7 100755
--- a/test/vhost/lvol/lvol_test.sh
+++ b/test/vhost/lvol/lvol_test.sh
@@ -76,7 +76,6 @@ vhosttestinit
 
 spdk_mask=$vhost_0_reactor_mask
 if $distribute_cores; then
-	# FIXME: this need to be handled entirely in common.sh
 	source $testdir/autotest.config
 	# Adjust the mask so vhost runs on separate cpus than qemu instances.
 	# We know that .config sets qemus to run on single cpu so simply take
diff --git a/test/vhost/manual.sh b/test/vhost/manual.sh
index 5cdb8a453..1d6da4732 100755
--- a/test/vhost/manual.sh
+++ b/test/vhost/manual.sh
@@ -5,8 +5,6 @@ rootdir=$(readlink -f $testdir/../..)
 source $rootdir/test/common/autotest_common.sh
 source $rootdir/test/vhost/common.sh
 
-DEFAULT_FIO_BIN="$DEPENDENCY_DIR/fio"
-
 case $1 in
 	-h | --help)
 		echo "usage: $(basename $0) TEST_TYPE"
@@ -35,11 +33,8 @@ if [[ $(uname -s) != Linux ]]; then
 	exit 0
 fi
 
-: ${FIO_BIN="$DEFAULT_FIO_BIN"}
 vhosttestinit
 
-WORKDIR=$(readlink -f $(dirname $0))
-
 case $1 in
 	-hp | --hotplug)
 		echo 'Running hotplug tests suite...'
diff --git a/test/vhost/vhost.sh b/test/vhost/vhost.sh
index 616d3224a..4d6deabbc 100755
--- a/test/vhost/vhost.sh
+++ b/test/vhost/vhost.sh
@@ -12,13 +12,8 @@ if [[ $(uname -s) != Linux ]]; then
 	exit 0
 fi
 
-DEFAULT_FIO_BIN="$DEPENDENCY_DIR/fio"
-
-: ${FIO_BIN="$DEFAULT_FIO_BIN"}
 vhosttestinit
 
-WORKDIR=$(readlink -f $(dirname $0))
-
 run_test "vhost_negative" $WORKDIR/other/negative.sh
 
 run_test "vhost_boot" $WORKDIR/vhost_boot/vhost_boot.sh --vm_image=$VM_IMAGE
-- 
2.26.2


From da71236778cbcc5214ef6928c54045450f3610a0 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Mon, 24 May 2021 09:55:26 +0800
Subject: [PATCH 322/342] test/nvme_pcie: cases for pmr mapping

Change-Id: Ie5af8012c15d63625abc4fe92e905aa6a9dc619c
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7943
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
---
 test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c | 58 +++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
index d1d189262..9c93ed734 100644
--- a/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie.c/nvme_pcie_ut.c
@@ -893,6 +893,63 @@ test_nvme_pcie_ctrlr_map_io_cmb(void)
 	CU_ASSERT(size == 0);
 }
 
+static void
+test_nvme_pcie_ctrlr_map_unmap_pmr(void)
+{
+	struct nvme_pcie_ctrlr pctrlr = {};
+	volatile struct spdk_nvme_registers regs = {};
+	union spdk_nvme_pmrcap_register pmrcap = {};
+	struct dev_mem_resource cmd_res = {};
+	int rc;
+
+	pctrlr.regs = &regs;
+	pctrlr.devhandle = (void *)&cmd_res;
+	regs.cap.bits.pmrs = 1;
+	cmd_res.addr = (void *)0x7F7C0080d000;
+	cmd_res.len = 0x800000;
+	cmd_res.phys_addr = 0xFC800000;
+	pmrcap.bits.bir = 2;
+	pmrcap.bits.cmss = 1;
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr,
+				  offsetof(struct spdk_nvme_registers, pmrcap.raw),
+				  pmrcap.raw);
+
+	nvme_pcie_ctrlr_map_pmr(&pctrlr);
+	CU_ASSERT(pctrlr.regs->pmrmscu == 0);
+	/* Controller memory space enable, bit 1 */
+	CU_ASSERT(pctrlr.regs->pmrmscl.raw == 0xFC800002);
+	CU_ASSERT(pctrlr.regs->pmrsts.raw == 0);
+	CU_ASSERT(pctrlr.pmr.bar_va == (void *)0x7F7C0080d000);
+	CU_ASSERT(pctrlr.pmr.bar_pa == 0xFC800000);
+	CU_ASSERT(pctrlr.pmr.size == 0x800000);
+
+	rc = nvme_pcie_ctrlr_unmap_pmr(&pctrlr);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(pctrlr.regs->pmrmscu == 0);
+	CU_ASSERT(pctrlr.regs->pmrmscl.raw == 0);
+
+	/* pmrcap value invalid */
+	memset(&pctrlr, 0, sizeof(pctrlr));
+	memset((void *)&regs, 0, sizeof(regs));
+	memset(&cmd_res, 0, sizeof(cmd_res));
+
+	pctrlr.regs = &regs;
+	pctrlr.devhandle = (void *)&cmd_res;
+	regs.cap.bits.pmrs = 1;
+	cmd_res.addr = (void *)0x7F7C0080d000;
+	cmd_res.len = 0x800000;
+	cmd_res.phys_addr = 0xFC800000;
+	pmrcap.raw = 0;
+	nvme_pcie_ctrlr_set_reg_4(&pctrlr.ctrlr,
+				  offsetof(struct spdk_nvme_registers, pmrcap.raw),
+				  pmrcap.raw);
+
+	nvme_pcie_ctrlr_map_pmr(&pctrlr);
+	CU_ASSERT(pctrlr.pmr.bar_va == NULL);
+	CU_ASSERT(pctrlr.pmr.bar_pa == 0);
+	CU_ASSERT(pctrlr.pmr.size == 0);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -913,6 +970,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_regs_get_set);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_map_unmap_cmb);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_map_io_cmb);
+	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_map_unmap_pmr);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 984fdca8538bb3bfe441660b92bf85f1a8096d60 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Tue, 1 Jun 2021 15:10:10 +0800
Subject: [PATCH 323/342] test/nvme_fabric: cases for fabric qpair connecting

Change-Id: I8b7babc5c3feb87c2b38c79dbf3cd158e2178162
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7580
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 .../lib/nvme/nvme_fabric.c/nvme_fabric_ut.c   | 128 ++++++++++++++++--
 1 file changed, 119 insertions(+), 9 deletions(-)

diff --git a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
index 10016acd3..0b5c8a6c1 100644
--- a/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
+++ b/test/unit/lib/nvme/nvme_fabric.c/nvme_fabric_ut.c
@@ -38,6 +38,7 @@
 
 SPDK_LOG_REGISTER_COMPONENT(nvme)
 
+pid_t g_spdk_nvme_pid;
 struct spdk_nvmf_fabric_prop_set_cmd g_ut_cmd = {};
 struct spdk_nvmf_fabric_prop_get_rsp g_ut_response = {};
 
@@ -75,20 +76,52 @@ DEFINE_STUB(nvme_transport_ctrlr_construct, struct spdk_nvme_ctrlr *,
 	     const struct spdk_nvme_ctrlr_opts *opts,
 	     void *devhandle), NULL);
 
-DEFINE_STUB(spdk_nvme_ctrlr_cmd_io_raw, int, (struct spdk_nvme_ctrlr *ctrlr,
-		struct spdk_nvme_qpair *qpair, struct spdk_nvme_cmd *cmd, void *buf,
-		uint32_t len, spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
-
-DEFINE_STUB(nvme_wait_for_completion_timeout, int,
-	    (struct spdk_nvme_qpair *qpair,
-	     struct nvme_completion_poll_status *status,
-	     uint64_t timeout_in_usecs), 0);
-
 DEFINE_STUB(spdk_nvme_transport_id_adrfam_str, const char *,
 	    (enum spdk_nvmf_adrfam adrfam), NULL);
 
 DEFINE_STUB(nvme_ctrlr_process_init, int, (struct spdk_nvme_ctrlr *ctrlr), 0);
 
+static struct spdk_nvmf_fabric_connect_data g_nvmf_data;
+
+int
+spdk_nvme_ctrlr_cmd_io_raw(struct spdk_nvme_ctrlr *ctrlr,
+			   struct spdk_nvme_qpair *qpair,
+			   struct spdk_nvme_cmd *cmd,
+			   void *buf, uint32_t len,
+			   spdk_nvme_cmd_cb cb_fn, void *cb_arg)
+{
+	struct nvme_request	*req;
+
+	req = nvme_allocate_request_contig(qpair, buf, len, cb_fn, cb_arg);
+
+	if (req == NULL) {
+		return -ENOMEM;
+	}
+
+	memcpy(&req->cmd, cmd, sizeof(req->cmd));
+	memcpy(&g_nvmf_data, buf, sizeof(g_nvmf_data));
+
+	return 0;
+}
+
+DEFINE_RETURN_MOCK(nvme_wait_for_completion_timeout, int);
+int
+nvme_wait_for_completion_timeout(struct spdk_nvme_qpair *qpair,
+				 struct nvme_completion_poll_status *status,
+				 uint64_t timeout_in_usecs)
+{
+	struct spdk_nvmf_fabric_connect_rsp *rsp = (void *)&status->cpl;
+
+	if (nvme_qpair_is_admin_queue(qpair)) {
+		rsp->status_code_specific.success.cntlid = 1;
+	}
+
+	status->timed_out = false;
+	HANDLE_RETURN_MOCK(nvme_wait_for_completion_timeout);
+
+	return 0;
+}
+
 int
 spdk_nvme_transport_id_populate_trstring(struct spdk_nvme_transport_id *trid, const char *trstring)
 {
@@ -305,6 +338,82 @@ test_nvme_fabric_discover_probe(void)
 	CU_ASSERT(g_ut_ctrlr_is_probed == false);
 }
 
+static void
+test_nvme_fabric_qpair_connect(void)
+{
+	struct spdk_nvme_qpair qpair = {};
+	struct nvme_request	req = {};
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct spdk_nvmf_fabric_connect_cmd *cmd = NULL;
+	int rc;
+	char hostnqn[SPDK_NVMF_NQN_MAX_LEN + 1] = "nqn.2016-06.io.spdk:host1";
+	char subnqn[SPDK_NVMF_NQN_MAX_LEN + 1] = "nqn.2016-06.io.spdk:subsystem1";
+	const uint8_t hostid[16] = {
+		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+		0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
+	};
+
+	cmd = (void *)&req.cmd;
+	qpair.ctrlr = &ctrlr;
+	req.qpair = &qpair;
+	STAILQ_INIT(&qpair.free_req);
+	STAILQ_INSERT_HEAD(&qpair.free_req, &req, stailq);
+	memset(&g_nvmf_data, 0, sizeof(g_nvmf_data));
+
+	qpair.id = 1;
+	ctrlr.opts.keep_alive_timeout_ms = 100;
+	ctrlr.cntlid = 2;
+	memcpy(ctrlr.opts.extended_host_id, hostid, sizeof(hostid));
+	memcpy(ctrlr.opts.hostnqn, hostnqn, sizeof(hostnqn));
+	memcpy(ctrlr.trid.subnqn, subnqn, sizeof(subnqn));
+
+	rc = nvme_fabric_qpair_connect(&qpair, 1);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(cmd->opcode == SPDK_NVME_OPC_FABRIC);
+	CU_ASSERT(cmd->fctype == SPDK_NVMF_FABRIC_COMMAND_CONNECT);
+	CU_ASSERT(cmd->qid == 1);
+	CU_ASSERT(cmd->sqsize == 0);
+	CU_ASSERT(cmd->kato == 100);
+	CU_ASSERT(g_nvmf_data.cntlid == 2);
+	CU_ASSERT(!strncmp(g_nvmf_data.hostid, ctrlr.opts.extended_host_id, sizeof(g_nvmf_data.hostid)));
+	CU_ASSERT(!strncmp(g_nvmf_data.hostnqn, ctrlr.opts.hostnqn, sizeof(ctrlr.opts.hostnqn)));
+	CU_ASSERT(!strncmp(g_nvmf_data.subnqn, ctrlr.trid.subnqn, sizeof(ctrlr.trid.subnqn)));
+	CU_ASSERT(STAILQ_EMPTY(&qpair.free_req));
+
+	/* qid is adminq */
+	memset(&g_nvmf_data, 0, sizeof(g_nvmf_data));
+	memset(&req, 0, sizeof(req));
+	STAILQ_INSERT_HEAD(&qpair.free_req, &req, stailq);
+	qpair.id = 0;
+	ctrlr.cntlid = 0;
+
+	rc = nvme_fabric_qpair_connect(&qpair, 1);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(cmd->opcode == SPDK_NVME_OPC_FABRIC);
+	CU_ASSERT(cmd->fctype == SPDK_NVMF_FABRIC_COMMAND_CONNECT);
+	CU_ASSERT(cmd->qid == 0);
+	CU_ASSERT(cmd->sqsize == 0);
+	CU_ASSERT(cmd->kato == 100);
+	CU_ASSERT(ctrlr.cntlid == 1);
+	CU_ASSERT(g_nvmf_data.cntlid == 0xffff);
+	CU_ASSERT(!strncmp(g_nvmf_data.hostid, ctrlr.opts.extended_host_id, sizeof(g_nvmf_data.hostid)));
+	CU_ASSERT(!strncmp(g_nvmf_data.hostnqn, ctrlr.opts.hostnqn, sizeof(ctrlr.opts.hostnqn)));
+	CU_ASSERT(!strncmp(g_nvmf_data.subnqn, ctrlr.trid.subnqn, sizeof(ctrlr.trid.subnqn)));
+	CU_ASSERT(STAILQ_EMPTY(&qpair.free_req));
+
+	/* Wait_for completion timeout */
+	STAILQ_INSERT_HEAD(&qpair.free_req, &req, stailq);
+	MOCK_SET(nvme_wait_for_completion_timeout, 1);
+
+	rc = nvme_fabric_qpair_connect(&qpair, 1);
+	CU_ASSERT(rc == -EIO);
+	MOCK_CLEAR(nvme_wait_for_completion_timeout);
+
+	/* Input parameters invalid */
+	rc = nvme_fabric_qpair_connect(&qpair, 0);
+	CU_ASSERT(rc == -EINVAL);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -318,6 +427,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_fabric_prop_get_cmd);
 	CU_ADD_TEST(suite, test_nvme_fabric_get_discovery_log_page);
 	CU_ADD_TEST(suite, test_nvme_fabric_discover_probe);
+	CU_ADD_TEST(suite, test_nvme_fabric_qpair_connect);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 6d93f9ef6701ba47f0100cec6fc459df079065d5 Mon Sep 17 00:00:00 2001
From: Karol Latecki <karol.latecki@intel.com>
Date: Wed, 26 May 2021 13:06:10 +0200
Subject: [PATCH 324/342] test/common: update vfio-user capable Qemu branch

This should be vfio-user-master now. vfio-user-v0.6
branch is obsolete.

Signed-off-by: Karol Latecki <karol.latecki@intel.com>
Change-Id: Iaa0b429c4de13c59e1f58fe59149367f941d42f2
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8062
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Michal Berger <michalx.berger@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 test/common/config/pkgdep/git | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/common/config/pkgdep/git b/test/common/config/pkgdep/git
index 78e00c74a..4f95dd8e9 100644
--- a/test/common/config/pkgdep/git
+++ b/test/common/config/pkgdep/git
@@ -288,7 +288,7 @@ function install_qemu() {
 
 	# Forked QEMUs
 	SPDK_QEMU_BRANCH=spdk-5.0.0
-	VFIO_QEMU_BRANCH=vfio-user-v0.6
+	VFIO_QEMU_BRANCH=vfio-user-master
 	VANILLA_QEMU_BRANCH=v6.0.0
 
 	_install_qemu $GIT_REPO_QEMU_SPDK $SPDK_QEMU_BRANCH
-- 
2.26.2


From e9d964bd3cc9bee186737d9bb7b2bdff862f107b Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Tue, 18 May 2021 17:18:50 +0800
Subject: [PATCH 325/342] test/nvme_opal: build nvme_opal unittest file

Change-Id: I74bd112800f0d8369bc4d4b7a02080fe3e6cbd1c
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/6695
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Community-CI: Mellanox Build Bot
---
 test/unit/lib/nvme/Makefile                   |   2 +-
 test/unit/lib/nvme/nvme_opal.c/.gitignore     |   1 +
 test/unit/lib/nvme/nvme_opal.c/Makefile       |  38 +++++
 test/unit/lib/nvme/nvme_opal.c/nvme_opal_ut.c | 142 ++++++++++++++++++
 test/unit/unittest.sh                         |   1 +
 5 files changed, 183 insertions(+), 1 deletion(-)
 create mode 100644 test/unit/lib/nvme/nvme_opal.c/.gitignore
 create mode 100644 test/unit/lib/nvme/nvme_opal.c/Makefile
 create mode 100644 test/unit/lib/nvme/nvme_opal.c/nvme_opal_ut.c

diff --git a/test/unit/lib/nvme/Makefile b/test/unit/lib/nvme/Makefile
index 11690f326..33697fd89 100644
--- a/test/unit/lib/nvme/Makefile
+++ b/test/unit/lib/nvme/Makefile
@@ -35,7 +35,7 @@ SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../../..)
 include $(SPDK_ROOT_DIR)/mk/spdk.common.mk
 
 DIRS-y = nvme.c nvme_ctrlr.c nvme_ctrlr_cmd.c nvme_ctrlr_ocssd_cmd.c nvme_ns.c nvme_ns_cmd.c nvme_ns_ocssd_cmd.c nvme_pcie.c nvme_poll_group.c nvme_qpair.c \
-	 nvme_quirks.c nvme_tcp.c nvme_transport.c nvme_io_msg.c nvme_pcie_common.c nvme_fabric.c \
+	 nvme_quirks.c nvme_tcp.c nvme_transport.c nvme_io_msg.c nvme_pcie_common.c nvme_fabric.c nvme_opal.c \
 
 DIRS-$(CONFIG_RDMA) += nvme_rdma.c
 DIRS-$(CONFIG_NVME_CUSE) += nvme_cuse.c
diff --git a/test/unit/lib/nvme/nvme_opal.c/.gitignore b/test/unit/lib/nvme/nvme_opal.c/.gitignore
new file mode 100644
index 000000000..8d75c8d36
--- /dev/null
+++ b/test/unit/lib/nvme/nvme_opal.c/.gitignore
@@ -0,0 +1 @@
+nvme_opal_ut
diff --git a/test/unit/lib/nvme/nvme_opal.c/Makefile b/test/unit/lib/nvme/nvme_opal.c/Makefile
new file mode 100644
index 000000000..e8818ecb0
--- /dev/null
+++ b/test/unit/lib/nvme/nvme_opal.c/Makefile
@@ -0,0 +1,38 @@
+#
+#  BSD LICENSE
+#
+#  Copyright (c) Intel Corporation.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright
+#      notice, this list of conditions and the following disclaimer in
+#      the documentation and/or other materials provided with the
+#      distribution.
+#    * Neither the name of Intel Corporation nor the names of its
+#      contributors may be used to endorse or promote products derived
+#      from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+SPDK_ROOT_DIR := $(abspath $(CURDIR)/../../../../..)
+
+TEST_FILE = nvme_opal_ut.c
+
+include $(SPDK_ROOT_DIR)/mk/spdk.unittest.mk
diff --git a/test/unit/lib/nvme/nvme_opal.c/nvme_opal_ut.c b/test/unit/lib/nvme/nvme_opal.c/nvme_opal_ut.c
new file mode 100644
index 000000000..bf68bf575
--- /dev/null
+++ b/test/unit/lib/nvme/nvme_opal.c/nvme_opal_ut.c
@@ -0,0 +1,142 @@
+/*-
+ *   BSD LICENSE
+ *
+ *   Copyright (c) Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "spdk/stdinc.h"
+#include "spdk_cunit.h"
+#include "nvme/nvme_opal.c"
+#include "common/lib/test_env.c"
+
+SPDK_LOG_REGISTER_COMPONENT(nvme)
+
+DEFINE_STUB(spdk_nvme_ctrlr_cmd_security_receive, int,
+	    (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp,
+	     uint8_t nssf, void *payload, uint32_t payload_size,
+	     spdk_nvme_cmd_cb cb_fn, void *cb_arg), 1);
+
+DEFINE_STUB(spdk_nvme_ctrlr_security_receive, int,
+	    (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp,
+	     uint16_t spsp, uint8_t nssf, void *payload, size_t size), 0);
+
+DEFINE_STUB(spdk_nvme_ctrlr_process_admin_completions, int,
+	    (struct spdk_nvme_ctrlr *ctrlr), 0);
+
+DEFINE_STUB(spdk_nvme_ctrlr_cmd_security_send, int,
+	    (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp,
+	     uint16_t spsp, uint8_t nssf, void *payload,
+	     uint32_t payload_size, spdk_nvme_cmd_cb cb_fn, void *cb_arg), 0);
+
+static int g_ut_recv_status = 0;
+static void *g_ut_sess_ctx;
+
+static void
+ut_opal_sess_cb(struct opal_session *sess, int status, void *ctx)
+{
+	g_ut_recv_status = status;
+	g_ut_sess_ctx = ctx;
+}
+
+static void
+reset_ut_global_variables(void)
+{
+	g_ut_recv_status = 0;
+	g_ut_sess_ctx = NULL;
+}
+
+static void
+test_opal_nvme_security_recv_send_done(void)
+{
+	struct spdk_nvme_cpl cpl = {};
+	struct spdk_opal_compacket header = {};
+	struct spdk_opal_dev dev = {};
+	struct opal_session sess = {};
+
+	sess.sess_cb = ut_opal_sess_cb;
+	sess.cb_arg = (void *)0xDEADBEEF;
+	sess.dev = &dev;
+	memcpy(sess.resp, &header, sizeof(header));
+
+	/* Case 1: receive/send IO error */
+	reset_ut_global_variables();
+	cpl.status.sct = SPDK_NVME_SCT_MEDIA_ERROR;
+
+	opal_nvme_security_recv_done(&sess, &cpl);
+	CU_ASSERT(g_ut_recv_status == -EIO);
+	CU_ASSERT(g_ut_sess_ctx == (void *)0xDEADBEEF);
+
+	reset_ut_global_variables();
+	opal_nvme_security_send_done(&sess, &cpl);
+	CU_ASSERT(g_ut_recv_status == -EIO);
+	CU_ASSERT(g_ut_sess_ctx == (void *)0xDEADBEEF);
+
+	/* Case 2: receive with opal header no outstanding data */
+	reset_ut_global_variables();
+	memset(&header, 0, sizeof(header));
+	cpl.status.sct = SPDK_NVME_SCT_GENERIC;
+
+	opal_nvme_security_recv_done(&sess, &cpl);
+	CU_ASSERT(g_ut_recv_status == 0);
+	CU_ASSERT(g_ut_sess_ctx == (void *)0xDEADBEEF);
+
+	/* Case 3: receive with opal header outstanding data and send done success */
+	reset_ut_global_variables();
+	header.outstanding_data = 0xff;
+	memcpy(sess.resp, &header, sizeof(header));
+	cpl.status.sct = SPDK_NVME_SCT_GENERIC;
+
+	opal_nvme_security_recv_done(&sess, &cpl);
+	CU_ASSERT(g_ut_recv_status == 1);
+	CU_ASSERT(g_ut_sess_ctx == (void *)0xDEADBEEF);
+
+	reset_ut_global_variables();
+	opal_nvme_security_send_done(&sess, &cpl);
+	CU_ASSERT(g_ut_recv_status == 1);
+	CU_ASSERT(g_ut_sess_ctx == (void *)0xDEADBEEF);
+}
+
+int main(int argc, char **argv)
+{
+	CU_pSuite	suite = NULL;
+	unsigned int	num_failures;
+
+	CU_set_error_action(CUEA_ABORT);
+	CU_initialize_registry();
+
+	suite = CU_add_suite("nvme_opal", NULL, NULL);
+	CU_ADD_TEST(suite, test_opal_nvme_security_recv_send_done);
+
+	CU_basic_set_mode(CU_BRM_VERBOSE);
+	CU_basic_run_tests();
+	num_failures = CU_get_number_of_failures();
+	CU_cleanup_registry();
+	return num_failures;
+}
diff --git a/test/unit/unittest.sh b/test/unit/unittest.sh
index 493076756..9d58cfc83 100755
--- a/test/unit/unittest.sh
+++ b/test/unit/unittest.sh
@@ -86,6 +86,7 @@ function unittest_nvme() {
 	$valgrind $testdir/lib/nvme/nvme_io_msg.c/nvme_io_msg_ut
 	$valgrind $testdir/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut
 	$valgrind $testdir/lib/nvme/nvme_fabric.c/nvme_fabric_ut
+	$valgrind $testdir/lib/nvme/nvme_opal.c/nvme_opal_ut
 }
 
 function unittest_nvmf() {
-- 
2.26.2


From 8742570d72bd4eccf380f98ffdb3a8cf2bd10b66 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Thu, 27 May 2021 15:28:29 +0800
Subject: [PATCH 326/342] test/nvme_tcp: cases for handling pdu payload

Change-Id: I1bba56ec5f3061362deac1470cb7b53461f7006e
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8092
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c | 96 +++++++++++++++++++++
 1 file changed, 96 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
index ae846ca96..d8c69a559 100644
--- a/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
+++ b/test/unit/lib/nvme/nvme_tcp.c/nvme_tcp_ut.c
@@ -1288,6 +1288,100 @@ test_nvme_tcp_icresp_handle(void)
 	CU_ASSERT(tqpair.flags.host_ddgst_enable == pdu.hdr.ic_resp.dgst.bits.ddgst_enable);
 }
 
+static void
+test_nvme_tcp_pdu_payload_handle(void)
+{
+	struct nvme_tcp_qpair	tqpair = {};
+	struct nvme_tcp_pdu	recv_pdu = {};
+	struct nvme_tcp_req	tcp_req = {};
+	struct nvme_request	req = {};
+	uint32_t		reaped = 0;
+
+	tqpair.recv_pdu = &recv_pdu;
+	tcp_req.tqpair = &tqpair;
+	tcp_req.req = &req;
+	tcp_req.req->qpair = &tqpair.qpair;
+
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD;
+	tqpair.qpair.id = 1;
+	recv_pdu.ddgst_enable = false;
+	recv_pdu.req = &tcp_req;
+	recv_pdu.hdr.c2h_data.common.flags = SPDK_NVME_TCP_C2H_DATA_FLAGS_SUCCESS;
+	recv_pdu.data_len = 1024;
+	tcp_req.ordering.bits.data_recv = 0;
+	tcp_req.req->cb_fn = ut_nvme_complete_request;
+	tcp_req.cid = 1;
+	TAILQ_INIT(&tcp_req.tqpair->outstanding_reqs);
+	TAILQ_INSERT_TAIL(&tcp_req.tqpair->outstanding_reqs, &tcp_req, link);
+
+	/* C2H_DATA */
+	recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_C2H_DATA;
+	tcp_req.datao = 1024;
+	tcp_req.req->payload_size = 2048;
+	tcp_req.state = NVME_TCP_REQ_ACTIVE;
+	tcp_req.ordering.bits.send_ack = 1;
+
+	nvme_tcp_pdu_payload_handle(&tqpair, &reaped);
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(tcp_req.rsp.status.p == 0);
+	CU_ASSERT(tcp_req.rsp.cid == 1);
+	CU_ASSERT(tcp_req.rsp.sqid == 1);
+	CU_ASSERT(tcp_req.ordering.bits.data_recv == 1);
+	CU_ASSERT(reaped == 1);
+
+	/* TermResp */
+	recv_pdu.hdr.common.pdu_type = SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ;
+	recv_pdu.hdr.term_req.fes = SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD;
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PAYLOAD;
+
+	nvme_tcp_pdu_payload_handle(&tqpair, &reaped);
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
+}
+
+static void
+test_nvme_tcp_capsule_resp_hdr_handle(void)
+{
+	struct nvme_tcp_qpair	tqpair = {};
+	struct nvme_request	req = {};
+	struct spdk_nvme_cpl	rccqe_tgt = {};
+	struct nvme_tcp_req	*tcp_req = NULL;
+	uint32_t		reaped = 0;
+	int			rc;
+
+	/* Initialize requests and pdus */
+	tqpair.num_entries = 1;
+	req.qpair = &tqpair.qpair;
+
+	rc = nvme_tcp_alloc_reqs(&tqpair);
+	SPDK_CU_ASSERT_FATAL(rc == 0);
+	tcp_req = nvme_tcp_req_get(&tqpair);
+	SPDK_CU_ASSERT_FATAL(tcp_req != NULL);
+	rc = nvme_tcp_req_init(&tqpair, &req, tcp_req);
+	SPDK_CU_ASSERT_FATAL(rc == 0);
+	tcp_req->ordering.bits.send_ack = 1;
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH;
+	/* tqpair.recv_pdu will be reseted after handling */
+	memset(&rccqe_tgt, 0xff, sizeof(rccqe_tgt));
+	rccqe_tgt.cid = 0;
+	memcpy(&tqpair.recv_pdu->hdr.capsule_resp.rccqe, &rccqe_tgt, sizeof(rccqe_tgt));
+
+	nvme_tcp_capsule_resp_hdr_handle(&tqpair, tqpair.recv_pdu, &reaped);
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_READY);
+	CU_ASSERT(!memcmp(&tcp_req->rsp, &rccqe_tgt, sizeof(rccqe_tgt)));
+	CU_ASSERT(tcp_req->ordering.bits.data_recv == 1);
+	CU_ASSERT(reaped == 1);
+	CU_ASSERT(TAILQ_EMPTY(&tcp_req->tqpair->outstanding_reqs));
+
+	/* Get tcp request error, expect fail */
+	reaped = 0;
+	tqpair.recv_pdu->hdr.capsule_resp.rccqe.cid = 1;
+	tqpair.recv_state = NVME_TCP_PDU_RECV_STATE_AWAIT_PDU_PSH;
+
+	nvme_tcp_capsule_resp_hdr_handle(&tqpair, tqpair.recv_pdu, &reaped);
+	CU_ASSERT(reaped == 0);
+	CU_ASSERT(tqpair.recv_state == NVME_TCP_PDU_RECV_STATE_ERROR);
+	nvme_tcp_free_reqs(&tqpair);
+}
 
 int main(int argc, char **argv)
 {
@@ -1317,6 +1411,8 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_tcp_qpair_icreq_send);
 	CU_ADD_TEST(suite, test_nvme_tcp_c2h_payload_handle);
 	CU_ADD_TEST(suite, test_nvme_tcp_icresp_handle);
+	CU_ADD_TEST(suite, test_nvme_tcp_pdu_payload_handle);
+	CU_ADD_TEST(suite, test_nvme_tcp_capsule_resp_hdr_handle);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 9d8e1ec03c389354c1763c5ad06f527c7a01e25f Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Mon, 24 May 2021 11:11:48 +0200
Subject: [PATCH 327/342] test/common: Reset IFS within print_backtrace()

In case IFS was modified in the environment where print_backtrace()
was called, it could impact the cmd substitution used for seq'ing
the main FUNCNAME loop. Example:

========== Backtrace start: ==========

/home/vagrant/spdk_repo/spdk/test/common/autotest_common.sh: line 980: 1
2
3
4: syntax error in expression (error token is "2
3
4")

Avoid that by resetting the IFS to its default value, but also,
replace said $() with arithmetic evaluation to avoid it altogether.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: I4ab098319dfae3a5356eb4fe0dbf9f4af2d2eea6
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8013
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
---
 test/common/autotest_common.sh | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/test/common/autotest_common.sh b/test/common/autotest_common.sh
index 30f5832e6..4df51d836 100755
--- a/test/common/autotest_common.sh
+++ b/test/common/autotest_common.sh
@@ -991,9 +991,11 @@ function print_backtrace() {
 	local args=("${BASH_ARGV[@]}")
 
 	xtrace_disable
+	# Reset IFS in case we were called from an environment where it was modified
+	IFS=" "$'\t'$'\n'
 	echo "========== Backtrace start: =========="
 	echo ""
-	for i in $(seq 1 $((${#FUNCNAME[@]} - 1))); do
+	for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
 		local func="${FUNCNAME[$i]}"
 		local line_nr="${BASH_LINENO[$((i - 1))]}"
 		local src="${BASH_SOURCE[$i]}"
-- 
2.26.2


From c754043946592ba5ecb6a171bc37d35afaeb31f8 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Mon, 7 Jun 2021 14:50:40 +0000
Subject: [PATCH 328/342] Revert "thread: speed up io_device lookup by using
 rbtree"

This reverts commit 2246a9371809c30333b1844afbf9772c4b06db79.

We are seeing a lot of failure on io_device lookup in the test
pool.  These only showed up after this patch was merged and sees
the most likely culprit.  Reverting this patch for now while we
continue debug.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I2ab098319dfae3a5356eb4fe0dbf9f4af2d2eea5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8199
Community-CI: Mellanox Build Bot
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 lib/thread/thread.c                       | 54 ++++++++++-------------
 test/unit/lib/thread/thread.c/thread_ut.c | 42 ++++++++++++------
 2 files changed, 52 insertions(+), 44 deletions(-)

diff --git a/lib/thread/thread.c b/lib/thread/thread.c
index 39a9839db..3cee7de00 100644
--- a/lib/thread/thread.c
+++ b/lib/thread/thread.c
@@ -177,22 +177,14 @@ struct io_device {
 	struct spdk_thread		*unregister_thread;
 	uint32_t			ctx_size;
 	uint32_t			for_each_count;
-	RB_ENTRY(io_device)		node;
+	TAILQ_ENTRY(io_device)		tailq;
 
 	uint32_t			refcnt;
 
 	bool				unregistered;
 };
 
-static RB_HEAD(io_device_tree, io_device) g_io_devices = RB_INITIALIZER(g_io_devices);
-
-static int
-io_device_cmp(struct io_device *dev1, struct io_device *dev2)
-{
-	return dev1->io_device - dev2->io_device;
-}
-
-RB_GENERATE_STATIC(io_device_tree, io_device, node, io_device_cmp);
+static TAILQ_HEAD(, io_device) g_io_devices = TAILQ_HEAD_INITIALIZER(g_io_devices);
 
 struct spdk_msg {
 	spdk_msg_fn		fn;
@@ -304,7 +296,7 @@ spdk_thread_lib_fini(void)
 {
 	struct io_device *dev;
 
-	RB_FOREACH(dev, io_device_tree, &g_io_devices) {
+	TAILQ_FOREACH(dev, &g_io_devices, tailq) {
 		SPDK_ERRLOG("io_device %s not unregistered\n", dev->name);
 	}
 
@@ -1850,15 +1842,6 @@ spdk_thread_set_interrupt_mode(bool enable_interrupt)
 	return;
 }
 
-static struct io_device *
-io_device_get(void *io_device)
-{
-	struct io_device find = {};
-
-	find.io_device = io_device;
-	return RB_FIND(io_device_tree, &g_io_devices, &find);
-}
-
 void
 spdk_io_device_register(void *io_device, spdk_io_channel_create_cb create_cb,
 			spdk_io_channel_destroy_cb destroy_cb, uint32_t ctx_size,
@@ -1902,14 +1885,16 @@ spdk_io_device_register(void *io_device, spdk_io_channel_create_cb create_cb,
 		      dev->name, dev->io_device, thread->name);
 
 	pthread_mutex_lock(&g_devlist_mutex);
-	tmp = RB_INSERT(io_device_tree, &g_io_devices, dev);
-	if (tmp != NULL) {
-		SPDK_ERRLOG("io_device %p already registered (old:%s new:%s)\n",
-			    io_device, tmp->name, dev->name);
-		free(dev);
-		pthread_mutex_unlock(&g_devlist_mutex);
-		return;
+	TAILQ_FOREACH(tmp, &g_io_devices, tailq) {
+		if (tmp->io_device == io_device) {
+			SPDK_ERRLOG("io_device %p already registered (old:%s new:%s)\n",
+				    io_device, tmp->name, dev->name);
+			free(dev);
+			pthread_mutex_unlock(&g_devlist_mutex);
+			return;
+		}
 	}
+	TAILQ_INSERT_TAIL(&g_io_devices, dev, tailq);
 	pthread_mutex_unlock(&g_devlist_mutex);
 }
 
@@ -1963,7 +1948,12 @@ spdk_io_device_unregister(void *io_device, spdk_io_device_unregister_cb unregist
 	}
 
 	pthread_mutex_lock(&g_devlist_mutex);
-	dev = io_device_get(io_device);
+	TAILQ_FOREACH(dev, &g_io_devices, tailq) {
+		if (dev->io_device == io_device) {
+			break;
+		}
+	}
+
 	if (!dev) {
 		SPDK_ERRLOG("io_device %p not found\n", io_device);
 		assert(false);
@@ -1980,7 +1970,7 @@ spdk_io_device_unregister(void *io_device, spdk_io_device_unregister_cb unregist
 
 	dev->unregister_cb = unregister_cb;
 	dev->unregistered = true;
-	RB_REMOVE(io_device_tree, &g_io_devices, dev);
+	TAILQ_REMOVE(&g_io_devices, dev, tailq);
 	refcnt = dev->refcnt;
 	dev->unregister_thread = thread;
 	pthread_mutex_unlock(&g_devlist_mutex);
@@ -2015,7 +2005,11 @@ spdk_get_io_channel(void *io_device)
 	int rc;
 
 	pthread_mutex_lock(&g_devlist_mutex);
-	dev = io_device_get(io_device);
+	TAILQ_FOREACH(dev, &g_io_devices, tailq) {
+		if (dev->io_device == io_device) {
+			break;
+		}
+	}
 	if (dev == NULL) {
 		SPDK_ERRLOG("could not find io_device %p\n", io_device);
 		pthread_mutex_unlock(&g_devlist_mutex);
diff --git a/test/unit/lib/thread/thread.c/thread_ut.c b/test/unit/lib/thread/thread.c/thread_ut.c
index a3d57c2fb..150aaed84 100644
--- a/test/unit/lib/thread/thread.c/thread_ut.c
+++ b/test/unit/lib/thread/thread.c/thread_ut.c
@@ -644,12 +644,12 @@ for_each_channel_unreg(void)
 
 	allocate_threads(1);
 	set_thread(0);
-	CU_ASSERT(RB_EMPTY(&g_io_devices));
+	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
 	spdk_io_device_register(&io_target, channel_create, channel_destroy, sizeof(int), NULL);
-	CU_ASSERT(!RB_EMPTY(&g_io_devices));
-	dev = RB_MIN(io_device_tree, &g_io_devices);
+	CU_ASSERT(!TAILQ_EMPTY(&g_io_devices));
+	dev = TAILQ_FIRST(&g_io_devices);
 	SPDK_CU_ASSERT_FATAL(dev != NULL);
-	CU_ASSERT(RB_NEXT(io_device_tree, &g_io_devices, dev) == NULL);
+	CU_ASSERT(TAILQ_NEXT(dev, tailq) == NULL);
 	ch0 = spdk_get_io_channel(&io_target);
 	spdk_for_each_channel(&io_target, unreg_ch_done, &ctx, unreg_foreach_done);
 
@@ -658,14 +658,14 @@ for_each_channel_unreg(void)
 	 * There is an outstanding foreach call on the io_device, so the unregister should not
 	 *  have removed the device.
 	 */
-	CU_ASSERT(dev == RB_MIN(io_device_tree, &g_io_devices));
+	CU_ASSERT(dev == TAILQ_FIRST(&g_io_devices));
 	spdk_io_device_register(&io_target, channel_create, channel_destroy, sizeof(int), NULL);
 	/*
 	 * There is already a device registered at &io_target, so a new io_device should not
 	 *  have been added to g_io_devices.
 	 */
-	CU_ASSERT(dev == RB_MIN(io_device_tree, &g_io_devices));
-	CU_ASSERT(RB_NEXT(io_device_tree, &g_io_devices, dev) == NULL);
+	CU_ASSERT(dev == TAILQ_FIRST(&g_io_devices));
+	CU_ASSERT(TAILQ_NEXT(dev, tailq) == NULL);
 
 	poll_thread(0);
 	CU_ASSERT(ctx.ch_done == true);
@@ -675,7 +675,7 @@ for_each_channel_unreg(void)
 	 *  even though a channel still exists for the device.
 	 */
 	spdk_io_device_unregister(&io_target, NULL);
-	CU_ASSERT(RB_EMPTY(&g_io_devices));
+	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
 
 	set_thread(0);
 	spdk_put_io_channel(ch0);
@@ -824,7 +824,7 @@ channel(void)
 	poll_threads();
 	spdk_io_device_unregister(&g_device2, NULL);
 	poll_threads();
-	CU_ASSERT(RB_EMPTY(&g_io_devices));
+	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
 	free_threads();
 	CU_ASSERT(TAILQ_EMPTY(&g_threads));
 }
@@ -879,7 +879,7 @@ channel_destroy_races(void)
 	spdk_io_device_unregister(&device, NULL);
 	poll_threads();
 
-	CU_ASSERT(RB_EMPTY(&g_io_devices));
+	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
 	free_threads();
 	CU_ASSERT(TAILQ_EMPTY(&g_threads));
 }
@@ -1135,6 +1135,20 @@ struct ut_nested_dev {
 	struct ut_nested_dev *child;
 };
 
+static struct io_device *
+ut_get_io_device(void *dev)
+{
+	struct io_device *tmp;
+
+	TAILQ_FOREACH(tmp, &g_io_devices, tailq) {
+		if (tmp->io_device == dev) {
+			return tmp;
+		}
+	}
+
+	return NULL;
+}
+
 static int
 ut_null_poll(void *ctx)
 {
@@ -1232,11 +1246,11 @@ nested_channel(void)
 	spdk_io_device_register(&_dev3, ut_nested_ch_create_cb, ut_nested_ch_destroy_cb,
 				sizeof(struct ut_nested_ch), "dev3");
 
-	dev1 = io_device_get(&_dev1);
+	dev1 = ut_get_io_device(&_dev1);
 	SPDK_CU_ASSERT_FATAL(dev1 != NULL);
-	dev2 = io_device_get(&_dev2);
+	dev2 = ut_get_io_device(&_dev2);
 	SPDK_CU_ASSERT_FATAL(dev2 != NULL);
-	dev3 = io_device_get(&_dev3);
+	dev3 = ut_get_io_device(&_dev3);
 	SPDK_CU_ASSERT_FATAL(dev3 != NULL);
 
 	/* A single call spdk_get_io_channel() to dev1 will also create channels
@@ -1301,7 +1315,7 @@ nested_channel(void)
 	spdk_io_device_unregister(&_dev1, NULL);
 	spdk_io_device_unregister(&_dev2, NULL);
 	spdk_io_device_unregister(&_dev3, NULL);
-	CU_ASSERT(RB_EMPTY(&g_io_devices));
+	CU_ASSERT(TAILQ_EMPTY(&g_io_devices));
 
 	free_threads();
 	CU_ASSERT(TAILQ_EMPTY(&g_threads));
-- 
2.26.2


From 3a7a66e5055a62716df0bbc6bf4c33d59ca402a4 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Mon, 17 May 2021 23:16:53 +0000
Subject: [PATCH 329/342] nvme: add wmb before writing shadow register

Fixes issue #1828.

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I02ba897b6c10f4ec870f46825f09e00f0c7c0235
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7905
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
---
 lib/nvme/nvme_pcie_internal.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib/nvme/nvme_pcie_internal.h b/lib/nvme/nvme_pcie_internal.h
index 5f7b08f9e..f1eb6c98c 100644
--- a/lib/nvme/nvme_pcie_internal.h
+++ b/lib/nvme/nvme_pcie_internal.h
@@ -241,6 +241,8 @@ nvme_pcie_qpair_update_mmio_required(struct spdk_nvme_qpair *qpair, uint16_t val
 		return true;
 	}
 
+	spdk_wmb();
+
 	old = *shadow_db;
 	*shadow_db = value;
 
-- 
2.26.2


From ab7bd10ad9dc12e95fb3665f2e5db1ff2a584e2c Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Mon, 7 Jun 2021 09:40:19 +0200
Subject: [PATCH 330/342] test/common: Remove BASH_XTRACEFD echo

This was added only for testing purposes. Right now it just
unnecessarily makes the build logs bigger and spams the stdout.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Id8ff3e1dfde955dc118e0a202897d6c6634c3995
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8194
Reviewed-by: Karol Latecki <karol.latecki@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 test/common/autotest_common.sh | 1 -
 1 file changed, 1 deletion(-)

diff --git a/test/common/autotest_common.sh b/test/common/autotest_common.sh
index 4df51d836..1e666cc39 100755
--- a/test/common/autotest_common.sh
+++ b/test/common/autotest_common.sh
@@ -8,7 +8,6 @@ function xtrace_fd() {
 	exec {BASH_XTRACEFD}>&2
 
 	set -x
-	echo "Tracing to $BASH_XTRACEFD FD"
 }
 
 function xtrace_disable() {
-- 
2.26.2


From 93e6e40442a43c89082b3166f902aaa8a2b4a0a8 Mon Sep 17 00:00:00 2001
From: Michal Berger <michalx.berger@intel.com>
Date: Wed, 2 Jun 2021 12:30:12 +0200
Subject: [PATCH 331/342] rpmbuild: Allow to define custom builddir

Alternative for the default of $HOME/rpmbuild.

Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Id1feb7207926b518deb87045fc17bb3d1d4c374e
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8159
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
---
 autopackage.sh  |  6 ++++--
 rpmbuild/rpm.sh | 15 +++++++++------
 2 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/autopackage.sh b/autopackage.sh
index 7f5c81e16..d73801901 100755
--- a/autopackage.sh
+++ b/autopackage.sh
@@ -11,6 +11,7 @@ fi
 source "$1"
 
 rootdir=$(readlink -f $(dirname $0))
+testdir=$rootdir # to get the storage space for tests
 source "$rootdir/test/common/autotest_common.sh"
 
 function build_rpms() (
@@ -20,7 +21,7 @@ function build_rpms() (
 	unset -v LD_LIBRARY_PATH
 
 	install_uninstall_rpms() {
-		rpms=("$HOME/rpmbuild/RPMS/x86_64/"spdk{,-devel,{,-dpdk}-libs}-$version-1.x86_64.rpm)
+		rpms=("$builddir/rpm/x86_64/"spdk{,-devel,{,-dpdk}-libs}-$version-1.x86_64.rpm)
 
 		sudo rpm -i "${rpms[@]}"
 		rpms=("${rpms[@]##*/}") rpms=("${rpms[@]%.rpm}")
@@ -31,11 +32,12 @@ function build_rpms() (
 	}
 
 	build_rpm() {
-		MAKEFLAGS="$MAKEFLAGS" SPDK_VERSION="$version" DEPS=no "$rootdir/rpmbuild/rpm.sh" "$@"
+		BUILDDIR=$builddir MAKEFLAGS="$MAKEFLAGS" SPDK_VERSION="$version" DEPS=no "$rootdir/rpmbuild/rpm.sh" "$@"
 		install_uninstall_rpms
 	}
 
 	version="test_shared"
+	builddir=$SPDK_TEST_STORAGE/test-rpm
 	run_test "build_shared_rpm" build_rpm --with-shared
 
 	if [[ -n $SPDK_TEST_NATIVE_DPDK ]]; then
diff --git a/rpmbuild/rpm.sh b/rpmbuild/rpm.sh
index 76b04ed9c..d358d6472 100755
--- a/rpmbuild/rpm.sh
+++ b/rpmbuild/rpm.sh
@@ -46,15 +46,18 @@ get_version() {
 }
 
 build_rpm() (
-	local macros=()
+	local macros=() dir
 
 	macros+=(-D "configure $configure")
 	macros+=(-D "make $make")
 	macros+=(-D "release $release")
 	macros+=(-D "version $version")
 
-	# Prepare default dir structure
-	mkdir -p "$HOME"/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
+	# Adjust dir macros to update the final location of the RPMS
+	for dir in build buildroot rpm source spec srcrpm; do
+		mkdir -p "$rpmbuild_dir/$dir"
+		macros+=(-D "_${dir}dir $rpmbuild_dir/$dir")
+	done
 
 	if [[ $configure == *"with-shared"* || $configure == *"with-dpdk"* ]]; then
 		macros+=(-D "dpdk 1")
@@ -82,10 +85,10 @@ build_rpm() (
 
 	fedora_python_sys_path_workaround
 
-	# Despite building in-place, rpmbuild still looks under SOURCES as defined
+	# Despite building in-place, rpmbuild still looks under source dir as defined
 	# in Source:. Create a dummy file to fulfil its needs and to keep Source in
 	# the .spec.
-	: > "$rpmbuild_dir/SOURCES/spdk-$version.tar.gz"
+	: > "$rpmbuild_dir/source/spdk-$version.tar.gz"
 
 	printf '* Starting rpmbuild...\n'
 	rpmbuild --clean --nodebuginfo "${macros[@]}" --build-in-place -ba "$spec"
@@ -99,7 +102,7 @@ release=${RPM_RELEASE:-1}
 requirements=${REQUIREMENTS:-}
 version=${SPDK_VERSION:-$(get_version)}
 
-rpmbuild_dir=$HOME/rpmbuild
+rpmbuild_dir=${BUILDDIR:-"$HOME/rpmbuild"}
 spec=$specdir/spdk.spec
 
 build_rpm
-- 
2.26.2


From 5a21edf4e3b16103cbd31e2f4f3c80943de3837f Mon Sep 17 00:00:00 2001
From: Nick Connolly <nick.connolly@mayadata.io>
Date: Mon, 29 Mar 2021 14:00:11 +0100
Subject: [PATCH 332/342] scripts: add autotest support for Windows

Source Windows specific definitions from common.sh. These adjust
uname to report the operating system as WSL, Msys or Cygwin and the
kernel name as Windows.  They also define kill() to invoke the SIGTERM
handler before causing a hard stop with TerminateProcess.

Adjust the ordering of the 'source' commands in autotest_common.sh so
that the config definitions are available when common.sh is loaded.
Define MAKE, MAKEFLAGS and HUGEMEM for Windows.

Signed-off-by: Nick Connolly <nick.connolly@mayadata.io>
Change-Id: I130b892ee55c925a0b033bda271a29133993afb7
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7101
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 scripts/common.sh              |  7 +++++++
 test/common/autotest_common.sh | 11 +++++++++--
 2 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/scripts/common.sh b/scripts/common.sh
index 2edd0eddf..edd5fa5f5 100644
--- a/scripts/common.sh
+++ b/scripts/common.sh
@@ -315,3 +315,10 @@ le() { cmp_versions "$1" "<=" "$2"; }
 ge() { cmp_versions "$1" ">=" "$2"; }
 eq() { cmp_versions "$1" "==" "$2"; }
 neq() { ! eq "$1" "$2"; }
+
+if [[ -e "$CONFIG_WPDK_DIR/bin/wpdk_common.sh" ]]; then
+	# Adjust uname to report the operating system as WSL, Msys or Cygwin
+	# and the kernel name as Windows. Define kill() to invoke the SIGTERM
+	# handler before causing a hard stop with TerminateProcess.
+	source "$CONFIG_WPDK_DIR/bin/wpdk_common.sh"
+fi
diff --git a/test/common/autotest_common.sh b/test/common/autotest_common.sh
index 1e666cc39..937597c93 100755
--- a/test/common/autotest_common.sh
+++ b/test/common/autotest_common.sh
@@ -28,8 +28,6 @@ xtrace_disable
 set -e
 shopt -s expand_aliases
 
-source "$rootdir/test/common/applications.sh"
-source "$rootdir/scripts/common.sh"
 if [[ -e $rootdir/test/common/build_config.sh ]]; then
 	source "$rootdir/test/common/build_config.sh"
 elif [[ -e $rootdir/mk/config.mk ]]; then
@@ -39,6 +37,10 @@ else
 	source "$rootdir/CONFIG"
 fi
 
+# Source scripts after the config so that the definitions are available.
+source "$rootdir/test/common/applications.sh"
+source "$rootdir/scripts/common.sh"
+
 # Dummy function to be called after restoring xtrace just so that it appears in the
 # xtrace log. This way we can consistently track when xtrace is enabled/disabled.
 function xtrace_enable() {
@@ -233,6 +235,11 @@ elif [ "$(uname -s)" = "FreeBSD" ]; then
 	MAKEFLAGS=${MAKEFLAGS:--j$(sysctl -a | grep -E -i 'hw.ncpu' | awk '{print $2}')}
 	# FreeBSD runs a much more limited set of tests, so keep the default 2GB.
 	export HUGEMEM=2048
+elif [ "$(uname -s)" = "Windows" ]; then
+	MAKE="make"
+	MAKEFLAGS=${MAKEFLAGS:--j$(nproc)}
+	# Keep the default 2GB for Windows.
+	export HUGEMEM=2048
 else
 	echo "Unknown OS \"$(uname -s)\""
 	exit 1
-- 
2.26.2


From 9cedc7202c6a447360817e186913f3cd03caccb0 Mon Sep 17 00:00:00 2001
From: GangCao <gang.cao@intel.com>
Date: Fri, 4 Jun 2021 15:23:41 -0400
Subject: [PATCH 333/342] Util: check the error case of NULL pointer

Change-Id: I0be36b584c99de822920b935c34708576617ffc3
Signed-off-by: GangCao <gang.cao@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8176
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Xiaodong Liu <xiaodong.liu@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: <dongx.yi@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
---
 examples/util/zipf/zipf.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/examples/util/zipf/zipf.c b/examples/util/zipf/zipf.c
index 795cd5054..d62ca2daf 100644
--- a/examples/util/zipf/zipf.c
+++ b/examples/util/zipf/zipf.c
@@ -83,6 +83,12 @@ main(int argc, char **argv)
 
 	zipf = spdk_zipf_create(range, theta, time(NULL));
 	h = spdk_histogram_data_alloc();
+	if (zipf == NULL || h == NULL) {
+		spdk_zipf_free(&zipf);
+		spdk_histogram_data_free(h);
+		printf("out of resource\n");
+		return 1;
+	}
 
 	for (i = 0; i < count; i++) {
 		spdk_histogram_data_tally(h, spdk_zipf_generate(zipf));
-- 
2.26.2


From e8c8d4ebc7e49385d9ba75b39d340722ff3ec0b9 Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Fri, 21 May 2021 15:19:50 +0800
Subject: [PATCH 334/342] test/pcie_common: cases for connecting qpair

Change-Id: If03ff8d382c663d1f1e291a2e9c84e7c0b1cd7a9
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7994
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Community-CI: Mellanox Build Bot
---
 .../nvme_pcie_common.c/nvme_pcie_common_ut.c  | 141 ++++++++++++++++++
 1 file changed, 141 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
index 7c5f8152b..bdc137516 100644
--- a/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
+++ b/test/unit/lib/nvme/nvme_pcie_common.c/nvme_pcie_common_ut.c
@@ -287,6 +287,146 @@ test_nvme_pcie_ctrlr_cmd_create_delete_io_queue(void)
 	CU_ASSERT(rc == -ENOMEM);
 }
 
+static void
+test_nvme_pcie_ctrlr_connect_qpair(void)
+{
+	struct nvme_pcie_ctrlr	pctrlr = {};
+	struct nvme_pcie_qpair	pqpair = {};
+	struct spdk_nvme_transport_poll_group poll_group = {};
+	struct spdk_nvme_cpl cpl = {};
+	struct spdk_nvme_qpair adminq = {};
+	struct nvme_request req[2] = {};
+	int rc;
+
+	pqpair.cpl = &cpl;
+	pqpair.num_entries = 1;
+	pqpair.qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair.qpair.id = 1;
+	pqpair.num_entries = 1;
+	pqpair.cpl_bus_addr = 0xDEADBEEF;
+	pqpair.cmd_bus_addr = 0xDDADBEEF;
+	pqpair.qpair.qprio = SPDK_NVME_QPRIO_HIGH;
+	pqpair.stat = NULL;
+	pqpair.qpair.poll_group = &poll_group;
+	pctrlr.ctrlr.page_size = 4096;
+
+	/* Shadow doorbell available */
+	pctrlr.doorbell_stride_u32 = 1;
+	pctrlr.ctrlr.shadow_doorbell = spdk_zmalloc(pctrlr.ctrlr.page_size, pctrlr.ctrlr.page_size,
+				       NULL, SPDK_ENV_LCORE_ID_ANY,
+				       SPDK_MALLOC_DMA | SPDK_MALLOC_SHARE);
+	pctrlr.ctrlr.eventidx = spdk_zmalloc(pctrlr.ctrlr.page_size, pctrlr.ctrlr.page_size,
+					     NULL, SPDK_ENV_LCORE_ID_ANY,
+					     SPDK_MALLOC_DMA | SPDK_MALLOC_SHARE);
+	pctrlr.ctrlr.adminq = &adminq;
+	STAILQ_INIT(&pctrlr.ctrlr.adminq->free_req);
+	for (int i = 0; i < 2; i++) {
+		STAILQ_INSERT_HEAD(&pctrlr.ctrlr.adminq->free_req, &req[i], stailq);
+	}
+
+	rc = nvme_pcie_ctrlr_connect_qpair(&pctrlr.ctrlr, &pqpair.qpair);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req[0].cmd.opc == SPDK_NVME_OPC_CREATE_IO_SQ);
+	CU_ASSERT(req[0].cmd.cdw10_bits.create_io_q.qid == 1);
+	CU_ASSERT(req[0].cmd.cdw10_bits.create_io_q.qsize == 0);
+	CU_ASSERT(req[0].cmd.cdw11_bits.create_io_sq.pc == 1);
+	CU_ASSERT(req[0].cmd.cdw11_bits.create_io_sq.qprio == SPDK_NVME_QPRIO_HIGH);
+	CU_ASSERT(req[0].cmd.cdw11_bits.create_io_sq.cqid = 1);
+	CU_ASSERT(req[0].cmd.dptr.prp.prp1 == 0xDDADBEEF);
+	CU_ASSERT(req[1].cmd.opc == SPDK_NVME_OPC_CREATE_IO_CQ);
+	CU_ASSERT(req[1].cmd.cdw10_bits.create_io_q.qid == 1);
+	CU_ASSERT(req[1].cmd.cdw10_bits.create_io_q.qsize == 0);
+	CU_ASSERT(req[1].cmd.cdw11_bits.create_io_cq.pc == 1);
+	CU_ASSERT(req[1].cmd.dptr.prp.prp1 == 0xDEADBEEF);
+	/* doorbell stride and qid are 1 */
+	CU_ASSERT(pqpair.shadow_doorbell.sq_tdbl == pctrlr.ctrlr.shadow_doorbell + 2);
+	CU_ASSERT(pqpair.shadow_doorbell.cq_hdbl == pctrlr.ctrlr.shadow_doorbell + 3);
+	CU_ASSERT(pqpair.shadow_doorbell.sq_eventidx == pctrlr.ctrlr.eventidx + 2);
+	CU_ASSERT(pqpair.shadow_doorbell.cq_eventidx == pctrlr.ctrlr.eventidx + 3);
+	CU_ASSERT(pqpair.flags.has_shadow_doorbell == 1);
+	CU_ASSERT(STAILQ_EMPTY(&pctrlr.ctrlr.adminq->free_req));
+
+	spdk_free(pctrlr.ctrlr.shadow_doorbell);
+	spdk_free(pctrlr.ctrlr.eventidx);
+	pctrlr.ctrlr.shadow_doorbell = NULL;
+	pctrlr.ctrlr.eventidx = NULL;
+
+	/* Shadow doorbell 0 */
+	memset(req, 0, sizeof(struct nvme_request) * 2);
+	memset(&pqpair, 0, sizeof(pqpair));
+	pqpair.cpl = &cpl;
+	pqpair.qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair.qpair.id = 1;
+	pqpair.num_entries = 1;
+	pqpair.cpl_bus_addr = 0xDEADBEEF;
+	pqpair.cmd_bus_addr = 0xDDADBEEF;
+	pqpair.qpair.qprio = SPDK_NVME_QPRIO_HIGH;
+	pqpair.stat = NULL;
+	pqpair.qpair.poll_group = &poll_group;
+	for (int i = 0; i < 2; i++) {
+		STAILQ_INSERT_HEAD(&pctrlr.ctrlr.adminq->free_req, &req[i], stailq);
+	}
+
+	rc = nvme_pcie_ctrlr_connect_qpair(&pctrlr.ctrlr, &pqpair.qpair);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(req[0].cmd.opc == SPDK_NVME_OPC_CREATE_IO_SQ);
+	CU_ASSERT(req[0].cmd.cdw10_bits.create_io_q.qid == 1);
+	CU_ASSERT(req[0].cmd.cdw10_bits.create_io_q.qsize == 0);
+	CU_ASSERT(req[0].cmd.cdw11_bits.create_io_sq.pc == 1);
+	CU_ASSERT(req[0].cmd.cdw11_bits.create_io_sq.qprio == SPDK_NVME_QPRIO_HIGH);
+	CU_ASSERT(req[0].cmd.cdw11_bits.create_io_sq.cqid = 1);
+	CU_ASSERT(req[0].cmd.dptr.prp.prp1 == 0xDDADBEEF);
+	CU_ASSERT(req[1].cmd.opc == SPDK_NVME_OPC_CREATE_IO_CQ);
+	CU_ASSERT(req[1].cmd.cdw10_bits.create_io_q.qid == 1);
+	CU_ASSERT(req[1].cmd.cdw10_bits.create_io_q.qsize == 0);
+	CU_ASSERT(req[1].cmd.cdw11_bits.create_io_cq.pc == 1);
+	CU_ASSERT(req[1].cmd.dptr.prp.prp1 == 0xDEADBEEF);
+	CU_ASSERT(pqpair.shadow_doorbell.sq_tdbl == NULL);
+	CU_ASSERT(pqpair.shadow_doorbell.sq_eventidx == NULL);
+	CU_ASSERT(pqpair.flags.has_shadow_doorbell == 0);
+	CU_ASSERT(STAILQ_EMPTY(&pctrlr.ctrlr.adminq->free_req));
+
+	/* Completion error */
+	memset(req, 0, sizeof(struct nvme_request) * 2);
+	memset(&pqpair, 0, sizeof(pqpair));
+	pqpair.cpl = &cpl;
+	pqpair.qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair.qpair.id = 1;
+	pqpair.num_entries = 1;
+	pqpair.cpl_bus_addr = 0xDEADBEEF;
+	pqpair.cmd_bus_addr = 0xDDADBEEF;
+	pqpair.qpair.qprio = SPDK_NVME_QPRIO_HIGH;
+	pqpair.stat = NULL;
+	pqpair.qpair.poll_group = &poll_group;
+	for (int i = 0; i < 2; i++) {
+		STAILQ_INSERT_HEAD(&pctrlr.ctrlr.adminq->free_req, &req[i], stailq);
+	}
+	MOCK_SET(nvme_wait_for_completion, -EIO);
+
+	rc = nvme_pcie_ctrlr_connect_qpair(&pctrlr.ctrlr, &pqpair.qpair);
+	CU_ASSERT(rc == -1);
+	/* Remove unused request */
+	STAILQ_REMOVE_HEAD(&pctrlr.ctrlr.adminq->free_req, stailq);
+	CU_ASSERT(STAILQ_EMPTY(&pctrlr.ctrlr.adminq->free_req));
+	MOCK_CLEAR(nvme_wait_for_completion);
+
+	/* No available request used */
+	memset(req, 0, sizeof(struct nvme_request) * 2);
+	memset(&pqpair, 0, sizeof(pqpair));
+	pqpair.cpl = &cpl;
+	pqpair.qpair.ctrlr = &pctrlr.ctrlr;
+	pqpair.qpair.id = 1;
+	pqpair.num_entries = 1;
+	pqpair.cpl_bus_addr = 0xDEADBEEF;
+	pqpair.cmd_bus_addr = 0xDDADBEEF;
+	pqpair.qpair.qprio = SPDK_NVME_QPRIO_HIGH;
+	pqpair.stat = NULL;
+	pqpair.qpair.poll_group = &poll_group;
+
+	rc = nvme_pcie_ctrlr_connect_qpair(&pctrlr.ctrlr, &pqpair.qpair);
+	CU_ASSERT(rc == -ENOMEM);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -299,6 +439,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_alloc_cmb);
 	CU_ADD_TEST(suite, test_nvme_pcie_qpair_construct_destroy);
 	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_cmd_create_delete_io_queue);
+	CU_ADD_TEST(suite, test_nvme_pcie_ctrlr_connect_qpair);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 109106d8887b34dcaf4db4b0546d81260ccc4baf Mon Sep 17 00:00:00 2001
From: Mao Jiang <maox.jiang@intel.com>
Date: Wed, 2 Jun 2021 15:15:17 +0800
Subject: [PATCH 335/342] test/nvme_ctrlr: cases for setting supported log
 pages

Change-Id: Id92a2de7899696abd428fe5e7ac56abc683117cb
Signed-off-by: Mao Jiang <maox.jiang@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8155
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 .../lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c     | 53 +++++++++++++++++++
 1 file changed, 53 insertions(+)

diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index 9fb0bf8ba..41a2b92ca 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -3004,6 +3004,58 @@ test_nvme_ctrlr_identify_namespaces_iocs_specific_next(void)
 	CU_ASSERT(ctrlr.state_timeout_tsc == NVME_TIMEOUT_INFINITE);
 }
 
+static void
+test_nvme_ctrlr_set_supported_log_pages(void)
+{
+	int rc;
+	struct spdk_nvme_ctrlr ctrlr = {};
+	struct spdk_nvme_intel_log_page_directory *log_page_directory = NULL;
+
+	/* Intel device */
+	ctrlr.cdata.lpa.celp = true;
+	ctrlr.cdata.vid = SPDK_PCI_VID_INTEL;
+	ctrlr.quirks |= NVME_INTEL_QUIRK_READ_LATENCY;
+	ctrlr.quirks |= NVME_INTEL_QUIRK_WRITE_LATENCY;
+	log_page_directory = spdk_zmalloc(sizeof(struct spdk_nvme_intel_log_page_directory),
+					  64, NULL, SPDK_ENV_SOCKET_ID_ANY, SPDK_MALLOC_DMA);
+	SPDK_CU_ASSERT_FATAL(log_page_directory != NULL);
+
+	log_page_directory->temperature_statistics_log_len = 1;
+	log_page_directory->smart_log_len = 1;
+	log_page_directory->marketing_description_log_len = 1;
+	MOCK_SET(spdk_zmalloc, log_page_directory);
+
+	rc = nvme_ctrlr_set_supported_log_pages(&ctrlr);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_ERROR] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_HEALTH_INFORMATION] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_FIRMWARE_SLOT] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_COMMAND_EFFECTS_LOG] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_INTEL_LOG_READ_CMD_LATENCY] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_INTEL_LOG_WRITE_CMD_LATENCY] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_INTEL_LOG_TEMPERATURE] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_INTEL_LOG_SMART] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_INTEL_MARKETING_DESCRIPTION] == true);
+	MOCK_CLEAR(spdk_zmalloc);
+
+	/* ana supported */
+	memset(&ctrlr, 0, sizeof(ctrlr));
+	ctrlr.cdata.cmic.ana_reporting = true;
+	ctrlr.cdata.lpa.celp = 1;
+	ctrlr.cdata.nanagrpid = 1;
+	ctrlr.cdata.nn = 1;
+
+	rc = nvme_ctrlr_set_supported_log_pages(&ctrlr);
+	CU_ASSERT(rc == 0);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_ERROR] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_HEALTH_INFORMATION] == true);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_FIRMWARE_SLOT] == true);
+	CU_ASSERT(ctrlr.ana_log_page_size == sizeof(struct spdk_nvme_ana_page) +
+		  sizeof(struct spdk_nvme_ana_group_descriptor) * 1 + sizeof(uint32_t) * 1);
+	CU_ASSERT(ctrlr.log_page_supported[SPDK_NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS] == true);
+	spdk_free(ctrlr.ana_log_page);
+}
+
 int main(int argc, char **argv)
 {
 	CU_pSuite	suite = NULL;
@@ -3055,6 +3107,7 @@ int main(int argc, char **argv)
 	CU_ADD_TEST(suite, test_nvme_ctrlr_aer_callback);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_ns_attr_changed);
 	CU_ADD_TEST(suite, test_nvme_ctrlr_identify_namespaces_iocs_specific_next);
+	CU_ADD_TEST(suite, test_nvme_ctrlr_set_supported_log_pages);
 
 	CU_basic_set_mode(CU_BRM_VERBOSE);
 	CU_basic_run_tests();
-- 
2.26.2


From 3a0f62449989930af876c72cf4d25613ddca3c0b Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Wed, 10 Feb 2021 00:04:19 +0000
Subject: [PATCH 336/342] nvmf: add USDT probes for subsystem state changes

Also add scripts/bpf/nvmf.bt to enable and log these
probes.

This patch also adds a script that can generate
a bpftrace script snippet with string maps for
needed enumerations (currently nvmf_tgt_state and
spdk_nvmf_subsystem_state).  This allows us to
dynamically generate this from the source code, and
can be extended for other enums we may want to
add in the future.

Thanks to Michal Berger for converting my original
gen_enums.py script into gen_enums.sh!

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Signed-off-by: Michal Berger <michalx.berger@intel.com>
Change-Id: Iff34a6218aef40055ac14932eea5fc00e1c8bcf5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7194
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
---
 lib/nvmf/subsystem.c                    | 14 +++++++
 module/event/subsystems/nvmf/nvmf_tgt.c |  2 +
 scripts/bpf/gen_enums.sh                | 52 +++++++++++++++++++++++++
 scripts/bpf/nvmf.bt                     | 29 ++++++++++++++
 scripts/bpftrace.sh                     |  8 +++-
 5 files changed, 104 insertions(+), 1 deletion(-)
 create mode 100755 scripts/bpf/gen_enums.sh
 create mode 100644 scripts/bpf/nvmf.bt

diff --git a/lib/nvmf/subsystem.c b/lib/nvmf/subsystem.c
index 6f3b1f483..0034c7614 100644
--- a/lib/nvmf/subsystem.c
+++ b/lib/nvmf/subsystem.c
@@ -48,6 +48,7 @@
 #include "spdk/bdev_module.h"
 #include "spdk/log.h"
 #include "spdk_internal/utf.h"
+#include "spdk_internal/usdt.h"
 
 #define MODEL_NUMBER_DEFAULT "SPDK bdev Controller"
 #define NVMF_SUBSYSTEM_DEFAULT_NAMESPACES 32
@@ -508,6 +509,9 @@ subsystem_state_change_done(struct spdk_io_channel_iter *i, int status)
 	struct subsystem_state_change_ctx *ctx = spdk_io_channel_iter_get_ctx(i);
 	enum spdk_nvmf_subsystem_state intermediate_state;
 
+	SPDK_DTRACE_PROBE4(nvmf_subsystem_change_state_done, ctx->subsystem->subnqn,
+			   ctx->requested_state, ctx->original_state, status);
+
 	if (status == 0) {
 		status = nvmf_subsystem_set_state(ctx->subsystem, ctx->requested_state);
 		if (status) {
@@ -543,6 +547,12 @@ static void
 subsystem_state_change_continue(void *ctx, int status)
 {
 	struct spdk_io_channel_iter *i = ctx;
+	struct subsystem_state_change_ctx *_ctx __attribute__((unused));
+
+	_ctx = spdk_io_channel_iter_get_ctx(i);
+	SPDK_DTRACE_PROBE3(nvmf_pg_change_state_done, _ctx->subsystem->subnqn,
+			   _ctx->requested_state, spdk_thread_get_id(spdk_get_thread()));
+
 	spdk_for_each_channel_continue(i, status);
 }
 
@@ -557,6 +567,8 @@ subsystem_state_change_on_pg(struct spdk_io_channel_iter *i)
 	ch = spdk_io_channel_iter_get_channel(i);
 	group = spdk_io_channel_get_ctx(ch);
 
+	SPDK_DTRACE_PROBE3(nvmf_pg_change_state, ctx->subsystem->subnqn,
+			   ctx->requested_state, spdk_thread_get_id(spdk_get_thread()));
 	switch (ctx->requested_state) {
 	case SPDK_NVMF_SUBSYSTEM_INACTIVE:
 		nvmf_poll_group_remove_subsystem(group, ctx->subsystem, subsystem_state_change_continue, i);
@@ -593,6 +605,8 @@ nvmf_subsystem_state_change(struct spdk_nvmf_subsystem *subsystem,
 		return -EBUSY;
 	}
 
+	SPDK_DTRACE_PROBE3(nvmf_subsystem_change_state, subsystem->subnqn,
+			   requested_state, subsystem->state);
 	/* If we are already in the requested state, just call the callback immediately. */
 	if (subsystem->state == requested_state) {
 		subsystem->changing_state = false;
diff --git a/module/event/subsystems/nvmf/nvmf_tgt.c b/module/event/subsystems/nvmf/nvmf_tgt.c
index 4df1f3060..00797386a 100644
--- a/module/event/subsystems/nvmf/nvmf_tgt.c
+++ b/module/event/subsystems/nvmf/nvmf_tgt.c
@@ -38,6 +38,7 @@
 #include "spdk/log.h"
 #include "spdk/nvme.h"
 #include "spdk/nvmf_cmd.h"
+#include "spdk_internal/usdt.h"
 
 enum nvmf_tgt_state {
 	NVMF_TGT_INIT_NONE = 0,
@@ -378,6 +379,7 @@ nvmf_tgt_advance_state(void)
 	int ret;
 
 	do {
+		SPDK_DTRACE_PROBE1(nvmf_tgt_state, g_tgt_state);
 		prev_state = g_tgt_state;
 
 		switch (g_tgt_state) {
diff --git a/scripts/bpf/gen_enums.sh b/scripts/bpf/gen_enums.sh
new file mode 100755
index 000000000..33fdaf5e7
--- /dev/null
+++ b/scripts/bpf/gen_enums.sh
@@ -0,0 +1,52 @@
+#!/usr/bin/env bash
+set -e
+
+rootdir=$(git rev-parse --show-toplevel)
+
+_print_enums() {
+	local enum_type=$1 enum_string=$2 enum_prefix=$3 enum output
+
+	output=$(< "$rootdir/$(git -C "$rootdir" grep -l "$enum_string" -- lib module)")
+
+	# Isolate the enum block
+	output=${output#*$enum_string$'\n'} output=${output%%$'\n'\};*}
+	# Fold it onto an array
+	IFS="," read -ra output <<< "${output//[[:space:]]/}"
+	# Drop the assignments
+	output=("${output[@]/=*/}")
+
+	for enum in "${!output[@]}"; do
+		if [[ ${output[enum]} != "$enum_prefix"* ]]; then
+			printf 'enum name %s does not start with expected prefix %s\n' "${output[enum]}" "$enum_prefix"
+			return 1
+		fi >&2
+		printf '  @%s[%d] = "%s";\n' "$enum_type" "$enum" "${output[enum]#$enum_prefix}"
+	done
+}
+
+print_enums() {
+	for state in "${!state_enums[@]}"; do
+		_print_enums "$state" "${state_enums["$state"]}" "${state_prefix["$state"]}"
+	done
+}
+
+print_clear() { printf '  clear(@%s);\n' "${!state_enums[@]}"; }
+
+declare -A state_enums=() state_prefix=()
+
+state_enums["target"]="enum nvmf_tgt_state {"
+state_enums["subsystem"]="enum spdk_nvmf_subsystem_state {"
+state_prefix["target"]=NVMF_TGT_
+state_prefix["subsystem"]=SPDK_NVMF_SUBSYSTEM_
+
+enums=$(print_enums)
+clear=$(print_clear)
+
+cat <<- ENUM
+	BEGIN {
+		$enums
+	}
+	END {
+		$clear
+	}
+ENUM
diff --git a/scripts/bpf/nvmf.bt b/scripts/bpf/nvmf.bt
new file mode 100644
index 000000000..b9322f07e
--- /dev/null
+++ b/scripts/bpf/nvmf.bt
@@ -0,0 +1,29 @@
+usdt:__EXE__:nvmf_tgt_state {
+	printf("%d.%06d: nvmf_tgt reached state %s\n",
+	       elapsed / (uint64)(1000 * 1000), elapsed % (uint64)(1000 * 1000),
+	       @target[arg0]);
+}
+
+usdt:__EXE__:nvmf_subsystem_change_state {
+	printf("%d.%06d: %s change state from %s to %s start\n",
+	       elapsed / (uint64)(1000 * 1000), elapsed % (uint64)(1000 * 1000),
+	       str(arg0), @subsystem[arg2], @subsystem[arg1]);
+}
+
+usdt:__EXE__:nvmf_subsystem_change_state_done {
+	printf("%d.%06d: %s change state from %s to %s %s\n",
+	       elapsed / (uint64)(1000 * 1000), elapsed % (uint64)(1000 * 1000),
+	       str(arg0), @subsystem[arg2], @subsystem[arg1], arg3 ? "failed" : "done");
+}
+
+usdt:__EXE__:nvmf_pg_change_state {
+	printf("%d.%06d: %s on thread %d state to %s start\n",
+	       elapsed / (uint64)(1000 * 1000), elapsed % (uint64)(1000 * 1000),
+	       str(arg0), arg2, @subsystem[arg1]);
+}
+
+usdt:__EXE__:nvmf_pg_change_state_done {
+	printf("%d.%06d: %s on thread %d state to %s done\n",
+	       elapsed / (uint64)(1000 * 1000), elapsed % (uint64)(1000 * 1000),
+	       str(arg0), arg2, @subsystem[arg1]);
+}
diff --git a/scripts/bpftrace.sh b/scripts/bpftrace.sh
index d35714b15..6a2afbb85 100755
--- a/scripts/bpftrace.sh
+++ b/scripts/bpftrace.sh
@@ -1,9 +1,15 @@
 #!/usr/bin/env bash
+set -e
+
 if [ $# -lt 2 ]; then
 	echo "usage: $0 <pid> <script>"
 	exit 1
 fi
 SCRIPTS_DIR=$(readlink -f $(dirname $0))
 BIN_PATH=$(readlink -f /proc/$1/exe)
-BPF_SCRIPT=$(sed "s#__EXE__#${BIN_PATH}#g" "${@:2}" | sed "s#__PID__#${1}#g")
+BPF_SCRIPT=$($SCRIPTS_DIR/bpf/gen_enums.sh)
+BPF_SCRIPT+=$(sed "s#__EXE__#${BIN_PATH}#g" "${@:2}" | sed "s#__PID__#${1}#g")
+if [ -n "$ECHO_SCRIPT" ]; then
+	echo "$BPF_SCRIPT"
+fi
 bpftrace -p $1 -e "$BPF_SCRIPT"
-- 
2.26.2


From e0c9c640c69926cea25c82321459e947adf53ff6 Mon Sep 17 00:00:00 2001
From: Jim Harris <james.r.harris@intel.com>
Date: Thu, 1 Apr 2021 00:52:42 +0000
Subject: [PATCH 337/342] doc: add a page for USDT

Signed-off-by: Jim Harris <james.r.harris@intel.com>
Change-Id: I5aa5ec3c3fc695a2555a34ac4e119e256da464a5
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7195
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Konrad Sztyber <konrad.sztyber@intel.com>
Reviewed-by: Paul Luse <paul.e.luse@intel.com>
---
 doc/Doxyfile       |   1 +
 doc/usdt.md        | 204 +++++++++++++++++++++++++++++++++++++++++++++
 doc/user_guides.md |   1 +
 3 files changed, 206 insertions(+)
 create mode 100644 doc/usdt.md

diff --git a/doc/Doxyfile b/doc/Doxyfile
index 7ecc216aa..c32c98622 100644
--- a/doc/Doxyfile
+++ b/doc/Doxyfile
@@ -843,6 +843,7 @@ INPUT                  += \
                          spdk_top.md \
                          ssd_internals.md \
                          system_configuration.md \
+                         usdt.md \
                          userspace.md \
                          vagrant.md \
                          vhost.md \
diff --git a/doc/usdt.md b/doc/usdt.md
new file mode 100644
index 000000000..08c258076
--- /dev/null
+++ b/doc/usdt.md
@@ -0,0 +1,204 @@
+# Userspace DTrace (USDT) {#usdt}
+
+## Package Dependencies
+
+These dependencies are needed for building bpftrace and
+the sys/sdt.h header file that SPDK libraries will include
+for DTRACE_PROBE macro definitions.
+
+Fedora:
+libbpf
+gtest-devel
+gmock-devel
+bcc-devel
+systemtap-sdt-devel
+llvm-devel
+bison
+flex
+
+Ubuntu:
+systemtap-sdt-dev
+libbpfcc-dev
+libclang-7-dev
+bison
+flex
+
+## Building bpftrace
+
+We have found issues with the packaged bpftrace on both Ubuntu 20.04
+and Fedora 33.  So bpftrace should be built and installed from source.
+
+```
+git clone https://github.com/iovisor/bpftrace.git
+mkdir bpftrace/build
+cd bpftrace/build
+cmake -DCMAKE_BUILD_TYPE=Release ..
+make
+sudo make install
+```
+
+## bpftrace.sh
+
+bpftrace.sh is a helper script that facilitates running bpftrace scripts
+against a running SPDK application.  Here is a typical usage:
+
+```
+scripts/bpftrace.sh `pidof spdk_tgt` scripts/bpf/nvmf.bt
+```
+
+Attaching to USDT probes requires the full path of the binary in the
+probe description. SPDK bpftrace scripts can be written with an __EXE__
+marker instead of a full path name, and bpftrace.sh will dynamically
+replace that string with the full path name using information from procfs.
+
+It is also useful to filter certain kernel events (such as system calls)
+based on the PID of the SPDK application.  SPDK bpftrace scripts can be
+written with a __PID__ marker, and bpftrace.sh will dynamically replace
+that string with the PID provided to the script.
+
+## Configuring SPDK Build
+
+```
+./configure --with-usdt
+```
+
+## Start SPDK application and bpftrace script
+
+From first terminal:
+
+```
+build/bin/spdk_tgt -m 0xC
+```
+
+From second terminal:
+
+```
+scripts/bpftrace.sh `pidof spdk_tgt` scripts/bpf/nvmf.bt
+```
+
+nvmf.bt will print information about nvmf subsystem and poll
+group info state transitions.
+
+From third terminal:
+
+```
+scripts/rpc.py <<EOF
+nvmf_create_transport -t tcp
+nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s SPDK00000000000001 -m 10
+nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t tcp -a 127.0.0.1 -s 4420
+bdev_null_create null0 1000 512
+nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 null0
+EOF
+```
+
+This creates the nvmf tcp transport, a new nvmf subsystem that listens on a tcp
+port, and a null bdev which is added as a namespace to the new nvmf subsystem.
+
+You will see output from the second terminal that looks like this:
+
+```
+2110.935735: nvmf_tgt reached state NONE
+2110.954316: nvmf_tgt reached state CREATE_TARGET
+2110.967905: nvmf_tgt reached state CREATE_POLL_GROUPS
+2111.235982: nvmf_tgt reached state START_SUBSYSTEMS
+2111.253560: nqn.2014-08.org.nvmexpress.discovery change state from INACTIVE to ACTIVE start
+2111.260278: nqn.2014-08.org.nvmexpress.discovery on thread 2 state to ACTIVE start
+2111.264281: nqn.2014-08.org.nvmexpress.discovery on thread 2 state to ACTIVE done
+2111.284083: nqn.2014-08.org.nvmexpress.discovery change state from INACTIVE to ACTIVE done
+2111.289197: nvmf_tgt reached state RUNNING
+2111.271573: nqn.2014-08.org.nvmexpress.discovery on thread 3 state to ACTIVE start
+2111.279787: nqn.2014-08.org.nvmexpress.discovery on thread 3 state to ACTIVE done
+2189.921492: nqn.2016-06.io.spdk:cnode1 change state from INACTIVE to ACTIVE start
+2189.952508: nqn.2016-06.io.spdk:cnode1 on thread 2 state to ACTIVE start
+2189.959125: nqn.2016-06.io.spdk:cnode1 on thread 2 state to ACTIVE done
+2190.005832: nqn.2016-06.io.spdk:cnode1 change state from INACTIVE to ACTIVE done
+2189.969058: nqn.2016-06.io.spdk:cnode1 on thread 3 state to ACTIVE start
+2189.999889: nqn.2016-06.io.spdk:cnode1 on thread 3 state to ACTIVE done
+2197.859104: nqn.2016-06.io.spdk:cnode1 change state from ACTIVE to PAUSED start
+2197.879199: nqn.2016-06.io.spdk:cnode1 on thread 2 state to PAUSED start
+2197.883416: nqn.2016-06.io.spdk:cnode1 on thread 2 state to PAUSED done
+2197.902291: nqn.2016-06.io.spdk:cnode1 change state from ACTIVE to PAUSED done
+2197.908939: nqn.2016-06.io.spdk:cnode1 change state from PAUSED to ACTIVE start
+2197.912644: nqn.2016-06.io.spdk:cnode1 on thread 2 state to ACTIVE start
+2197.927409: nqn.2016-06.io.spdk:cnode1 on thread 2 state to ACTIVE done
+2197.949742: nqn.2016-06.io.spdk:cnode1 change state from PAUSED to ACTIVE done
+2197.890812: nqn.2016-06.io.spdk:cnode1 on thread 3 state to PAUSED start
+2197.897233: nqn.2016-06.io.spdk:cnode1 on thread 3 state to PAUSED done
+2197.931278: nqn.2016-06.io.spdk:cnode1 on thread 3 state to ACTIVE start
+2197.946124: nqn.2016-06.io.spdk:cnode1 on thread 3 state to ACTIVE done
+2205.859904: nqn.2016-06.io.spdk:cnode1 change state from ACTIVE to PAUSED start
+2205.891392: nqn.2016-06.io.spdk:cnode1 on thread 2 state to PAUSED start
+2205.896588: nqn.2016-06.io.spdk:cnode1 on thread 2 state to PAUSED done
+2205.920133: nqn.2016-06.io.spdk:cnode1 change state from ACTIVE to PAUSED done
+2205.905900: nqn.2016-06.io.spdk:cnode1 on thread 3 state to PAUSED start
+2205.914856: nqn.2016-06.io.spdk:cnode1 on thread 3 state to PAUSED done
+2206.091084: nqn.2016-06.io.spdk:cnode1 change state from PAUSED to ACTIVE start
+2206.099222: nqn.2016-06.io.spdk:cnode1 on thread 2 state to ACTIVE start
+2206.105445: nqn.2016-06.io.spdk:cnode1 on thread 2 state to ACTIVE done
+2206.119271: nqn.2016-06.io.spdk:cnode1 change state from PAUSED to ACTIVE done
+2206.109144: nqn.2016-06.io.spdk:cnode1 on thread 3 state to ACTIVE start
+2206.115636: nqn.2016-06.io.spdk:cnode1 on thread 3 state to ACTIVE done
+```
+
+Now stop the bpftrace.sh running in the second terminal, and start
+it again with the send_msg.bt script.  This script keeps a count of
+functions executed as part of an spdk_for_each_channel or
+spdk_thread_send_msg function call.
+
+```
+scripts/bpftrace.sh `pidof spdk_tgt` scripts/bpf/send_msg.bt
+```
+
+From the third terminal, create another null bdev and add it as a
+namespace to the cnode1 subsystem.
+
+```
+scripts/rpc.py <<EOF
+bdev_null_create null1 1000 512
+nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 null1
+EOF
+```
+
+Now Ctrl-C the bpftrace.sh in the second terminal, and it will
+print the final results of the maps.
+
+```
+@for_each_channel[subsystem_state_change_on_pg]: 2
+
+@send_msg[_finish_unregister]: 1
+@send_msg[_call_completion]: 2
+@send_msg[put_io_channel]: 4
+@send_msg[_call_channel]: 4
+```
+
+## TODOs and known limitations
+
+- add definitions for common nvmf data structures - then we can pass the subsystem pointer
+  itself as a probe parameter and let the script decide which fields it wants to access
+  (Note: these would need to be kept up-to-date with the C definitions of the struct - it is
+  not possible to include the header files in a bpftrace script)
+
+- investigate using pahole to generate data structure definitions that can be included in
+  bpftrace scripts; this would allow us to pass the subsystem pointer itself as a probe
+  argument, and let the script decide which fields it wants to access; for example,
+  `pahole -E -C spdk_nvmf_subsystem build/bin/spdk_tgt` gets us close to what we need,
+  but there are some limiters:
+
+	- our structures have char arrays (not char pointers) for things like subnqn; large
+	  arrays like these cannot currently be passed to bpftrace printf without generating
+	  a stack space error (probe points are limited to 512 bytes of stack); we could
+	  modify SPDK to have the char array for storage, and a char pointer that points to
+	  that storage, the latter could easily then be used in bpftrace scripts
+	- our structures include fields with their enum types instead of int; bpftrace will
+	  complain it does not know about the enum (pahole doesn't print out enum
+	  descriptions); information on enums can be found in the applications .debug_info
+	  section, but we would need something that can convert that into a file we can
+	  include in a bpftrace script
+
+- Note that bpftrace prints are not always printed in exact chronological order; this can
+  be seen especially with spdk_for_each_channel iterations, where we execute trace points
+  on multiple threads in a very short period of time, and those may not get printed to the
+  console in exact order; this is why the nvmf.bt script prints out a msec.nsec timestamp
+  so that the user can understand the ordering and even pipe through sort if desired
+
+- flesh out more DTrace probes in the nvmf code
diff --git a/doc/user_guides.md b/doc/user_guides.md
index adf4465e6..741f7ba10 100644
--- a/doc/user_guides.md
+++ b/doc/user_guides.md
@@ -11,3 +11,4 @@
 - @subpage blobfs
 - @subpage jsonrpc
 - @subpage jsonrpc_proxy
+- @subpage usdt
-- 
2.26.2


From d63fbc8a8edbfe6dde99131f62da4697a8212438 Mon Sep 17 00:00:00 2001
From: Yuri <yuriy.kirichok@hpe.com>
Date: Fri, 21 May 2021 17:09:00 +0000
Subject: [PATCH 338/342] nvmf: allow poll groups to run on a subset of cores

In order to avoid latency imbalances, the user can specify a cpu mask
on which the poll groups should run. This code update added data structures
to control set of CPU cores.

Change-Id: Iaf69d75da2fc6fed350d97d11027ce09e9432210
Signed-off-by: Yuri <yuriy.kirichok@hpe.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/5610
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
Reviewed-by: Michael Haeuptle <michaelhaeuptle@gmail.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 mk/spdk.lib_deps.mk                       |  2 +-
 module/event/subsystems/nvmf/event_nvmf.h |  2 ++
 module/event/subsystems/nvmf/nvmf_tgt.c   | 20 +++++++++++++++++---
 3 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/mk/spdk.lib_deps.mk b/mk/spdk.lib_deps.mk
index bc812ac7f..225144ba5 100644
--- a/mk/spdk.lib_deps.mk
+++ b/mk/spdk.lib_deps.mk
@@ -167,7 +167,7 @@ DEPDIRS-event_vmd := init vmd $(JSON_LIBS) log thread
 DEPDIRS-event_bdev := init bdev event_accel event_vmd event_sock
 
 DEPDIRS-event_nbd := init nbd event_bdev
-DEPDIRS-event_nvmf := init nvmf event_bdev event_sock thread log bdev $(JSON_LIBS)
+DEPDIRS-event_nvmf := init nvmf event_bdev event_sock thread log bdev util $(JSON_LIBS)
 DEPDIRS-event_scsi := init scsi event_bdev
 
 DEPDIRS-event_iscsi := init iscsi event_scsi event_sock
diff --git a/module/event/subsystems/nvmf/event_nvmf.h b/module/event/subsystems/nvmf/event_nvmf.h
index 72b52d2ec..9c796f9bb 100644
--- a/module/event/subsystems/nvmf/event_nvmf.h
+++ b/module/event/subsystems/nvmf/event_nvmf.h
@@ -61,4 +61,6 @@ extern uint16_t g_spdk_nvmf_tgt_crdt[3];
 
 extern struct spdk_nvmf_tgt *g_spdk_nvmf_tgt;
 
+extern struct spdk_cpuset *g_poll_groups_mask;
+
 #endif
diff --git a/module/event/subsystems/nvmf/nvmf_tgt.c b/module/event/subsystems/nvmf/nvmf_tgt.c
index 00797386a..65b40b8d6 100644
--- a/module/event/subsystems/nvmf/nvmf_tgt.c
+++ b/module/event/subsystems/nvmf/nvmf_tgt.c
@@ -64,6 +64,7 @@ struct spdk_nvmf_tgt_conf g_spdk_nvmf_tgt_conf = {
 	.admin_passthru.identify_ctrlr = false
 };
 
+struct spdk_cpuset *g_poll_groups_mask = NULL;
 struct spdk_nvmf_tgt *g_spdk_nvmf_tgt = NULL;
 uint32_t g_spdk_nvmf_tgt_max_subsystems = 0;
 uint16_t g_spdk_nvmf_tgt_crdt[3] = {0, 0, 0};
@@ -150,6 +151,16 @@ nvmf_tgt_destroy_poll_groups(void)
 	}
 }
 
+static uint32_t
+nvmf_get_cpuset_count(void)
+{
+	if (g_poll_groups_mask) {
+		return spdk_cpuset_count(g_poll_groups_mask);
+	} else {
+		return spdk_env_get_core_count();
+	}
+}
+
 static void
 nvmf_tgt_create_poll_group_done(void *ctx)
 {
@@ -157,9 +168,9 @@ nvmf_tgt_create_poll_group_done(void *ctx)
 
 	TAILQ_INSERT_TAIL(&g_poll_groups, pg, link);
 
-	assert(g_num_poll_groups < spdk_env_get_core_count());
+	assert(g_num_poll_groups < nvmf_get_cpuset_count());
 
-	if (++g_num_poll_groups == spdk_env_get_core_count()) {
+	if (++g_num_poll_groups == nvmf_get_cpuset_count()) {
 		g_tgt_state = NVMF_TGT_INIT_START_SUBSYSTEMS;
 		nvmf_tgt_advance_state();
 	}
@@ -195,9 +206,12 @@ nvmf_tgt_create_poll_groups(void)
 	assert(g_tgt_init_thread != NULL);
 
 	SPDK_ENV_FOREACH_CORE(i) {
+		if (g_poll_groups_mask && !spdk_cpuset_get_cpu(g_poll_groups_mask, i)) {
+			continue;
+		}
 		snprintf(thread_name, sizeof(thread_name), "nvmf_tgt_poll_group_%u", i);
 
-		thread = spdk_thread_create(thread_name, NULL);
+		thread = spdk_thread_create(thread_name, g_poll_groups_mask);
 		assert(thread != NULL);
 
 		spdk_thread_send_msg(thread, nvmf_tgt_create_poll_group, NULL);
-- 
2.26.2


From 4f4f505c77ace180f7be6ebd9fc2e6cc19f206f3 Mon Sep 17 00:00:00 2001
From: tyler_sun <tyler_sun@dell.com>
Date: Sat, 24 Apr 2021 15:58:44 +0800
Subject: [PATCH 339/342] nvme: get changed ns log once AER notice of ns
 changed received.

Each time the following file
"/sys/kernel/config/nvmet/subsystems/nqn_name/namespaces/ns_id/enable"
on the target side was changed, the SPDK initiator should receive an
async event (type: SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE, info:
SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED).
But actually not.
Since for SPDK, when target sent the non-first event, the condition
"nvmet_aen_bit_disabled(ctrl, NVME_AEN_BIT_NS_ATTR)" that prevents
target from sending event was matched.
This commit fix this issue by issuing a get_log_page cmd for each async
event received, just as the kernel initiator does.

Fixes #1825.

Signed-off-by: tyler.sun <tyler.sun@dell.com>
Change-Id: I2973470a81893456ca12e86ac390ea1de0eed62c
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/7107
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
---
 include/spdk/nvme_spec.h |  5 +++
 lib/nvme/nvme_ctrlr.c    | 86 +++++++++++++++++++++++++++++++++++++---
 2 files changed, 85 insertions(+), 6 deletions(-)

diff --git a/include/spdk/nvme_spec.h b/include/spdk/nvme_spec.h
index db122a66a..d44755819 100644
--- a/include/spdk/nvme_spec.h
+++ b/include/spdk/nvme_spec.h
@@ -72,6 +72,11 @@ extern "C" {
  */
 #define SPDK_NVME_DATASET_MANAGEMENT_RANGE_MAX_BLOCKS	0xFFFFFFFFu
 
+/**
+ * Maximum number of entries in the log page of Changed Namespace List.
+ */
+#define SPDK_NVME_MAX_CHANGED_NAMESPACES 1024
+
 union spdk_nvme_cap_register {
 	uint64_t	raw;
 	struct {
diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index 28cafdff8..5588ca41f 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -38,6 +38,7 @@
 
 #include "spdk/env.h"
 #include "spdk/string.h"
+#include "spdk/endian.h"
 
 struct nvme_active_ns_ctx;
 
@@ -2614,24 +2615,81 @@ fail:
 	return rc;
 }
 
+static int
+nvme_ctrlr_clear_changed_ns_log(struct spdk_nvme_ctrlr *ctrlr)
+{
+	struct nvme_completion_poll_status	*status;
+	int		rc = -ENOMEM;
+	char		*buffer = NULL;
+	uint32_t	nsid;
+	size_t		buf_size = (SPDK_NVME_MAX_CHANGED_NAMESPACES * sizeof(uint32_t));
+
+	buffer = spdk_dma_zmalloc(buf_size, 4096, NULL);
+	if (!buffer) {
+		NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate buffer for getting "
+				  "changed ns log.\n");
+		return rc;
+	}
+
+	status = calloc(1, sizeof(*status));
+	if (!status) {
+		NVME_CTRLR_ERRLOG(ctrlr, "Failed to allocate status tracker\n");
+		goto free_buffer;
+	}
+
+	rc = spdk_nvme_ctrlr_cmd_get_log_page(ctrlr,
+					      SPDK_NVME_LOG_CHANGED_NS_LIST,
+					      SPDK_NVME_GLOBAL_NS_TAG,
+					      buffer, buf_size, 0,
+					      nvme_completion_poll_cb, status);
+
+	if (rc) {
+		NVME_CTRLR_ERRLOG(ctrlr, "spdk_nvme_ctrlr_cmd_get_log_page() failed: rc=%d\n", rc);
+		free(status);
+		goto free_buffer;
+	}
+
+	rc = nvme_wait_for_completion_timeout(ctrlr->adminq, status,
+					      ctrlr->opts.admin_timeout_ms * 1000);
+	if (!status->timed_out) {
+		free(status);
+	}
+
+	if (rc) {
+		NVME_CTRLR_ERRLOG(ctrlr, "wait for spdk_nvme_ctrlr_cmd_get_log_page failed: rc=%d\n", rc);
+		goto free_buffer;
+	}
+
+	/* only check the case of overflow. */
+	nsid = from_le32(buffer);
+	if (nsid == 0xffffffffu) {
+		NVME_CTRLR_WARNLOG(ctrlr, "changed ns log overflowed.\n");
+	}
+
+free_buffer:
+	spdk_dma_free(buffer);
+	return rc;
+}
+
 void
 nvme_ctrlr_process_async_event(struct spdk_nvme_ctrlr *ctrlr,
 			       const struct spdk_nvme_cpl *cpl)
 {
 	union spdk_nvme_async_event_completion event;
 	struct spdk_nvme_ctrlr_process *active_proc;
+	bool				ns_changed = false;
 	int rc;
 
 	event.raw = cpl->cdw0;
 
 	if ((event.bits.async_event_type == SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE) &&
 	    (event.bits.async_event_info == SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED)) {
-		rc = nvme_ctrlr_identify_active_ns(ctrlr);
-		if (rc) {
-			return;
-		}
-		nvme_ctrlr_update_namespaces(ctrlr);
-		nvme_io_msg_ctrlr_update(ctrlr);
+		/*
+		 * apps (e.g., test/nvme/aer/aer.c) may also get changed ns log (through
+		 * active_proc->aer_cb_fn). To avoid impaction, move our operations
+		 * behind call of active_proc->aer_cb_fn.
+		 */
+		ns_changed = true;
 	}
 
 	if ((event.bits.async_event_type == SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE) &&
@@ -2647,6 +2705,22 @@ nvme_ctrlr_process_async_event(struct spdk_nvme_ctrlr *ctrlr,
 	if (active_proc && active_proc->aer_cb_fn) {
 		active_proc->aer_cb_fn(active_proc->aer_cb_arg, cpl);
 	}
+
+	if (ns_changed) {
+		/*
+		 * Must have the changed ns log cleared by getting it.
+		 * Otherwise, the target won't send
+		 * the subsequent ns enabling/disabling events to us.
+		 */
+		nvme_ctrlr_clear_changed_ns_log(ctrlr);
+
+		rc = nvme_ctrlr_identify_active_ns(ctrlr);
+		if (rc) {
+			return;
+		}
+		nvme_ctrlr_update_namespaces(ctrlr);
+		nvme_io_msg_ctrlr_update(ctrlr);
+	}
 }
 
 static void
-- 
2.26.2


From 0e3d4ada7b7224666737033cf4f34eb03243a3d4 Mon Sep 17 00:00:00 2001
From: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Date: Thu, 27 May 2021 18:44:36 +0900
Subject: [PATCH 340/342] CHANGELOG: Red-black tree was added by using FreeBSD
 under the same BSD license

Signed-off-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>
Change-Id: I7bb15bae30dcea4c3e241506ae40d878f3479a6b
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8071
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
---
 CHANGELOG.md | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index cc4929eed..1f542624c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,8 +3,12 @@
 ## v21.07: (Upcoming Release)
 
 ### bdev
+
 Change `spdk_bdev_read_blocks_with_md` arg offset definiton from int64_t to uint64_t.
 
+Red-black tree has been used to organize the bdev names and aliases uniformly
+to provide faster lookup.
+
 ### dpdk
 
 Updated DPDK submodule to DPDK 21.02.
@@ -53,6 +57,16 @@ and if not supported then use existing READ/WRITE commands.
 
 Added iov to spdk_bdev_zcopy_start
 
+### thread
+
+Red-black tree has been used for timed pollers to provide faster insertion and deletion
+and for io_devices to provide faster lookup.
+
+### util
+
+Red-black tree macros has been added by using the macros provided by the FreeBSD operating system
+under the same BSD license.
+
 ## v21.04:
 
 ### accel
-- 
2.26.2


From b69827a3940b246580f9fa3e23bca48c6908a71b Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Thu, 3 Jun 2021 21:00:29 +0800
Subject: [PATCH 341/342] nvme/pcie: move nvme_pcie_qpair_submit_request() to
 pcie common layer

The PCIE and VFIOUSER both can use this function, the only difference
is VFIOUSER should use IOVA=VA to do the vtophys translation, so
here we will move the function to the common PCIe layer as the first
step.

Change-Id: I699edb67a00a2fa534072fc02ac2dd4a27aba8f4
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8030
Community-CI: Mellanox Build Bot
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvme/nvme_pcie.c          | 514 ----------------------------------
 lib/nvme/nvme_pcie_common.c   | 514 ++++++++++++++++++++++++++++++++++
 lib/nvme/nvme_pcie_internal.h |   1 +
 3 files changed, 515 insertions(+), 514 deletions(-)

diff --git a/lib/nvme/nvme_pcie.c b/lib/nvme/nvme_pcie.c
index b52f0e3f9..a9c854ef7 100644
--- a/lib/nvme/nvme_pcie.c
+++ b/lib/nvme/nvme_pcie.c
@@ -1067,520 +1067,6 @@ nvme_pcie_qpair_iterate_requests(struct spdk_nvme_qpair *qpair,
 	return 0;
 }
 
-static void
-nvme_pcie_fail_request_bad_vtophys(struct spdk_nvme_qpair *qpair, struct nvme_tracker *tr)
-{
-	/*
-	 * Bad vtophys translation, so abort this request and return
-	 *  immediately.
-	 */
-	nvme_pcie_qpair_manual_complete_tracker(qpair, tr, SPDK_NVME_SCT_GENERIC,
-						SPDK_NVME_SC_INVALID_FIELD,
-						1 /* do not retry */, true);
-}
-
-/*
- * Append PRP list entries to describe a virtually contiguous buffer starting at virt_addr of len bytes.
- *
- * *prp_index will be updated to account for the number of PRP entries used.
- */
-static inline int
-nvme_pcie_prp_list_append(struct nvme_tracker *tr, uint32_t *prp_index, void *virt_addr, size_t len,
-			  uint32_t page_size)
-{
-	struct spdk_nvme_cmd *cmd = &tr->req->cmd;
-	uintptr_t page_mask = page_size - 1;
-	uint64_t phys_addr;
-	uint32_t i;
-
-	SPDK_DEBUGLOG(nvme, "prp_index:%u virt_addr:%p len:%u\n",
-		      *prp_index, virt_addr, (uint32_t)len);
-
-	if (spdk_unlikely(((uintptr_t)virt_addr & 3) != 0)) {
-		SPDK_ERRLOG("virt_addr %p not dword aligned\n", virt_addr);
-		return -EFAULT;
-	}
-
-	i = *prp_index;
-	while (len) {
-		uint32_t seg_len;
-
-		/*
-		 * prp_index 0 is stored in prp1, and the rest are stored in the prp[] array,
-		 * so prp_index == count is valid.
-		 */
-		if (spdk_unlikely(i > SPDK_COUNTOF(tr->u.prp))) {
-			SPDK_ERRLOG("out of PRP entries\n");
-			return -EFAULT;
-		}
-
-		phys_addr = spdk_vtophys(virt_addr, NULL);
-		if (spdk_unlikely(phys_addr == SPDK_VTOPHYS_ERROR)) {
-			SPDK_ERRLOG("vtophys(%p) failed\n", virt_addr);
-			return -EFAULT;
-		}
-
-		if (i == 0) {
-			SPDK_DEBUGLOG(nvme, "prp1 = %p\n", (void *)phys_addr);
-			cmd->dptr.prp.prp1 = phys_addr;
-			seg_len = page_size - ((uintptr_t)virt_addr & page_mask);
-		} else {
-			if ((phys_addr & page_mask) != 0) {
-				SPDK_ERRLOG("PRP %u not page aligned (%p)\n", i, virt_addr);
-				return -EFAULT;
-			}
-
-			SPDK_DEBUGLOG(nvme, "prp[%u] = %p\n", i - 1, (void *)phys_addr);
-			tr->u.prp[i - 1] = phys_addr;
-			seg_len = page_size;
-		}
-
-		seg_len = spdk_min(seg_len, len);
-		virt_addr += seg_len;
-		len -= seg_len;
-		i++;
-	}
-
-	cmd->psdt = SPDK_NVME_PSDT_PRP;
-	if (i <= 1) {
-		cmd->dptr.prp.prp2 = 0;
-	} else if (i == 2) {
-		cmd->dptr.prp.prp2 = tr->u.prp[0];
-		SPDK_DEBUGLOG(nvme, "prp2 = %p\n", (void *)cmd->dptr.prp.prp2);
-	} else {
-		cmd->dptr.prp.prp2 = tr->prp_sgl_bus_addr;
-		SPDK_DEBUGLOG(nvme, "prp2 = %p (PRP list)\n", (void *)cmd->dptr.prp.prp2);
-	}
-
-	*prp_index = i;
-	return 0;
-}
-
-static int
-nvme_pcie_qpair_build_request_invalid(struct spdk_nvme_qpair *qpair,
-				      struct nvme_request *req, struct nvme_tracker *tr, bool dword_aligned)
-{
-	assert(0);
-	nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-	return -EINVAL;
-}
-
-/**
- * Build PRP list describing physically contiguous payload buffer.
- */
-static int
-nvme_pcie_qpair_build_contig_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
-				     struct nvme_tracker *tr, bool dword_aligned)
-{
-	uint32_t prp_index = 0;
-	int rc;
-
-	rc = nvme_pcie_prp_list_append(tr, &prp_index, req->payload.contig_or_cb_arg + req->payload_offset,
-				       req->payload_size, qpair->ctrlr->page_size);
-	if (rc) {
-		nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-	}
-
-	return rc;
-}
-
-/**
- * Build an SGL describing a physically contiguous payload buffer.
- *
- * This is more efficient than using PRP because large buffers can be
- * described this way.
- */
-static int
-nvme_pcie_qpair_build_contig_hw_sgl_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
-		struct nvme_tracker *tr, bool dword_aligned)
-{
-	void *virt_addr;
-	uint64_t phys_addr, mapping_length;
-	uint32_t length;
-	struct spdk_nvme_sgl_descriptor *sgl;
-	uint32_t nseg = 0;
-
-	assert(req->payload_size != 0);
-	assert(nvme_payload_type(&req->payload) == NVME_PAYLOAD_TYPE_CONTIG);
-
-	sgl = tr->u.sgl;
-	req->cmd.psdt = SPDK_NVME_PSDT_SGL_MPTR_CONTIG;
-	req->cmd.dptr.sgl1.unkeyed.subtype = 0;
-
-	length = req->payload_size;
-	virt_addr = req->payload.contig_or_cb_arg + req->payload_offset;
-
-	while (length > 0) {
-		if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
-			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-			return -EFAULT;
-		}
-
-		if (dword_aligned && ((uintptr_t)virt_addr & 3)) {
-			SPDK_ERRLOG("virt_addr %p not dword aligned\n", virt_addr);
-			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-			return -EFAULT;
-		}
-
-		mapping_length = length;
-		phys_addr = spdk_vtophys(virt_addr, &mapping_length);
-		if (phys_addr == SPDK_VTOPHYS_ERROR) {
-			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-			return -EFAULT;
-		}
-
-		mapping_length = spdk_min(length, mapping_length);
-
-		length -= mapping_length;
-		virt_addr += mapping_length;
-
-		sgl->unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
-		sgl->unkeyed.length = mapping_length;
-		sgl->address = phys_addr;
-		sgl->unkeyed.subtype = 0;
-
-		sgl++;
-		nseg++;
-	}
-
-	if (nseg == 1) {
-		/*
-		 * The whole transfer can be described by a single SGL descriptor.
-		 *  Use the special case described by the spec where SGL1's type is Data Block.
-		 *  This means the SGL in the tracker is not used at all, so copy the first (and only)
-		 *  SGL element into SGL1.
-		 */
-		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
-		req->cmd.dptr.sgl1.address = tr->u.sgl[0].address;
-		req->cmd.dptr.sgl1.unkeyed.length = tr->u.sgl[0].unkeyed.length;
-	} else {
-		/* SPDK NVMe driver supports only 1 SGL segment for now, it is enough because
-		 *  NVME_MAX_SGL_DESCRIPTORS * 16 is less than one page.
-		 */
-		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_LAST_SEGMENT;
-		req->cmd.dptr.sgl1.address = tr->prp_sgl_bus_addr;
-		req->cmd.dptr.sgl1.unkeyed.length = nseg * sizeof(struct spdk_nvme_sgl_descriptor);
-	}
-
-	return 0;
-}
-
-/**
- * Build SGL list describing scattered payload buffer.
- */
-static int
-nvme_pcie_qpair_build_hw_sgl_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
-				     struct nvme_tracker *tr, bool dword_aligned)
-{
-	int rc;
-	void *virt_addr;
-	uint64_t phys_addr, mapping_length;
-	uint32_t remaining_transfer_len, remaining_user_sge_len, length;
-	struct spdk_nvme_sgl_descriptor *sgl;
-	uint32_t nseg = 0;
-
-	/*
-	 * Build scattered payloads.
-	 */
-	assert(req->payload_size != 0);
-	assert(nvme_payload_type(&req->payload) == NVME_PAYLOAD_TYPE_SGL);
-	assert(req->payload.reset_sgl_fn != NULL);
-	assert(req->payload.next_sge_fn != NULL);
-	req->payload.reset_sgl_fn(req->payload.contig_or_cb_arg, req->payload_offset);
-
-	sgl = tr->u.sgl;
-	req->cmd.psdt = SPDK_NVME_PSDT_SGL_MPTR_CONTIG;
-	req->cmd.dptr.sgl1.unkeyed.subtype = 0;
-
-	remaining_transfer_len = req->payload_size;
-
-	while (remaining_transfer_len > 0) {
-		rc = req->payload.next_sge_fn(req->payload.contig_or_cb_arg,
-					      &virt_addr, &remaining_user_sge_len);
-		if (rc) {
-			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-			return -EFAULT;
-		}
-
-		/* Bit Bucket SGL descriptor */
-		if ((uint64_t)virt_addr == UINT64_MAX) {
-			/* TODO: enable WRITE and COMPARE when necessary */
-			if (req->cmd.opc != SPDK_NVME_OPC_READ) {
-				SPDK_ERRLOG("Only READ command can be supported\n");
-				goto exit;
-			}
-			if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
-				SPDK_ERRLOG("Too many SGL entries\n");
-				goto exit;
-			}
-
-			sgl->unkeyed.type = SPDK_NVME_SGL_TYPE_BIT_BUCKET;
-			/* If the SGL describes a destination data buffer, the length of data
-			 * buffer shall be discarded by controller, and the length is included
-			 * in Number of Logical Blocks (NLB) parameter. Otherwise, the length
-			 * is not included in the NLB parameter.
-			 */
-			remaining_user_sge_len = spdk_min(remaining_user_sge_len, remaining_transfer_len);
-			remaining_transfer_len -= remaining_user_sge_len;
-
-			sgl->unkeyed.length = remaining_user_sge_len;
-			sgl->address = 0;
-			sgl->unkeyed.subtype = 0;
-
-			sgl++;
-			nseg++;
-
-			continue;
-		}
-
-		remaining_user_sge_len = spdk_min(remaining_user_sge_len, remaining_transfer_len);
-		remaining_transfer_len -= remaining_user_sge_len;
-		while (remaining_user_sge_len > 0) {
-			if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
-				SPDK_ERRLOG("Too many SGL entries\n");
-				goto exit;
-			}
-
-			if (dword_aligned && ((uintptr_t)virt_addr & 3)) {
-				SPDK_ERRLOG("virt_addr %p not dword aligned\n", virt_addr);
-				goto exit;
-			}
-
-			mapping_length = remaining_user_sge_len;
-			phys_addr = spdk_vtophys(virt_addr, &mapping_length);
-			if (phys_addr == SPDK_VTOPHYS_ERROR) {
-				goto exit;
-			}
-
-			length = spdk_min(remaining_user_sge_len, mapping_length);
-			remaining_user_sge_len -= length;
-			virt_addr += length;
-
-			if (nseg > 0 && phys_addr ==
-			    (*(sgl - 1)).address + (*(sgl - 1)).unkeyed.length) {
-				/* extend previous entry */
-				(*(sgl - 1)).unkeyed.length += length;
-				continue;
-			}
-
-			sgl->unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
-			sgl->unkeyed.length = length;
-			sgl->address = phys_addr;
-			sgl->unkeyed.subtype = 0;
-
-			sgl++;
-			nseg++;
-		}
-	}
-
-	if (nseg == 1) {
-		/*
-		 * The whole transfer can be described by a single SGL descriptor.
-		 *  Use the special case described by the spec where SGL1's type is Data Block.
-		 *  This means the SGL in the tracker is not used at all, so copy the first (and only)
-		 *  SGL element into SGL1.
-		 */
-		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
-		req->cmd.dptr.sgl1.address = tr->u.sgl[0].address;
-		req->cmd.dptr.sgl1.unkeyed.length = tr->u.sgl[0].unkeyed.length;
-	} else {
-		/* SPDK NVMe driver supports only 1 SGL segment for now, it is enough because
-		 *  NVME_MAX_SGL_DESCRIPTORS * 16 is less than one page.
-		 */
-		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_LAST_SEGMENT;
-		req->cmd.dptr.sgl1.address = tr->prp_sgl_bus_addr;
-		req->cmd.dptr.sgl1.unkeyed.length = nseg * sizeof(struct spdk_nvme_sgl_descriptor);
-	}
-
-	return 0;
-
-exit:
-	nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-	return -EFAULT;
-}
-
-/**
- * Build PRP list describing scattered payload buffer.
- */
-static int
-nvme_pcie_qpair_build_prps_sgl_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
-				       struct nvme_tracker *tr, bool dword_aligned)
-{
-	int rc;
-	void *virt_addr;
-	uint32_t remaining_transfer_len, length;
-	uint32_t prp_index = 0;
-	uint32_t page_size = qpair->ctrlr->page_size;
-
-	/*
-	 * Build scattered payloads.
-	 */
-	assert(nvme_payload_type(&req->payload) == NVME_PAYLOAD_TYPE_SGL);
-	assert(req->payload.reset_sgl_fn != NULL);
-	req->payload.reset_sgl_fn(req->payload.contig_or_cb_arg, req->payload_offset);
-
-	remaining_transfer_len = req->payload_size;
-	while (remaining_transfer_len > 0) {
-		assert(req->payload.next_sge_fn != NULL);
-		rc = req->payload.next_sge_fn(req->payload.contig_or_cb_arg, &virt_addr, &length);
-		if (rc) {
-			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-			return -EFAULT;
-		}
-
-		length = spdk_min(remaining_transfer_len, length);
-
-		/*
-		 * Any incompatible sges should have been handled up in the splitting routine,
-		 *  but assert here as an additional check.
-		 *
-		 * All SGEs except last must end on a page boundary.
-		 */
-		assert((length == remaining_transfer_len) ||
-		       _is_page_aligned((uintptr_t)virt_addr + length, page_size));
-
-		rc = nvme_pcie_prp_list_append(tr, &prp_index, virt_addr, length, page_size);
-		if (rc) {
-			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-			return rc;
-		}
-
-		remaining_transfer_len -= length;
-	}
-
-	return 0;
-}
-
-typedef int(*build_req_fn)(struct spdk_nvme_qpair *, struct nvme_request *, struct nvme_tracker *,
-			   bool);
-
-static build_req_fn const g_nvme_pcie_build_req_table[][2] = {
-	[NVME_PAYLOAD_TYPE_INVALID] = {
-		nvme_pcie_qpair_build_request_invalid,			/* PRP */
-		nvme_pcie_qpair_build_request_invalid			/* SGL */
-	},
-	[NVME_PAYLOAD_TYPE_CONTIG] = {
-		nvme_pcie_qpair_build_contig_request,			/* PRP */
-		nvme_pcie_qpair_build_contig_hw_sgl_request		/* SGL */
-	},
-	[NVME_PAYLOAD_TYPE_SGL] = {
-		nvme_pcie_qpair_build_prps_sgl_request,			/* PRP */
-		nvme_pcie_qpair_build_hw_sgl_request			/* SGL */
-	}
-};
-
-static int
-nvme_pcie_qpair_build_metadata(struct spdk_nvme_qpair *qpair, struct nvme_tracker *tr,
-			       bool sgl_supported, bool dword_aligned)
-{
-	void *md_payload;
-	struct nvme_request *req = tr->req;
-
-	if (req->payload.md) {
-		md_payload = req->payload.md + req->md_offset;
-		if (dword_aligned && ((uintptr_t)md_payload & 3)) {
-			SPDK_ERRLOG("virt_addr %p not dword aligned\n", md_payload);
-			goto exit;
-		}
-
-		if (sgl_supported && dword_aligned) {
-			assert(req->cmd.psdt == SPDK_NVME_PSDT_SGL_MPTR_CONTIG);
-			req->cmd.psdt = SPDK_NVME_PSDT_SGL_MPTR_SGL;
-			tr->meta_sgl.address = spdk_vtophys(md_payload, NULL);
-			if (tr->meta_sgl.address == SPDK_VTOPHYS_ERROR) {
-				goto exit;
-			}
-			tr->meta_sgl.unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
-			tr->meta_sgl.unkeyed.length = req->md_size;
-			tr->meta_sgl.unkeyed.subtype = 0;
-			req->cmd.mptr = tr->prp_sgl_bus_addr - sizeof(struct spdk_nvme_sgl_descriptor);
-		} else {
-			req->cmd.mptr = spdk_vtophys(md_payload, NULL);
-			if (req->cmd.mptr == SPDK_VTOPHYS_ERROR) {
-				goto exit;
-			}
-		}
-	}
-
-	return 0;
-
-exit:
-	nvme_pcie_fail_request_bad_vtophys(qpair, tr);
-	return -EINVAL;
-}
-
-static int
-nvme_pcie_qpair_submit_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req)
-{
-	struct nvme_tracker	*tr;
-	int			rc = 0;
-	struct spdk_nvme_ctrlr	*ctrlr = qpair->ctrlr;
-	struct nvme_pcie_qpair	*pqpair = nvme_pcie_qpair(qpair);
-	enum nvme_payload_type	payload_type;
-	bool			sgl_supported;
-	bool			dword_aligned = true;
-
-	if (spdk_unlikely(nvme_qpair_is_admin_queue(qpair))) {
-		nvme_robust_mutex_lock(&ctrlr->ctrlr_lock);
-	}
-
-	tr = TAILQ_FIRST(&pqpair->free_tr);
-
-	if (tr == NULL) {
-		pqpair->stat->queued_requests++;
-		/* Inform the upper layer to try again later. */
-		rc = -EAGAIN;
-		goto exit;
-	}
-
-	pqpair->stat->submitted_requests++;
-	TAILQ_REMOVE(&pqpair->free_tr, tr, tq_list); /* remove tr from free_tr */
-	TAILQ_INSERT_TAIL(&pqpair->outstanding_tr, tr, tq_list);
-	tr->req = req;
-	tr->cb_fn = req->cb_fn;
-	tr->cb_arg = req->cb_arg;
-	req->cmd.cid = tr->cid;
-
-	if (req->payload_size != 0) {
-		payload_type = nvme_payload_type(&req->payload);
-		/* According to the specification, PRPs shall be used for all
-		 *  Admin commands for NVMe over PCIe implementations.
-		 */
-		sgl_supported = (ctrlr->flags & SPDK_NVME_CTRLR_SGL_SUPPORTED) != 0 &&
-				!nvme_qpair_is_admin_queue(qpair);
-
-		if (sgl_supported) {
-			/* Don't use SGL for DSM command */
-			if (spdk_unlikely((ctrlr->quirks & NVME_QUIRK_NO_SGL_FOR_DSM) &&
-					  (req->cmd.opc == SPDK_NVME_OPC_DATASET_MANAGEMENT))) {
-				sgl_supported = false;
-			}
-		}
-
-		if (sgl_supported && !(ctrlr->flags & SPDK_NVME_CTRLR_SGL_REQUIRES_DWORD_ALIGNMENT)) {
-			dword_aligned = false;
-		}
-		rc = g_nvme_pcie_build_req_table[payload_type][sgl_supported](qpair, req, tr, dword_aligned);
-		if (rc < 0) {
-			goto exit;
-		}
-
-		rc = nvme_pcie_qpair_build_metadata(qpair, tr, sgl_supported, dword_aligned);
-		if (rc < 0) {
-			goto exit;
-		}
-	}
-
-	nvme_pcie_qpair_submit_tracker(qpair, tr);
-
-exit:
-	if (spdk_unlikely(nvme_qpair_is_admin_queue(qpair))) {
-		nvme_robust_mutex_unlock(&ctrlr->ctrlr_lock);
-	}
-
-	return rc;
-}
-
 void
 spdk_nvme_pcie_set_hotplug_filter(spdk_nvme_pcie_hotplug_filter_cb filter_cb)
 {
diff --git a/lib/nvme/nvme_pcie_common.c b/lib/nvme/nvme_pcie_common.c
index 5bf8a841f..11242b44c 100644
--- a/lib/nvme/nvme_pcie_common.c
+++ b/lib/nvme/nvme_pcie_common.c
@@ -1045,6 +1045,520 @@ free:
 	return 0;
 }
 
+static void
+nvme_pcie_fail_request_bad_vtophys(struct spdk_nvme_qpair *qpair, struct nvme_tracker *tr)
+{
+	/*
+	 * Bad vtophys translation, so abort this request and return
+	 *  immediately.
+	 */
+	nvme_pcie_qpair_manual_complete_tracker(qpair, tr, SPDK_NVME_SCT_GENERIC,
+						SPDK_NVME_SC_INVALID_FIELD,
+						1 /* do not retry */, true);
+}
+
+/*
+ * Append PRP list entries to describe a virtually contiguous buffer starting at virt_addr of len bytes.
+ *
+ * *prp_index will be updated to account for the number of PRP entries used.
+ */
+static inline int
+nvme_pcie_prp_list_append(struct nvme_tracker *tr, uint32_t *prp_index, void *virt_addr, size_t len,
+			  uint32_t page_size)
+{
+	struct spdk_nvme_cmd *cmd = &tr->req->cmd;
+	uintptr_t page_mask = page_size - 1;
+	uint64_t phys_addr;
+	uint32_t i;
+
+	SPDK_DEBUGLOG(nvme, "prp_index:%u virt_addr:%p len:%u\n",
+		      *prp_index, virt_addr, (uint32_t)len);
+
+	if (spdk_unlikely(((uintptr_t)virt_addr & 3) != 0)) {
+		SPDK_ERRLOG("virt_addr %p not dword aligned\n", virt_addr);
+		return -EFAULT;
+	}
+
+	i = *prp_index;
+	while (len) {
+		uint32_t seg_len;
+
+		/*
+		 * prp_index 0 is stored in prp1, and the rest are stored in the prp[] array,
+		 * so prp_index == count is valid.
+		 */
+		if (spdk_unlikely(i > SPDK_COUNTOF(tr->u.prp))) {
+			SPDK_ERRLOG("out of PRP entries\n");
+			return -EFAULT;
+		}
+
+		phys_addr = spdk_vtophys(virt_addr, NULL);
+		if (spdk_unlikely(phys_addr == SPDK_VTOPHYS_ERROR)) {
+			SPDK_ERRLOG("vtophys(%p) failed\n", virt_addr);
+			return -EFAULT;
+		}
+
+		if (i == 0) {
+			SPDK_DEBUGLOG(nvme, "prp1 = %p\n", (void *)phys_addr);
+			cmd->dptr.prp.prp1 = phys_addr;
+			seg_len = page_size - ((uintptr_t)virt_addr & page_mask);
+		} else {
+			if ((phys_addr & page_mask) != 0) {
+				SPDK_ERRLOG("PRP %u not page aligned (%p)\n", i, virt_addr);
+				return -EFAULT;
+			}
+
+			SPDK_DEBUGLOG(nvme, "prp[%u] = %p\n", i - 1, (void *)phys_addr);
+			tr->u.prp[i - 1] = phys_addr;
+			seg_len = page_size;
+		}
+
+		seg_len = spdk_min(seg_len, len);
+		virt_addr += seg_len;
+		len -= seg_len;
+		i++;
+	}
+
+	cmd->psdt = SPDK_NVME_PSDT_PRP;
+	if (i <= 1) {
+		cmd->dptr.prp.prp2 = 0;
+	} else if (i == 2) {
+		cmd->dptr.prp.prp2 = tr->u.prp[0];
+		SPDK_DEBUGLOG(nvme, "prp2 = %p\n", (void *)cmd->dptr.prp.prp2);
+	} else {
+		cmd->dptr.prp.prp2 = tr->prp_sgl_bus_addr;
+		SPDK_DEBUGLOG(nvme, "prp2 = %p (PRP list)\n", (void *)cmd->dptr.prp.prp2);
+	}
+
+	*prp_index = i;
+	return 0;
+}
+
+static int
+nvme_pcie_qpair_build_request_invalid(struct spdk_nvme_qpair *qpair,
+				      struct nvme_request *req, struct nvme_tracker *tr, bool dword_aligned)
+{
+	assert(0);
+	nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+	return -EINVAL;
+}
+
+/**
+ * Build PRP list describing physically contiguous payload buffer.
+ */
+static int
+nvme_pcie_qpair_build_contig_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
+				     struct nvme_tracker *tr, bool dword_aligned)
+{
+	uint32_t prp_index = 0;
+	int rc;
+
+	rc = nvme_pcie_prp_list_append(tr, &prp_index, req->payload.contig_or_cb_arg + req->payload_offset,
+				       req->payload_size, qpair->ctrlr->page_size);
+	if (rc) {
+		nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+	}
+
+	return rc;
+}
+
+/**
+ * Build an SGL describing a physically contiguous payload buffer.
+ *
+ * This is more efficient than using PRP because large buffers can be
+ * described this way.
+ */
+static int
+nvme_pcie_qpair_build_contig_hw_sgl_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
+		struct nvme_tracker *tr, bool dword_aligned)
+{
+	void *virt_addr;
+	uint64_t phys_addr, mapping_length;
+	uint32_t length;
+	struct spdk_nvme_sgl_descriptor *sgl;
+	uint32_t nseg = 0;
+
+	assert(req->payload_size != 0);
+	assert(nvme_payload_type(&req->payload) == NVME_PAYLOAD_TYPE_CONTIG);
+
+	sgl = tr->u.sgl;
+	req->cmd.psdt = SPDK_NVME_PSDT_SGL_MPTR_CONTIG;
+	req->cmd.dptr.sgl1.unkeyed.subtype = 0;
+
+	length = req->payload_size;
+	virt_addr = req->payload.contig_or_cb_arg + req->payload_offset;
+
+	while (length > 0) {
+		if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
+			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+			return -EFAULT;
+		}
+
+		if (dword_aligned && ((uintptr_t)virt_addr & 3)) {
+			SPDK_ERRLOG("virt_addr %p not dword aligned\n", virt_addr);
+			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+			return -EFAULT;
+		}
+
+		mapping_length = length;
+		phys_addr = spdk_vtophys(virt_addr, &mapping_length);
+		if (phys_addr == SPDK_VTOPHYS_ERROR) {
+			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+			return -EFAULT;
+		}
+
+		mapping_length = spdk_min(length, mapping_length);
+
+		length -= mapping_length;
+		virt_addr += mapping_length;
+
+		sgl->unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
+		sgl->unkeyed.length = mapping_length;
+		sgl->address = phys_addr;
+		sgl->unkeyed.subtype = 0;
+
+		sgl++;
+		nseg++;
+	}
+
+	if (nseg == 1) {
+		/*
+		 * The whole transfer can be described by a single SGL descriptor.
+		 *  Use the special case described by the spec where SGL1's type is Data Block.
+		 *  This means the SGL in the tracker is not used at all, so copy the first (and only)
+		 *  SGL element into SGL1.
+		 */
+		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
+		req->cmd.dptr.sgl1.address = tr->u.sgl[0].address;
+		req->cmd.dptr.sgl1.unkeyed.length = tr->u.sgl[0].unkeyed.length;
+	} else {
+		/* SPDK NVMe driver supports only 1 SGL segment for now, it is enough because
+		 *  NVME_MAX_SGL_DESCRIPTORS * 16 is less than one page.
+		 */
+		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_LAST_SEGMENT;
+		req->cmd.dptr.sgl1.address = tr->prp_sgl_bus_addr;
+		req->cmd.dptr.sgl1.unkeyed.length = nseg * sizeof(struct spdk_nvme_sgl_descriptor);
+	}
+
+	return 0;
+}
+
+/**
+ * Build SGL list describing scattered payload buffer.
+ */
+static int
+nvme_pcie_qpair_build_hw_sgl_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
+				     struct nvme_tracker *tr, bool dword_aligned)
+{
+	int rc;
+	void *virt_addr;
+	uint64_t phys_addr, mapping_length;
+	uint32_t remaining_transfer_len, remaining_user_sge_len, length;
+	struct spdk_nvme_sgl_descriptor *sgl;
+	uint32_t nseg = 0;
+
+	/*
+	 * Build scattered payloads.
+	 */
+	assert(req->payload_size != 0);
+	assert(nvme_payload_type(&req->payload) == NVME_PAYLOAD_TYPE_SGL);
+	assert(req->payload.reset_sgl_fn != NULL);
+	assert(req->payload.next_sge_fn != NULL);
+	req->payload.reset_sgl_fn(req->payload.contig_or_cb_arg, req->payload_offset);
+
+	sgl = tr->u.sgl;
+	req->cmd.psdt = SPDK_NVME_PSDT_SGL_MPTR_CONTIG;
+	req->cmd.dptr.sgl1.unkeyed.subtype = 0;
+
+	remaining_transfer_len = req->payload_size;
+
+	while (remaining_transfer_len > 0) {
+		rc = req->payload.next_sge_fn(req->payload.contig_or_cb_arg,
+					      &virt_addr, &remaining_user_sge_len);
+		if (rc) {
+			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+			return -EFAULT;
+		}
+
+		/* Bit Bucket SGL descriptor */
+		if ((uint64_t)virt_addr == UINT64_MAX) {
+			/* TODO: enable WRITE and COMPARE when necessary */
+			if (req->cmd.opc != SPDK_NVME_OPC_READ) {
+				SPDK_ERRLOG("Only READ command can be supported\n");
+				goto exit;
+			}
+			if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
+				SPDK_ERRLOG("Too many SGL entries\n");
+				goto exit;
+			}
+
+			sgl->unkeyed.type = SPDK_NVME_SGL_TYPE_BIT_BUCKET;
+			/* If the SGL describes a destination data buffer, the length of data
+			 * buffer shall be discarded by controller, and the length is included
+			 * in Number of Logical Blocks (NLB) parameter. Otherwise, the length
+			 * is not included in the NLB parameter.
+			 */
+			remaining_user_sge_len = spdk_min(remaining_user_sge_len, remaining_transfer_len);
+			remaining_transfer_len -= remaining_user_sge_len;
+
+			sgl->unkeyed.length = remaining_user_sge_len;
+			sgl->address = 0;
+			sgl->unkeyed.subtype = 0;
+
+			sgl++;
+			nseg++;
+
+			continue;
+		}
+
+		remaining_user_sge_len = spdk_min(remaining_user_sge_len, remaining_transfer_len);
+		remaining_transfer_len -= remaining_user_sge_len;
+		while (remaining_user_sge_len > 0) {
+			if (nseg >= NVME_MAX_SGL_DESCRIPTORS) {
+				SPDK_ERRLOG("Too many SGL entries\n");
+				goto exit;
+			}
+
+			if (dword_aligned && ((uintptr_t)virt_addr & 3)) {
+				SPDK_ERRLOG("virt_addr %p not dword aligned\n", virt_addr);
+				goto exit;
+			}
+
+			mapping_length = remaining_user_sge_len;
+			phys_addr = spdk_vtophys(virt_addr, &mapping_length);
+			if (phys_addr == SPDK_VTOPHYS_ERROR) {
+				goto exit;
+			}
+
+			length = spdk_min(remaining_user_sge_len, mapping_length);
+			remaining_user_sge_len -= length;
+			virt_addr += length;
+
+			if (nseg > 0 && phys_addr ==
+			    (*(sgl - 1)).address + (*(sgl - 1)).unkeyed.length) {
+				/* extend previous entry */
+				(*(sgl - 1)).unkeyed.length += length;
+				continue;
+			}
+
+			sgl->unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
+			sgl->unkeyed.length = length;
+			sgl->address = phys_addr;
+			sgl->unkeyed.subtype = 0;
+
+			sgl++;
+			nseg++;
+		}
+	}
+
+	if (nseg == 1) {
+		/*
+		 * The whole transfer can be described by a single SGL descriptor.
+		 *  Use the special case described by the spec where SGL1's type is Data Block.
+		 *  This means the SGL in the tracker is not used at all, so copy the first (and only)
+		 *  SGL element into SGL1.
+		 */
+		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
+		req->cmd.dptr.sgl1.address = tr->u.sgl[0].address;
+		req->cmd.dptr.sgl1.unkeyed.length = tr->u.sgl[0].unkeyed.length;
+	} else {
+		/* SPDK NVMe driver supports only 1 SGL segment for now, it is enough because
+		 *  NVME_MAX_SGL_DESCRIPTORS * 16 is less than one page.
+		 */
+		req->cmd.dptr.sgl1.unkeyed.type = SPDK_NVME_SGL_TYPE_LAST_SEGMENT;
+		req->cmd.dptr.sgl1.address = tr->prp_sgl_bus_addr;
+		req->cmd.dptr.sgl1.unkeyed.length = nseg * sizeof(struct spdk_nvme_sgl_descriptor);
+	}
+
+	return 0;
+
+exit:
+	nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+	return -EFAULT;
+}
+
+/**
+ * Build PRP list describing scattered payload buffer.
+ */
+static int
+nvme_pcie_qpair_build_prps_sgl_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req,
+				       struct nvme_tracker *tr, bool dword_aligned)
+{
+	int rc;
+	void *virt_addr;
+	uint32_t remaining_transfer_len, length;
+	uint32_t prp_index = 0;
+	uint32_t page_size = qpair->ctrlr->page_size;
+
+	/*
+	 * Build scattered payloads.
+	 */
+	assert(nvme_payload_type(&req->payload) == NVME_PAYLOAD_TYPE_SGL);
+	assert(req->payload.reset_sgl_fn != NULL);
+	req->payload.reset_sgl_fn(req->payload.contig_or_cb_arg, req->payload_offset);
+
+	remaining_transfer_len = req->payload_size;
+	while (remaining_transfer_len > 0) {
+		assert(req->payload.next_sge_fn != NULL);
+		rc = req->payload.next_sge_fn(req->payload.contig_or_cb_arg, &virt_addr, &length);
+		if (rc) {
+			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+			return -EFAULT;
+		}
+
+		length = spdk_min(remaining_transfer_len, length);
+
+		/*
+		 * Any incompatible sges should have been handled up in the splitting routine,
+		 *  but assert here as an additional check.
+		 *
+		 * All SGEs except last must end on a page boundary.
+		 */
+		assert((length == remaining_transfer_len) ||
+		       _is_page_aligned((uintptr_t)virt_addr + length, page_size));
+
+		rc = nvme_pcie_prp_list_append(tr, &prp_index, virt_addr, length, page_size);
+		if (rc) {
+			nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+			return rc;
+		}
+
+		remaining_transfer_len -= length;
+	}
+
+	return 0;
+}
+
+typedef int(*build_req_fn)(struct spdk_nvme_qpair *, struct nvme_request *, struct nvme_tracker *,
+			   bool);
+
+static build_req_fn const g_nvme_pcie_build_req_table[][2] = {
+	[NVME_PAYLOAD_TYPE_INVALID] = {
+		nvme_pcie_qpair_build_request_invalid,			/* PRP */
+		nvme_pcie_qpair_build_request_invalid			/* SGL */
+	},
+	[NVME_PAYLOAD_TYPE_CONTIG] = {
+		nvme_pcie_qpair_build_contig_request,			/* PRP */
+		nvme_pcie_qpair_build_contig_hw_sgl_request		/* SGL */
+	},
+	[NVME_PAYLOAD_TYPE_SGL] = {
+		nvme_pcie_qpair_build_prps_sgl_request,			/* PRP */
+		nvme_pcie_qpair_build_hw_sgl_request			/* SGL */
+	}
+};
+
+static int
+nvme_pcie_qpair_build_metadata(struct spdk_nvme_qpair *qpair, struct nvme_tracker *tr,
+			       bool sgl_supported, bool dword_aligned)
+{
+	void *md_payload;
+	struct nvme_request *req = tr->req;
+
+	if (req->payload.md) {
+		md_payload = req->payload.md + req->md_offset;
+		if (dword_aligned && ((uintptr_t)md_payload & 3)) {
+			SPDK_ERRLOG("virt_addr %p not dword aligned\n", md_payload);
+			goto exit;
+		}
+
+		if (sgl_supported && dword_aligned) {
+			assert(req->cmd.psdt == SPDK_NVME_PSDT_SGL_MPTR_CONTIG);
+			req->cmd.psdt = SPDK_NVME_PSDT_SGL_MPTR_SGL;
+			tr->meta_sgl.address = spdk_vtophys(md_payload, NULL);
+			if (tr->meta_sgl.address == SPDK_VTOPHYS_ERROR) {
+				goto exit;
+			}
+			tr->meta_sgl.unkeyed.type = SPDK_NVME_SGL_TYPE_DATA_BLOCK;
+			tr->meta_sgl.unkeyed.length = req->md_size;
+			tr->meta_sgl.unkeyed.subtype = 0;
+			req->cmd.mptr = tr->prp_sgl_bus_addr - sizeof(struct spdk_nvme_sgl_descriptor);
+		} else {
+			req->cmd.mptr = spdk_vtophys(md_payload, NULL);
+			if (req->cmd.mptr == SPDK_VTOPHYS_ERROR) {
+				goto exit;
+			}
+		}
+	}
+
+	return 0;
+
+exit:
+	nvme_pcie_fail_request_bad_vtophys(qpair, tr);
+	return -EINVAL;
+}
+
+int
+nvme_pcie_qpair_submit_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req)
+{
+	struct nvme_tracker	*tr;
+	int			rc = 0;
+	struct spdk_nvme_ctrlr	*ctrlr = qpair->ctrlr;
+	struct nvme_pcie_qpair	*pqpair = nvme_pcie_qpair(qpair);
+	enum nvme_payload_type	payload_type;
+	bool			sgl_supported;
+	bool			dword_aligned = true;
+
+	if (spdk_unlikely(nvme_qpair_is_admin_queue(qpair))) {
+		nvme_robust_mutex_lock(&ctrlr->ctrlr_lock);
+	}
+
+	tr = TAILQ_FIRST(&pqpair->free_tr);
+
+	if (tr == NULL) {
+		pqpair->stat->queued_requests++;
+		/* Inform the upper layer to try again later. */
+		rc = -EAGAIN;
+		goto exit;
+	}
+
+	pqpair->stat->submitted_requests++;
+	TAILQ_REMOVE(&pqpair->free_tr, tr, tq_list); /* remove tr from free_tr */
+	TAILQ_INSERT_TAIL(&pqpair->outstanding_tr, tr, tq_list);
+	tr->req = req;
+	tr->cb_fn = req->cb_fn;
+	tr->cb_arg = req->cb_arg;
+	req->cmd.cid = tr->cid;
+
+	if (req->payload_size != 0) {
+		payload_type = nvme_payload_type(&req->payload);
+		/* According to the specification, PRPs shall be used for all
+		 *  Admin commands for NVMe over PCIe implementations.
+		 */
+		sgl_supported = (ctrlr->flags & SPDK_NVME_CTRLR_SGL_SUPPORTED) != 0 &&
+				!nvme_qpair_is_admin_queue(qpair);
+
+		if (sgl_supported) {
+			/* Don't use SGL for DSM command */
+			if (spdk_unlikely((ctrlr->quirks & NVME_QUIRK_NO_SGL_FOR_DSM) &&
+					  (req->cmd.opc == SPDK_NVME_OPC_DATASET_MANAGEMENT))) {
+				sgl_supported = false;
+			}
+		}
+
+		if (sgl_supported && !(ctrlr->flags & SPDK_NVME_CTRLR_SGL_REQUIRES_DWORD_ALIGNMENT)) {
+			dword_aligned = false;
+		}
+		rc = g_nvme_pcie_build_req_table[payload_type][sgl_supported](qpair, req, tr, dword_aligned);
+		if (rc < 0) {
+			goto exit;
+		}
+
+		rc = nvme_pcie_qpair_build_metadata(qpair, tr, sgl_supported, dword_aligned);
+		if (rc < 0) {
+			goto exit;
+		}
+	}
+
+	nvme_pcie_qpair_submit_tracker(qpair, tr);
+
+exit:
+	if (spdk_unlikely(nvme_qpair_is_admin_queue(qpair))) {
+		nvme_robust_mutex_unlock(&ctrlr->ctrlr_lock);
+	}
+
+	return rc;
+}
+
 struct spdk_nvme_transport_poll_group *
 nvme_pcie_poll_group_create(void)
 {
diff --git a/lib/nvme/nvme_pcie_internal.h b/lib/nvme/nvme_pcie_internal.h
index f1eb6c98c..d7b554c2c 100644
--- a/lib/nvme/nvme_pcie_internal.h
+++ b/lib/nvme/nvme_pcie_internal.h
@@ -344,6 +344,7 @@ int nvme_pcie_qpair_destroy(struct spdk_nvme_qpair *qpair);
 struct spdk_nvme_qpair *nvme_pcie_ctrlr_create_io_qpair(struct spdk_nvme_ctrlr *ctrlr, uint16_t qid,
 		const struct spdk_nvme_io_qpair_opts *opts);
 int nvme_pcie_ctrlr_delete_io_qpair(struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair);
+int nvme_pcie_qpair_submit_request(struct spdk_nvme_qpair *qpair, struct nvme_request *req);
 
 struct spdk_nvme_transport_poll_group *nvme_pcie_poll_group_create(void);
 int nvme_pcie_poll_group_connect_qpair(struct spdk_nvme_qpair *qpair);
-- 
2.26.2


From 5e4fe0adc81c0fd2d5c70fb9ddd3ee3a3082bdc4 Mon Sep 17 00:00:00 2001
From: Changpeng Liu <changpeng.liu@intel.com>
Date: Fri, 4 Jun 2021 16:07:05 +0800
Subject: [PATCH 342/342] nvme: inline nvme_pcie_vtophys

The inline function can also be used in the coming submit request
function.

Change-Id: If4a5511001e6586dbce0978298beddc537f54d8b
Signed-off-by: Changpeng Liu <changpeng.liu@intel.com>
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8173
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
Reviewed-by: Aleksey Marchuk <alexeymar@mellanox.com>
Reviewed-by: Ben Walker <benjamin.walker@intel.com>
---
 lib/nvme/nvme_pcie_common.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/lib/nvme/nvme_pcie_common.c b/lib/nvme/nvme_pcie_common.c
index 11242b44c..d5582f43d 100644
--- a/lib/nvme/nvme_pcie_common.c
+++ b/lib/nvme/nvme_pcie_common.c
@@ -43,11 +43,11 @@
 
 __thread struct nvme_pcie_ctrlr *g_thread_mmio_ctrlr = NULL;
 
-static uint64_t
-nvme_pcie_vtophys(struct spdk_nvme_ctrlr *ctrlr, const void *buf)
+static inline uint64_t
+nvme_pcie_vtophys(struct spdk_nvme_ctrlr *ctrlr, const void *buf, uint64_t *size)
 {
 	if (spdk_likely(ctrlr->trid.trtype == SPDK_NVME_TRANSPORT_PCIE)) {
-		return spdk_vtophys(buf, NULL);
+		return spdk_vtophys(buf, size);
 	} else {
 		/* vfio-user address translation with IOVA=VA mode */
 		return (uint64_t)(uintptr_t)buf;
@@ -187,7 +187,7 @@ nvme_pcie_qpair_construct(struct spdk_nvme_qpair *qpair,
 			assert(pqpair->sq_vaddr != NULL);
 			pqpair->cmd_bus_addr = sq_paddr;
 		} else {
-			pqpair->cmd_bus_addr = nvme_pcie_vtophys(ctrlr, pqpair->cmd);
+			pqpair->cmd_bus_addr = nvme_pcie_vtophys(ctrlr, pqpair->cmd, NULL);
 			if (pqpair->cmd_bus_addr == SPDK_VTOPHYS_ERROR) {
 				SPDK_ERRLOG("spdk_vtophys(pqpair->cmd) failed\n");
 				return -EFAULT;
@@ -210,7 +210,7 @@ nvme_pcie_qpair_construct(struct spdk_nvme_qpair *qpair,
 		assert(pqpair->cq_vaddr != NULL);
 		pqpair->cpl_bus_addr = cq_paddr;
 	} else {
-		pqpair->cpl_bus_addr =  nvme_pcie_vtophys(ctrlr, pqpair->cpl);
+		pqpair->cpl_bus_addr =  nvme_pcie_vtophys(ctrlr, pqpair->cpl, NULL);
 		if (pqpair->cpl_bus_addr == SPDK_VTOPHYS_ERROR) {
 			SPDK_ERRLOG("spdk_vtophys(pqpair->cpl) failed\n");
 			return -EFAULT;
@@ -238,7 +238,7 @@ nvme_pcie_qpair_construct(struct spdk_nvme_qpair *qpair,
 
 	for (i = 0; i < num_trackers; i++) {
 		tr = &pqpair->tr[i];
-		nvme_qpair_construct_tracker(tr, i, nvme_pcie_vtophys(ctrlr, tr));
+		nvme_qpair_construct_tracker(tr, i, nvme_pcie_vtophys(ctrlr, tr, NULL));
 		TAILQ_INSERT_HEAD(&pqpair->free_tr, tr, tq_list);
 	}
 
-- 
2.26.2

