commit b4b0ac87aaadc5c4ad768d3468a7e8fa3fb384e2
Author: Evgeniy Kochetov <evgeniik@mellanox.com>
Date:   Sat Mar 14 16:38:06 2020 +0000

    nvme/ctrlr: Remove Get Num Queues initialization step
    
    NVMe specification in ch.7.6 "Controller Initialization" suggests to
    use only Set Features "Number of queues" command and says nothing
    about Get Features. All required information is available after Set
    Num Queues step.
    
    Fixes #1270
    
    Signed-off-by: Evgeniy Kochetov <evgeniik@mellanox.com>
    Change-Id: Ide38ba9c7f063f1d6b13bfce4232c588cc906784
    Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/1271
    Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
    Reviewed-by: Ben Walker <benjamin.walker@intel.com>
    Reviewed-by: Jim Harris <james.r.harris@intel.com>
    Reviewed-by: Changpeng Liu <changpeng.liu@intel.com>
    Reviewed-by: Shuhei Matsumoto <shuhei.matsumoto.xt@hitachi.com>

diff --git a/lib/nvme/nvme_ctrlr.c b/lib/nvme/nvme_ctrlr.c
index f0e0e33eb..684bf4260 100644
--- a/lib/nvme/nvme_ctrlr.c
+++ b/lib/nvme/nvme_ctrlr.c
@@ -895,10 +895,6 @@ nvme_ctrlr_state_string(enum nvme_ctrlr_state state)
 		return "set number of queues";
 	case NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES:
 		return "wait for set number of queues";
-	case NVME_CTRLR_STATE_GET_NUM_QUEUES:
-		return "get number of queues";
-	case NVME_CTRLR_STATE_WAIT_FOR_GET_NUM_QUEUES:
-		return "wait for get number of queues";
 	case NVME_CTRLR_STATE_CONSTRUCT_NS:
 		return "construct namespaces";
 	case NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS:
@@ -1522,51 +1518,12 @@ nvme_ctrlr_identify_id_desc_namespaces(struct spdk_nvme_ctrlr *ctrlr)
 
 static void
 nvme_ctrlr_set_num_queues_done(void *arg, const struct spdk_nvme_cpl *cpl)
-{
-	struct spdk_nvme_ctrlr *ctrlr = (struct spdk_nvme_ctrlr *)arg;
-
-	if (spdk_nvme_cpl_is_error(cpl)) {
-		SPDK_ERRLOG("Set Features - Number of Queues failed!\n");
-	}
-	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_GET_NUM_QUEUES,
-			     ctrlr->opts.admin_timeout_ms);
-}
-
-static int
-nvme_ctrlr_set_num_queues(struct spdk_nvme_ctrlr *ctrlr)
-{
-	int rc;
-
-	if (ctrlr->opts.num_io_queues > SPDK_NVME_MAX_IO_QUEUES) {
-		SPDK_NOTICELOG("Limiting requested num_io_queues %u to max %d\n",
-			       ctrlr->opts.num_io_queues, SPDK_NVME_MAX_IO_QUEUES);
-		ctrlr->opts.num_io_queues = SPDK_NVME_MAX_IO_QUEUES;
-	} else if (ctrlr->opts.num_io_queues < 1) {
-		SPDK_NOTICELOG("Requested num_io_queues 0, increasing to 1\n");
-		ctrlr->opts.num_io_queues = 1;
-	}
-
-	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES,
-			     ctrlr->opts.admin_timeout_ms);
-
-	rc = nvme_ctrlr_cmd_set_num_queues(ctrlr, ctrlr->opts.num_io_queues,
-					   nvme_ctrlr_set_num_queues_done, ctrlr);
-	if (rc != 0) {
-		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_ERROR, NVME_TIMEOUT_INFINITE);
-		return rc;
-	}
-
-	return 0;
-}
-
-static void
-nvme_ctrlr_get_num_queues_done(void *arg, const struct spdk_nvme_cpl *cpl)
 {
 	uint32_t cq_allocated, sq_allocated, min_allocated, i;
 	struct spdk_nvme_ctrlr *ctrlr = (struct spdk_nvme_ctrlr *)arg;
 
 	if (spdk_nvme_cpl_is_error(cpl)) {
-		SPDK_ERRLOG("Get Features - Number of Queues failed!\n");
+		SPDK_ERRLOG("Set Features - Number of Queues failed!\n");
 		ctrlr->opts.num_io_queues = 0;
 	} else {
 		/*
@@ -1603,15 +1560,24 @@ nvme_ctrlr_get_num_queues_done(void *arg, const struct spdk_nvme_cpl *cpl)
 }
 
 static int
-nvme_ctrlr_get_num_queues(struct spdk_nvme_ctrlr *ctrlr)
+nvme_ctrlr_set_num_queues(struct spdk_nvme_ctrlr *ctrlr)
 {
 	int rc;
 
-	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_GET_NUM_QUEUES,
+	if (ctrlr->opts.num_io_queues > SPDK_NVME_MAX_IO_QUEUES) {
+		SPDK_NOTICELOG("Limiting requested num_io_queues %u to max %d\n",
+			       ctrlr->opts.num_io_queues, SPDK_NVME_MAX_IO_QUEUES);
+		ctrlr->opts.num_io_queues = SPDK_NVME_MAX_IO_QUEUES;
+	} else if (ctrlr->opts.num_io_queues < 1) {
+		SPDK_NOTICELOG("Requested num_io_queues 0, increasing to 1\n");
+		ctrlr->opts.num_io_queues = 1;
+	}
+
+	nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES,
 			     ctrlr->opts.admin_timeout_ms);
 
-	/* Obtain the number of queues allocated using Get Features. */
-	rc = nvme_ctrlr_cmd_get_num_queues(ctrlr, nvme_ctrlr_get_num_queues_done, ctrlr);
+	rc = nvme_ctrlr_cmd_set_num_queues(ctrlr, ctrlr->opts.num_io_queues,
+					   nvme_ctrlr_set_num_queues_done, ctrlr);
 	if (rc != 0) {
 		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_ERROR, NVME_TIMEOUT_INFINITE);
 		return rc;
@@ -2423,14 +2389,6 @@ nvme_ctrlr_process_init(struct spdk_nvme_ctrlr *ctrlr)
 		spdk_nvme_qpair_process_completions(ctrlr->adminq, 0);
 		break;
 
-	case NVME_CTRLR_STATE_GET_NUM_QUEUES:
-		rc = nvme_ctrlr_get_num_queues(ctrlr);
-		break;
-
-	case NVME_CTRLR_STATE_WAIT_FOR_GET_NUM_QUEUES:
-		spdk_nvme_qpair_process_completions(ctrlr->adminq, 0);
-		break;
-
 	case NVME_CTRLR_STATE_CONSTRUCT_NS:
 		rc = nvme_ctrlr_construct_namespaces(ctrlr);
 		nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS,
diff --git a/lib/nvme/nvme_internal.h b/lib/nvme/nvme_internal.h
index 88d7d0e3e..25f83240b 100644
--- a/lib/nvme/nvme_internal.h
+++ b/lib/nvme/nvme_internal.h
@@ -494,16 +494,6 @@ enum nvme_ctrlr_state {
 	 */
 	NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES,
 
-	/**
-	 * Get Number of Queues of the controller.
-	 */
-	NVME_CTRLR_STATE_GET_NUM_QUEUES,
-
-	/**
-	 * Waiting for Get Num of Queues command to be completed.
-	 */
-	NVME_CTRLR_STATE_WAIT_FOR_GET_NUM_QUEUES,
-
 	/**
 	 * Construct Namespace data structures of the controller.
 	 */
diff --git a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
index 2ab963b42..9c54ba81c 100644
--- a/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
+++ b/test/unit/lib/nvme/nvme_ctrlr.c/nvme_ctrlr_ut.c
@@ -353,8 +353,8 @@ int
 nvme_ctrlr_cmd_get_num_queues(struct spdk_nvme_ctrlr *ctrlr,
 			      spdk_nvme_cmd_cb cb_fn, void *cb_arg)
 {
-	fake_cpl_success(cb_fn, cb_arg);
-	return 0;
+	CU_ASSERT(0);
+	return -1;
 }
 
 int
