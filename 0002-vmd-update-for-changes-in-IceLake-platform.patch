From 65425be69a0882ac283fb489aa151d7df06c52ad Mon Sep 17 00:00:00 2001
From: Sydney Vanda <sydney.m.vanda@intel.com>
Date: Mon, 14 Jun 2021 20:06:35 +0000
Subject: [PATCH] vmd: update for changes in IceLake platform

Add the new device ID for VMD devices so VMD devices
can be unbound and used with the SPDK setup script.

Bus numbering for VMD devices is different on IceLake platforms,
and only half of the bus numbers are available. Add a function to
set the starting bus number and the max bus number by reading the
new BUS_RESTRICT_CAP and BUS_RESTRICTIONS VMD registers.

Signed-off-by: Sydney Vanda <sydney.m.vanda@intel.com>
Change-Id: I8905d4bcba84c74e3dadfb27262e668c4281b0c8
Reviewed-on: https://review.spdk.io/gerrit/c/spdk/spdk/+/8331
Community-CI: Broadcom CI <spdk-ci.pdl@broadcom.com>
Community-CI: Mellanox Build Bot
Reviewed-by: Jim Harris <james.r.harris@intel.com>
Reviewed-by: Ziye Yang <ziye.yang@intel.com>
Reviewed-by: Tomasz Zawadzki <tomasz.zawadzki@intel.com>
Tested-by: SPDK CI Jenkins <sys_sgci@intel.com>
---
 include/spdk/pci_ids.h | 14 +++++++++-
 lib/env_dpdk/pci_vmd.c |  3 ++-
 lib/vmd/vmd.c          | 58 ++++++++++++++++++++++++++++++++++--------
 lib/vmd/vmd.h          |  2 ++
 lib/vmd/vmd_spec.h     |  5 +++-
 5 files changed, 69 insertions(+), 13 deletions(-)

diff --git a/include/spdk/pci_ids.h b/include/spdk/pci_ids.h
index 0791b75fc..0ac5388ab 100644
--- a/include/spdk/pci_ids.h
+++ b/include/spdk/pci_ids.h
@@ -131,7 +131,19 @@ extern "C" {
 
 #define PCI_DEVICE_ID_VIRTIO_VHOST_USER 0x1017
 
-#define PCI_DEVICE_ID_INTEL_VMD		0x201d
+#define PCI_DEVICE_ID_INTEL_VMD_SKX	0x201d
+#define PCI_DEVICE_ID_INTEL_VMD_ICX	0x28c0
+
+#define PCI_ROOT_PORT_A_INTEL_SKX	0x2030
+#define PCI_ROOT_PORT_B_INTEL_SKX	0x2031
+#define PCI_ROOT_PORT_C_INTEL_SKX	0x2032
+#define PCI_ROOT_PORT_D_INTEL_SKX	0x2033
+#define PCI_ROOT_PORT_A_INTEL_ICX	0x347a
+#define PCI_ROOT_PORT_B_INTEL_ICX	0x347b
+#define PCI_ROOT_PORT_C_INTEL_ICX	0x347c
+#define PCI_ROOT_PORT_D_INTEL_ICX	0x347d
+
+
 
 #ifdef __cplusplus
 }
diff --git a/lib/env_dpdk/pci_vmd.c b/lib/env_dpdk/pci_vmd.c
index 19289e051..58b222679 100644
--- a/lib/env_dpdk/pci_vmd.c
+++ b/lib/env_dpdk/pci_vmd.c
@@ -36,7 +36,8 @@
 #include "spdk/pci_ids.h"
 
 static struct spdk_pci_id vmd_pci_driver_id[] = {
-	{ SPDK_PCI_DEVICE(SPDK_PCI_VID_INTEL, PCI_DEVICE_ID_INTEL_VMD) },
+	{ SPDK_PCI_DEVICE(SPDK_PCI_VID_INTEL, PCI_DEVICE_ID_INTEL_VMD_SKX) },
+	{ SPDK_PCI_DEVICE(SPDK_PCI_VID_INTEL, PCI_DEVICE_ID_INTEL_VMD_ICX) },
 	{ .vendor_id = 0, /* sentinel */ },
 };
 
diff --git a/lib/vmd/vmd.c b/lib/vmd/vmd.c
index 0998b6fab..3468b141f 100644
--- a/lib/vmd/vmd.c
+++ b/lib/vmd/vmd.c
@@ -94,11 +94,15 @@ vmd_device_is_enumerated(const struct vmd_pci_device *vmd_device)
 static bool
 vmd_device_is_root_port(const struct vmd_pci_device *vmd_device)
 {
-	return vmd_device->header->common.vendor_id == 0x8086 &&
-	       (vmd_device->header->common.device_id == 0x2030 ||
-		vmd_device->header->common.device_id == 0x2031 ||
-		vmd_device->header->common.device_id == 0x2032 ||
-		vmd_device->header->common.device_id == 0x2033);
+	return vmd_device->header->common.vendor_id == SPDK_PCI_VID_INTEL &&
+	       (vmd_device->header->common.device_id == PCI_ROOT_PORT_A_INTEL_SKX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_B_INTEL_SKX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_C_INTEL_SKX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_D_INTEL_SKX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_A_INTEL_ICX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_B_INTEL_ICX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_C_INTEL_ICX ||
+		vmd_device->header->common.device_id == PCI_ROOT_PORT_D_INTEL_ICX);
 }
 
 static void
@@ -593,7 +597,7 @@ vmd_bus_device_present(struct vmd_pci_bus *bus, uint32_t devfn)
 	volatile struct pci_header *header;
 
 	header = (volatile struct pci_header *)(bus->vmd->cfg_vaddr +
-						CONFIG_OFFSET_ADDR(bus->bus_number, devfn, 0, 0));
+						CONFIG_OFFSET_ADDR(bus->config_bus_number, devfn, 0, 0));
 	if (!vmd_is_valid_cfg_addr(bus, (uint64_t)header)) {
 		return false;
 	}
@@ -625,7 +629,7 @@ vmd_alloc_dev(struct vmd_pci_bus *bus, uint32_t devfn)
 	}
 
 	header = (struct pci_header * volatile)(bus->vmd->cfg_vaddr +
-						CONFIG_OFFSET_ADDR(bus->bus_number, devfn, 0, 0));
+						CONFIG_OFFSET_ADDR(bus->config_bus_number, devfn, 0, 0));
 
 	SPDK_DEBUGLOG(vmd, "PCI device found: %04x:%04x ***\n",
 		      header->common.vendor_id, header->common.device_id);
@@ -674,6 +678,7 @@ vmd_create_new_bus(struct vmd_pci_bus *parent, struct vmd_pci_device *bridge, ui
 	new_bus->secondary_bus = new_bus->subordinate_bus = bus_number;
 	new_bus->self = bridge;
 	new_bus->vmd = parent->vmd;
+	new_bus->config_bus_number = new_bus->bus_number - new_bus->vmd->vmd_bus.bus_start;
 	TAILQ_INIT(&new_bus->dev_list);
 
 	bridge->subordinate = new_bus;
@@ -1158,14 +1163,48 @@ vmd_map_bars(struct vmd_adapter *vmd, struct spdk_pci_device *dev)
 	return rc;
 }
 
+static void
+vmd_set_starting_bus_number(struct vmd_adapter *vmd, uint8_t *bus_start,
+			    uint8_t *max_bus)
+{
+	uint32_t vmd_cap = 0, vmd_config = 0;
+	uint8_t bus_restrict_cap, bus_restrictions;
+
+	spdk_pci_device_cfg_read32(vmd->pci, &vmd_cap, PCI_VMD_VMCAP);
+	spdk_pci_device_cfg_read32(vmd->pci, &vmd_config, PCI_VMD_VMCONFIG);
+
+	bus_restrict_cap = vmd_cap & 0x1; /* bit 0 */
+	bus_restrictions = (vmd_config >> 8) & 0x3; /* bits 8-9 */
+	if ((bus_restrict_cap == 0x1) && (bus_restrictions == 0x1)) {
+		*bus_start = 128;
+		*max_bus = 255;
+	} else {
+		*bus_start = 0;
+		*max_bus = 127;
+	}
+}
+
 static int
 vmd_enumerate_devices(struct vmd_adapter *vmd)
 {
+	uint8_t max_bus, bus_start;
+
 	vmd->vmd_bus.vmd = vmd;
-	vmd->vmd_bus.secondary_bus = vmd->vmd_bus.subordinate_bus = 0;
-	vmd->vmd_bus.primary_bus = vmd->vmd_bus.bus_number = 0;
 	vmd->vmd_bus.domain = vmd->pci->addr.domain;
 
+	if (vmd->pci->id.device_id == PCI_DEVICE_ID_INTEL_VMD_ICX) {
+		vmd_set_starting_bus_number(vmd, &bus_start, &max_bus);
+		vmd->vmd_bus.bus_start = bus_start;
+		vmd->vmd_bus.secondary_bus = vmd->vmd_bus.subordinate_bus = vmd->vmd_bus.bus_start;
+		vmd->vmd_bus.primary_bus = vmd->vmd_bus.bus_number = vmd->vmd_bus.bus_start;
+		vmd->max_pci_bus = max_bus;
+	} else {
+		vmd->vmd_bus.bus_start = 0;
+		vmd->vmd_bus.secondary_bus = vmd->vmd_bus.subordinate_bus = 0;
+		vmd->vmd_bus.primary_bus = vmd->vmd_bus.bus_number = 0;
+		vmd->max_pci_bus = PCI_MAX_BUS_NUMBER;
+	}
+
 	return vmd_scan_pcibus(&vmd->vmd_bus);
 }
 
@@ -1216,7 +1255,6 @@ vmd_enum_cb(void *ctx, struct spdk_pci_device *pci_dev)
 	vmd_c->vmd[i].vmd_index = i;
 	vmd_c->vmd[i].domain =
 		(pci_dev->addr.bus << 16) | (pci_dev->addr.dev << 8) | pci_dev->addr.func;
-	vmd_c->vmd[i].max_pci_bus = PCI_MAX_BUS_NUMBER;
 	TAILQ_INIT(&vmd_c->vmd[i].bus_list);
 
 	if (vmd_map_bars(&vmd_c->vmd[i], pci_dev) == -1) {
diff --git a/lib/vmd/vmd.h b/lib/vmd/vmd.h
index d44ede902..db1740b37 100644
--- a/lib/vmd/vmd.h
+++ b/lib/vmd/vmd.h
@@ -66,6 +66,8 @@ struct vmd_pci_bus {
 	uint32_t  primary_bus     : 8;
 	uint32_t  secondary_bus   : 8;
 	uint32_t  subordinate_bus : 8;
+	uint32_t  bus_start       : 8;
+	uint32_t  config_bus_number : 8;
 
 	TAILQ_HEAD(, vmd_pci_device) dev_list;	/* list of pci end device attached to this bus */
 	TAILQ_ENTRY(vmd_pci_bus) tailq;		/* link for all buses found during scan */
diff --git a/lib/vmd/vmd_spec.h b/lib/vmd/vmd_spec.h
index 07a4a113d..d97cfdc7d 100644
--- a/lib/vmd/vmd_spec.h
+++ b/lib/vmd/vmd_spec.h
@@ -36,7 +36,6 @@
 #define VMD_SPEC_H
 
 #define MAX_VMD_SUPPORTED 48  /* max number of vmd controllers in a system - */
-#define VMD_DOMAIN_START 0x201D
 
 #define PCI_INVALID_VENDORID 0xFFFF
 #define ONE_MB (1<<20)
@@ -46,6 +45,10 @@
 #define VMD_UPPER_BASE_SIGNATURE  0xFFFFFFEF
 #define VMD_UPPER_LIMIT_SIGNATURE 0xFFFFFFED
 
+/* VMD Registers */
+#define PCI_VMD_VMCAP		0x40
+#define PCI_VMD_VMCONFIG	0x44
+
 /*
  *  BAR assignment constants
  */
-- 
2.26.2

